module local_hash;

[[
#include "storage.h"
#include "glib.h"
]]

class LocalHash [[Storage::LocalHash*]]
{
	LocalHash(string name="DEFAULT_DB")
		[[
				*self = new Storage::LocalHash();
            if (lua_gettop(L)==2 && lua_istable(L,-2))
            {
                lua_pushvalue(L,-2);
                lb_set_props_from_table(L);
                lua_pop(L,1);
            }
				else
				{
					g_debug("Name is: %p (%s)",name,name);
					(*self)->name = name;
				}

				(*self)->connect();
		]];

	~LocalHash()
		[[
			delete self;
		]];

	readonly int count
		[[
			count = self->count();
		]];

	table get(table key=0)
		[[
			size_t key_length;
			const char *key_buf = luaL_checklstring(L, 2, &key_length);

			Storage::String tKey = Storage::String(key_buf, key_length);
			Storage::String value = self->get(tKey);
			lua_pushlstring(L, value.data(), value.length());
		]];

	put(table key=0, table value=0)
		[[
			size_t key_length;
			const char *key_buf = luaL_checklstring(L, 2, &key_length);

			size_t value_length;
			const char *value_buf = luaL_checklstring(L, 3, &value_length);

			Storage::String tKey = Storage::String(key_buf, key_length);
			Storage::String tValue = Storage::String(value_buf, value_length);
			self->put(tKey, tValue);
		]];

	del(table key=0)
		[[
			size_t key_length;
			const char *key_buf = luaL_checklstring(L, 2, &key_length);

			Storage::String tKey = Storage::String(key_buf, key_length);
			self->del(tKey);
		]];

	nuke()
		[[
			self->nuke();
		]];

	begin()
		[[
			self->begin();
		]];

	commit()
		[[
			self->commit();
		]];

	abort()
		[[
			self->abort();
		]];

	flush()
		[[
			self->flush();
		]];
}

import getpass
import sys
import socket
import select
import telnetlib
import hashlib
import uuid

branch = 'z9hG4bKg40a3m4gXXj3c'

udp_sip_client_ip = "10.0.190.153"

udp_sip_server_port = 5060
udp_sip_client_port = 50418

from_tag = 'gHrSD9H4BFrgg'

options_rtsp = "OPTIONS rtsp://tpmini.internal.trickplay.com/sample.sdp RTSP/1.0\r\n\
CSeq: 1\r\n\r\n"
#User-Agent: QuickTime/7.6.6 (qtver=7.6.6;cpu=IA32;os=Mac 10.6.8)\r\n\
#Authorization: Basic YnJvYWRjYXN0OnNheXdoYXQ=\r\n\r\n"

sdp_header = "v=0\r\n\
o=- 0 0 IN IP4 127.0.0.1\r\n\
s=Livu\r\n\
c=IN IP4 tpmini.internal.trickplay.com\r\n\
t=0 0\r\n\
a=tool:Livu RTP\r\n\
m=audio 0 RTP/AVP 96\r\n\
b=AS:64\r\n\
a=rtpmap:96 MPEG4-GENERIC/44100/1\r\n\
a=fmtp:96 profile-level-id=1;mode=AAC-hbr;sizelength=13;indexlength=3;indexdeltalength=3; config=1208\r\n\
a=control:streamid=0\r\n\
m=video 0 RTP/AVP 97\r\n\
b=AS:64\r\n\
a=rtpmap:97 H264/90000\r\n\
a=fmtp:97 packetization-mode=1;sprop-parameter-sets=Z0IAHo1oCgPZ,aM4JyA==\r\n\
a=control:streamid=1"

rtp_udp_sdp = "v=0\r\n\
o=- 536 3212164818 IN IP4 127.0.0.0\r\n\
s=QuickTime\r\n\
c=IN IP4 10.0.190.5\r\n\
t=0 0\r\n\
a=range:npt=now-\r\n\
a=isma-compliance:2,2.0,2\r\n\
m=audio 6970 RTP/AVP 96\r\n\
b=AS:64\r\n\
a=rtpmap:96 mpeg4-generic/44100/1\r\n\
a=fmtp:96 profile-level-id=15;mode=AAC-hbr;sizelength=13;indexlength=3;indexdeltalength=3;config=1388\r\n\
a=mpeg4-esid:101\r\n\
a=control:trackid=1\r\n\
m=video 6970 RTP/AVP 97\r\n\
b=AS:1372\r\n\
a=rtpmap:97 H264/90000\r\n\
a=fmtp:97 packetization-mode=1;sprop-parameter-sets=Z0IAHo1oCgPZ,aM4JyA==\r\n\
a=mpeg4-esid:201\r\n\
a=cliprect:0,0,480,640\r\n\
a=framesize:97 640-480\r\n\
a=control:trackid=2\r\n"


sip_udp_sdp = "v=0\r\n\
o=- 536 3212164818 IN IP4 10.0.190.153\r\n\
s=Python\r\n\
t=0 0\r\n\
a=range:npt=now-\r\n\
a=isma-compliance:2,2.0,2\r\n\
m=audio 6970 RTP/AVP 96\r\n\
b=AS:64\r\n\
a=rtpmap:96 mpeg4-generic/44100/1\r\n\
a=fmtp:96 profile-level-id=15;mode=AAC-hbr;sizelength=13;indexlength=3;indexdeltalength=3;config=1388\r\n\
a=mpeg4-esid:101\r\n\
a=control:trackid=1\r\n\
m=video 6970 RTP/AVP 97\r\n\
b=AS:1372\r\n\
a=rtpmap:97 H264/90000\r\n\
a=fmtp:97 packetization-mode=1;sprop-parameter-sets=Z0IAHo1oCgPZ,aM4JyA==\r\n\
a=mpeg4-esid:201\r\n\
a=cliprect:0,0,480,640\r\n\
a=framesize:97 640-480\r\n\
a=control:trackid=2\r\n"


sip_register = 'REGISTER sip:asterisk-1.asterisk.trickplay.com SIP/2.0\r\n\
Via: SIP/2.0/UDP 10.0.190.153:50418;rport;branch=' + branch + '\r\n\
Max-Forwards: 70\r\n\
From: <sip:phone@asterisk-1.asterisk.trickplay.com>;tag=gHrSD9H4BFrgg\r\n\
To: <sip:phone@asterisk-1.asterisk.trickplay.com>\r\n\
Call-ID: 2b464c7a-c332-122f-5db0-842b2b9cc652\r\n\
CSeq: 23479747 REGISTER\r\n\
Contact: <sip:phone@10.0.190.153:50418>\r\n\
User-Agent: Python\r\n\
Allow: INVITE, ACK, BYE, CANCEL, OPTIONS, PRACK, MESSAGE, UPDATE\r\n\
Supported: timer, 100rel, path\r\n'

sender_uri = "sip:phone@asterisk-1.asterisk.trickplay.com"
remote_uri = "sip:rex@asterisk-1.asterisk.trickplay.com"

# Used to record the SIP route taken by a request and used to route the response
# back to the originator.
# UAs generating a request records its own address in a Via and adds it to the header.
# Order of Via header fields is significant as it determines routes
Via = {
    1 : {
        'protocol' : "SIP/2.0/UDP",
        'client_ip' : udp_sip_client_ip,
        'client_port' : str(udp_sip_client_port),
    }
}

# How many times can this bounce around the network?
Max_Forwards = '70'

# Where is this sending from? tag is generated locally (UAC)
From = {
    'sender' : '<' + sender_uri + '>',
    'tag' : uuid.uuid4().hex,
}

# Who are you calling? tag is generated by UAS
To = {
    'remote_contact' : '<' + remote_uri + '>',
    'tag' : ""
}

# All Calls have are tied to a specific Call-ID. OPTIONS always
# has unique Call-IDs. All REGISTERs from the same UA have the
# same Call-ID.
Call_IDs = {
    'REGISTER' : str(uuid.uuid4())
}

# Sequence Number, increments per request for same call.
# Exception is ACK or CANCEL where it uses the CSeq number of the INVITE
# it's referencing.
CSeqs = {
    'REGISTER' : 101,
    'INVITE' : 1001
}

# This is your routable address. The SIP Server caches this and forwards
# all outside requests to this address therfore this must reference
# your address outside the NAT. All INVITES and 200 responses must have
# a Contact. REGISTERs may have Contact: * to remove all existing
# Registrations.
Contact = "<sip:phone@" + udp_sip_client_ip + ":" + str(udp_sip_client_port) + ">"

# A useless name you can include, may help with logs on server side
User_Agent = "Python"

# These are the Requests we allow. All of these should be implemented to complete
# this project.
Allow = "INVITE, ACK, BYE, CANCEL, OPTIONS, PRACK, MESSAGE, UPDATE"

# This is additional stuff you support. NOTE: we don't support any of it. But
# Entropy does in the Wireshark packets so I'm including it now anyway.
# May support it later, who knows?
Supported = "timer, 100rel, path"

# Strings to help with Authorization
Auth_1 = 'Authorization: Digest username="phone", realm="asterisk", nonce="'
Auth_2 = '", algorithm=MD5, uri="sip:asterisk-1.asterisk.trickplay.com", response="'

# Default Content length of 0 indicates no message body
Content_Length = 'Content-Length: 0\r\n\
\r\n'


sip_invite = 'INVITE sip:rex@asterisk-1.asterisk.trickplay.com SIP/2.0\r\n\
Via: SIP/2.0/UDP 10.0.190.153:' + str(udp_sip_client_port) + ';rport;branch=' + branch + '\r\n\
Max-Forwards: 70\r\n\
From: <sip:phone@asterisk-1.asterisk.trickplay.com>;tag=' + from_tag + '\r\n\
To: <sip:rex@asterisk-1.asterisk.trickplay.com>\r\n\
Call-ID: 83bf049a-cfcd-122f-c1a7-842b2b9cc652\r\n\
CSeq: 24172815 INVITE\r\n\
Contact: <sip:phone@10.0.190.153:39588>\r\n\
User-Agent: Telepathy-SofiaSIP/0.6.3 sofia-sip/1.12.10\r\n\
Allow: INVITE, ACK, BYE, CANCEL, OPTIONS, PRACK, MESSAGE, UPDATE\r\n\
Supported: timer, 100rel\r\n\
Min-SE: 120\r\n\
Content-Type: application/sdp\r\n\
Content-Disposition: session\r\n\
Content-Length: 601\r\n'




#####################################


host = socket.gethostbyname("asterisk-1.asterisk.trickplay.com")

log = open("sip.log", "w")

"""
tn = telnetlib.Telnet(host, udp_sip_server_port)

sock = tn.get_socket()
print "Source: "
print sock.getsockname()
print "Destination: "
print sock.getpeername()
print "\n"
"""

branch_start = 'z9hG4bK'
register_branch = ""

session = ""
nonce = None
ha3 = ""

udp_sip_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
udp_sip_sock.bind(("", udp_sip_client_port))


read_buf = ""
write_buf = ""

current_header = {}

states = ["UnRegistered", "Registered", "Inviting"]

state = "UnRegistered"


def gen_branch():
    """Use to create a unique branch id"""

    return branch_start + uuid.uuid4().hex



def gen_register(authorization):
    """Create and return a REGISTER packet"""

    global register_branch
    # generate new branch id
    register_branch = gen_branch()

    # build REGISTER packet
    register = "REGISTER sip:asterisk-1.asterisk.trickplay.com SIP/2.0\r\n"
    register += "Via: " + Via[1]['protocol'] + " " + Via[1]['client_ip'] + \
                ":" + Via[1]['client_port'] + ";rport;branch=" + register_branch + \
                "\r\n"
    register += "Max-Forwards: " + Max_Forwards + "\r\n"
    register += "From: " + From['sender'] + ";tag=" + From['tag'] + "\r\n"
    register += "To: " + From['sender'] + "\r\n"
    register += "Call-ID: " + Call_IDs['REGISTER'] + "\r\n"
    register += "CSeq: " + str(CSeqs['REGISTER']) + " REGISTER\r\n"
    register += "Contact: " + Contact + "\r\n"
    register += "User-Agent: " + User_Agent + "\r\n"
    register += "Allow: " + Allow + "\r\n"
    register += "Supported: " + Supported + "\r\n"

    # add authorization line if available
    if authorization:
        register += authorization

    # terminate with default Content-Length of 0
    register += Content_Length

    # increment sequence number
    CSeqs['REGISTER'] += 1

    return register



def register(nonce):
    """Register to the SIP Server"""

    # if authorization key exists then generate auth line
    auth = None
    if nonce:
        ha1 = hashlib.md5("phone:asterisk:saywhat").hexdigest()
        ha2 = hashlib.md5("REGISTER:sip:asterisk-1.asterisk.trickplay.com").hexdigest()
        ha3 = hashlib.md5(ha1 + ":" + nonce + ":" + ha2).hexdigest()

        auth = Auth_1 + nonce + Auth_2 + ha3 + '"\r\n'

    # create REGISTER packet
    packet = gen_register(auth)

    # send over network
    sip_send(packet)



def sip_parse(data):
    """Parses incoming data"""

    global read_buf, current_header
    read_buf = read_buf + data
    result = read_buf.split('\r\n\r\n', 1)
    if len(result) < 2:
        return False
    header, read_buf = result

    elements = header.split('\r\n')
    current_header['Status-Line'] = elements[0]
    
    for element in elements[1:]:
        key, var = element.split(":", 1)
        current_header[key] = var

    print 'current_header:\n', current_header, '\n\n'

    return True

def handle_state():
    """State machine stuff"""

    global states, state

    

def sip_send(packet):
    """Send sip request, log request and response"""
    print packet
    print "\n"

    global nonce

    log.write(packet)
    log.write("\n\n")

    readable, writeable, in_error = select.select([udp_sip_sock], [udp_sip_sock], [], 5)

    if readable.count(udp_sip_sock):
        data, addr = udp_sip_sock.recvfrom(1024)
        print "received from", addr, ":", data

    if writeable.count(udp_sip_sock):
        udp_sip_sock.sendto(packet, (host, udp_sip_server_port))

    while True:
        readable, writeable, in_error = select.select([udp_sip_sock], [udp_sip_sock], [], 5)

        #if readable.count(udp_sip_sock)
        #    data, addr = udp_sip_sock.recvfrom(1024)
        #    print "received from", addr, ":\n", data
        #    if sip_parse(data):
        #        handle_state()

        if readable.count(udp_sip_sock):
            data, addr = udp_sip_sock.recvfrom(1024)
            print "received from", addr, ":\n", data
            sip_parse(data)
            if data.find('nonce="') >= 0:
                begin = data.find('nonce="')
                start = data.find('"', begin)
                end = data.find('"', start+1)
                nonce = data[start+1:end]
                print "nonce: " + nonce

            if data[:7] != 'SIP/2.0':
                continue

            break

        if in_error.count(udp_sip_sock):
            print "error"
            print udp_sip_sock.error
            break

    print "\n"


def get_frames():
    """Store all the frames into a list"""
    frames_fd = open("frames_rex_new.bin", "rb")

    all_frames = frames_fd.read()

    global frames
    frames = all_frames.split("REXFENLEY\x00")

    frames_fd.close()


def rtp_send():
    """Send rtp frames over and over"""
    global frames

    counter = 0
    
    while True:
        for frame in frames[0:]:
            print "writing a frame"
            tn.write(frame)
            #print tn.read_until("\r\n\r\n", 1)
            print counter
            counter = counter + 1
    
    print tn.read_until("\r\n\r\n", 5)

def udp_sip():
    """This is a udp sip session"""
    udp_sip_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    udp_sip_sock.bind(("", udp_sip_client_port))


def udp_rtsp_session():
    """This sets up a UDP RTSP session and sends frames via UDP"""

    global udp_rtp_server_port
    global udp_rtp_client_port
    global udp_rtcp_client_port
    global udp_rtp_sock
    global frames

    udp_rtcp_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    udp_rtcp_sock.bind(("", udp_rtcp_client_port))

    rtsp_send(udp_announce2 + udp_sdp2)
    ##rtsp_send(udp_announce + udp_sdp)
    rtsp_send(udp_options)
    rtsp_send(udp_setup)
    rtsp_send(udp_record + session + "\r\n\r\n")

    index = 1
    counter = 1

    while True:
        readable, writeable, in_error = select.select([udp_rtcp_sock], [udp_rtp_sock], [], 5)

        if readable.count(udp_rtcp_sock):
            data, addr = udp_rtcp_sock.recvfrom(1024)
            print "received from", addr, ":", data

        if writeable.count(udp_rtp_sock):
            udp_rtp_sock.sendto(frames[index], (host, udp_rtp_server_port))
            index += 1

        if index >= len(frames):
            index = 1
            #print counter
            #counter += 1
            #print "wrote all frames"
    



#get_frames()
#udp_rtsp_session()

#sip_send(sip_register + sip_content_length)

#ha1 = hashlib.md5("phone:asterisk:saywhat").hexdigest()
#ha2 = hashlib.md5("REGISTER:sip:asterisk-1.asterisk.trickplay.com").hexdigest()
#ha3 = hashlib.md5(ha1 + ":" + nonce + ":" + ha2).hexdigest()

#sip_send(sip_register + sip_auth_1 + nonce + sip_auth_2 + ha3 + '"\r\n' + sip_content_length)

#sip_send(sip_invite + sip_udp_sdp)

register(nonce)
register(nonce)

log.close()
#tn.close()

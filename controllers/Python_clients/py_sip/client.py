import getpass
import sys
import socket
import select
import telnetlib
import hashlib
import uuid
from collections import deque

branch = 'z9hG4bKg40a3m4gXXj3c'

udp_sip_client_ip = "10.0.190.153"

udp_sip_server_port = 5060
udp_sip_client_port = 50418

from_tag = 'gHrSD9H4BFrgg'

options_rtsp = "OPTIONS rtsp://tpmini.internal.trickplay.com/sample.sdp RTSP/1.0\r\n\
CSeq: 1\r\n\r\n"
#User-Agent: QuickTime/7.6.6 (qtver=7.6.6;cpu=IA32;os=Mac 10.6.8)\r\n\
#Authorization: Basic YnJvYWRjYXN0OnNheXdoYXQ=\r\n\r\n"

sdp_header = "v=0\r\n\
o=- 0 0 IN IP4 127.0.0.1\r\n\
s=Livu\r\n\
c=IN IP4 tpmini.internal.trickplay.com\r\n\
t=0 0\r\n\
a=tool:Livu RTP\r\n\
m=audio 0 RTP/AVP 96\r\n\
b=AS:64\r\n\
a=rtpmap:96 MPEG4-GENERIC/44100/1\r\n\
a=fmtp:96 profile-level-id=1;mode=AAC-hbr;sizelength=13;indexlength=3;indexdeltalength=3; config=1208\r\n\
a=control:streamid=0\r\n\
m=video 0 RTP/AVP 97\r\n\
b=AS:64\r\n\
a=rtpmap:97 H264/90000\r\n\
a=fmtp:97 packetization-mode=1;sprop-parameter-sets=Z0IAHo1oCgPZ,aM4JyA==\r\n\
a=control:streamid=1"

rtp_udp_sdp = "v=0\r\n\
o=- 536 3212164818 IN IP4 127.0.0.0\r\n\
s=QuickTime\r\n\
c=IN IP4 10.0.190.5\r\n\
t=0 0\r\n\
a=range:npt=now-\r\n\
a=isma-compliance:2,2.0,2\r\n\
m=audio 6970 RTP/AVP 96\r\n\
b=AS:64\r\n\
a=rtpmap:96 mpeg4-generic/44100/1\r\n\
a=fmtp:96 profile-level-id=15;mode=AAC-hbr;sizelength=13;indexlength=3;indexdeltalength=3;config=1388\r\n\
a=mpeg4-esid:101\r\n\
a=control:trackid=1\r\n\
m=video 6970 RTP/AVP 97\r\n\
b=AS:1372\r\n\
a=rtpmap:97 H264/90000\r\n\
a=fmtp:97 packetization-mode=1;sprop-parameter-sets=Z0IAHo1oCgPZ,aM4JyA==\r\n\
a=mpeg4-esid:201\r\n\
a=cliprect:0,0,480,640\r\n\
a=framesize:97 640-480\r\n\
a=control:trackid=2\r\n"


sip_udp_sdp = "v=0\r\n\
o=- 536 3212164818 IN IP4 10.0.190.153\r\n\
s=Python\r\n\
t=0 0\r\n\
a=range:npt=now-\r\n\
a=isma-compliance:2,2.0,2\r\n\
m=audio 6970 RTP/AVP 96\r\n\
b=AS:64\r\n\
a=rtpmap:96 mpeg4-generic/44100/1\r\n\
a=fmtp:96 profile-level-id=15;mode=AAC-hbr;sizelength=13;indexlength=3;indexdeltalength=3;config=1388\r\n\
a=mpeg4-esid:101\r\n\
a=control:trackid=1\r\n\
m=video 6970 RTP/AVP 97\r\n\
b=AS:1372\r\n\
a=rtpmap:97 H264/90000\r\n\
a=fmtp:97 packetization-mode=1;sprop-parameter-sets=Z0IAHo1oCgPZ,aM4JyA==\r\n\
a=mpeg4-esid:201\r\n\
a=cliprect:0,0,480,640\r\n\
a=framesize:97 640-480\r\n\
a=control:trackid=2\r\n"


sip_register = 'REGISTER sip:asterisk-1.asterisk.trickplay.com SIP/2.0\r\n\
Via: SIP/2.0/UDP 10.0.190.153:50418;rport;branch=' + branch + '\r\n\
Max-Forwards: 70\r\n\
From: <sip:phone@asterisk-1.asterisk.trickplay.com>;tag=gHrSD9H4BFrgg\r\n\
To: <sip:phone@asterisk-1.asterisk.trickplay.com>\r\n\
Call-ID: 2b464c7a-c332-122f-5db0-842b2b9cc652\r\n\
CSeq: 23479747 REGISTER\r\n\
Contact: <sip:phone@10.0.190.153:50418>\r\n\
User-Agent: Python\r\n\
Allow: INVITE, ACK, BYE, CANCEL, OPTIONS, PRACK, MESSAGE, UPDATE\r\n\
Supported: timer, 100rel, path\r\n'

sender_uri = "sip:phone@asterisk-1.asterisk.trickplay.com"
remote_uri = "sip:rex@asterisk-1.asterisk.trickplay.com"

# Used to record the SIP route taken by a request and used to route the response
# back to the originator.
# UAs generating a request records its own address in a Via and adds it to the header.
# Order of Via header fields is significant as it determines routes
Via = {
    1 : {
        'protocol' : "SIP/2.0/UDP",
        'client_ip' : udp_sip_client_ip,
        'client_port' : str(udp_sip_client_port),
    }
}

# How many times can this bounce around the network?
Max_Forwards = '70'

# Where is this sending from? tag is generated locally (UAC)
From = {
    'sender' : '<' + sender_uri + '>',
    'tag' : uuid.uuid4().hex,
}

# Who are you calling? tag is generated by UAS
To = {
    'remote_contact' : '<' + remote_uri + '>',
    'tag' : ""
}

# All Calls are tied to a specific Call-ID. OPTIONS always
# has a unique Call-ID. All REGISTERs from the same UA have the
# same Call-ID.
Call_IDs = {
    'REGISTER' : str(uuid.uuid4()),
    'INVITE' : str(uuid.uuid4())
}

# Sequence Number, increments per request for same call.
# Exception is ACK or CANCEL where it uses the CSeq number of the INVITE
# it's referencing.
CSeqs = {
    'REGISTER' : 101,
    'INVITE' : 1001
}

# This is your routable address. The SIP Server caches this and forwards
# all outside requests to this address therfore this must reference
# your address outside the NAT. All INVITES and 200 responses must have
# a Contact. REGISTERs may have Contact: * to remove all existing
# Registrations.
Contact = "<sip:phone@" + udp_sip_client_ip + ":" + str(udp_sip_client_port) + ">"

# A useless name you can include, may help with logs on server side
User_Agent = "Python"

# These are the Requests we allow. All of these should be implemented to complete
# this project.
Allow = "INVITE, ACK, BYE, CANCEL, OPTIONS, PRACK, MESSAGE, UPDATE"

# This is additional stuff you support. NOTE: we don't support any of it. But
# Entropy does in the Wireshark packets so I'm including it now anyway.
# May support it later, who knows?
Supported = "timer, 100rel, path"

# Strings to help with Authorization
Auth_1 = 'Authorization: Digest username="phone", realm="asterisk", nonce="'
Auth_2 = '", algorithm=MD5, uri="sip:asterisk-1.asterisk.trickplay.com", response="'

# Default Content length of 0 indicates no message body
Content_Length = 'Content-Length: 0\r\n\
\r\n'


sip_invite = 'INVITE sip:rex@asterisk-1.asterisk.trickplay.com SIP/2.0\r\n\
Via: SIP/2.0/UDP 10.0.190.153:' + str(udp_sip_client_port) + ';rport;branch=' + branch + '\r\n\
Max-Forwards: 70\r\n\
From: <sip:phone@asterisk-1.asterisk.trickplay.com>;tag=' + from_tag + '\r\n\
To: <sip:rex@asterisk-1.asterisk.trickplay.com>\r\n\
Call-ID: 83bf049a-cfcd-122f-c1a7-842b2b9cc652\r\n\
CSeq: 24172815 INVITE\r\n\
Contact: <sip:phone@10.0.190.153:39588>\r\n\
User-Agent: Telepathy-SofiaSIP/0.6.3 sofia-sip/1.12.10\r\n\
Allow: INVITE, ACK, BYE, CANCEL, OPTIONS, PRACK, MESSAGE, UPDATE\r\n\
Supported: timer, 100rel\r\n\
Min-SE: 120\r\n\
Content-Type: application/sdp\r\n\
Content-Disposition: session\r\n\
Content-Length: 601\r\n'



#####################################


host = socket.gethostbyname("asterisk-1.asterisk.trickplay.com")

log = open("sip.log", "w")

"""
tn = telnetlib.Telnet(host, udp_sip_server_port)

sock = tn.get_socket()
print "Source: "
print sock.getsockname()
print "Destination: "
print sock.getpeername()
print "\n"
"""

branch_start = 'z9hG4bK'

session = ""
nonce = None
ha3 = ""

udp_sip_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
udp_sip_sock.bind(("", udp_sip_client_port))


read_buf = bytearray("")

write_queue = deque([])

current_header = {}

states = ["UnRegistered", "Registered", "Inviting"]

state = "UnRegistered"


def sip_parse(data):
    """Parses incoming data"""

    global read_buf
    read_buf = read_buf + data
    result = read_buf.split('\r\n\r\n', 1)
    if len(result) < 2:
        return False
    header, read_buf = result

    elements = header.split('\r\n')

    response = {}
    response['Status-Line'] = str(elements[0])
    
    for element in elements[1:]:
        key, var = element.split(": ", 1)
        response[str(key)] = str(var)

    print 'response:\n', response, '\n\n'

    if 'Call-ID' in response:
        return response

    return False 


def get_frames():
    """Store all the frames into a list"""
    frames_fd = open("frames_rex_new.bin", "rb")

    all_frames = frames_fd.read()

    global frames
    frames = all_frames.split("REXFENLEY\x00")

    frames_fd.close()


#########################


import call

active_calls = {}


register_call = call.Register("phone", sender_uri, remote_uri, udp_sip_client_ip,
                     udp_sip_client_port, udp_sip_server_port, write_queue)

invite_call = call.Invite("phone", sender_uri, remote_uri, udp_sip_client_ip,
                     udp_sip_client_port, udp_sip_server_port, write_queue)

active_calls[register_call.Call_ID] = register_call
active_calls[invite_call.Call_ID] = invite_call

def register_callback():
    invite_call.invite()

register_call.callback = register_callback

register_call.register()


def select_loop():
    """
    Continuously checks for data to read and room to write
    and informs call state machines of activity.
    """

    global nonce

    while True:
        readable, writeable, in_error = select.select([udp_sip_sock], [udp_sip_sock], [], 5)

        # this is how we read
        if readable.count(udp_sip_sock):
            data, addr = udp_sip_sock.recvfrom(1024)

            print "received from", addr, ":\n", data
            log.write("\n" + data + "\n\n")

            response = sip_parse(data)
            
            if response and response['Call-ID'] in active_calls:
                active_calls[response['Call-ID']].interpret(response)

        # this is how we write
        if writeable.count(udp_sip_sock) and len(write_queue):
            packet = write_queue.popleft()

            print "\nwriting:\n" + packet + "\n\n"
            log.write('\n' + packet + "\n\n")

            udp_sip_sock.sendto(packet, (host, udp_sip_server_port))

        # this is why im hot
        if in_error.count(udp_sip_sock):
            print "error"
            print udp_sip_sock.error


select_loop()

log.close()
#tn.close()

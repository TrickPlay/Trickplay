
Title: Lua Binding/LB



Group: Introduction

The TrickPlay Engine enables Lua code statements to invoke C/C++ functions and reference C/C++ data. This capability is generally used to give TrickPlay Lua applications access to third-party libraries written in C/C++, such as Clutter, Cairo, and many others.

The binding of Lua to C/C++ is accomplished by writing an intermediate source file that handles the two-way communication between the Engine's embedded Lua interpreter and the C/C++ library. This intermediate file contains special Lua Binding (LB) directives, plus C++ code. The LB directives are internal Engine features, specific to TrickPlay, with their own syntax requirements. Intermediate files are saved as standard text files with an .lb extension.

To successfully implement a new LB module, the developer should understand the Lua stack and how to manipulate its contents. For background information, refer to the Lua documentation about low-level internal Lua functions, such as lua_call().



Group: TrickPlay LB Implementation

The Engine's LB functionality is implemented in three source files stored in the engine/lb directory. Each source file implements one component of the LB functionality. Note: To create a new LB module, it is not necessary to understand the internal operations of any of these source files.

	Python parser and code generator (lb.py) - processes the .lb intermediate file and generates C++ code
	LB header file (lb.h) - contains macro definitions used by the generated C++ code
	LB utility file (lp.cpp) - contains utility functions used by the generated C++ code



Group: Creating a New LB Module

To bind Lua to a new C/C++ library, follow these general steps.

	- Write an LB file. Save it in the engine/bindings subdirectory.
	- Add the LB filename to the LB_FILES list contained in the engine/CMakeLists.txt file.
	- Add the appropriate luaopen_XXX() extern function declaration near the top of the engine/source/app.cpp file.
	- Invoke the luaopen_XXX() function in the App::run_part2 method contained in the engine/source/app.cpp file.

The luaopen_XXX() function is created automatically by the LB code generator when it encounters certain LB directives (i.e., the module, class, interface, and global directives described later). The XXX portion is the name of the module/class/etc. defined by the LB directive, such as luaopen_myUtilLib().

The luaopen_XXX() function will always have the prototype shown below.

	(code)
	void
	luaopen_XXX( lua_State * L )
	(end)

When invoking luaopen_XXX() and declaring its extern prototype as described in the steps above, refer to the existing LB luaopen_XXX() functions and simply use the same syntax.



Group: Embedded C/C++ Code

An .lb file consists of the following elements.

	- LB directives
	- LB declarations of constructors, destructors, functions, properties and callbacks (event handlers)
	- Embedded C/C++ code that implements the declared constructors, destructors, etc.

All C/C++ code must be surrounded by two opening and two closing square brackets, as shown below. The C/C++ code may extend over multiple lines. The LB parser passes all C/C++ statements, unchanged, directly to the generated C++ output file.

	(code)
	[[ C/C++ code ]]
	
	[[ C/C++ code
	   more C/C++ code
	]]
	(end)



Group: LB Comments

Comments in embedded C/C++ code are regular C/C++ comments. Comments outside of embedded C/C++ code are specified with # for single-line comments; /* and */ specify the boundaries of a multi-line comment.

	*Example Code:*
	
		(code)
		module myUtilLib;
		
		# This module defines some utility functions.
		
		/* Utility Function List:
				printNum()
				printStr()
				printName()
		*/
		(end)



Group: The module Directive

	Syntax:

		(code)
		module ModuleName;
		(end)
		
The module directive instructs the LB code generator to create a single luaopen_XXX() function that injects all the .lb file's class, interface and global definitions into the Lua state variable. The XXX portion of the function name will be the ModuleName specified in the directive. If an .lb file does not specify a module directive, a separate luaopen_XXX() function is created for each class, interface and global definition in the file, with the XXX portion being the class/interface/global name. The luaopen_XXX() function must be added to the CMakeLists.txt and engine/source/app.cpp files as described in <Creating a New LB Module>.

An .lb file may have a maximum of one module directive. It is typically specified at the beginning of the file. 



Group: The interface Directive

	Syntax:
	
		(code)
		interface InterfaceName [[ C/C++ data pointer ]]
		{
			# Define interface properties, functions and callbacks (event handlers) here
		}
		(end)

The interface directive defines a group of properties, functions and callbacks (event handlers) with the intention of being inherited by one or more LB classes or global variables. It is not possible for a Lua application to create an instance of an interface. Instead, an LB class or global variable inherits the properties and functions of the interface. When a Lua application creates an instance of the class/global variable, the properties and functions of the inherited interface(s) are also created. An example of an interface in the TrickPlay SDK is the UIElement interface which is inherited by severak SDK classes, including the Rectangle and Image classes. The screen global variable also inherits the UIElement interface.

The interface is referenced through the InterfaceName specified in its definition.

The C/C++ data pointer specifies an existing C/C++ class or struct or it can be a void *. The LB code generator creates a C/C++ variable called "self" of the same type; the "self" variable can be accessed in the embedded C/C++ code of the interface's functions, property handlers and callbacks.



Group: The class Directive

	Syntax:
	
		(code)
		class ClassName [[ C/C++ data pointer ]] InterfaceInheritanceList
		{
			# Define class constructor, destructor, properties, functions and callbacks (event handlers) here
		}
		(end)	

The class directive defines a Lua class that can provide a constructor, destructor, properties, functions and callbacks (event handlers). The LB code generator automatically creates the necessary framework so a Lua application can create instances of the class using the name specified as the ClassName.

The C/C++ data pointer specifies an existing C/C++ class or struct or it can be a void *. The LB code generator creates a C/C++ variable called "self" of the same type. The "self" variable can be accessed in the embedded C/C++ code of the class's constructor, destructor, property handlers, functions and callbacks.

A class can optionally inherit the functions, properties and callbacks from one or multiple interfaces by specifying the interfaces in the InterfaceInheritanceList. Multiple interfaces should be separated by a comma. When a class inherits from an interface, the C/C++ data pointers for the class and all inherited interfaces *must reference the same data type.* For example, if an interface is defined with a pointer to type Foo, then any class that inherits the interface must also be defined with a pointer to type Foo.

Some example LB class directives are shown below.

	(code)
	# Define a class that a Lua application can create instances of
	class PerlinNoise [[ perlinNoise * ]] {
		# Constructor, functions, etc. defined here
	}
	
	# Define some interfaces that will be inherited by some classes
	interface Color [[ Object * ]] { /* Properties, functions and callback definitions */ }
	interface Font  [[ Object * ]] { /* Properties, functions and callback definitions */ }
	
	# Define a class that inherits from the Color interface
	class Box [[ Object * ]] Color {
		# Constructor, functions, etc. definitions
	}
	
	# Define a class that inherits from the Color and Font interfaces
	class TextBox [[ Object * ]] Color, Font {
		# Constructor, functions, etc. definitions
	}
	(end)



Group: The global Directive

	Syntax:
	
		(code)
		global GlobalName [[ C/C++ data pointer ]] InterfaceInheritanceList
		{
			# Define global properties, functions and callbacks (event handlers) here
		}
		(end)

The global directive defines a Lua global variable that can provide properties, functions and callbacks (event handlers). A single instance of the variable using the name specified by GlobalName is created by the generated code; no additional instances can be created. An example of a global variable is the TrickPlay SDK screen variable.

The C/C++ data pointer specifies an existing C/C++ class or struct or it can be a void *. The LB code generator creates a C/C++ variable called "self" of the same type. The "self" variable can be accessed in the embedded C/C++ code of the global's property handlers, functions and callbacks.

A global variable can optionally inherit the functions, properties and callbacks from one or multiple interfaces by specifying the interfaces in the InterfaceInheritanceList. Multiple interfaces should be separated by a comma. When a global variable inherits from an interface, the C/C++ data pointers for the variable and all inherited interfaces *must reference the same data type.* For example, if an interface is defined with a pointer to type Foo, then any global variable that inherits the interface must also be defined with a pointer to type Foo.

The syntax for the global directive is identical to the class directive syntax. (Note: Although their syntax is identical, the two directives cause different code to be generated.) For examples of global directives, refer to the examples in <The class Directive>.



Group: LB Data Types

LB declarations of constructors, destructors, functions, property handlers and callbacks can include arguments and return values. All arguments and return values must be an LB data type; they cannot be a C/C++ data type. The LB data types are converted to C/C++ data types by the LB code generator. The list of recognized LB data types and the C/C++ data types they are converted to is shown below.

	(code)
	LB Data Type	C/C++ Data Type
	------------	---------------
	int				int
	double			lua_Number
	bool			bool
	integer			lua_Integer
	long			long
	string			const char *
	lstring			const char *
	table			int (index of the table in the Lua stack)
	function		int (index of the function in the Lua stack)
	udata			int (index of the udata in the Lua stack)
	any				int (index of the argument in the Lua stack)
	(end)

In addition to the above LB data types, any other identifier used as an LB data type is treated as type "any". For example, a function called PerlinNoise() may return a value of type "noise" which would be processed by the LB parser and code generator as a value of type "any."



Group: Declaring Arguments to Constructors and Functions

LB constructors and functions can accept zero or more arguments. Each argument must be an LB data type. The syntax for arguments is shown below.

	(code)
	functionName( LBdataType arg01Name, LBdataType arg02Name, ... )

	Example:
				perlinNoise( double x, double y, double z )
	(end)

It is possible to specify default values for arguments. The default value will be used if the argument is not included in the function call. To specify a default value, follow the argument declaration with an equal sign and a C++ expression that can be validly assigned to the argument. For an argument of a data type that is converted to an index within the Lua stack, such as a table or function, an empty default value can be assigned a value of 0.  Some examples are shown below.

	(code)
	perlinNoise( double x = 1.0, double y = 1.0, double z = 0.0 )
	sortTable( table unsortedTable = 0 )
	(end)

Note: A bug exists that prevents default values from containing spaces. The bug can be worked around by defining a #define constant to the space-containing default value and then referencing the constant as the argument's default. An example is shown below.

	(code)
	# This doesn't work because of the spaces in the default value
	printTitle( string title = "Welcome to TrickPlay" )
	
	# Here is the work-around
	[[
	#define	DEFAULT_TITLE		"Welcome to TrickPlay"
	]]
	
	printTitle( string title = [[ DEFAULT_TITLE ]] )
	(end)

LB constructors and functions can accept a variable number of arguments. A variable number of arguments is specified by an ellipsis (...) in the argument list, as shown below.

	(code)
	printGroceries( ... )
	(end)

When not using a variable number of arguments, the LB code generator will create all the code necessary to correctly handle the Lua stack. When using a variable number of arguments, however, the function, itself, must manually perform any required manipulations of the Lua stack.



Group: LB Constructors

Each LB class can have a single constructor. Like a C++ constructor, the LB constructor must have the same name as the class. Constructor overloading is not supported, but the use of multiple arguments and default argument values can adequately offset this.

To correctly initialize the new object, the constructor's embedded C++ code must call one of the following macros.

	(code)
	lb_construct_empty() - Constructs an empty object.
	lb_construct( DataType, Pointer ) - Constructs a new object of type DataType. The Pointer argument references an instance of the new object.
	lb_construct( DataType, gobject ) - Constructs a new object of type DataType. The gobject argument references an instance of the new GObject-based object.
	(end)
		
For information on GObjects, refer to the <GObject Reference Manual at http://developer.gnome.org/gobject/stable/>. Many of the TrickPlay SDK's Clutter-based objects, such as Rectangle and Image, are implemented as GObjects.

The LB code generator automatically creates a variable called "self" of type DataType. The self variable will be available in the object's destructor, functions, property handlers, and callbacks. If the constructor's embedded C++ code assigns the return value of the lb_construct() macros to the self variable, these other functions will be able to access the object. Assigning a value to the self variable is optional; however, if the constructor allocates memory for the object, having the self variable reference the object might be necessary in order to free the memory. The example below shows a common constructor definition.

	(code)
	class Foo [[ Bar * ]] {
		
		# Constructor
		Foo() [[
			
			# Construct object and save reference to allocated memory in self variable
			self = lb_construct( Bar, new Bar() );
		]];
	}
	(end)

Constructors should not call the return statement. The LB-generated code handles the constructor's return, and always returns an instance of the new object.



Group: LB Destructors

Each LB class may have a single destructor. Destructors are optional. Like a C++ destructor, the LB destructor must have the same name as the class and be preceded by a tilde '~' character. Destructors accept no arguments. Destructors should not call the return statement; the LB-generated code handles the destructor's return.

The example below shows a common destructor definition that releases object memory that had been allocated in the constructor.

	(code)
	# Destructor for class Foo
	~Foo() [[
	
		# Free allocated memory
		delete self;
	]];
	(end)



Group: Properties





















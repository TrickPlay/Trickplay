
Title: User Interface

Group: The Basics

Creating your app's user interface couldn't be easier. You simply create UI Elements,
add them to the screen and show the screen.

Let's dive right in and show you the code for a simple "Hello World!"
app. You can paste the code below into your app's "main.lua" file and run it
to see the results.

(code)
screen:add(Text{font="Sans 38px",color="FFFFFF",text="Hello World!"})
screen:show()
(end)

Topic: Creating UI Elements

Now, let's break it down a bit. In the first line, we created a Text element and
added it to the screen.

"Text" is a function that TrickPlay provides. This function returns a newly created
Text element. In Lua, function parameters are typically given inside parenthesis, but
if a function requires only a single parameter and that parameter is a table, we can
skip the parenthesis and just pass the table. We could have done the same thing
like this:

(code)
local my_text_properties={font="Sans 38px",color="FFFFFF",text="Hello World!"}
local my_text=Text(my_text_properties)
screen:add(my_text)
(end)

So, we are calling the "Text" function and passing it a table with 3 fields: "font",
"color" and "text". It just so happens that those three fields are also properties
of all Text elements, so we could have done it like this too:

(code)
local my_text=Text()
my_text.font="Sans 38px"
my_text.color="FFFFFF"
my_text.text="Hello World!"
screen:add(my_text)
(end)

You will find this pattern throughout the TrickPlay API.


Topic: Constructors and Globals

You may have noticed in our first example that "screen" is not capitalized, whereas
"Text" is. There is a good reason for that: "screen" is a global object
that TrickPlay creates automatically for you; you cannot create any more screens.
Text is a function that creates a text element; you can think of it as a constructor.

In this API, global objects and global functions that are not constructors
(like "print") are not capitalized, whereas constructors are.


Topic: Methods and Functions

You may have also noticed that we used a colon to call the "add" method of screen.
This is Lua syntax that shortens a call to a function that requires an object as the
first parameter. The following calls are the same:

(code)
screen:add(my_text)

screen.add(screen,my_text)
(end)

The first one just passes the "screen" parameter automatically.

Topic: Properties

Properties behave as you expect, for the most part. In our earlier example, we
did this:

(code)
my_text.text="Hello World!"
(end)

This sets the property "text" of the "my_text" object to the value "Hello World!".

You'll see later that even though most properties are simple types, some accept tables
as values. In these cases, you should know that you can only set and get the tables
as a whole, you cannot modify them in place.

For example, most UI elements have a "position" property that lets you specify
bot the x and y coordinates in one table, like this:

(code)
my_text.position={10,50}
(end)

This is a short-hand way to set both the x and y properties. In the same way, you
can get the x and y positions by accessing the position table directly:

(code)
local x=my_text.position[1]
(end)

That bit of code returns the position of "my_text" as a table, and we are indexing
the first member of that table. What you cannot do is this:

(code)
my_text.position[1]=50
(end)

More correctly: you can do that, but it won't have the effect that you want. The 50
will get put into the table, but that table won't be assigned back to the position
of "my_text". In most cases, TrickPlay also provides properties that give you direct
access to the same values, so you can do:

(code)
my_text.x=50
(end)

But there are times when you will need to read the property value as a table, change
it and then assign the whole table back to the property, like this:

(code)
local position=my_text.position
position[1]=50
my_text.position=position
(end)


Topic: Events

Events are just like other properties, but they let you set a function to handle
the event. All events in TrickPlay are prefixed with "on_". You can set an event
handler like this:

(code)
function my_image_on_loaded(image,failed)
    print("LOADED",failed)
end

my_image.on_loaded=my_image_on_loaded
(end)

You can also use an anonymous function, one that is defined inline and has no name
like this:

(code)
my_image.on_loaded=function(image,failed) print("LOADED",failed) end
(end)

Lua has one additional bit of syntactic sugar which lets you do
it like this:

(code)
function my_image.on_loaded(image,failed)
    print("LOADED",failed)
end
(end)

In that case, it is still an anonymous function that is assigned to the "on_loaded"
property of "my_image".

You can remove an event handler by setting it to nil, and it is a good idea to do
so.

(code)
my_image.on_loaded=nil
(end)


Group: UI Elements

All of TrickPlay's UI elements implement a basic interface that provides the
features common to them. It is called the "UIElement" interface. It has the properties
and methods you would expect: position, size, rotation, scale, opacity, visibility, etc.
It also provides events, such as on_key_down and on_show.

Two UI elements also implement the "Container" interface; because these elements
can contain others. The Container interface lets you add, remove and iterate children.

Here is the complete list of all available
UI elements:

screen -    Automatically created by TrickPlay, it implements both UIElement
            and Container.
            
Group -     Implements UIElement and Container, so you can group other elements.

Rectangle - A simple texture that is always rectangular and can have a border.

Image -     For images; lets you easily use local and remote images.

Text -      Lets you display and edit text.

Clone -     Lets you clone another UI element, with little additional expense.

Canvas -    Lets you create textures by drawing and filling shapes or paths.


Even though that is not a long list, it provides all the building blocks for complex
and rich user interfaces.


Topic: screen

The screen object is created automatically and is initialized to the width and height
of the display. It is a special kind of <Group> that is invisible; but all other
UI elements have to be added to it in order to become visible. That is, you can
create a <Rectangle> but it won't be visible until you add it to the screen.

You can move and resize the screen, or even animate it, and you can place other
UI elements anywhere inside it.


Topic: Group

Groups let you do just that, group other UI elements. Groups are not visible and,
by default, don't clip their children; so you can create a 1x1 pixel group that
contains all kinds of UI elements that spill outside its bounds. But, you can
operate on the group and affect all of its children; you could rotate it, for example.


Topic: Rectangle

Rectangles are UI elements that have color and can have a border. They are always
rectangular.


Topic: Image

Images can be loaded from your app bundle or using a URL. They have a "src" property
that lets you do this.

(code)
screen:add(Image{src="http://www.google.com/logos/giroux1.jpg"})
(end)

Images have events that let you know when they have been loaded or when their
size changes.

They can also be tiled horizontally and/or vertically to fill any space.


Topic: Text

Text elements let you display and edit text. They support a variety of methods,
properties and events for controlling their behavior. There are no real surprises
here, so take a look at the reference.


Topic: Clone

Clone lets you clone another UI element without duplicating that element's texture.
You do so by setting the "source" property of the clone; pointing it at another
element.

Clones are useful when you have to repeat an image, because you only have to have
the image in memory once. Imagine an app that shows many clouds; you could load
one cloud image and then create many clones, with different scale, rotation and
opacity for variety.

Here is a simple example that uses a Clone to
create a reflection:

(code)
local image=Image{src="http://www.google.com/logos/giroux1.jpg"}

function image.on_loaded(image)
    local clone=Clone{source=image,x_rotation={180,image.height,0},opacity=100}
    screen:add(image,clone)
    screen:show()
end
(end)

It creates an image and sets a handler for the "on_loaded" event. Once the image
is loaded, it creates a clone that is rotated around the x axis and is a bit transparent.


Topic: Canvas

Canvas is a texture that you can paint on. You can create paths, fill them and stroke
them. You can create irregular shapes and use color gradients. Once you are finished
drawing on the Canvas, you can treat it just like any other UI element.



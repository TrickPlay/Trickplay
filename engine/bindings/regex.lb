[[
#include "common.h"
#include "util.h"

/**
 * Returns the ceil form of base 10 logarithm for a 32 bit integer.
 * âˆ’1 is returned if ''n'' is <= 0 or if you are insane.
 */
int ceilLog10(const int n) {
    if (n <= 0)
        return -1;

    if(n < 10) return 1;
    if(n < 100) return 2;
    if(n < 1000) return 3;
    if(n < 10000) return 4;
    if(n < 100000) return 5;
    if(n < 1000000) return 6;
    
    g_critical("Dude, that's way too many captures.  Try something less insane.");
    return -1;
}

]]

/*
	Global: regex
	
	The regex global variable provides perl-compatible regular expression functions for the TrickPlay SDK Libraries. A TrickPlay application can call any of the functions described here.  These functions are designed to mirror the built-in Lua string functions "replace", "match", and "find", but to work with perl-compatible regular expressions instead of the crappy junk pattern broken bullshit that Lua deigns to provide you with.
*/

global regex [[void*]]
{

    /*
        Function: replace

        The replace() function performs a text-replacement operation; the text to find and the text to be replaced are specified using <Perl-compatible regular expression patterns at http://perldoc.perl.org/perlre.html>.

        *Arguments:*

	        origin - string to process
	        pattern - regular expression string specifying text to search for
			replacement - regular expression string specifying replacement text. This string must be UTF-8 encoded.
			start_pos - one-based index within origin argument at which to begin searching. This argument is optional. If not specified, the search begins with the first character in the origin argument (index 1).

        *Return Value:* modified string, if successful, else the original string. Note: The resulting string should not contain NUL characters.

        It is possible to use the regex:replace() function without knowing Perl regular expression syntax. The following code statement performs a simple search-and-replace operation.

        (code)
        -- Replace "Hello" with "Good-bye"
        print( regex:replace( "Hello World", "Hello", "Good-bye" ) )
        
        Outputs:
        	Good-bye World
        (end)
        
        For Perl programmers, the equivalent Perl code for the Lua-based regex:replace() function is shown below.
        
        (code)
        -- Lua version
        str = regex:replace( original, find, replacement )
        
        -- Perl version
        $_ = $original;
        s/$find/$replacement/;
        $str = $_;
        (end)
        
        There may be times when the matched text is variable (such as matching any digit between 0-9) and this variable match must be part of the replacement string. For example, to format some text, a regular expression can be used to parse the text into tokens. The tokens are then reorganized in the new format by including them in a replacement regular expression. In Perl terminology, you want to "capture" each token and then reference the captured text in the replacement regular expression. Perl stores captured text in "capture variables." The first group of captured text is stored in the variable $1. If multiple groups of text are captured, the capture variables $2, $3, etc. are used for each subsequent group. There is no upper limit on the number of capture variables.
        
        In the Lua-based regex:replace() function, the equivalent to Perl's $1 capture variable is \\1. (Note: The actual Lua capture variable is \1, but the backslash character must be escaped to be interpreted correctly.) Subsequent Lua capture variables use the names \\2, \\3, etc.. The capture variable \\0 is special; it contains the entire matched text, not just any captured subsections.
        
        The code sample below formats a raw telephone number using capture variables.
        
        (code)
        -- Format telephone number as (nnn) nnn - nnnn
        -- The search regular expression looks for sequences of 3 digits, 3 digits and 4 digits. Each sequence is captured in
        -- the capture variables \\1, \\2 and \\3 which are referenced in the replacement regular expression.
        print( regex:replace( "John Doe, phone: 4083063517",
                              "([0-9]{3})([0-9]{3})([0-9]{4})",
                              "(\\1) \\2 - \\3" ) )
        Outputs:
        	John Doe, phone: (408) 306 - 3517
        (end)
        
        Specifying capture variables using the \\1 syntax is sometimes insufficient. For example, say we want to change the second digit in any "nn" sequence to zero, such as changing "99" to "90 and "34" to "30". If we capture the first digit in capture variable \\1 (as in the regular expression of "([0-9])[1-9]") then the replacement regular expression to append a zero to the capture variable would be "\\10". However, this does not work because the ending zero is interpreted as being part of the capture variable, i.e., \\10. To reference the capture variable \\1 and append a '0' to the resulting string, we need to reference the capture variable using a different syntax.
        
        In Perl, the "\g{1}" syntax is an equivalent reference to the Perl $1 capture variable. In the Lua-based regex:replace() function, the "\\g<1>" syntax is equivalent to referencing the "\\1" capture variable. Subsequent capture variables (\\2, \\3, etc.) use the same syntax (\\g<2>, \\g<3>, etc.).
         
         The code segment below demonstrates this alternative syntax for capture variables with the regex:replace() function.

        (code)
        -- Replace ".dd" with ".d0" where 'd' is any digit 0-9
        print( regex:replace( "MSRP: $10.99, Sale Price: $6.45", ".([0-9])[1-9]", ".\\g<1>0" ) )
        
        Outputs:
        	MSRP: $10.90, Sale Price: $6.40
        (end)

		Captured text can also be assigned a name by using the syntax (?<name>...). The name can subsequently be used to reference the related capture variable (\\1, etc.). When referencing a capture name, the syntax is \\g<name>, as in \\g<Group1>. A version of the earlier phone-number formatting example that uses capture names is shown below.
		
		(code)
		-- Format a telephone number as (nnn) nnn - nnnn. Use capture names.
		print( regex:replace( "John Doe, phone: 4083063517",
                              "(?<area>[0-9]{3})(?<group1>[0-9]{3})(?<group2>[0-9]{4})",
                              "(\\g<area>) \\g<group1> - \\g<group2>" ) )
        Outputs:
        	John Doe, phone: (408) 306 - 3517
		(end)

        *See Also:* <Perl regular expression documentation at http://perldoc.perl.org/perlre.html>
    */

    string replace( lstring origin, string pattern, string replacement, int start_pos = 1 )
        [[
            FreeLater free_later;

            GError * error = 0;

            GRegex * re_pat = g_regex_new( pattern, (GRegexCompileFlags) (G_REGEX_MULTILINE | G_REGEX_DOTALL), (GRegexMatchFlags) 0, &error );

            if (error)
            {
                g_warning("FAILED TO COMPILE REGEX '%s' : %s",pattern,error->message);
                g_clear_error(&error);
                result = origin;
            }
            else
            {
                gchar * replaced = g_regex_replace( re_pat, origin, origin_len, start_pos-1, replacement, (GRegexMatchFlags) 0, &error );

                if (error)
                {
                    g_warning("FAILED TO EXECUTE REGEX REPLACE '%s' : %s",pattern,error->message);
                    g_clear_error(&error);
                    result = origin;
                }
                else
                {
                    free_later( replaced );
                    
                    result = replaced;
                }
            }

            if ( re_pat )
            {            
                g_regex_unref( re_pat );
            }
        ]];


    /*
        Function: match
        
        The match() function finds a substring in a string; the text to find is specified using <Perl-compatible regular expression patterns at http://perldoc.perl.org/perlre.html>.  Captures can be used to identify sub-strings within the match expression.
        
        *Arguments:*
        
	        origin - string to process
	        pattern - regular expression string specifying text to search for
			start_pos - one-based index within origin argument at which to begin searching. This argument is optional. If not specified, the search begins with the first character in the origin argument (index 1).

        *Return Value:* If the pattern contains no captures, the full match is returned.  If the pattern does contain captures, then a list of the captures is returned in order:
        
        regex:match('test','te') -->  "te"
        regex:match('test','(t)(e)') --> "t", "e"
        regex:match('test','t(e)') --> "e"

    */

    multi match ( lstring origin, string pattern, int start_pos = 1 )
    [[
        GError * error = 0;
        
        gint num_matches = 0;

        GRegex * re_pat = g_regex_new( pattern, (GRegexCompileFlags) (G_REGEX_MULTILINE | G_REGEX_DOTALL), (GRegexMatchFlags) 0, &error );

        if (error)
        {
            String message( error->message );
            g_clear_error( & error );
            return luaL_error( L , "FAILED TO COMPILE REGEX '%s' : %s",pattern,message.c_str() ); 
        }


        GMatchInfo * match_info = 0;
        gboolean result = g_regex_match_full( re_pat, origin, origin_len, start_pos-1, (GRegexMatchFlags) 0, &match_info, &error );
        
        if (error)
        {
            g_warning("FAILED IN REGEX MATCH: %s",error->message);
            g_clear_error(&error);
        }
        else
        {
            if(result)
            {
                gint num_captures = g_match_info_get_match_count( match_info );
        
                if( num_captures > 1 )
                {
                    for(int i=1; i<=num_captures; i++)
                    {
                        if ( gchar * word = g_match_info_fetch( match_info, i ) )
                        {
                            lua_pushstring( L, word );
                            g_free( word );
                            ++num_matches;
                        }
                        else
                        {
                            g_critical( "g_match_info_fetch RETURNED NULL" );
                            g_assert( false );
                        }
                    }
                }
                else // No captures, so just return the match
                {
                    if ( gchar * word = g_match_info_fetch ( match_info, 0 ) )
                    {
                        lua_pushstring( L , word );
                        g_free( word );
                        ++num_matches;
                    }
                    else
                    {
                        g_critical( "g_match_info_fetch RETURNED NULL" );
                        g_assert( false );
                    }
                }
            }
        }

        if ( match_info )
        {
            g_match_info_free(match_info);
        }
        
        g_regex_unref( re_pat );

        if (error)
        {
            g_warning("FAILED IN REGEX MATCH GETTING MATCHES: %s",error->message);
            g_clear_error(&error);
        }
        
        return num_matches;
    ]];

    /*
        Function: find

        The find() function finds the location of a substring in a string; the text to find is specified using <Perl-compatible regular expression patterns at http://perldoc.perl.org/perlre.html>.  Captures can be used to identify sub-strings within the match expression.

        *Arguments:*

	        origin - string to process
	        pattern - regular expression string specifying text to search for
			start_pos - one-based index within origin argument at which to begin searching. This argument is optional. If not specified, the search begins with the first character in the origin argument (index 1).

        *Return Value:* If an instance of the pattern is found a pair of values representing the start and end of the string is returned. If the pattern cannot be found nil is returned.  If the pattern contains captures, then a list of the captures is returned in order after the start/end indices.

        regex:find('test','te') -->  1, 2
        regex:find('test','(t)(e)') --> 1, 2, "t", "e"
        regex:find('test','t(e)') --> 1, 2, "e"

    */

    multi find ( lstring origin, string pattern, int start_pos = 1 )
    [[
        int num_matches = 0;

        GError *error = 0;

        GRegex * re_pat = g_regex_new( pattern, (GRegexCompileFlags) (G_REGEX_MULTILINE | G_REGEX_DOTALL), (GRegexMatchFlags) 0, &error );
        if (error)
        {
            g_warning("FAILED TO COMPILE REGEX '%s' : %s",pattern,error->message);
            g_clear_error(&error);
            return 0;
        }
        else
        {
            GMatchInfo *match_info;
            gboolean result = g_regex_match_full( re_pat, origin, origin_len, start_pos-1, (GRegexMatchFlags) 0, &match_info, &error );
            if (error)
            {
                g_warning("FAILED IN REGEX MATCH: %s",error->message);
                g_clear_error(&error);
            }
            else
            {
                if(result)
                {
                    gint begin_pos, end_pos;
                    g_match_info_fetch_pos( match_info, 0, &begin_pos, &end_pos );

                    lua_pushnumber( L, begin_pos+1 );
                    lua_pushnumber( L, end_pos );
                    num_matches = 2;

                    gint num_captures = g_regex_get_capture_count( re_pat );
                    if( num_captures > 0 )
                    {
                        for(int i=1; i<=num_captures; i++)
                        {
                            gchar *word = g_match_info_fetch( match_info, i );

                            if(NULL != word)
                            {
                                lua_pushstring( L, word );
                                g_free( word );
                            }
                        }

                        num_matches += num_captures;
                    }
                }
            }

            g_match_info_free(match_info);
            g_regex_unref( re_pat );

            if (error)
            {
                g_warning("FAILED IN REGEX MATCH GETTING MATCHES: %s",error->message);
                g_clear_error(&error);
            }
        }
        
        return num_matches;
    ]];

}

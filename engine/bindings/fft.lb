module fft;

[[
#include "glib.h"
#include "kiss_fft.h"
#include "common.h"

class complex_array
{
public:
    
    complex_array(lua_State * l, size_t size)
		L ( l ),
		the_array_size ( size ),
		the_array ( new kiss_fft_complex[size] )
    {
    }

    ~complex_array()
    {
    	delete [] the_array;
    }
    
	kiss_fft_complex* get_element_at(size_t position)
	{
		g_assert(position < the_array_size);
		return the_array[position];
	}

	void set_element_at(size_t position, kiss_fft_complex complex)
	{
		g_assert(position < the_array_size);
		the_array[position].r = complex.r;
		the_array[position].i = complex.i;
	}

	const String to_string()
	{
		String result;
		size_t i;
		for(i=0; i<the_array_size; i++)
		{
			result += "r: ";
			result += the_array[i].r;
			result += ", i: ";
			result += the_array[i].i;
			reault += "\n";
		}

		return result;
	}

private:
    
    lua_State * L;
    kiss_fft_complex *the_array;
    size_t the_array_size;
};

]]


# Class: ComplexArray
# An array of complex reals -- the data is stored efficiently and intended to be passed around as a "blob".
# You can access the elements of the array, and even set them, but this is not especially efficient.  However,
# perform FFT operations on this blob works quite nicely, and there are various other functions which can produce data
# in this blob format.



class ComplexArray [[complex_array*]]
{
    ComplexArray()
        [[
            *self = new complex_arrray(L);

            if (lua_gettop(L)==2 && lua_istable(L,-2))
            {
                lua_pushvalue(L,-2);
                lb_set_props_from_table(L);
                lua_pop(L,1);
            }
	    else
	    {
		if (interval>0)
		    (*self)->set_interval(interval);
		    
		if (on_timer)
		{
		    lua_pushvalue(L,on_timer);
		    lb_set_callback(L,*self,"on_timer");
		    lua_pop(L,1);
		}
	    }
	    
	    if (lb_callback_attached(L,*self,"on_timer",-1))
		(*self)->start();
        ]];
        
    ~Timer()
        [[
            delete self;
        ]];
	
    # Property: interval
    # The interval, in seconds, after which the timer fires. 
        
    double interval
        [[interval=self->get_interval();]]
        [[self->set_interval(interval);]];
        
    # Function: start
    # Starts the timer if it has not started already
    
    start()
        [[
	    if (lb_callback_attached(L,self,"on_timer",1))
		self->start();
	]];
	
    # Function: stop
    # Stops the timer. It won't tick again unless you start it.
    
    stop()
	[[self->stop();]];

    # Event: on_timer
    # This function gets called every time the timer fires. Timers keep firing
    # until you do one of these things: set the on_timer callback to nil,
    # call <stop> or return false from the on_timer callback.
    #
    # Arguments:
    # timer - The associated Timer
    
    callback on_timer
	[[
	    if(!on_timer)
		self->stop();
	]];        
}

[[

timer::timer(lua_State * l )
:
    L(l) ,
    source( NULL ),
    interval( 0 ) 
{
}

timer::~timer()
{
    cancel();
}

void timer::start( )
{
    if (source)
	return;
    
    if (interval<=0)
	return;
    
    source = g_timeout_source_new( interval * 1000 );
	    
    g_source_set_callback( source , timer_fired , this , NULL );
    g_source_attach( source , g_main_context_default()  );
}

void timer::stop()
{
    if (!source)
	return;
    
    g_source_destroy(source);
    g_source_unref(source);
    source=NULL;
}

void timer::set_interval(lua_Number new_interval)
{
    if (new_interval==interval)
	return;
    
    interval = new_interval;
    
    if(source)
    {
	stop();
	start();
    }
}

lua_Number timer::get_interval() const
{
    return interval;
}
        
void timer::cancel()
{
    stop();
}
      
gboolean timer::timer_fired(gpointer data)
{
    timer * self = (timer*)data;
   
    if (!invoke_Timer_on_timer(self->L,self,0,1))
    {
	self->cancel();
	return FALSE;
    }
    
    if (lua_isboolean(self->L,-1) && !lua_toboolean(self->L,-1))
    {
	self->cancel();
	lua_pop(self->L,1);
	return FALSE;
    }
    lua_pop(self->L,1);
    return TRUE;
}

]]

module clutter_animator;

[[
#include "clutter/clutter.h"
#include "util.h"
#include "clutter_util.h"

int set_animator_value(lua_State * L, int index, ClutterAnimator* animator, ClutterActor * source, 
				  	   String name , String mode, double progress, bool ease_in)
{
	GValue gvalue={0};
	double value;
	const char *k = name.c_str();
	gulong nmode=ClutterUtil::to_clutter_animation_mode(mode.c_str());

	if (!strcmp("x",k)||!strcmp("y",k)||!strcmp("w",k)||!strcmp("width",k)||!strcmp("h",k)||!strcmp("height",k)||
		!strcmp("z",k)||!strcmp("depth",k)||!strcmp("opacity",k))
	{
		if (lua_type(L, index) == LUA_TNUMBER) 
		{
			value = lua_tonumber(L, index);

			g_value_init(&gvalue,G_TYPE_FLOAT);
			g_value_set_float(&gvalue,value);

			clutter_animator_set_key(animator, G_OBJECT(source), name.c_str(), nmode, progress, &gvalue);
			clutter_animator_property_set_ease_in(animator, G_OBJECT(source), name.c_str(), ease_in);
		} 
		else 
		{
		    return luaL_error(L, "incorrect argument, failed to set the third argument of keys : number expected");
		}
	}
	else if (!strcmp("position",k))
	{
		if (lua_type(L,index)==LUA_TTABLE)
		{
			lua_rawgeti(L,index,1);
			value = lua_tonumber(L, -1);
			g_value_init(&gvalue,G_TYPE_FLOAT);
			g_value_set_float(&gvalue, value);
			lua_pop(L,1);
			clutter_animator_set_key(animator, G_OBJECT(source), "x", nmode, progress, &gvalue);
			clutter_animator_property_set_ease_in(animator, G_OBJECT(source), "x", ease_in);
			    
			lua_rawgeti(L,index,2);
			value = lua_tonumber(L, -1);
			g_value_unset(&gvalue);
			g_value_init(&gvalue,G_TYPE_FLOAT);
			g_value_set_float(&gvalue,value);
			lua_pop(L,1);
			clutter_animator_set_key(animator, G_OBJECT(source), "y", nmode, progress, &gvalue);
			clutter_animator_property_set_ease_in(animator, G_OBJECT(source), "y", ease_in);
		}
		else 
		{
		    return luaL_error(L, "incorrect argument, failed to set the third argument of keys : table expected");
		}
	} 
	else if (!strcmp("size",k))
	{
		if (lua_type(L,index)==LUA_TTABLE)
		{
			lua_rawgeti(L,index,1);
			value = lua_tonumber(L, -1);
			g_value_init(&gvalue,G_TYPE_FLOAT);
			g_value_set_float(&gvalue, value);
			lua_pop(L,1);
			clutter_animator_set_key(animator, G_OBJECT(source), "width", nmode, progress, &gvalue);
			clutter_animator_property_set_ease_in(animator, G_OBJECT(source), "width", ease_in);
			    
			lua_rawgeti(L,index,2);
			value = lua_tonumber(L, -1);
			g_value_unset(&gvalue);
			g_value_init(&gvalue,G_TYPE_FLOAT);
			g_value_set_float(&gvalue,value);
			lua_pop(L,1);
			clutter_animator_set_key(animator, G_OBJECT(source), "height", nmode, progress, &gvalue);
			clutter_animator_property_set_ease_in(animator, G_OBJECT(source), "height", ease_in);

		}			
		else 
		{
		    return luaL_error(L, "incorrect argument, failed to set the third argument of keys : table expected");
		}
	}
	else if (!strcmp("scale",k))
	{
		if (lua_type(L,index)==LUA_TTABLE)
		{
			lua_rawgeti(L,index,1);
			value = lua_tonumber(L, -1);
			g_value_init(&gvalue,G_TYPE_DOUBLE);
			g_value_set_float(&gvalue, value);
			lua_pop(L,1);
			clutter_animator_set_key(animator, G_OBJECT(source), "scale-x", nmode, progress, &gvalue);
			clutter_animator_property_set_ease_in(animator, G_OBJECT(source), "scale-x", ease_in);
			    
			lua_rawgeti(L,index,2);
			value = lua_tonumber(L, -1);
			g_value_unset(&gvalue);
			g_value_init(&gvalue,G_TYPE_DOUBLE);
			g_value_set_float(&gvalue,value);
			lua_pop(L,1);
			clutter_animator_set_key(animator, G_OBJECT(source), "scale-y", nmode, progress, &gvalue);
			clutter_animator_property_set_ease_in(animator, G_OBJECT(source), "scale-y", ease_in);
		}			
		else 
		{
		    return luaL_error(L, "incorrect argument, failed to set the third argument of keys : table expected");
		}
	}
	else if (!strcmp("x_rotation",k))
	{
		if (lua_type(L,index)==LUA_TTABLE)
		{
			    
		}
		else
		{
			value = lua_tonumber(L, -1);
			g_value_init(&gvalue,G_TYPE_DOUBLE);
			g_value_set_float(&gvalue,value);
			clutter_animator_set_key(animator, G_OBJECT(source), "rotation-angle-x", nmode, progress, &gvalue);
			clutter_animator_property_set_ease_in(animator, G_OBJECT(source), "rotation-angle-x", ease_in);

		}
	}
	else if (!strcmp("y_rotation",k))
	{
		if (lua_type(L,index)==LUA_TTABLE)
		{
		
		}
		else
		{
			value = lua_tonumber(L, -1);
			g_value_init(&gvalue,G_TYPE_DOUBLE);
			g_value_set_float(&gvalue,value);
			clutter_animator_set_key(animator, G_OBJECT(source), "rotation-angle-y", nmode, progress, &gvalue);
			clutter_animator_property_set_ease_in(animator, G_OBJECT(source), "rotation-angle-y", ease_in);
		}
	}
	else if (!strcmp("z_rotation",k))
	{
		if (lua_type(L,index)==LUA_TTABLE)
		{
			    
		}
		else
		{
			value = lua_tonumber(L, -1);
			g_value_init(&gvalue,G_TYPE_DOUBLE);
			g_value_set_float(&gvalue,value);
			clutter_animator_set_key(animator, G_OBJECT(source), "rotation-angle-z", nmode, progress, &gvalue);
			clutter_animator_property_set_ease_in(animator, G_OBJECT(source), "rotation-angle-z", ease_in);
		}
	}
	else if (!strcmp("color",k))
	{
		if ((lua_type(L,index)==LUA_TTABLE) || (lua_type(L, index) == LUA_TSTRING))
		{
			ClutterColor color;
			ClutterUtil::to_clutter_color(L, index, &color);

			//ClutterColor color = ClutterUtil::string_to_color(lua_tostring(L, index));

			g_value_init(&gvalue,CLUTTER_TYPE_COLOR);
			clutter_value_set_color(&gvalue, &color);

			clutter_animator_set_key(animator, G_OBJECT(source), "color", nmode, progress, &gvalue);
			clutter_animator_property_set_ease_in(animator, G_OBJECT(source), "color", ease_in);
		}
		else 
		{
		    return luaL_error(L, "incorrect argument, failed to set the third argument of keys : table expected");
		}
	}
	return 0;
}


int populate_animator( lua_State * L, int index, ClutterAnimator* animator )
{

    if (lua_type(L, index) != LUA_TTABLE) 
		return luaL_error(L, "incorrect argument, table expected");

	int duration = 2000;

	lua_getfield(L, index, "duration");
	if(!lua_isnil(L, -1)) 
	{
		if(!lua_isnumber(L, -1))
		{
			return luaL_error(L, "incorrect argument, failed to set \'duration\' : number expected");
		}
		duration =  lua_tonumber(L, -1);
		if (!(duration > 0 ))
		{	
			return luaL_error(L, "incorrect argument, failed to set \'duration\' : positive number expected");
		}
	}
    lua_pop(L, 1);

    clutter_animator_set_duration (animator, duration);

	//properties 
	lua_getfield(L, index, "properties");
	if (!lua_istable(L, -1))
	{
		return luaL_error(L, "incorrect argument, fail to set \'properties\' : table expected");
	}
			
	int pt = lua_gettop(L);

	lua_pushnil(L);
	while(lua_next(L, pt) != 0) {
		if (!lua_istable(L, -1)) 
		{
			return luaL_error(L, "incorrect argument, fail to set \'properties\' elements : table expected");
		}
		// source 
		lua_getfield(L, -1, "source");
		ClutterActor * source = ClutterUtil::user_data_to_actor( L, lua_gettop(L) );
	    lua_pop(L,1);
		if (!source) 
		{
			return luaL_error(L, "incorrect argument, fail to set \'source\' : userdata expected");
		}

		// name 
		lua_getfield(L, -1, "name");
		const char * cname = lua_tostring(L,-1);
		if (!cname) 
		{
			return luaL_error(L, "incorrect argument, failed to set \'name\' : string expected");
		}
		String name = cname; 
	    lua_pop(L,1);

    	// default parameter
    	bool ease_in = true;

		// ease_in 
		lua_getfield(L, -1, "ease_in");
		if (!lua_isnil(L, -1))
		{
			if (!lua_isboolean(L, -1))
			{
				return luaL_error(L, "incorrect argument, failed to set \'ease_in\' : boolean expected");
			}
			ease_in = lua_toboolean(L,-1);
		}
	    lua_pop(L,1);
		 
		 
		 // keys 
		lua_getfield(L, -1, "keys");
		if (!lua_istable(L,-1))
		{
			return luaL_error(L, "incorrect argument, failed to set \'keys\' : table expected");
		}

		int kt = lua_gettop(L);

		lua_pushnil(L); 
		while(lua_next(L, kt) != 0) 
		{
			if (!lua_istable(L,-1))
			{
				return luaL_error(L, "incorrect argument, failed to set \'keys\' element : table expected");
			}

			// default parameter
    	    String mode = "LINEAR"; 
			double progress;

		 	lua_rawgeti(L,-1,1);
		 	lua_rawgeti(L,-2,2);
		 	lua_rawgeti(L,-3,3);

			// progress 
			if(!lua_isnumber(L, -3))
			{
				return luaL_error(L, "incorrect argument, failed to set the first arguement of keys : number(0..1) expected");
			}
			if(lua_tonumber(L,-3) > 1 || lua_tonumber(L, -3) < 0) 
			{
				return luaL_error(L, "incorrect argument, failed to set the frirst arguement of keys : number(0..1) expected");
			}
			progress = lua_tonumber(L,-3);

			// mode, value  
			if ((lua_type(L, -2) == LUA_TNUMBER)||(lua_type(L, -2) == LUA_TTABLE))
			{
				set_animator_value(L, -2, animator, source, name , mode, progress, ease_in);
			}
			else if(lua_isstring(L, -2)) 
			{
				const char* cmode = lua_tostring(L,-2); 
				if (cmode)
				{
					mode  = cmode;
				}
			    if((lua_isnumber(L, -1))||(lua_istable(L, -1))) 
				{
					set_animator_value(L, -1, animator, source, name , mode, progress, ease_in);
				}
			} 
			else 
			{
				return luaL_error (L, "incorrect argument, failed to set keys value"); 
			}

			lua_pop(L,4);
		 }
	     lua_pop(L,2);
	 }
	 lua_pop(L,1);

     return 0;
}

]]

/*
    Class: Animator
    
    A animator is an object providing declarative animations for UIElements properties belonging to one or more UIElements 
    to ClutterIntervals.  ClutterAnimator is used to build and describe complex animations in terms of "key frames". 
*/

class Animator [[ClutterAnimator*]]
{
    Animator(table props = 0)
	[[
		self=clutter_animator_new();
		g_object_ref(self);
		self=lb_construct_gobject(ClutterAnimator,self);
		populate_animator(L, props, self);
    	g_object_unref(self);
	]];
	
    ~Animator()
	[[
	]];
	
	/*
		Property: duration
		The duration of the animator in milliseconds.
	*/
	
    int duration
	[[duration=clutter_animator_get_duration(self);]]
	[[clutter_animator_set_duration(self,duration);]];
	
 	/*
		Property: timeline
	*/

	Timeline timeline
	[[
    	ClutterUtil::wrap_timeline( L , clutter_animator_get_timeline(self) );
	]]
	[[
    	if ( ClutterTimeline * t = ClutterUtil::user_data_to_timeline( L , lua_gettop( L ) ) )
     	{
       		clutter_animator_set_timeline( self , t );
        }
	]];

	/*
		Function: start
		Starts the animator.
	*/
	
    start()
	[[
	  clutter_animator_start(self);
    ]];
}

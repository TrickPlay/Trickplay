module clutter_animator;

[[
#include "clutter/clutter.h"
#include "util.h"
#include "clutter_util.h"

bool get_two_floats_from_table( lua_State * L , int index , GValue * a , GValue * b )
{
    index = abs_index( L , index );
    
	if ( lua_type( L , index ) != LUA_TTABLE )
	{
	   return false;
	}
	
	lua_rawgeti( L , index , 1 );
	lua_rawgeti( L , index , 2 );
	
    float va = lua_tonumber( L , -2 );
    float vb = lua_tonumber( L , -1 );
    
    lua_pop( L , 2 );
    
    g_value_init( a , G_TYPE_FLOAT );
    g_value_set_float( a , va );
    
    g_value_init( b , G_TYPE_FLOAT );
    g_value_set_float( b , vb );
    
    return true; 	
}

int set_animator_value(lua_State * L, int index, ClutterAnimator* animator, ClutterActor * source, 
				  	   const String & name , const String & mode, double progress, bool ease_in)
{
	const char *k = name.c_str();
	gulong nmode=ClutterUtil::to_clutter_animation_mode(mode.c_str());

	if (!strcmp("x",k)||!strcmp("y",k)||!strcmp("w",k)||!strcmp("width",k)||!strcmp("h",k)||!strcmp("height",k)||
		!strcmp("z",k)||!strcmp("depth",k)||!strcmp("opacity",k))
	{
		if (lua_type(L, index) == LUA_TNUMBER) 
		{
            GValue gvalue={0};
			
			g_value_init(&gvalue,G_TYPE_FLOAT);
			g_value_set_float(&gvalue,lua_tonumber(L, index));

			clutter_animator_set_key(animator, G_OBJECT(source), name.c_str(), nmode, progress, &gvalue);
			clutter_animator_property_set_ease_in(animator, G_OBJECT(source), name.c_str(), ease_in);
			
			g_value_unset(&gvalue);
		} 
		else 
		{
		    return luaL_error(L, "Incorrect argument, failed to set the third argument of keys : number expected");
		}
	}
	else if (!strcmp("position",k))
	{
	    GValue x={0};
	    GValue y={0};
	    
	    if ( get_two_floats_from_table( L , index , & x , &y ) )
	    {
            clutter_animator_set_key(animator, G_OBJECT(source), "x", nmode, progress, &x);
            clutter_animator_property_set_ease_in(animator, G_OBJECT(source), "x", ease_in);

            clutter_animator_set_key(animator, G_OBJECT(source), "y", nmode, progress, &y);
            clutter_animator_property_set_ease_in(animator, G_OBJECT(source), "y", ease_in);

            g_value_unset(&x);
            g_value_unset(&y);
	    }
	    else
	    {
		    return luaL_error(L, "Incorrect argument for 'position' : table expected");
		}
	} 
	else if (!strcmp("size",k))
	{
	    GValue width={0};
	    GValue height={0};
	    
        if ( get_two_floats_from_table( L , index , & width , & height ) )
        {
            clutter_animator_set_key(animator, G_OBJECT(source), "width", nmode, progress, &width);
            clutter_animator_property_set_ease_in(animator, G_OBJECT(source), "width", ease_in);
            
            clutter_animator_set_key(animator, G_OBJECT(source), "height", nmode, progress, &height);
            clutter_animator_property_set_ease_in(animator, G_OBJECT(source), "height", ease_in);

            g_value_unset(&width);
            g_value_unset(&height);
        }
        else
        {
		    return luaL_error(L, "Incorrect argument for 'size' : table expected");
		}
	}
	else if (!strcmp("scale",k))
	{
        GValue scalex={0};
        GValue scaley={0};
        
        if ( get_two_floats_from_table( L , index , &scalex , &scaley ) )
        {
            clutter_animator_set_key(animator, G_OBJECT(source), "scale-x", nmode, progress, &scalex);
            clutter_animator_property_set_ease_in(animator, G_OBJECT(source), "scale-x", ease_in);
            
            clutter_animator_set_key(animator, G_OBJECT(source), "scale-y", nmode, progress, &scaley);
            clutter_animator_property_set_ease_in(animator, G_OBJECT(source), "scale-y", ease_in);

            g_value_unset(&scalex);
            g_value_unset(&scaley);
        }
		else 
		{
		    return luaL_error(L, "Incorrect argument for 'scale' : table expected");
		}
	}
	else if (!strcmp("x_rotation",k))
	{
		if (lua_type(L,index)==LUA_TTABLE)
		{
			    
		}
		else
		{
			GValue gvalue={0};
			g_value_init(&gvalue,G_TYPE_DOUBLE);
			g_value_set_float(&gvalue,lua_tonumber(L, -1));
			clutter_animator_set_key(animator, G_OBJECT(source), "rotation-angle-x", nmode, progress, &gvalue);
			clutter_animator_property_set_ease_in(animator, G_OBJECT(source), "rotation-angle-x", ease_in);
            g_value_unset(&gvalue);
		}
	}
	else if (!strcmp("y_rotation",k))
	{
		if (lua_type(L,index)==LUA_TTABLE)
		{
		
		}
		else
		{
			GValue gvalue={0};
			g_value_init(&gvalue,G_TYPE_DOUBLE);
			g_value_set_float(&gvalue,lua_tonumber(L, -1));
			clutter_animator_set_key(animator, G_OBJECT(source), "rotation-angle-y", nmode, progress, &gvalue);
			clutter_animator_property_set_ease_in(animator, G_OBJECT(source), "rotation-angle-y", ease_in);
            g_value_unset(&gvalue);
		}
	}
	else if (!strcmp("z_rotation",k))
	{
		if (lua_type(L,index)==LUA_TTABLE)
		{
			    
		}
		else
		{
		    GValue gvalue={0};
			g_value_init(&gvalue,G_TYPE_DOUBLE);
			g_value_set_float(&gvalue,lua_tonumber(L, -1));
			clutter_animator_set_key(animator, G_OBJECT(source), "rotation-angle-z", nmode, progress, &gvalue);
			clutter_animator_property_set_ease_in(animator, G_OBJECT(source), "rotation-angle-z", ease_in);
            g_value_unset(&gvalue);
		}
	}
	else if (!strcmp("color",k))
	{
		if ((lua_type(L,index)==LUA_TTABLE) || (lua_type(L, index) == LUA_TSTRING))
		{
			ClutterColor color;
			ClutterUtil::to_clutter_color(L, index, &color);

			//ClutterColor color = ClutterUtil::string_to_color(lua_tostring(L, index));

            GValue gvalue={0};
			g_value_init(&gvalue,CLUTTER_TYPE_COLOR);
			clutter_value_set_color(&gvalue, &color);

			clutter_animator_set_key(animator, G_OBJECT(source), "color", nmode, progress, &gvalue);
			clutter_animator_property_set_ease_in(animator, G_OBJECT(source), "color", ease_in);
            g_value_unset(&gvalue);
		}
		else 
		{
		    return luaL_error(L, "Incorrect argument, failed to set the third argument of keys : table expected");
		}
	}
	return 0;
}


int populate_animator( lua_State * L, int index, ClutterAnimator* animator )
{
    if (lua_type(L, index) != LUA_TTABLE)
    { 
		return luaL_error(L, "Incorrect argument, table expected");
	}

	int duration = 2000;

	lua_getfield(L, index, "duration");
	
	if(!lua_isnil(L, -1)) 
	{
		if(!lua_isnumber(L, -1))
		{
			return luaL_error(L, "Incorrect argument, failed to set \'duration\' : number expected");
		}
		duration =  lua_tonumber(L, -1);
		if (!(duration > 0 ))
		{	
			return luaL_error(L, "Incorrect argument, failed to set \'duration\' : positive number expected");
		}
	}
    lua_pop(L, 1);

    clutter_animator_set_duration (animator, duration);

	//properties 
	lua_getfield(L, index, "properties");
	if (!lua_istable(L, -1))
	{
		return luaL_error(L, "Incorrect argument, fail to set \'properties\' : table expected");
	}
			
	int pt = lua_gettop(L);

	lua_pushnil(L);
	while(lua_next(L, pt) != 0) 
	{
		if (!lua_istable(L, -1)) 
		{
			return luaL_error(L, "Incorrect argument, fail to set \'properties\' elements : table expected");
		}
		
		// source 
		lua_getfield(L, -1, "source");
		ClutterActor * source = ClutterUtil::user_data_to_actor( L, lua_gettop(L) );
	    lua_pop(L,1);
		if (!source) 
		{
			return luaL_error(L, "Incorrect argument, fail to set \'source\' : userdata expected");
		}

		// name 
		lua_getfield(L, -1, "name");
		const char * cname = lua_tostring(L,-1);
		if (!cname) 
		{
			return luaL_error(L, "Incorrect argument, failed to set \'name\' : string expected");
		}
		String name = cname; 
	    lua_pop(L,1);

    	// default parameter
    	bool ease_in = true;

		// ease_in 
		lua_getfield(L, -1, "ease_in");
		if (!lua_isnil(L, -1))
		{
			if (!lua_isboolean(L, -1))
			{
				return luaL_error(L, "Incorrect argument, failed to set \'ease_in\' : boolean expected");
			}
			ease_in = lua_toboolean(L,-1);
		}
	    lua_pop(L,1);
		 
		 
		 // keys 
		lua_getfield(L, -1, "keys");
		if (!lua_istable(L,-1))
		{
			return luaL_error(L, "Incorrect argument, failed to set \'keys\' : table expected");
		}

		int kt = lua_gettop(L);

		lua_pushnil(L); 
		while(lua_next(L, kt) != 0) 
		{
			if (!lua_istable(L,-1))
			{
				return luaL_error(L, "Incorrect argument, failed to set \'keys\' element : table expected");
			}

			// default parameter
    	    String mode = "LINEAR"; 
			double progress;

		 	lua_rawgeti(L,-1,1);
		 	lua_rawgeti(L,-2,2);
		 	lua_rawgeti(L,-3,3);

			// progress 
			if(!lua_isnumber(L, -3))
			{
				return luaL_error(L, "Incorrect argument, failed to set the first argument of keys : number(0..1) expected");
			}
			
			if(lua_tonumber(L,-3) > 1 || lua_tonumber(L, -3) < 0) 
			{
				return luaL_error(L, "Incorrect argument, failed to set the first argument of keys : number(0..1) expected");
			}
			
			progress = lua_tonumber(L,-3);

			// mode, value  
			if ((lua_type(L, -2) == LUA_TNUMBER)||(lua_type(L, -2) == LUA_TTABLE))
			{
				set_animator_value(L, -2, animator, source, name , mode, progress, ease_in);
			}
			else if(lua_isstring(L, -2)) 
			{
				const char* cmode = lua_tostring(L,-2); 
				if (cmode)
				{
					mode  = cmode;
				}
			    if((lua_isnumber(L, -1))||(lua_istable(L, -1))) 
				{
					set_animator_value(L, -1, animator, source, name , mode, progress, ease_in);
				}
			} 
			else 
			{
				return luaL_error (L, "Incorrect argument, failed to set keys value"); 
			}

			lua_pop(L,4);
		 }
	     lua_pop(L,2);
	 }
	 lua_pop(L,1);

     return 0;
}

]]

/*
    Class: Animator
    
    A animator is an object providing declarative animations for UIElements' properties. Animator is used to 
    build and describe complex animations in terms of "key frames". 
*/

class Animator [[ClutterAnimator*]]
{
    Animator( table props )
		[[
			self=clutter_animator_new();
			g_object_ref(self);
			self=lb_construct_gobject(ClutterAnimator,self);
			populate_animator(L, props, self);
	    	g_object_unref(self);
		]];
	
    ~Animator()
		[[
		]];
	
	/*
		Property: duration
		The duration of the animator in milliseconds.
	*/
	
    int duration
		[[duration=clutter_animator_get_duration(self);]]
		[[clutter_animator_set_duration(self,duration);]];
	
 	/*
		Property: timeline
	*/

	Timeline timeline
		[[
	    	ClutterUtil::wrap_timeline( L , clutter_animator_get_timeline(self) );
		]]
		[[
	    	if ( ClutterTimeline * t = ClutterUtil::user_data_to_timeline( L , lua_gettop( L ) ) )
	     	{
	       		clutter_animator_set_timeline( self , t );
	        }
		]];

	/*
		Function: start
		Starts the animator.
	*/
	
    start()
		[[
		  clutter_animator_start(self);
	    ]];
}

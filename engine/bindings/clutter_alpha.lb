module clutter_alpha;

[[
#include "clutter/clutter.h"

#include "util.h"
#include "clutter_util.h"
]]

[[
gdouble Alpha_on_alpha(ClutterAlpha*self,gpointer lsp);
void Alpha_on_alpha_destroy(gpointer lsp);

extern int wrap_Timeline(lua_State*L,ClutterTimeline* self);

]]

/*
    Class: Alpha 
    
    An alpha is an object that converts progress values from a <Timeline>. It is used
    to implement different animation modes, such as ease-in. It has nothing to do with
    color alpha values.
    
    You can attach your own function to <on_alpha> which lets you create 
    your own conversions.  
*/

class Alpha [[ClutterAlpha*]]
{
    Alpha(table props = 0)
	[[
	    self=clutter_alpha_new();
	    g_object_ref_sink(self);
	    g_object_ref(self);
	    self=lb_construct_gobject( ClutterAlpha , self );
    	ClutterUtil::set_props_from_table(L,props);
    	g_object_unref(self);
	]];

    
    ~Alpha()
	[[
	]];
	
	/*
		Property: timeline
		
		The Timeline this alpha is attached to. 
	*/
	
    Timeline timeline
		[[
		    ClutterTimeline * timeline=clutter_alpha_get_timeline(self);
		    if ( ! timeline )
		    {
		    	lua_pushnil( L );
		    }
		    else if ( UserData * ud = UserData::get( G_OBJECT( timeline ) ) )
		    {
		    	ud->push_proxy();
		    }
		    else
		    {
		    	lua_pushnil( L );
		    }
		]]
		[[
		    luaL_checkudata(L,-1,"TIMELINE_METATABLE");
		    
		    UserData * ud = UserData::get( L , -1 );
		    
		    if ( ud )
		    {
		    	GObject * timeline = ud->get_master();
		    	
		    	if ( timeline && CLUTTER_IS_TIMELINE( timeline ) )
		    	{
			    	clutter_alpha_set_timeline(self,CLUTTER_TIMELINE(timeline));
		    	}
		    }		    
		]];
		
	/*
		Property: mode
		
		To use one of the built-in modes, you can pass its name to this property.
		
		Possible Values:
		
		  LINEAR - Linear.
		  EASE_IN_QUAD - Ease in quadratic.
		  EASE_OUT_QUAD - Ease out quadratic.
		  EASE_IN_OUT_QUAD - Ease in and out quadratic.
		  EASE_IN_CUBIC - Ease in cubic.
		  EASE_OUT_CUBIC - Ease out cubic.
		  EASE_IN_OUT_CUBIC - Ease in and out cubic.
		  EASE_IN_QUART - Ease in quartic.
		  EASE_OUT_QUART - Ease out quartic.
		  EASE_IN_OUT_QUART - Ease in and out quartic.
		  EASE_IN_QUINT - Ease in quintic.
		  EASE_OUT_QUINT - Ease out quintic.
		  EASE_IN_OUT_QUINT - Ease in and out quintic.
		  EASE_IN_SINE - Ease in sinusoidal.
		  EASE_OUT_SINE - Ease out sinusoidal
		  EASE_IN_OUT_SINE - Ease in and out sinusoidal
		  EASE_IN_EXPO - Ease in exponential.
		  EASE_OUT_EXPO - Ease out exponential.
		  EASE_IN_OUT_EXPO - Ease in and out exponential.
		  EASE_IN_CIRC - Ease in circular.
		  EASE_OUT_CIRC - Ease out circular.
		  EASE_IN_OUT_CIRC - Ease in and out circular.
		  EASE_IN_ELASTIC - Ease in elastic.
		  EASE_OUT_ELASTIC - Ease out elastic.
		  EASE_IN_OUT_ELASTIC - Ease in and out elastic.
		  EASE_IN_BACK - Ease in overshooting cubic.
		  EASE_OUT_BACK - Ease out overshooting cubic.
		  EASE_IN_OUT_BACK - Ease in and out overshooting cubic.
		  EASE_IN_BOUNCE - Ease in exponentially decaying parabolic.
		  EASE_OUT_BOUNCE - Ease out exponentially decaying parabolic.
		  EASE_IN_OUT_BOUNCE - Ease in and out exponentially decaying parabolic.
			
	*/
	
    string mode
		[[
		    GEnumClass * ec = G_ENUM_CLASS(g_type_class_ref(CLUTTER_TYPE_ANIMATION_MODE));
		    GEnumValue * v  = g_enum_get_value(ec,clutter_alpha_get_mode(self));
		    mode = (v?&(v->value_name[8]):"");
		    g_type_class_unref(ec);	    
		]]
		[[
		    GEnumClass * ec = G_ENUM_CLASS(g_type_class_ref(CLUTTER_TYPE_ANIMATION_MODE));
		    std::string cm("CLUTTER_");
		    cm+= mode;
		    
		    GEnumValue * v = g_enum_get_value_by_name(ec,cm.c_str());
		    
		    if(!v)
			luaL_error(L,"Invalid alpha mode '%s'",mode);
			
			
		    clutter_alpha_set_mode(self,v->value);
		    g_type_class_unref(ec);
		]];
	
	/*
		Property: alpha
		
		Returns the current value of this alpha.
	*/
	
    readonly double alpha
		[[alpha=clutter_alpha_get_alpha(self);]];
	
	/*
		Event: on_alpha
		
		This is a function that receives a number between 0 and 1 and returns
		a new number. If you return the same number you received as an argument,
		it would be a linear alpha.
		
		(code)
		local my_alpha = Alpha()
		
		function my_alpha.on_alpha( alpha, progress )
			return progress
		end 
		(end)
		
		Arguments:
		
			alpha - The alpha object this event applies to.
			
			progress - A number between 0 and 1 - the timeline's progress value.
			
		Returns:
		
			number - The converted result.
	*/
    
    callback on_alpha
		[[
		    clutter_alpha_set_func(self,NULL,NULL,NULL);
		    if (on_alpha)
		    {
			clutter_alpha_set_func(
			    self,
			    Alpha_on_alpha,
			    App::get(L)->ref_lua_state_proxy(),
			    Alpha_on_alpha_destroy);
		    }
		]];	    
}

[[

void Alpha_on_alpha_destroy(gpointer lsp)
{
    ((LuaStateProxy*)lsp)->unref();
}

gdouble Alpha_on_alpha(ClutterAlpha*self,gpointer lsp)
{
    lua_State * L=((LuaStateProxy*)lsp)->get_lua_state();
    
    if (!L)
    {
		return 0;
    }
    
    lua_pushnumber(L,clutter_timeline_get_progress(clutter_alpha_get_timeline(self)));
    
    UserData::invoke_callback( G_OBJECT( self ) , "on_alpha" , 1 , 1 , L );
    
    gdouble result(lua_tonumber(L,-1));
    lua_pop(L,1);
    
    return result;    
}
]]

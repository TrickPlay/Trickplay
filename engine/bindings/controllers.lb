
module controllers_module;

[[
#include "app.h"    
#include "context.h"
#include "controller_list.h"
#include "images.h"
#include "bitmap.h"
#include "json.h"
]]

#==============================================================================

[[

class ControllerListDelegate;

class ControllerDelegate : public Controller::Delegate
{
public:
    
    ControllerDelegate(lua_State * _L,Controller * _controller,ControllerListDelegate * _list);
    ~ControllerDelegate();
    
    inline Controller * get_controller()
    {
        return controller;
    }
    
    inline bool has_cap(unsigned int cap)
    {
        return controller->get_capabilities()&cap;        
    }
    
    //.........................................................................
    // Delegate functions
    
    virtual void disconnected();
    virtual bool key_down(unsigned int key_code,unsigned long int unicode);
    virtual bool key_up(unsigned int key_code,unsigned long int unicode);
    virtual void accelerometer(double x,double y,double z);
    virtual bool pointer_move( int x, int y );
    virtual bool pointer_button_down( int button , int x, int y );
    virtual bool pointer_button_up( int button , int x, int y );
    virtual void touch_down(int finger,int x,int y);
    virtual void touch_move(int finger,int x,int y);
    virtual void touch_up(int finger,int x,int y);
    virtual void ui_event(const String & parameters);
    virtual void submit_picture( void * data, unsigned int size, const char * mime_type );
    virtual void submit_audio_clip( void * data, unsigned int size, const char * mime_type );
    
    bool declare_resource( const String & name , const String & uri );

private:
    
    lua_State *                 L;
    Controller *                controller;
    ControllerListDelegate *    list;
    String                      resource_group;
};

]]

#==============================================================================

[[

class ControllerListDelegate : public ControllerList::Delegate
{
public:
    
    ControllerListDelegate(lua_State * l);
    ~ControllerListDelegate();

    //.........................................................................
    // Delegate function
    
    virtual void connected(Controller * controller);
    
    void push_connected();
    
    void proxy_disconnected(ControllerDelegate * proxy);
    
    void start_pointer();

private:

    lua_State *         L;
    ControllerList *    list;
    
    typedef std::map< ControllerDelegate* , UserData::Handle * > ProxyMap;
    
    ProxyMap            proxies;
};
    

]]


#==============================================================================
/*
	Global: controllers
	
	Controllers are human interface devices. The simple examples are the keyboard
	on the TrickPlay emulator or the remote control on a TV. TrickPlay also supports
	clients that run on other devices and connect to TrickPlay to act as controllers.
	
	The controllers global lets you enumerate all the controllers that are currently
	connected, using the <connected> property. You can also be notified when a new 
	controller is connected by using the <on_controller_connected> event.
*/

global controllers [[ControllerListDelegate*]]
{
    controllers()
        [[
            self=lb_construct( ControllerListDelegate , new ControllerListDelegate(L) );            
        ]];
        
    ~controllers()
        [[
            delete self;
        ]];
        
    /*
    	Property: connected
    	
    	This property returns a table of <controller> objects containing all the 
    	controllers that are currently connected.
    */
    
    readonly table connected
        [[
            self->push_connected();
        ]];
    
    /*
       Function: start_pointer

       A convenience function that tells all connected controllers to start
       sending pointer events.
    */

    start_pointer()
        [[
            self->start_pointer();
        ]];

    /*
    	Event: on_controller_connected
    	
    	This event happens any time a new controller connects to TrickPlay.
    	
    	Arguments:
    	
    		controllers - The <controllers> global.
    		
    		controller - The <controller> that connected.
    */    
    
    callback on_controller_connected;    
}

#==============================================================================

/*
	Class: controller
	
	This class represents a controller that is connected to TrickPlay. You cannot
	create new controllers, they are created automatically by TrickPlay when they
	connect.
*/

interface controller [[ControllerDelegate*]]
{
    controller()
        [[
            self=lb_construct( ControllerDelegate , lua_touserdata(L,-2) );
        ]];
        
    ~controller()
        [[
            delete self;    
        ]];
        
    /*
    	Property: is_connected
    	
    	Lets you know if this controller is still connected to TrickPlay. It is possible
    	for a controller to disconnect but its object to remain alive in your app.
    */
    
    readonly bool is_connected
        [[
            is_connected=self->get_controller()->is_connected();    
        ]];
    
    /*
    	Property: name
    	
    	The name that the controller reports, which could be something like "Bill's phone".
    */
        
    readonly string name
        [[
            String s(self->get_controller()->get_name());
            name=s.c_str();    
        ]];
        
    /*
    	Property: has_keys
    	
    	This property tells you whether the controller can send key events.
    */
    
    readonly bool has_keys
        [[
            has_keys=self->has_cap(TP_CONTROLLER_HAS_KEYS);    
        ]];

	/*
		Property: has_accelerometer
		
		Whether the controller has an accelerometer.
	*/
	
    readonly bool has_accelerometer
        [[
            has_accelerometer=self->has_cap(TP_CONTROLLER_HAS_ACCELEROMETER);
        ]];
        
    readonly bool has_clicks
        [[
            has_clicks=false;
        ]];

    /*
        Property: has_pointer

        Whether the controller can send pointer events.
    */
    
    readonly bool has_pointer
        [[
            has_pointer=self->has_cap(TP_CONTROLLER_HAS_POINTER);
        ]];
    
    /*
    	Property: has_touches
    	
    	Whether the controller can send touch events.
    */    
    
    readonly bool has_touches
        [[
            has_touches=self->has_cap(TP_CONTROLLER_HAS_TOUCHES);    
        ]];
    
    /*
    	Property: has_multiple_choice
    	
    	Whether the controller supports a multiple choice UI.
    */
        
    readonly bool has_multiple_choice
        [[
            has_multiple_choice=self->has_cap(TP_CONTROLLER_HAS_MULTIPLE_CHOICE); 
        ]];
        
	/*
		Property: has_sound
		
		Whether the controller can play sounds.
	*/        
	
    readonly bool has_sound
        [[
            has_sound=self->has_cap(TP_CONTROLLER_HAS_SOUND);    
        ]];
    
    /*
    	Property: has_ui
    	
    	Whether the controller supports a user interface display.
    */
        
    readonly bool has_ui
        [[
            has_ui=self->has_cap(TP_CONTROLLER_HAS_UI);
        ]];
        
	/*
		Property: has_text_entry
		
		Whether the controller supports text entry.
	*/
	       
    readonly bool has_text_entry
        [[
            has_text_entry=self->has_cap(TP_CONTROLLER_HAS_TEXT_ENTRY);
        ]];
    
    /*
        Property: has_pictures
        
        Whether the controller supports pictures.
    */
           
    readonly bool has_pictures
        [[
            has_pictures=self->has_cap(TP_CONTROLLER_HAS_PICTURES);
        ]];
    
    /*
        Property: has_audio_clips
        
        Whether the controller supports audio clips.
    */
           
    readonly bool has_audio_clips
        [[
            has_audio_clips=self->has_cap(TP_CONTROLLER_HAS_AUDIO_CLIPS);
        ]];
    
    /*
        Property: has_advanced_ui

        Whether the controller supports advanced UI functions.
    */

    readonly bool has_advanced_ui
        [[
            has_advanced_ui = self->has_cap( TP_CONTROLLER_HAS_ADVANCED_UI );
        ]];

    /*
    	Property: ui_size
    	
    	This property returns a table containing the width and height 
    	of the controller's UI display area.
    */    
    
    readonly table ui_size
        [[
            unsigned int w;
            unsigned int h;
            
            self->get_controller()->get_ui_size(w,h);
            
            lua_newtable(L);
            lua_pushinteger(L,w);
            lua_rawseti(L,-2,1);
            lua_pushinteger(L,h);
            lua_rawseti(L,-2,2);
        ]];
        
    /*
    	Property: input_size
    	
    	Returns a table containing the width and height of the controller's
    	input area - the area for touch and click events.
    */
    
    readonly table input_size
        [[
            unsigned int w;
            unsigned int h;
            
            self->get_controller()->get_input_size(w,h);
            
            lua_newtable(L);
            lua_pushinteger(L,w);
            lua_rawseti(L,-2,1);
            lua_pushinteger(L,h);
            lua_rawseti(L,-2,2);
        ]];
    
    /*
    	Function: reset
    	
    	Resets the controller to its default state. The controller will 
    	stop sending all events other than key events and its UI, if any,
    	will be cleared.
    	
    	Returns:
    	
    		true - If it was successful.
    		
    		false - Otherwise.
    */
        
    bool reset()
        [[
            result=self->get_controller()->reset();    
        ]];
        
    /*
    	Function: start_accelerometer
    	
    	Tells the controller to start sending accelerometer events.
    	
    	Arguments:
    	
    		filter - A string that can be "L" for a low-pass filter
    				 or "H" for a high pass filter.
    				 
    		interval - The interval, in seconds, between events.
    	
    	Returns:
    	
    		true - If it was successful.
    		
    		false - Otherwise.
    */

    bool start_accelerometer(string filter,double interval)
        [[
            Controller::AccelerometerFilter f=Controller::NONE;
            
            if (filter)
            {
                if (*filter=='L'||*filter=='l')
                {
                    f=Controller::LOW;
                }
                else if (*filter=='H'||*filter=='h')
                {
                    f=Controller::HIGH;
                }
            }

            result=self->get_controller()->start_accelerometer(f,interval);
        ]];

	/*
		Function: stop_accelerometer
		
		Tells the controller to stop sending accelerometer events.
    	
    	Returns:
    	
    		true - If it was successful.
    		
    		false - Otherwise.
	*/
	        
    bool stop_accelerometer()
        [[
            result=self->get_controller()->stop_accelerometer();    
        ]];
        

    /*
        Function: start_pointer

        Tells the controller to start sending pointer events.

        Returns:

            true - If it was successful.

            false - Otherwise.
    */

    bool start_pointer()
        [[
            result=self->get_controller()->start_pointer();
        ]];
        
    /*
        Function: stop_pointer

        Tells the controller to stop sending pointer events.

        Returns:

            true - If it was successful.

            false - Otherwise.
    */

    bool stop_pointer()
        [[
            result=self->get_controller()->stop_pointer();
        ]];
    
    /*
    	Function: start_touches
    	
    	Tells the controller to start sending touch events.
    	
    	Returns:
    	
    		true - If it was successful.
    		
    		false - Otherwise.
    */
        
    bool start_touches()
        [[
            result=self->get_controller()->start_touches();
        ]];
        
    /*
    	Function: stop_touches
    	
    	Stop sending touch events.
    		
    	Returns:
    	
    		true - If it was successful.
    		
    		false - Otherwise.
	*/
	
    bool stop_touches()
        [[
            result=self->get_controller()->stop_touches();
        ]];

    # Deprecated, use the other one
    
    bool show_multiple_choice_ui()
        [[
            g_warning("DEPRECATED CALL TO controller:show_multiple_choice_ui");
            result=false;
        ]];
        
    /*
    	Function: show_multiple_choice
    	
    	Tells the controller to show a simple UI with a list of choices. The
    	user of the controller will be able to click on the choices and the
    	controller will generate an <on_ui_event> with the identifier of the 
    	choice.
    	
    	Note that the controller will not automatically dismiss the multiple
    	choice UI when the user makes a choice; you have to call <clear_ui>.
    	
    	> controller:show_multiple_choice( "Pick a state" , "1" , "California" , "2" , "Texas" )
    	
    	Arguments:
    	
    		label - A string that describes the list of choices. The controller 
    				will usually display this label above the list of choices.
    				
    		others - After the label, you can pass a number of identifier/label
    				 pairs. The controller will display each label as a choice 
    				 and will retain its associated identifier to send back 
    				 in an <on_ui_event>.
    		
    	Returns:
    	
    		true - If it was successful.
    		
    		false - Otherwise.
	*/
	        
    bool show_multiple_choice(string label,...)
        [[
            StringPairList list;
            
            int count=lua_gettop(L);
            
            for (int i=3;i+1<=count;i+=2)
            {
                const char * id=lua_tostring(L,i);
                const char * choice=lua_tostring(L,i+1);                

                if (id && choice)
                    list.push_back(StringPair(String(id),String(choice)));
            }
            
            result=list.empty()?false:self->get_controller()->show_multiple_choice(label,list);
        ]];

	/*
		Function: clear_ui
		
		Removes all UI elements from the controller's screen.
		    		
    	Returns:
    	
    		true - If it was successful.
    		
    		false - Otherwise.
	*/
	
    bool clear_ui()
        [[
            result=self->get_controller()->clear_ui();    
        ]];
    
    # Deprecated, use the other one
    
    bool set_background(string resource)
        [[
            g_warning("DEPRECATED CALL TO controller:set_background");            
            result=false;
        ]];

	/*
		Function: set_ui_background
		
		Tells the controller to set its background to an image that
		you specify. Images are declared to the controller 
		using <declare_resource>.
		
		Arguments:
		
			resource - Name of the image resource.
			
			mode - One of "CENTER", "TILE" or "STRETCH".

    	Returns:
    	
    		true - If it was successful.
    		
    		false - Otherwise.
	*/
	
    bool set_ui_background(string resource,string mode="CENTER")
        [[
            Controller::UIBackgroundMode m=Controller::CENTER;
            
            if (mode)
            {
                if (*mode=='S'||*mode=='s')
                {
                    m=Controller::STRETCH;
                }
                else if (*mode=='T'||*mode=='t')
                {
                    m=Controller::TILE;
                }
            }
            
            result=self->get_controller()->set_ui_background(resource,m);
        ]];

	/*
		Function: set_ui_image
		
		Tells the controller to place the given image at the given coordinates
		with the given size.
		
		Arguments:
		
			resource - Name of an image resource declared with <declare_resource>.
			
			x,y - The position of the image.
			
			width,height - The size of the image.

    	Returns:
    	
    		true - If it was successful.
    		
    		false - Otherwise.
	*/
	        
    bool set_ui_image(string resource,int x,int y,int width,int height)
        [[
            result=self->get_controller()->set_ui_image(resource,x,y,width,height);    
        ]];

	/*
		Function: play_sound
		
		Tells the controller to play a sound.
		
		Arguments:
		
			resource - Name of a sound resource declared with <declare_resource>.
			
			loop - How many times to play the sound. 

    	Returns:
    	
    		true - If it was successful.
    		
    		false - Otherwise.
	*/
	
    bool play_sound(string resource, int loop)
        [[
            result=self->get_controller()->play_sound(resource,loop);
        ]];

	/*
		Function: stop_sound
		
		Tells the controller to stop playing sounds.
		
    	Returns:
    	
    		true - If it was successful.
    		
    		false - Otherwise.		
	*/
	
    bool stop_sound()
        [[
            result=self->get_controller()->stop_sound();
        ]];

	/*
		Function: declare_resource
		
		This function is used to associate a name with a resource,
		such as an image or a sound file. You can also use a URL
		as the second parameter.
		
		Declaring a resource gives it a name that can be used in
		future calls. The controller may need to download the resource
		before it is used, so it is a good idea to declare resources
		early.
		
		Arguments:
		
			resource - A name for the resource.
			
			url - A path or URL to the resource.
			 		
    	Returns:
    	
    		true - If it was successful.
    		
    		false - Otherwise.		
	*/

    bool declare_resource(string resource, string url)
        [[
            result=false;
            
            bool is_uri=false;
            
            App * app = App::get(L);

            gchar * path=app->normalize_path(url,&is_uri);
            
            if (path)
            {
                String final_uri(path);
                g_free(path);
                
                if (!is_uri)
                {
                    final_uri="file://"+final_uri;
                }
                
                result=self->declare_resource(resource,final_uri);
            }
        ]];
        
	/*
		Function: enter_text
		
		Tells the controller to show a text entry UI, such as a keyboard, and 
		allow the user to enter or edit text. Once the text has been entered, it
		will be sent back to your app via <on_ui_event>.
		
		Arguments:
		
			label - A caption for the text.
			
			text - The initial text to edit.
		 
    	Returns:
    	
    		true - If it was successful.
    		
    		false - Otherwise.		
	*/
	        
    bool enter_text(string label,string text)
        [[
            result=self->get_controller()->enter_text(label,text);    
        ]];

    /*
        Function: submit_picture
        
        Tells the controller to send a picture. The app will receive the picture via <on_picture>.
        
        Arguments:
        
            max_dimensions - An optional table containing two integers. The first is the
                             maximum desired width for the picture. The second is the maximum
                             desired height for the picture. If they are both zero or not
                             provided, the picture will be sent at its original dimensions.

            edit -           If true, the controller may give the user a chance to edit
                             the picture before it is submitted.

            mask -           This should be the name of an image previously declared as a
                             resource. When it is present, the controller will composite the
                             mask with the picture and submit the result.
         
        Returns:
        
            true - If it was successful.
            
            false - Otherwise.      
    */
            
    bool submit_picture( table max_dimensions = 0 , bool edit = false , string mask = "" )
        [[
            unsigned int max_width = 0;
            unsigned int max_height = 0;

            if ( max_dimensions )
            {
                lua_rawgeti( L , max_dimensions , 1 );
                max_width = lua_tointeger( L , -1 );
                lua_pop( L , 1 );
                lua_rawgeti( L , max_dimensions , 2 );
                max_height = lua_tointeger( L , -1 );
                lua_pop( L , 1 );
            }

            result=self->get_controller()->submit_picture( max_width , max_height , edit , String( mask ) );
        ]];

    /*
        Function: submit_audio_clip
        
        Tells the controller to send an audio clip. The app will receive the audio clip via <on_audio_clip>.
        
        
         
        Returns:
        
            true - If it was successful.
            
            false - Otherwise.      
    */
            
    bool submit_audio_clip( )
        [[
            result=self->get_controller()->submit_audio_clip( );    
        ]];

    /*
        Function: advanced_ui_create
    */
      
    bool advanced_ui_create( table payload )
        [[
            JSON::Value value = JSON::to_json( L , payload );

            if ( ! value.is<JSON::Array>() )
            {
                result = false;
            }
            else
            {
                result = self->get_controller()->advanced_ui( TP_CONTROLLER_ADVANCED_UI_CREATE , value.stringify() );
            }
        ]];

    /*
        Function: advanced_ui_destroy
    */

    bool advanced_ui_destroy( table payload )
        [[
            JSON::Value value = JSON::to_json( L , payload );

            if ( ! value.is<JSON::Array>() )
            {
                result = false;
            }
            else
            {
                result = self->get_controller()->advanced_ui( TP_CONTROLLER_ADVANCED_UI_DESTROY , value.stringify() );
            }
        ]];

    /*
        Function: advanced_ui_set
    */

    bool advanced_ui_set( table payload )
        [[
            JSON::Value value = JSON::to_json( L , payload );

            if ( ! value.is<JSON::Array>() )
            {
                result = false;
            }
            else
            {
                result = self->get_controller()->advanced_ui( TP_CONTROLLER_ADVANCED_UI_SET , value.stringify() );
            }
        ]];

    /*
        Function: advanced_ui_get
    */

    bool advanced_ui_get( table payload )
        [[
            JSON::Value value = JSON::to_json( L , payload );

            if ( ! value.is<JSON::Array>() )
            {
                result = false;
            }
            else
            {
                result = self->get_controller()->advanced_ui( TP_CONTROLLER_ADVANCED_UI_GET , value.stringify() );
            }
        ]];

     /*
		Event: on_disconnected
		
		This event is triggered when the controller is disconnected from
		TrickPlay.
		
		Arguments:
		
			controller - The controller that was disconnected.			
	*/	
	
    callback on_disconnected;
    
    /*
    	Event: on_key_down
    	
    	A key down event.
    	
    	Arguments:
    	
    		controller - The controller that generated the event.
    		
    		key code - The numeric code of the key.
    		
    		unicode - The unicode value of the key or 0.
    		
    	Returns:
    	
    		false - If you don't want the event to be propagated.
    */
    
    callback on_key_down;
    
    /*
    	Event: on_key_up
    	
    	A key up event.
    	
    	Arguments:
    	
    		controller - The controller that generated the event.
    		
    		key code - The numeric code of the key.
    		
    		unicode - The unicode value of the key or 0.

    	Returns:
    	
    		false - If you don't want the event to be propagated.
    */

    callback on_key_up;
    
    /*
    	Event: on_accelerometer
    	
    	An accelerometer event.
    	
    	Arguments:
    	
    		controller - The controller that generated the event.
    		
    		x,y,z - The three values of the accelerometer.
    */
    
    callback on_accelerometer;

	/*
		Event: on_pointer_move
		
		A pointer move event.
		
    	Arguments:
    	
    		controller - The controller that generated the event.
    		
    		x,y - The coordinates of the event.

        Returns:

            false - If you don't want the event to be propagated.
	*/
	    
    callback on_pointer_move;

    /*
        Event: on_pointer_button_down

        A pointer button was pressed.

        Arguments:

            controller - The controller that generated the event.

            button - The button, starting at 0.

            x,y - The coordinates of the event.

        Returns:

            false - If you don't want the event to be propagated.
    */

    callback on_pointer_button_down;

    /*
        Event: on_pointer_button_up

        A pointer button was released.

        Arguments:

            controller - The controller that generated the event.

            button - The button, starting at 0.

            x,y - The coordinates of the event.

        Returns:

            false - If you don't want the event to be propagated.
    */

    callback on_pointer_button_up;

    /*
		Event: on_touch_down
		
		A touch down event.

    	Arguments:
    	
    		controller - The controller that generated the event.
    		
    		finger - The finger, starting at 0.

    		x,y - The coordinates of the event.
	*/
	    
    callback on_touch_down;
    
	/*
		Event: on_touch_move
		
		A touch move event.

    	Arguments:
    	
    		controller - The controller that generated the event.
    		
            finger - The finger, starting at 0.

    		x,y - The coordinates of the event.
	*/

    callback on_touch_move;
    
	/*
		Event: on_touch_up
		
		A touch up event.

    	Arguments:
    	
    		controller - The controller that generated the event.
    		
            finger - The finger, starting at 0.

    		x,y - The coordinates of the event.
	*/

    callback on_touch_up;

    /*
    	Event: on_ui_event
    	
    	A UI event. This is sent when you use <show_multiple_choice> or 
    	<enter_text>.
    	
    	Arguments:
    	
    		controller - The controller that generated the event.
    		
    		text - The text of the event. Either an identifier for a 
    		       multiple choice, or the resulting text of <enter_text>.
    */
    
    callback on_ui_event;


    /*
        Event: on_picture
        
        A picture event. This is sent when you use <submit_picture>.
        
        Arguments:
            controller - The controller that generated the event.
            
            bitmap - The bitmap received from the controller.
            
    */
    callback on_picture;
    
}

#==============================================================================

[[

//.........................................................................

ControllerDelegate::ControllerDelegate(lua_State * _L,Controller * _controller,ControllerListDelegate * _list)
:
    L(_L),
    controller(_controller),
    list(_list)
{
    controller->ref();
    controller->add_delegate(this);        
}

//.........................................................................

ControllerDelegate::~ControllerDelegate()
{
    if ( ! resource_group.empty() )
    {
        controller->drop_resource_group( resource_group );
    }

    controller->remove_delegate(this);
    controller->unref();    
}

//.........................................................................
// Delegate functions

void ControllerDelegate::disconnected()
{   
    invoke_controller_on_disconnected(L,this,0,0);
    
    list->proxy_disconnected(this);    
}

bool ControllerDelegate::key_down(unsigned int key_code,unsigned long int unicode)
{
    lua_pushnumber(L,key_code);
    lua_pushnumber(L,unicode);

    bool result = true;

    if ( invoke_controller_on_key_down(L,this,2,1) )
    {
	    if ( lua_isboolean( L , -1 ) && ! lua_toboolean( L , -1 ) )
	    {
	    	result = false;
	    } 
	    
	    lua_pop( L , 1 );
	}    
    
    return result;
}

bool ControllerDelegate::key_up(unsigned int key_code,unsigned long int unicode)
{
    lua_pushnumber(L,key_code);
    lua_pushnumber(L,unicode);

    bool result = true;

    if ( invoke_controller_on_key_up(L,this,2,1) )
    {
    
    	if ( lua_isboolean( L , -1 ) && ! lua_toboolean( L , -1 ) )
    	{
    		result = false;
    	} 
    
    	lua_pop( L , 1 );
    }
    
    return result;
}

void ControllerDelegate::accelerometer(double x,double y,double z)
{
    lua_pushnumber(L,x);
    lua_pushnumber(L,y);
    lua_pushnumber(L,z);    
    invoke_controller_on_accelerometer(L,this,3,0);    
}

bool ControllerDelegate::pointer_move(int x,int y)
{
    lua_pushnumber(L,x);
    lua_pushnumber(L,y);

    bool result = true;

    if ( invoke_controller_on_pointer_move(L,this,2,1) )
    {
        if ( lua_isboolean( L , -1 ) && ! lua_toboolean( L , -1 ) )
        {
            result = false;
        }

        lua_pop( L , 1 );
    }
    return result;
}

bool ControllerDelegate::pointer_button_down(int button,int x,int y)
{
    lua_pushnumber(L,button);
    lua_pushnumber(L,x);
    lua_pushnumber(L,y);

    bool result = true;

    if ( invoke_controller_on_pointer_button_down(L,this,3,1) )
    {
        if ( lua_isboolean( L , -1 ) && ! lua_toboolean( L , -1 ) )
        {
            result = false;
        }

        lua_pop( L , 1 );
    }
    return result;
}

bool ControllerDelegate::pointer_button_up(int button,int x,int y)
{
    lua_pushnumber(L,button);
    lua_pushnumber(L,x);
    lua_pushnumber(L,y);

    bool result = true;

    if ( invoke_controller_on_pointer_button_up(L,this,3,1) )
    {
        if ( lua_isboolean( L , -1 ) && ! lua_toboolean( L , -1 ) )
        {
            result = false;
        }

        lua_pop( L , 1 );
    }
    return result;
}

void ControllerDelegate::touch_down(int finger,int x,int y)
{   
    lua_pushnumber(L,finger);
    lua_pushnumber(L,x);
    lua_pushnumber(L,y);
    invoke_controller_on_touch_down(L,this,3,0);
}

void ControllerDelegate::touch_move(int finger, int x,int y)
{
    lua_pushnumber(L,finger);
    lua_pushnumber(L,x);
    lua_pushnumber(L,y);
    invoke_controller_on_touch_move(L,this,3,0);
}

void ControllerDelegate::touch_up(int finger, int x,int y)
{
    lua_pushnumber(L,finger);
    lua_pushnumber(L,x);
    lua_pushnumber(L,y);
    invoke_controller_on_touch_up(L,this,3,0);
}

void ControllerDelegate::ui_event(const String & parameters)
{
    lua_pushstring(L,parameters.c_str());
    invoke_controller_on_ui_event(L,this,1,0);
}

void ControllerDelegate::submit_picture( void * data, unsigned int size, const char * mime_type )
{
    Image * image = Image::decode(data, size, mime_type);
    
    if ( !image ) 
    {
        return;
    }
    
    lua_getglobal( L , "Bitmap" );
    lua_pushliteral( L , "" );
    lua_call( L , 1 , 1 );

    if ( Bitmap * bitmap = ( Bitmap * ) UserData::get_client( L , lua_gettop( L ) ) )
    {
        bitmap->set_image( image ); 
        
        invoke_controller_on_picture( L , this , 1 , 0 );
    }
    else
    {
        lua_pop( L , 1 );
        
        delete image;
    }
}

void ControllerDelegate::submit_audio_clip( void * data, unsigned int size, const char * mime_type )
{
}

bool ControllerDelegate::declare_resource( const String & name , const String & uri )
{
    if ( resource_group.empty() )
    {
        resource_group = App::get(L)->get_id();
    }

    return controller->declare_resource( name , uri , resource_group );
}

]]

#==============================================================================

[[

//.........................................................................

ControllerListDelegate::ControllerListDelegate(lua_State * l)
:
    L(l)
{
    list=App::get(L)->get_context()->get_controller_list();
    list->add_delegate(this);
}

//.........................................................................

ControllerListDelegate::~ControllerListDelegate()
{
    list->remove_delegate(this);
    
    for ( ProxyMap::iterator it = proxies.begin(); it != proxies.end(); ++it )
    {
    	UserData::Handle::destroy( it->second );
    }
}

//.........................................................................
// Delegate function

void ControllerListDelegate::connected(Controller * controller)
{
    ControllerDelegate * d=new ControllerDelegate(L,controller,this);
    
    lua_pushlightuserdata(L,d);
    
    new_controller(L);
    
    lua_remove(L,-2);

	// When a controller is connected, we create a handle to it - to keep the
	// Lua object around as long as it remains connected.
	
	proxies[ d ] = UserData::Handle::make( L , -1 );
    
    invoke_controllers_on_controller_connected(L,this,1,0);
}

//.........................................................................

void ControllerListDelegate::proxy_disconnected(ControllerDelegate * proxy)
{
	ProxyMap::iterator it = proxies.find( proxy );
	
	if ( it != proxies.end() )
	{
		UserData::Handle::destroy( it->second );
		
		proxies.erase( it );		
	}
}

//.........................................................................

void ControllerListDelegate::push_connected()
{
    lua_newtable(L);
    
    // These exist as Lua objects, so we should be able to find instances
    // for all of them. However, the proxies may not be connected
    
    int i=1;
    
    ControllerList::ControllerSet found;
    
    for(ProxyMap::iterator it=proxies.begin();it!=proxies.end();++it)
    {
        if (! it->first->get_controller()->is_connected())
            continue;
        
        UserData * ud = it->second->get_user_data();
        g_assert( ud );
        ud->push_proxy();
        
        lua_rawseti(L,-2,i++);
        
        found.insert(it->first->get_controller());
    }
    
    // These may not exist as Lua objects but they are definitely connected
    
    // This should not happen any more - since we hold on to the Lua objects as 
    // soon as they connect.
    
    ControllerList::ControllerSet controllers(list->get_controllers());
        
    for(ControllerList::ControllerSet::iterator it=controllers.begin();
        it!=controllers.end();++it)
    {
        if (found.find(*it)!=found.end())
        {
            continue;
        }
        
        ControllerDelegate * d=new ControllerDelegate(L,*it,this);
        
        lua_pushlightuserdata(L,d);
        
        new_controller(L);
        
        lua_remove(L,-2);
        
        proxies[ d ] = UserData::Handle::make( L , -1 );
        
        lua_rawseti(L,-2,i++);
    }
}

void ControllerListDelegate::start_pointer()
{
    ControllerList::ControllerSet controllers(list->get_controllers());

    for(ControllerList::ControllerSet::iterator it=controllers.begin();
        it!=controllers.end();++it)
    {
        (*it)->start_pointer();
    }
}

]]

#==============================================================================

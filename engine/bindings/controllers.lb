
module controllers_module;

[[
#include "app.h"    
#include "context.h"
#include "controller_list.h"
]]

#==============================================================================

[[

class ControllerListDelegate;

class ControllerDelegate : public Controller::Delegate
{
public:
    
    ControllerDelegate(lua_State * _L,Controller * _controller,ControllerListDelegate * _list);
    ~ControllerDelegate();
    
    inline Controller * get_controller()
    {
        return controller;
    }
    
    inline bool has_cap(unsigned int cap)
    {
        return controller->get_capabilities()&cap;        
    }
    
    //.........................................................................
    // Delegate functions
    
    virtual void disconnected();
    virtual void key_down(unsigned int key_code,unsigned long int unicode);
    virtual void key_up(unsigned int key_code,unsigned long int unicode);
    virtual void accelerometer(double x,double y,double z);
    virtual void click(int x,int y);
    virtual void touch_down(int x,int y);
    virtual void touch_move(int x,int y);  
    virtual void touch_up(int x,int y);    
    virtual void ui_event(const String & parameters);
    
private:
    
    lua_State *                 L;
    Controller *                controller;
    ControllerListDelegate *    list;
};

]]

#==============================================================================

[[

class ControllerListDelegate : public ControllerList::Delegate
{
public:
    
    ControllerListDelegate(lua_State * l);
    ~ControllerListDelegate();

    //.........................................................................
    // Delegate function
    
    virtual void connected(Controller * controller);
    
    void push_connected();
    
    void proxy_destroyed(ControllerDelegate * proxy);
    
private:

    lua_State *         L;
    ControllerList *    list;
    
    typedef std::set<ControllerDelegate*> ProxySet;
    
    ProxySet            proxies;
};
    

]]


#==============================================================================
/*
	Global: controllers
	
	Controllers are human interface devices. The simple examples are the keyboard
	on the TrickPlay emulator or the remote control on a TV. TrickPlay also supports
	clients that run on other devices and connect to TrickPlay to act as controllers.
	
	The controllers global lets you enumerate all the controllers that are currently
	connected, using the <connected> property. You can also be notified when a new 
	controller is connected by using the <on_controller_connected> event.
*/

global controllers [[ControllerListDelegate*]]
{
    controllers()
        [[
            *self=new ControllerListDelegate(L);            
        ]];
        
    ~controllers()
        [[
            delete self;
        ]];
        
    /*
    	Property: connected
    	
    	This property returns a table of <controller> objects containing all the 
    	controllers that are currently connected.
    */
    
    readonly table connected
        [[
            self->push_connected();
        ]];
    
    /*
    	Event: on_controller_connected
    	
    	This event happens any time a new controller connects to TrickPlay.
    	
    	Arguments:
    	
    		controllers - The <controllers> global.
    		
    		controller - The <controller> that connected.
    */    
    
    callback on_controller_connected;    
}

#==============================================================================

/*
	Class: controller
	
	This class represents a controller that is connected to TrickPlay. You cannot
	create new controllers, they are created automatically by TrickPlay when they
	connect.
*/

interface controller [[ControllerDelegate*]]
{
    controller()
        [[
            *self=(ControllerDelegate*)lua_touserdata(L,-2);
        ]];
        
    ~controller()
        [[
            delete self;    
        ]];
        
    /*
    	Property: is_connected
    	
    	Lets you know if this controller is still connected to TrickPlay. It is possible
    	for a controller to disconnect but its object to remain alive in your app.
    */
    
    readonly bool is_connected
        [[
            is_connected=self->get_controller()->is_connected();    
        ]];
    
    /*
    	Property: name
    	
    	The name that the controller reports, which could be something like "Bill's phone".
    */
        
    readonly string name
        [[
            String s(self->get_controller()->get_name());
            name=s.c_str();    
        ]];
        
    /*
    	Property: has_keys
    	
    	This property tells you whether the controller can send key events.
    */
    
    readonly bool has_keys
        [[
            has_keys=self->has_cap(TP_CONTROLLER_HAS_KEYS);    
        ]];

	/*
		Property: has_accelerometer
		
		Whether the controller has an accelerometer.
	*/
	
    readonly bool has_accelerometer
        [[
            has_accelerometer=self->has_cap(TP_CONTROLLER_HAS_ACCELEROMETER);
        ]];
        
    /*
    	Property: has_clicks
    	
    	Whether the controller can send click events.
    */
    
    readonly bool has_clicks
        [[
            has_clicks=self->has_cap(TP_CONTROLLER_HAS_CLICKS);
        ]];
    
    /*
    	Property: has_touches
    	
    	Whether the controller can send touch events.
    */    
    
    readonly bool has_touches
        [[
            has_touches=self->has_cap(TP_CONTROLLER_HAS_TOUCHES);    
        ]];
    
    /*
    	Property: has_multiple_choice
    	
    	Whether the controller supports a multiple choice UI.
    */
        
    readonly bool has_multiple_choice
        [[
            has_multiple_choice=self->has_cap(TP_CONTROLLER_HAS_MULTIPLE_CHOICE); 
        ]];
        
	/*
		Property: has_sound
		
		Whether the controller can play sounds.
	*/        
	
    readonly bool has_sound
        [[
            has_sound=self->has_cap(TP_CONTROLLER_HAS_SOUND);    
        ]];
    
    /*
    	Property: has_ui
    	
    	Whether the controller supports a user interface display.
    */
        
    readonly bool has_ui
        [[
            has_ui=self->has_cap(TP_CONTROLLER_HAS_UI);
        ]];
        
	/*
		Property: has_text_entry
		
		Whether the controller supports text entry.
	*/
	       
    readonly bool has_text_entry
        [[
            has_text_entry=self->has_cap(TP_CONTROLLER_HAS_TEXT_ENTRY);
        ]];
    
    /*
    	Property: ui_size
    	
    	This property returns a table containing the width and height 
    	of the controller's UI display area.
    */    
    
    readonly table ui_size
        [[
            unsigned int w;
            unsigned int h;
            
            self->get_controller()->get_ui_size(w,h);
            
            lua_newtable(L);
            lua_pushinteger(L,w);
            lua_rawseti(L,-2,1);
            lua_pushinteger(L,h);
            lua_rawseti(L,-2,2);
        ]];
        
    /*
    	Property: input_size
    	
    	Returns a table containing the width and height of the controller's
    	input area - the area for touch and click events.
    */
    
    readonly table input_size
        [[
            unsigned int w;
            unsigned int h;
            
            self->get_controller()->get_input_size(w,h);
            
            lua_newtable(L);
            lua_pushinteger(L,w);
            lua_rawseti(L,-2,1);
            lua_pushinteger(L,h);
            lua_rawseti(L,-2,2);
        ]];
    
    /*
    	Function: reset
    	
    	Resets the controller to its default state. The controller will 
    	stop sending all events other than key events and its UI, if any,
    	will be cleared.
    	
    	Returns:
    	
    		true - If it was successful.
    		
    		false - Otherwise.
    */
        
    bool reset()
        [[
            result=self->get_controller()->reset();    
        ]];
        
    /*
    	Function: start_accelerometer
    	
    	Tells the controller to start sending accelerometer events.
    	
    	Arguments:
    	
    		filter - A string that can be "L" for a low-pass filter
    				 or "H" for a high pass filter.
    				 
    		interval - The interval, in seconds, between events.
    	
    	Returns:
    	
    		true - If it was successful.
    		
    		false - Otherwise.
    */

    bool start_accelerometer(string filter,double interval)
        [[
            Controller::AccelerometerFilter f=Controller::NONE;
            
            if (filter)
            {
                if (*filter=='L'||*filter=='l')
                {
                    f=Controller::LOW;
                }
                else if (*filter=='H'||*filter=='h')
                {
                    f=Controller::HIGH;
                }
            }

            result=self->get_controller()->start_accelerometer(f,interval);
        ]];

	/*
		Function: stop_accelerometer
		
		Tells the controller to stop sending accelerometer events.
    	
    	Returns:
    	
    		true - If it was successful.
    		
    		false - Otherwise.
	*/
	        
    bool stop_accelerometer()
        [[
            result=self->get_controller()->stop_accelerometer();    
        ]];
        

	/*
		Function: start_clicks
		
		Instructs the controller to start sending click events.
		
	    Returns:
    	
    		true - If it was successful.
    		
    		false - Otherwise.		
	*/
	
    bool start_clicks()
        [[
            result=self->get_controller()->start_clicks();
        ]];
        
	/*
		Function: stop_clicks
		
		Tells the controller to stop sending click events.
		
    	
    	Returns:
    	
    		true - If it was successful.
    		
    		false - Otherwise.
	*/
			        
    bool stop_clicks()
        [[
            result=self->get_controller()->stop_clicks();
        ]];
    
    /*
    	Function: start_touches
    	
    	Tells the controller to start sending touch events.
    	
    	Returns:
    	
    		true - If it was successful.
    		
    		false - Otherwise.
    */
        
    bool start_touches()
        [[
            result=self->get_controller()->start_touches();
        ]];
        
    /*
    	Function: stop_touches
    	
    	Stop sending touch events.
    		
    	Returns:
    	
    		true - If it was successful.
    		
    		false - Otherwise.
	*/
	
    bool stop_touches()
        [[
            result=self->get_controller()->stop_touches();
        ]];

    # Deprecated, use the other one
    
    bool show_multiple_choice_ui()
        [[
            g_warning("DEPRECATED CALL TO controller:show_multiple_choice_ui");
            result=false;
        ]];
        
    /*
    	Function: show_multiple_choice
    	
    	Tells the controller to show a simple UI with a list of choices. The
    	user of the controller will be able to click on the choices and the
    	controller will generate an <on_ui_event> with the identifier of the 
    	choice.
    	
    	Note that the controller will not automatically dismiss the multiple
    	choice UI when the user makes a choice; you have to call <clear_ui>.
    	
    	> controller.show_multiple_choice( "Pick a state" , "1" , "California" , "2" , "Texas" )
    	
    	Arguments:
    	
    		label - A string that describes the list of choices. The controller 
    				will usually display this label above the list of choices.
    				
    		others - After the label, you can pass a number of identifier/label
    				 pairs. The controller will display each label as a choice 
    				 and will retain its associated identifier to send back 
    				 in an <on_ui_event>.
    		
    	Returns:
    	
    		true - If it was successful.
    		
    		false - Otherwise.
	*/
	        
    bool show_multiple_choice(string label,...)
        [[
            StringPairList list;
            
            int count=lua_gettop(L);
            
            for (int i=3;i+1<=count;i+=2)
            {
                const char * id=lua_tostring(L,i);
                const char * choice=lua_tostring(L,i+1);                

                if (id && choice)
                    list.push_back(StringPair(String(id),String(choice)));
            }
            
            result=list.empty()?false:self->get_controller()->show_multiple_choice(label,list);
        ]];

	/*
		Function: clear_ui
		
		Removes all UI elements from the controller's screen.
		    		
    	Returns:
    	
    		true - If it was successful.
    		
    		false - Otherwise.
	*/
	
    bool clear_ui()
        [[
            result=self->get_controller()->clear_ui();    
        ]];
    
    # Deprecated, use the other one
    
    bool set_background(string resource)
        [[
            g_warning("DEPRECATED CALL TO controller:set_background");            
            result=false;
        ]];

	/*
		Function: set_ui_background
		
		Tells the controller to set its background to an image that
		you specify. Images are declared to the controller 
		using <declare_resource>.
		
		Arguments:
		
			resource - Name of the image resource.
			
			mode - One of "CENTER", "TILE" or "STRETCH".

    	Returns:
    	
    		true - If it was successful.
    		
    		false - Otherwise.
	*/
	
    bool set_ui_background(string resource,string mode="CENTER")
        [[
            Controller::UIBackgroundMode m=Controller::CENTER;
            
            if (mode)
            {
                if (*mode=='S'||*mode=='s')
                {
                    m=Controller::STRETCH;
                }
                else if (*mode=='T'||*mode=='t')
                {
                    m=Controller::TILE;
                }
            }
            
            result=self->get_controller()->set_ui_background(resource,m);
        ]];

	/*
		Function: set_ui_image
		
		Tells the controller to place the given image at the given coordinates
		with the given size.
		
		Arguments:
		
			resource - Name of an image resource declared with <declare_resource>.
			
			x,y - The position of the image.
			
			width,height - The size of the image.

    	Returns:
    	
    		true - If it was successful.
    		
    		false - Otherwise.
	*/
	        
    bool set_ui_image(string resource,int x,int y,int width,int height)
        [[
            result=self->get_controller()->set_ui_image(resource,x,y,width,height);    
        ]];

	/*
		Function: play_sound
		
		Tells the controller to play a sound.
		
		Arguments:
		
			resource - Name of a sound resource declared with <declare_resource>.
			
			loop - How many times to play the sound. 

    	Returns:
    	
    		true - If it was successful.
    		
    		false - Otherwise.
	*/
	
    bool play_sound(string resource, int loop)
        [[
            result=self->get_controller()->play_sound(resource,loop);
        ]];

	/*
		Function: stop_sound
		
		Tells the controller to stop playing sounds.
		
    	Returns:
    	
    		true - If it was successful.
    		
    		false - Otherwise.		
	*/
	
    bool stop_sound()
        [[
            result=self->get_controller()->stop_sound();
        ]];

	/*
		Function: declare_resource
		
		This function is used to associate a name with a resource,
		such as an image or a sound file. You can also use a URL
		as the second parameter.
		
		Declaring a resource gives it a name that can be used in
		future calls. The controller may need to download the resource
		before it is used, so it is a good idea to declare resources
		early.
		
		Arguments:
		
			resource - A name for the resource.
			
			url - A path or URL to the resource.
			 		
    	Returns:
    	
    		true - If it was successful.
    		
    		false - Otherwise.		
	*/

    bool declare_resource(string resource, string url)
        [[
            result=false;
            
            bool is_uri=false;
            
            gchar * path=App::get(L)->normalize_path(url,&is_uri);
            
            if (path)
            {
                String final_uri(path);
                g_free(path);
                
                if (!is_uri)
                {
                    final_uri="file://"+final_uri;
                }
                
                result=self->get_controller()->declare_resource(resource,final_uri);
            }
        ]];
        
	/*
		Function: enter_text
		
		Tells the controller to show a text entry UI, such as a keyboard, and 
		allow the user to enter or edit text. Once the text has been entered, it
		will be sent back to your app via <on_ui_event>.
		
		Arguments:
		
			label - A caption for the text.
			
			text - The initial text to edit.
		 
    	Returns:
    	
    		true - If it was successful.
    		
    		false - Otherwise.		
	*/
	        
    bool enter_text(string label,string text)
        [[
            result=self->get_controller()->enter_text(label,text);    
        ]];

	/*
		Event: on_disconnected
		
		This event is triggered when the controller is disconnected from
		TrickPlay.
		
		Arguments:
		
			controller - The controller that was disconnected.			
	*/	
	
    callback on_disconnected;
    
    /*
    	Event: on_key_down
    	
    	A key down event.
    	
    	Arguments:
    	
    		controller - The controller that generated the event.
    		
    		key code - The numeric code of the key.
    		
    		unicode - The unicode value of the key or 0.
    */
    
    callback on_key_down;
    
    /*
    	Event: on_key_up
    	
    	A key up event.
    	
    	Arguments:
    	
    		controller - The controller that generated the event.
    		
    		key code - The numeric code of the key.
    		
    		unicode - The unicode value of the key or 0.
    */

    callback on_key_up;
    
    /*
    	Event: on_accelerometer
    	
    	An accelerometer event.
    	
    	Arguments:
    	
    		controller - The controller that generated the event.
    		
    		x,y,z - The three values of the accelerometer.
    */
    
    callback on_accelerometer;

	/*
		Event: on_click
		
		A click event.
		
    	Arguments:
    	
    		controller - The controller that generated the event.
    		
    		x,y - The coordinates of the event.
	*/
	    
    callback on_click;

	/*
		Event: on_touch_down
		
		A touch down event.

    	Arguments:
    	
    		controller - The controller that generated the event.
    		
    		x,y - The coordinates of the event.
	*/
	    
    callback on_touch_down;
    
	/*
		Event: on_touch_move
		
		A touch move event.

    	Arguments:
    	
    		controller - The controller that generated the event.
    		
    		x,y - The coordinates of the event.
	*/

    callback on_touch_move;
    
	/*
		Event: on_touch_up
		
		A touch up event.

    	Arguments:
    	
    		controller - The controller that generated the event.
    		
    		x,y - The coordinates of the event.
	*/

    callback on_touch_up;

    /*
    	Event: on_ui_event
    	
    	A UI event. This is sent when you use <show_multiple_choice> or 
    	<enter_text>.
    	
    	Arguments:
    	
    		controller - The controller that generated the event.
    		
    		text - The text of the event. Either an identifier for a 
    		       multiple choice, or the resulting text of <enter_text>.
    */
    
    callback on_ui_event;
}

#==============================================================================

[[

//.........................................................................

ControllerDelegate::ControllerDelegate(lua_State * _L,Controller * _controller,ControllerListDelegate * _list)
:
    L(_L),
    controller(_controller),
    list(_list)
{
    controller->ref();
    controller->add_delegate(this);        
}

//.........................................................................

ControllerDelegate::~ControllerDelegate()
{
    controller->remove_delegate(this);
    controller->unref();
    
    list->proxy_destroyed(this);
}

//.........................................................................
// Delegate functions

void ControllerDelegate::disconnected()
{   
    invoke_controller_on_disconnected(L,this,0,0);
    detach_controller(L,this);
}

void ControllerDelegate::key_down(unsigned int key_code,unsigned long int unicode)
{
    lua_pushnumber(L,key_code);
    lua_pushnumber(L,unicode);
    invoke_controller_on_key_down(L,this,2,0);
}

void ControllerDelegate::key_up(unsigned int key_code,unsigned long int unicode)
{
    lua_pushnumber(L,key_code);
    lua_pushnumber(L,unicode);
    invoke_controller_on_key_up(L,this,2,0);
}

void ControllerDelegate::accelerometer(double x,double y,double z)
{
    lua_pushnumber(L,x);
    lua_pushnumber(L,y);
    lua_pushnumber(L,z);    
    invoke_controller_on_accelerometer(L,this,3,0);    
}

void ControllerDelegate::click(int x,int y)
{
    lua_pushnumber(L,x);
    lua_pushnumber(L,y);
    invoke_controller_on_click(L,this,2,0);        
}

void ControllerDelegate::touch_down(int x,int y)
{   
    lua_pushnumber(L,x);
    lua_pushnumber(L,y);
    invoke_controller_on_touch_down(L,this,2,0);        
}

void ControllerDelegate::touch_move(int x,int y)
{
    lua_pushnumber(L,x);
    lua_pushnumber(L,y);
    invoke_controller_on_touch_move(L,this,2,0);            
}

void ControllerDelegate::touch_up(int x,int y)
{
    lua_pushnumber(L,x);
    lua_pushnumber(L,y);
    invoke_controller_on_touch_up(L,this,2,0);            
}

void ControllerDelegate::ui_event(const String & parameters)
{
    lua_pushstring(L,parameters.c_str());
    invoke_controller_on_ui_event(L,this,1,0);
}

]]

#==============================================================================

[[

//.........................................................................

ControllerListDelegate::ControllerListDelegate(lua_State * l)
:
    L(l)
{
    list=App::get(L)->get_context()->get_controller_list();
    list->add_delegate(this);
}

//.........................................................................

ControllerListDelegate::~ControllerListDelegate()
{
    list->remove_delegate(this);
}

//.........................................................................
// Delegate function

void ControllerListDelegate::connected(Controller * controller)
{
    ControllerDelegate * d=new ControllerDelegate(L,controller,this);
    
    proxies.insert(d);
    
    lua_pushlightuserdata(L,d);
    
    new_controller(L);
    
    lua_remove(L,-2);
    
    invoke_controllers_on_controller_connected(L,this,1,0);
}

//.........................................................................

void ControllerListDelegate::proxy_destroyed(ControllerDelegate * proxy)
{
    proxies.erase(proxy);
}

//.........................................................................

void ControllerListDelegate::push_connected()
{
    lua_newtable(L);
    
    // These exist as Lua objects, so we should be able to find instances
    // for all of them. However, the proxies may not be connected
    
    int i=1;
    
    ControllerList::ControllerSet found;
    
    for(ProxySet::iterator it=proxies.begin();it!=proxies.end();++it)
    {
        if (!(*it)->get_controller()->is_connected())
            continue;
        
        int is_new=wrap_controller(L,(*it));
        g_assert(!is_new);
        lua_rawseti(L,-2,i++);
        
        found.insert((*it)->get_controller());
    }
    
    // These may not exist as Lua objects but they are definitely connected
    
    ControllerList::ControllerSet controllers(list->get_controllers());
        
    for(ControllerList::ControllerSet::iterator it=controllers.begin();
        it!=controllers.end();++it)
    {
        if (found.find(*it)!=found.end())
        {
            continue;
        }
        
        ControllerDelegate * d=new ControllerDelegate(L,*it,this);
        
        proxies.insert(d);
        
        lua_pushlightuserdata(L,d);
        
        new_controller(L);
        
        lua_remove(L,-2);
        
        lua_rawseti(L,-2,i++);
    }
}

]]

#==============================================================================

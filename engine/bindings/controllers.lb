
module controllers_module;

[[
#include "app.h"    
#include "context.h"
#include "controllers.h"

//=============================================================================

class ControllersDelegate;

class Controller
{
public:
    
    Controller(lua_State *,gpointer source,const Controllers::ControllerInfo & info,ControllersDelegate * delegate,Controllers * controllers);
    ~Controller();
    
    void disconnected();
    
    void accelerometer(double x,double y,double z);

	void click(double x, double y);
    
    void ui_event(const gchar * event);

    const Controllers::ControllerInfo & get_info() const
    {
        return info;
    }
    
    bool is_connected() const
    {
        return connected;
    }
    
    bool start_accelerometer(const char * filter,double interval);
    bool stop_accelerometer();
    bool reset();

    bool ui_clear();

    bool ui_show_multiple_choice(const String & label,const StringPairList & choices);

    bool ui_declare_resource(const String &label, const String &url);
    bool ui_background_image(const String &resource_label);
    bool ui_play_sound(const String &resource_label, unsigned int loop=1);
    bool ui_stop_sound();

private:
    
    bool                        connected;
    lua_State *                 L;
    gpointer                    source;
    Controllers::ControllerInfo info;
    ControllersDelegate *       delegate;
    Controllers *               controllers;
    
};

//=============================================================================

class ControllersDelegate : private Controllers::Delegate
{
public:
    
    ControllersDelegate(lua_State*);
    ~ControllersDelegate();
    
    bool is_ready() const
    {
        return controllers->is_ready();
    }
    
    void controller_destroyed(gpointer source,Controller * controller);
    
    void push_connected_table();
    
    const String & get_web_server_group() const
    {
        return web_server_group;
    }
    
private:

    virtual void connected(gpointer source,const Controllers::ControllerInfo & info);
    virtual void disconnected(gpointer source);
    virtual void click(gpointer source,double x,double y);
    virtual void accelerometer(gpointer source,double x,double y,double z);
    virtual void ui_event(gpointer source,const gchar * event);

    typedef std::multimap<gpointer,Controller*>  ControllerMap;
        
    typedef std::set<gpointer> GPointerSet;
        
    lua_State *     L;
    Controllers *   controllers;
    ControllerMap   proxies;
    GPointerSet     all_connected;
    String          web_server_group;
};

//=============================================================================

]]

interface controller [[Controller*]]
{
    controller()
        [[
            *self=(Controller*)lua_touserdata(L,-2);
        ]];
        
    ~controller()
        [[
            delete self;    
        ]];
        
    readonly bool is_connected
        [[
            is_connected=self->is_connected();    
        ]];
        
    readonly string name
        [[
            name=self->get_info().name.c_str();    
        ]];
        
    readonly int version
        [[
            version=self->get_info().version;    
        ]];
        
    readonly bool has_accelerometer
        [[
            has_accelerometer=self->get_info().has_accelerometer();    
        ]];
        
    bool start_accelerometer(string filter,double interval)
        [[
            result=self->start_accelerometer(filter,interval);
        ]];
        
    bool stop_accelerometer()
        [[
            result=self->stop_accelerometer();    
        ]];
        
    bool reset()
        [[
            result=self->reset();    
        ]];
        
    bool clear_ui()
        [[
            result=self->ui_clear();    
        ]];
        
    bool show_multiple_choice_ui(string label)
        [[
            StringPairList list;
            
            int count=lua_gettop(L);
            
            for (int i=3;i+1<=count;i+=2)
            {
                const char * id=lua_tostring(L,i);
                const char * choice=lua_tostring(L,i+1);                

                if (id && choice)
                    list.push_back(std::make_pair(String(id),String(choice)));
            }
            
            result=list.empty()?false:self->ui_show_multiple_choice(label,list);
        ]];
        

    bool declare_resource(string label, string url)
    [[
            result = self->ui_declare_resource(label, url);
    ]];
	
    bool set_background(string label)
    [[
    	result = self->ui_background_image(label);
    ]];

    bool play_sound(string resource_label, int loop)
    [[
    	result = self->ui_play_sound(resource_label, loop);
    ]];

	bool stop_sound()
	[[
		result = self->ui_stop_sound();
	]];

    callback on_disconnected;
    

	callback on_click;

    callback on_accelerometer;
    
    callback on_ui_event;
}

#==============================================================================

global controllers [[ControllersDelegate*]]
{
    controllers()
        [[
            *self=new ControllersDelegate(L);            
        ]];
        
    ~controllers()
        [[
            delete self;
        ]];
        
    readonly bool ready
        [[
            ready=self->is_ready();
        ]];
        
    readonly table connected
        [[
            self->push_connected_table();    
        ]];
        
    callback on_controller_connected;    
}

#==============================================================================

[[

Controller::Controller(lua_State *l,gpointer s,const Controllers::ControllerInfo & i,ControllersDelegate * d,Controllers * c)
:
    connected(true),
    L(l),
    source(s),
    info(i),
    delegate(d),
    controllers(c)
{   
}

Controller::~Controller()
{
    delegate->controller_destroyed(source,this);    
}

void Controller::disconnected()
{
    connected=false;
    invoke_controller_on_disconnected(L,this,0,0);
    detach_controller(L,this);
}

void Controller::click(double x, double y)
{
    lua_pushnumber(L,x);
    lua_pushnumber(L,y);
    
    invoke_controller_on_click(L,this,2,0);
}

void Controller::accelerometer(double x,double y,double z)
{
    lua_pushnumber(L,x);
    lua_pushnumber(L,y);
    lua_pushnumber(L,z);
    
    invoke_controller_on_accelerometer(L,this,3,0);
}

void Controller::ui_event(const gchar * event)
{
    lua_pushstring(L,event);
    
    invoke_controller_on_ui_event(L,this,1,0);
}

bool Controller::start_accelerometer(const char * filter,double interval)
{
    if (!info.has_accelerometer())
        return false;
    return controllers->start_accelerometer(source,filter,interval);        
}

bool Controller::stop_accelerometer()
{
    return controllers->stop_accelerometer(source);
}

bool Controller::reset()
{
    return controllers->reset(source);
}

bool Controller::ui_clear()
{
    return controllers->ui_clear(source);    
}

bool Controller::ui_show_multiple_choice(const String & label,const StringPairList & choices)
{
    return controllers->ui_show_multiple_choice(source,label,choices);
}


bool Controller::ui_declare_resource(const String &label, const String &url)
{
    bool is_uri=false;
    
    char * path=App::get(L)->normalize_path(url.c_str(),&is_uri);

    if (!path)
    {
        return false;
    }
    
    Util::GFreeLater free_path(path);
    
    if (is_uri)
    {
        return controllers->ui_declare_resource(source, label, url);        
    }

    // It is a path to a local file
    
    if (!g_file_test(path,G_FILE_TEST_IS_REGULAR))
    {
        return false;
    }
    
    // It exists
    
    String local_url=controllers->serve_path(delegate->get_web_server_group(),path);
    
    return controllers->ui_declare_resource(source,label,local_url);
    
}

bool Controller::ui_background_image(const String &resource_label)
{
    return controllers->ui_background_image(source, resource_label);
}

bool Controller::ui_play_sound(const String &resource_label, unsigned int loop)
{
    return controllers->ui_play_sound(source, resource_label, loop);
}

bool Controller::ui_stop_sound()
{
    return controllers->ui_stop_sound(source);
}


//=============================================================================

ControllersDelegate::ControllersDelegate(lua_State*l)
:
    L(l)
{
    App * app=App::get(L);
    
    controllers=app->get_context()->get_controllers();

    if (controllers)
    {
        controllers->add_delegate(this);
    }
    
    web_server_group=app->get_metadata().id;
}

ControllersDelegate::~ControllersDelegate()
{
    if (controllers)
    {
        controllers->remove_delegate(this);
        controllers->drop_web_server_group(web_server_group);
    }
}

void ControllersDelegate::controller_destroyed(gpointer source,Controller * controller)
{
    std::pair<ControllerMap::iterator,ControllerMap::iterator>
        range(proxies.equal_range(source));
        
    for(ControllerMap::iterator it=range.first;it!=range.second;)
    {
        if (it->second==controller)
            proxies.erase(it++);
        else
            ++it;
    }
}

void ControllersDelegate::connected(gpointer source,const Controllers::ControllerInfo & info)
{
    all_connected.insert(source);
    
    Controller * controller=new Controller(L,source,info,this,controllers);
    
    proxies.insert(std::make_pair(source,controller));
    
    lua_pushlightuserdata(L,controller);
    
    new_controller(L);
    
    lua_remove(L,-2);
    
    invoke_controllers_on_controller_connected(L,this,1,0);
}

void ControllersDelegate::disconnected(gpointer source)
{
    GPointerSet::iterator ait=all_connected.find(source);
    if (ait!=all_connected.end())
        all_connected.erase(ait);
    
    std::pair<ControllerMap::const_iterator,ControllerMap::const_iterator>
        range(proxies.equal_range(source));
        
    for(ControllerMap::const_iterator it=range.first;it!=range.second;++it)
    {
        it->second->disconnected();
    }    
}

void ControllersDelegate::click(gpointer source,double x,double y)
{
    std::pair<ControllerMap::const_iterator,ControllerMap::const_iterator>
        range(proxies.equal_range(source));
        
    for(ControllerMap::const_iterator it=range.first;it!=range.second;++it)
    {
        it->second->click(x,y);
    }
}

void ControllersDelegate::accelerometer(gpointer source,double x,double y,double z)
{
    std::pair<ControllerMap::const_iterator,ControllerMap::const_iterator>
        range(proxies.equal_range(source));
        
    for(ControllerMap::const_iterator it=range.first;it!=range.second;++it)
    {
        it->second->accelerometer(x,y,z);
    }        
}

void ControllersDelegate::ui_event(gpointer source,const gchar * event)
{
    std::pair<ControllerMap::const_iterator,ControllerMap::const_iterator>
        range(proxies.equal_range(source));
        
    for(ControllerMap::const_iterator it=range.first;it!=range.second;++it)
    {
        it->second->ui_event(event);
    }            
}

void ControllersDelegate::push_connected_table()
{
    lua_newtable(L);
    
    if (!controllers)
    {
        return;
    }
    
    // These exist as Lua objects, so we should be able to find instances
    // for all of them. However, the proxies may not be connected
    
    int i=1;
    
    for(ControllerMap::iterator it=proxies.begin();it!=proxies.end();++it,++i)
    {
        if (!it->second->is_connected())
            continue;
        
        int is_new=wrap_controller(L,it->second);
        g_assert(!is_new);
        lua_rawseti(L,-2,i);
    }
    
    // These may not exist as Lua objects but they are definitely connected
    
    for(GPointerSet::iterator it=all_connected.begin();it!=all_connected.end();++it)
    {
        gpointer source=*it;
        
        if (proxies.find(source)!=proxies.end())
            continue;
        
        // It is not in our map, get its info
        
        Controllers::ControllerInfo * info=controllers->find_controller(source);
        
        if (!info)
            continue;
        
        Controller * controller=new Controller(L,source,*info,this,controllers);
        
        proxies.insert(std::make_pair(source,controller));
        
        lua_pushlightuserdata(L,controller);
        
        new_controller(L);
        
        lua_remove(L,-2);
        
        lua_rawseti(L,-2,i++);
    }    
}

]]

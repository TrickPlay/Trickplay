[[

#include "glib.h"

extern "C"
{
    #include "tcutil.h"
    #include "tchdb.h"
}

#include "context.h"
#include "util.h"

class Settings
{
public:
    
    Settings(lua_State*l)
    :
        L(l),
	db(NULL)
    {
	TPContext::get_from_lua(L)->add_notification_handler(TP_NOTIFICATION_PROFILE_CHANGE,profile_change_handler,this);
    }
    
    ~Settings()
    {
	close();
    }
    
    void open()
    {
	if (db)
	    return;
	
        db = tchdbnew();
        
        if (!db)
        {
            g_error("Failed to create settings database");
        }
        
        if(!tchdbtune(db,256,-1,-1,0))
        {
            g_warning("Failed to tune settings database : %s", tchdberrmsg(tchdbecode(db)));
        }
	
	TPContext * c=TPContext::get_from_lua(L);
	
	gchar * name=g_strdup_printf("settings-%d.tch",c->get_int(PROFILE_ID));
	Util::GFreeLater free_name(name);
        
        gchar * file_name=g_build_filename(c->get(APP_DATA_PATH),name,NULL);
        Util::GFreeLater free_file_name(file_name);
        
	if(!tchdbopen(db,file_name,HDBOWRITER|HDBOREADER|HDBOCREAT))
        {
            g_error("Failed to open settings file : %s", tchdberrmsg(tchdbecode(db)));
        }
    }
    
    void close()
    {
	if (db)
	{
	    tchdbclose(db);
	    tchdbdel(db);
	    db=NULL;
	}	
    }
    
    void set()
    {
	open();
	
        size_t key_len;
        
        const char * key=lua_tolstring(L,2,&key_len);
        
        if (!key)
        {
            g_warning("Trying to add settings with non-string key");
            return;
        }
        
        // If they set it to nil, we delete the record
        
        if (lua_isnil(L,3))
        {
            if (!tchdbout(db,key,key_len))
            {
                g_warning("Failed to delete setting '%s' : %s",key,tchdberrmsg(tchdbecode(db)));
            }
        }
        else
        {
            size_t value_len;
    
            const char * value=lua_tolstring(L,3,&value_len);
            
            // If the value cannot be converted to a string, there
            // is not much we can do. (we could try to serialize it)
            
            if (!value)
            {
                g_warning("Trying to add settings with non-string value");
                return;
            }
            
            if(!tchdbput(db,key,key_len,value,value_len))
            {
                g_warning("Failed to store setting '%s' = '%s' : %s",key,value,tchdberrmsg(tchdbecode(db)));
            }
        }
    }
    
    bool get()
    {
	open();
	
        size_t key_len;
        
        const char * key=lua_tolstring(L,2,&key_len);
        
        if (!key)
        {
            g_warning("Trying to get settings with non-string key");
            return false;
        }
        
        int value_len;
        void * value =tchdbget(db,key,key_len,&value_len);
        
        if (!value)
            return false;
        
        lua_pushlstring(L,(const char *)value,value_len);
        free(value);
        
        return true;
    }
    
private:
    
    static void profile_change_handler(const char *,void * self)
    {
	// We just close the current database - so that a new one will be
	// opened when needed using the new profile id
	
	((Settings*)self)->close();
    }
    
    lua_State * L;
    TCHDB *     db;
};

]]

# Global: settings
# Lets you store and retrieve key-value pairs. These are profile-specific, the
# settings object will switch for you when the profile changes.
#
# The settings object masquerades as a Lua table, so you set values in the normal
# Lua way
#
# > settings.something="Hello World"
# > settings[ "something" ]="Hello World"
#
# Unlike Lua tables, settings only accepts strings as keys and the values
# can be either numbers or strings. You cannot save tables, functions or other
# types of data.
#
# If you set a key to nil, it is deleted from the settings database. Similarly,
# if you ask for a key that does not exist, you will receive nil.
#
# This will delete the key "something" from the settings database
# > settings[ "something" ] = nil
#
# So, this will print out nil
# > print( settings.something )
#
# Also, since settings is not really a Lua table, you cannot use the standard
# table functions, or table library to iterate over keys (pairs, ipairs, table.*)

global settings [[Settings*]] table
{
    settings()
        [[
            *self=new Settings(L);
        ]];
        
    ~settings()
        [[
            delete self;
        ]];
        
    multi __index()
        [[
            if (!self->get())
                lua_pushnil(L);
            return 1;
        ]];
        
    __newindex()
        [[
            self->set();
        ]];        
}

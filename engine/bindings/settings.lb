[[
extern "C"
{
    #include "tcutil.h"
    #include "tchdb.h"
}

#include "app.h"
#include "util.h"

class Settings
{
public:
    
    Settings(lua_State*l)
    :
        L(l),
	db(NULL)
    {
	App::get(L)->add_notification_handler(TP_NOTIFICATION_PROFILE_CHANGE,profile_change_handler,this);
    }
    
    ~Settings()
    {
	close();
    }
    
    void open()
    {
	if (db)
	    return;
	
        db = tchdbnew();
        
        if (!db)
        {
            g_error("FAILED TO CREATE SETTINGS DATABASE");
        }
        
        if(!tchdbtune(db,256,-1,-1,0))
        {
            g_warning("FAILED TO TUNE SETTINGS DATABASE : %s", tchdberrmsg(tchdbecode(db)));
        }
	
	App * app=App::get(L);
	
	gchar * name=g_strdup_printf("settings-%d.tch",app->get_profile_id());
	Util::GFreeLater free_name(name);
        
        gchar * file_name=g_build_filename(app->get_data_path().c_str(),name,NULL);
        Util::GFreeLater free_file_name(file_name);
        
	if(!tchdbopen(db,file_name,HDBOWRITER|HDBOREADER|HDBOCREAT))
        {
            g_error("FAILED TO OPEN SETTINGS DATABASE : %s", tchdberrmsg(tchdbecode(db)));
        }
    }
    
    void close()
    {
	if (db)
	{
	    tchdbclose(db);
	    tchdbdel(db);
	    db=NULL;
	}	
    }
    
    void set()
    {
	open();
	
        size_t key_len;
        
        const char * key=lua_tolstring(L,2,&key_len);
        
        if (!key)
        {
            g_warning("TRYING TO ADD SETTINGS WITH NON-STRING KEY");
            return;
        }
        
        // If they set it to nil, we delete the record
        
        if (lua_isnil(L,3))
        {
            if (!tchdbout(db,key,key_len))
            {
                g_warning("FAILED TO DELETE SETTING '%s' : %s",key,tchdberrmsg(tchdbecode(db)));
            }
        }
        else
        {
	    LSG;
	    
	    lua_getglobal(L,"serialize");
	    lua_pushvalue(L,3);
	    lua_call(L,1,1);
	    
            size_t value_len;
    
            const char * value=lua_tolstring(L,-1,&value_len);
            
            if(!tchdbput(db,key,key_len,value,value_len))
            {
                g_warning("FAILED TO STORE SETTING '%s' = '%s' : %s",key,value,tchdberrmsg(tchdbecode(db)));
            }
	    
	    lua_pop(L,1);
	    
	    LSG_END(0);
        }
    }
    
    bool get()
    {
	open();
	
        size_t key_len;
        
        const char * key=lua_tolstring(L,2,&key_len);
        
        if (!key)
        {
            g_warning("TRYING TO GET SETTING WITH NON-STRING KEY");
            return false;
        }
        
        int value_len;
        void * value =tchdbget(db,key,key_len,&value_len);
        
        if (!value)
            return false;
        
	String statement="return "+String((const char *)value,value_len);
	
	free(value);
	
	if (luaL_dostring(L,statement.c_str())!=0)
	{
	    g_warning("FAILED TO EVALUATE SETTING VALUE");
	    // pop the error
	    lua_pop( L, 1 );
	    return false;
	}
	else
	{
	    // The result of dostring should be at the top of the stack	    
    	}
        
        return true;
    }
    
private:
    
    static void profile_change_handler(const char *,void * self)
    {
	// We just close the current database - so that a new one will be
	// opened when needed using the new profile id
	
	((Settings*)self)->close();
    }
    
    lua_State * L;
    TCHDB *     db;
};

]]

# Global: settings
# Lets you store and retrieve key-value pairs. These are profile-specific, the
# settings object will switch for you when the profile changes.
#
# The settings object masquerades as a Lua table, so you set values in the normal
# Lua way
#
# > settings.something="Hello World"
# > settings[ "something" ]="Hello World"
#
# Unlike Lua tables, settings only accepts strings as keys. Values can be numbers,
# booleans, tables or strings. Functions are not accepted (they become nil).
#
# If you set a key to nil, it is deleted from the settings database. Similarly,
# if you ask for a key that does not exist, you will receive nil.
#
# This will delete the key "something" from the settings database
# > settings[ "something" ] = nil
#
# So, this will print out nil
# > print( settings.something )
#
# Also, since settings is not really a Lua table, you cannot use the standard
# table functions, or table library to iterate over keys (pairs, ipairs, table.*)

global settings [[Settings*]] table
{
    settings()
        [[
            *self=new Settings(L);
        ]];
        
    ~settings()
        [[
            delete self;
        ]];
        
    multi __index()
        [[
            if (!self->get())
                lua_pushnil(L);
            return 1;
        ]];
        
    __newindex()
        [[
            self->set();
        ]];        
}

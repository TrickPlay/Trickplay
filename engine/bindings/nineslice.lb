module nineslice;

[[
#include "clutter_util.h"
#include "util.h"
#include "nineslice.h"

#include "sprite_sheet.lb.h"
]]

    /*
        Class: NineSlice

        The NineSlice class will draw a grid of up to nine sprites from a spritesheet as if they were one fluid image. Instead of simply stretching, the object will adapt to different sizes by stretching or tiling the center sprites on both axes, leaving the corners unchanged.

        An example constructor is shown below.

        (code)
        button = NineSlice {
            sheet = SpriteSheet { map = "button.json" },
            tile = { true, true },
            ids = { nw = "button-nw.png", n = "button-n.png", ne = "button-ne.png",
                    w  = "button-w.png",  c = "button-c.png", e  = "button-e.png",
                    sw = "button-sw.png", s = "button-s.png", se = "button-se.png" }
        }
        (end)

        Notice that "button-n.png" and "button-s.png" will be tiled horizontally, "button-w.png" and "button-e.png" will be tiled vertically, and "button-c.png" will be tiled in both directions. The layout of the nine positions in the ids table is shown below.

        (see NineSliceCompass.png)

        Properties may be changed after construction.

        (code)
        -- change the spritesheet from which the sprites are pulled

        button.sheet = SpriteSheet { map = "button-focus.json" }
        button.tile = { true, false }

        -- animate the opacity of an NineSlice

        aState = AnimationState {
            transitions = {
                {
                    source = "*", target = "hide",
                    keys = { { button, "opacity", 0 } }
                },
            }
        }
        (end)

        *Code Example:* Creating a NineSlice sized to fit around a UIElement.

        (code)
        uiSheet = SpriteSheet { map = "ui.json" }

        -- simple 3-slice text bounding box
        -- the ids table only contains the NW, N, and NE ids, which means the box can expand horizontally but not vertically.

        box = NineSlice {
            sheet = uiSheet,
            ids = { nw = "box-left-edge.png", n = "box-middle.png", nw = "box-right-edge.png" }
        }
        left, right = table.unpack( box.borders )
        text = Text { x = left, text = "Text Button!" }
        box.size = { left + text.w + right, 1 }
        textBox = Group { children = { box, text } }

        -- more complex 9-slice button

        button = NineSlice {
            sheet = uiSheet,
            opacity = 255,
            ids = { nw = "button-nw.png", n = "button-n.png", ne = "button-ne.png",
                    w  = "button-w.png",  c = "button-c.png", e  = "button-e.png",
                    sw = "button-sw.png", s = "button-s.png", se = "button-se.png" }
        }

        -- create an image inside of a group with enough padding for the borders of the button to nicely enclose the image

        left, right, top, bottom = table.unpack( buttonEffect.borders )
        image = Image { src = "assets/image.png", x = left, y = top }
        button.size = { left + image.w + right, top + image.h + bottom }

        imgButton = Group { children = { button, image } }
        (end)

        In addition to the properties and functions described on this page, the NineSlice type also supports all the properties and functions defined in the <UIElement> interface.
    */

[[

static const char * keys[9] = { "nw", "n", "ne", "w", "c", "e", "sw", "s", "se" };

struct NineSliceBinding
{
    NineSliceBinding( NineSliceEffect * _effect ) : async( false ), effect( _effect ), sheet( NULL ) { assert( effect ); };
    
    NineSliceEffect * get_effect() { return effect; };
    
    bool get_tile( unsigned i ) { return nineslice_effect_get_tile( effect, i ); }
    void set_tile( unsigned i, bool t, bool guess ) { nineslice_effect_set_tile( effect, i, t, guess ); }
    
    bool is_loaded() { return nineslice_effect_is_loaded( effect ); };
    
    std::vector< int > * get_borders() { return nineslice_effect_get_borders( effect ); }
    
    std::string & get_id( unsigned i )
    {
        g_assert( i < 9 );
        return ids[i];
    };
    
    void set_id( unsigned i, const std::string & new_id )
    {
        g_assert( i < 9 );
        ids[i] = new_id;
        nineslice_effect_set_sprite( effect, i, sheet ? sheet->get_sprite( ids[i].c_str() ) : NULL, async );
    }
    
    void set_sheet( SpriteSheet * _sheet )
    {
        sheet = _sheet;
        
        for ( unsigned i = 0; i < 9; ++i )
        {
            nineslice_effect_set_sprite( effect, i, sheet ? sheet->get_sprite( ids[i].c_str() ) : NULL, async );
        }
    }
    
    void signal_loaded_later()
    {
        if ( async )
        {
            nineslice_effect_signal_loaded_later( effect );
        }
    }
    
    bool async;
    bool can_fire;
    
private:
    NineSliceEffect * effect;
    SpriteSheet * sheet;
    std::string ids[9];
};

#define get_binding( self ) ( (NineSliceBinding *) g_object_get_data( G_OBJECT( self ), "tp-binding" ) )
#define get_ref( self ) ( (int *) g_object_get_data( G_OBJECT( self ), "tp-sheet-ref" ) )

void NineSlice_on_loaded( NineSliceEffect * effect, gpointer error, lua_State * L );

]]

class NineSlice [[ClutterActor*]] actor
{
    /*
        Constructor: NineSlice

        The NineSlice() constructor creates a new NineSlice object.

        *Arguments:*

        props - table defining the object's properties

        *Return Value:* new NineSlice object
    */

    NineSlice( table props = 0 )
        [[
            self = lb_construct_gobject( ClutterActor , ClutterUtil::make_actor( clutter_actor_new ) );
            ClutterUtil::initialize_actor( L, self, NINESLICE_METATABLE );

            ClutterEffect * effect = nineslice_effect_new();
            clutter_actor_add_effect_with_name( self,  "tp-nineslice-effect", effect );
            clutter_actor_set_offscreen_redirect( self, CLUTTER_OFFSCREEN_REDIRECT_ALWAYS );
            
            g_signal_connect_data( G_OBJECT( effect ), "load-finished",
                (GCallback) NineSlice_on_loaded,
                L, 0, GConnectFlags( 0 ) );
            
            g_object_set_data( G_OBJECT( self ), "tp-binding", new NineSliceBinding( NINESLICE_EFFECT( effect ) ) );
            g_object_set_data_full( G_OBJECT( self ), "tp-sheet-ref", g_new0( int, 1 ), g_free );
            * get_ref( self ) = LUA_REFNIL;
            
            ClutterUtil::set_props_from_table( L, props );
            
            g_object_unref( self );
        ]];

    ~NineSlice()
        [[
            if ( * get_ref( self ) ) lb_strong_unref( L, * get_ref( self ) );
            delete get_binding( self );
        ]];

    /*
        Property: sheet

        The sheet property is a <SpriteSheet> object specifying where to pull sprites from, based on the ids provided at construction.

        If the sheet is changed, the ids will be reevaluated. If a sheet lacks some or all of the ids, those ids will not be drawn.

        *See Also:* the <ids> property
    */

    SpriteSheet sheet
        [[
            lb_strong_deref( L, * get_ref( self ) );
        ]]
        [[
            NineSliceBinding * binding = get_binding( self );
            if ( * get_ref( self ) ) lb_strong_unref( L, * get_ref( self ) );
            
            SpriteSheet * new_sheet = LB_GET_SPRITESHEET( L, 2 );
            
            if ( new_sheet )
            {
                binding->set_sheet( new_sheet );
                * get_ref( self ) = lb_strong_ref( L );
            }
            else
            {
                binding->set_sheet( NULL );
                * get_ref( self ) = LUA_REFNIL;
            }
            
            get_binding( self )->signal_loaded_later();
        ]];

    /*
        Property: ids

        The ids property is a table containing the string ids of the nine sprites used by the NineSlice.

        nw - top left
        n - top center, adjusts horizontally
        ne - top right
        w - middle left, adjusts vertically
        c - center, adjusts both directions
        e - middle right, adjusts vertically
        sw - bottom left
        s - bottom center, adjusts horizontally
        se - bottom right

        Some of the ids may be nil or not applicable to the current spritesheet, in which case they will not be drawn. For example, a 3-slice button can be created by providing just the top three positions with left-cap, middle, and right-cap sprites, and leaving the rest blank.

        If the sheet property is changed, the ids will be reevaluated.

        *See Also:* the <sheet> property
    */

    table ids
        [[
            NineSliceBinding * binding = get_binding( self );

            lua_newtable( L );

            for ( unsigned i = 0; i < 9; ++i )
            {
                lua_pushstring( L, keys[i] );
                lua_pushstring( L, binding->get_id( i ).c_str() );
                lua_rawset( L, -3 );
            }
        ]]
        [[
            if ( lua_istable( L, 2 ) )
            {
                NineSliceBinding * binding = get_binding( self );
                
                for ( unsigned i = 0; i < 9; ++i )
                {
                    lua_getfield( L, 2, keys[i] );
                    const char * id = lua_tostring( L, -1 );
                    binding->set_id( i, std::string( id != NULL ? id : "" ) );
                    lua_pop( L, 1 );
                }
                
                get_binding( self )->signal_loaded_later();
            }
            else
            {
                g_warning( "Trying to set IDs on a nineslice with a thing that wasn't a table. Bad." );
            }
        ]];

    /*
        Property: tile

        The tile property is a table containing six boolean values specifying whether sprites should tile horizontally and/or vertically instead of stretching.

        In order to match the dimensions of the target object's bounding box, the center sprites (N, S, W, E, and C) must be either stretched or tiled.

        tile[1] - C tile horizontally
        tile[2] - C tile vertically
        tile[3] - N tile horizontally
        tile[4] - S tile horizontally
        tile[5] - W tile vertically
        tile[6] - E tile vertically

        The tile property can also be set more compactly using a two-boolean table, { horizontal, vertical }, or a single boolean; however, it can only be retrieved as a table of six.

        *Default Setting:* tile = { false, false, false, false, false, false }
    */

    table tile
        [[
            NineSliceBinding * binding = get_binding( self );
            
            lua_newtable( L );

            for ( unsigned i = 0; i < 6; ++i )
            {
                lua_pushboolean( L, binding->get_tile( i ) );
                lua_rawseti( L, -2, i + 1 );
            }
        ]]
        [[
            NineSliceBinding * binding = get_binding( self );

            if ( lua_istable( L, 2 ) )
            {
                for ( unsigned i = 0; i < 6; ++i )
                {
                    lua_rawgeti( L, 2, i + 1 );
                    binding->set_tile( i, lua_toboolean( L, -1 ), lua_isnil( L, -1 ) );
                    lua_pop( L, 1 );
                }
            }
            else if lua_isboolean( L, 2 )
            {
                for ( unsigned i = 0; i < 6; ++i )
                {
                    binding->set_tile( i, lua_toboolean( L, 2 ), false );
                }
            }
            else
            {
                g_warning( "Trying to set tile on a nineslice with a thing that wasn't a table or a boolean. Bad." );
            }
        ]];
        
    /*
        Property: async
        
        The async property is a boolean value that determines whether source images of the NineSlice (managed by its SpriteSheet) are loaded asynchronously or not.
        
        When either the <sheet> or <ids> change, any new source images that need to be loaded will also be loaded according to this value.
        
        *Default Setting:* false, i.e., all source images are loaded synchronously
        
        *See Also:* the <on_loaded> event
    */
        
    bool async
        [[
            async = get_binding( self )->async;
        ]]
        [[
            get_binding( self )->async = async;
        ]];
        
    /*
        Property: loaded
        
        The loaded property is a boolean value indicating if all source images currently in use by the NineSlice are loaded successfully. For the purposes of this property, the NineSlice will ignore all ids not found in its spritesheet.
        
        *Default Setting:* true
        
        *See Also:* the <ids> property
    */
        
    readonly bool loaded
        [[
            loaded = get_binding( self )->is_loaded();
        ]];
        
    /*
        Function: add_onloaded_listener
        
        The add_onloaded_listener() function registers a handler function for <on_loaded> events.
        
        *Arguments*
        
            fn - reference to handler function. The function prototype is described below.

        *Return Value:* Handle to the registered handler. Pass this handle to the <remove_onloaded_listener> function to unregister the handler.

        *Handler Prototype:*

        (code)
        fn( NineSlice self, boolean failed )
        (end)

        *Handler Arguments:*

            self - the NineSlice object that has finished loading
            failed - boolean value indicating overall failure or success of all load operations (true=failure)
        
        *Handler Return Value:* None
        
        *See Also:* the <on_loaded> event and the <remove_onloaded_listener> function
    */
        
    int add_onloaded_listener( function fn )
        [[
            result = UserData::get( L )->add_callback( (char *) "on_loaded" , L );
        ]];
        
    /*
        Function: remove_onloaded_listener

        The remove_onloaded_listener() function unregisters the specified event handler.

        *Arguments:*

            ref - handle for event handler to unregister. This handle is returned by the <add_onloaded_listener> function.

        *Return Value:* None

        *See Also:* the <add_onloaded_listener> function
    */

    remove_onloaded_listener( int ref )
        [[
            UserData::get( L )->remove_callback( (char *) "on_loaded" , L );
        ]];

    /*
        Event: on_loaded

        The on_loaded event occurs when all asynchronous loading operations have completed. 

        *See Also:* the <add_onloaded_listener> function
    */

    function on_loaded
        [[
            return UserData::get( L )->get_last_callback( (char *) "on_loaded" , L );
        ]]
        [[
            UserData::get( L )->set_last_callback( (char *) "on_loaded" , L );
        ]];

    /*
        Property: borders

        The borders property is a table reflecting the maximum sizes of the sprites making up the left, right, top, and bottom borders of the NineSlice, in that order.

        borders[1] - reflects the left border (maximum width of NW, W, and SW sprites)
        borders[2] - reflects the right border (maximum width of NE, E, and SE sprites)
        borders[3] - reflects the top border (maximum height of SW, S, and SE sprites)
        borders[4] - reflects the bottom border, (maximum height of NW, N, and NE sprites)
    */

    readonly table borders
        [[
            std::vector< int > * list = get_binding( self )->get_borders();

            lua_createtable( L, 0, 4 );

            for ( unsigned i = 0; i < 4; ++i )
            {
                lua_pushnumber( L, list->at( i ) );
                lua_rawseti( L, -2, i + 1 );
            }
            
            delete list;
        ]];
}

[[

void NineSlice_on_loaded( NineSliceEffect * effect, gpointer error, lua_State * L )
{
    ClutterActor * self = clutter_actor_meta_get_actor( CLUTTER_ACTOR_META( effect ) );
    
    if ( get_binding( self )->async )
    {
        lua_pushboolean( L, error ? 1 : 0 );
        UserData::invoke_callbacks( G_OBJECT( self ), "on_loaded", 1, 0, L );
    }
}

]]

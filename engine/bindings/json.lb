
[[
#include <json-glib/json-glib.h>

#if ! JSON_CHECK_VERSION(0,5,0)
#error "NEED JSON-GLIB VERSION 0.5.0 OR GREATER"
#endif

#include "util.h"

//-----------------------------------------------------------------------------
// This is a static we use as a light user data to represent a JSON null.
// Its address will never change, so equality testing works. It is also the 
// readonly property JSON.null

void * json_null()
{
	static char null = 0;
	
	return &null;
}

//-----------------------------------------------------------------------------
// Forward declaration

void json_to_lua( lua_State * L, JsonNode * node );

//-----------------------------------------------------------------------------
// Adds a member of an object to a Lua table at the top of the stack

void object_member_to_lua( JsonObject * object, const gchar *member_name, JsonNode * member_node, gpointer user_data)
{
	g_assert( object );
	g_assert( member_name );
	g_assert( member_node );
	g_assert( user_data );
	
	lua_State * L = ( lua_State * ) user_data;
	
	lua_pushstring( L, member_name );
	json_to_lua( L, member_node );
	lua_rawset( L, -3 );
}

//-----------------------------------------------------------------------------
// Adds an element of an array to a Lua table at the top of the stack

void array_element_to_lua( JsonArray * array, guint index, JsonNode * element_node, gpointer user_data)
{
	g_assert( array );
	g_assert( element_node );
	g_assert( user_data );
	
	lua_State * L = ( lua_State * ) user_data;
	
	json_to_lua( L, element_node );
	lua_rawseti( L, -2, index + 1 );
}

//-----------------------------------------------------------------------------
// Converts all the possible types to Lua types

void json_to_lua( lua_State * L, JsonNode * node )
{	
	switch( JSON_NODE_TYPE( node ) )
	{
		case JSON_NODE_OBJECT:
		{
			lua_newtable( L );
			
			json_object_foreach_member( json_node_get_object( node ), object_member_to_lua, L );
			
			break;
		}
		
		case JSON_NODE_ARRAY:
		{
			lua_newtable( L );
			
			json_array_foreach_element( json_node_get_array( node ), array_element_to_lua, L );
			
			break;
		}
		
		case JSON_NODE_VALUE:
		{
			switch( json_node_get_value_type( node ) )
			{
				case G_TYPE_BOOLEAN:
				{
					lua_pushboolean( L, json_node_get_boolean( node ) );
					break;
				}
				
				case G_TYPE_DOUBLE:
				{
					lua_pushnumber( L, json_node_get_double( node ) );
					break;
				}
				
				case G_TYPE_INT:
				case G_TYPE_INT64:
				{
					lua_pushinteger( L, json_node_get_int( node ) );
					break;
				}
				
				case G_TYPE_STRING:
				{
					lua_pushstring( L, json_node_get_string( node ) );
					break;
				}
				
				default:
				{
					g_warning( "INVALID JSON VALUE TYPE : %s", json_node_type_name( node ) );
					lua_pushlightuserdata( L, json_null() );
					break;
				}
			}
			
			break;
		}
		
		case JSON_NODE_NULL:
		{
			lua_pushlightuserdata( L, json_null() );
			break;
		}
		
		default:
		{
			g_assert( false );
		}
	}
}

JsonNode * lua_value_to_json( lua_State * L, int index )
{
	JsonNode * result = NULL;
	
	switch( lua_type( L, index ) )
	{
		case LUA_TNUMBER:
			
			result = json_node_new( JSON_NODE_VALUE );
			
			if ( lua_tointeger( L, index ) == lua_tonumber( L, index ) )
			{
				json_node_set_int( result, lua_tointeger( L, index ) );
			}
			else
			{
				json_node_set_double( result, lua_tonumber( L, index ) );
			}
			
			break;
			
		case LUA_TBOOLEAN:
		
			result = json_node_new( JSON_NODE_VALUE );
			
			json_node_set_boolean( result, lua_toboolean( L, index ) );
			
			break;
			
		case LUA_TSTRING:
		
			result = json_node_new( JSON_NODE_VALUE );
			
			json_node_set_string( result, lua_tostring( L, index ) );
			
			break;
			
		case LUA_TTABLE:

			// If it has a length, we treat it as an array
						
			if ( lua_objlen( L, index ) > 0 ) 
			{
				JsonArray * array = json_array_new();
				
				lua_pushnil( L );
				
				while ( lua_next( L, index ) )
				{
					json_array_add_element( array, lua_value_to_json( L, lua_gettop( L ) ) );
					
					lua_pop( L, 1 );
				}
				
				result = json_node_new( JSON_NODE_ARRAY );
				
				json_node_take_array( result, array );
			}
			else
			{
				JsonObject * object = json_object_new();
				
				lua_pushnil( L );
				
				while( lua_next( L, index ) )
				{
					if ( lua_isstring( L, -2 ) )
					{
						json_object_set_member( object, lua_tostring( L, -2 ), lua_value_to_json( L, lua_gettop( L ) ) ); 
					}
					
					lua_pop( L, 1 );
				}
				
				result = json_node_new( JSON_NODE_OBJECT );
				
				json_node_take_object( result, object );
			}
			
			break;
			
		default:
		
			break;
	}
	
	
	if ( ! result )
	{
		result = json_node_new( JSON_NODE_NULL );
	}
	
	return result;
}

]]

/*
	Global: json
	
	This global object lets you convert JSON strings to Lua objects. 
	You invoke it like this
	
	> local t = json:parse( "<some JSON string>" )
	
	The parser is strict in that it requires the top level JSON element to be either an array
	or an object. 
*/

global json [[void*]]
{
	json()
		[[
			
		]];
		
	/*
		Property: null
		
		This property is used to represent a null value. It is not the same as Lua's nil, 
		and is only useful for comparisons. For example:
		
		> local j = json:parse( "[null]" )
		> j[ 1 ] == nil -- False, it is not equal to nil.
		> j[ 1 ] == json.null -- True, this is a JSON null value. 
	*/
		
	readonly lightuserdata null
		[[
			lua_pushlightuserdata( L, json_null() );
		]];
		
	/*
		Function: parse
		
		Decodes the JSON string and returns a Lua table, or nil if decoding failed.
		
		Arguments:
		
			data - A JSON string to parse
			
		Returns:
		
			A Lua table - If decoding succeeded.
						
			nil - If there was a problem parsing the string.
	*/
	
	table parse( lstring data )
		[[
			int top = lua_gettop( L );
			
			JsonParser * parser = json_parser_new();
			
			GError * error = NULL;
			
			if ( ! json_parser_load_from_data( parser, data, data_len, &error ) )
			{
				g_warning( "FAILED TO PARSE JSON : %s", error->message );
				
				g_clear_error( &error );
			}	
			else
			{
				JsonNode * root = json_parser_get_root( parser );
				
				if ( ! root )
				{
					g_warning( "FAILED TO PARSE JSON : INVALID ROOT ELEMENT '%s'", data );
				}
				else
				{				
					JsonNodeType type = JSON_NODE_TYPE( root );

					if ( type != JSON_NODE_OBJECT && type != JSON_NODE_ARRAY )
					{
						g_warning( "FAILED TO PARSE JSON : INVALID ROOT ELEMENT '%s'", data );
					}
					else
					{
						json_to_lua( L, root );
					}
				}
			}
			
			g_object_unref( G_OBJECT( parser ) );
			
			int new_top = lua_gettop( L );
			
			if ( new_top == top )
			{
				lua_pushnil( L );
			}
			else if ( new_top != top + 1 )
			{
				// We pushed more than one thing
				
				g_assert( false );
			}
			
		]];
		
	/*	
		Function: stringify
		
		Converts a table to a JSON string. 
		
		Lua tables can have a mixture of 
		numerically indexed entries and key/value entries. This is not possible 
		with JSON; Lua tables that have indexed entries will become JSON arrays
		and those that don't will become JSON objects. JSON objects only support
		string keys, so members of Lua tables that have other types of keys will
		not be present in the output. Functions, user data or other types that 
		cannot be converted to JSON will be represented as nulls.
		
		Arguments:
		
			t - A table to convert to JSON.
			
		Returns:
		
			string - A JSON representation of the table.
			
			nil - If there is a problem. 
	*/
	
	lstring stringify( table t )
		[[
			JsonNode * root = lua_value_to_json( L, t );
			
			g_assert( root );
			
			result = NULL;
			result_len = 0;
			
			FreeLater free_later;
			
			switch ( json_node_get_node_type( root ) )
			{
				case JSON_NODE_OBJECT:
				case JSON_NODE_ARRAY:
				
					{
						JsonGenerator * g = json_generator_new();
						
						json_generator_set_root( g, root );
						
						gsize length = 0;
						
						gchar * json = json_generator_to_data( g, & length );
						
						g_object_unref( G_OBJECT( g ) );
						
						free_later( json );
						
						result = json;
						result_len = length;
					}
				
					break;
				
				default:
					
					break;
			}
			
			json_node_free( root );
			
		]];
}

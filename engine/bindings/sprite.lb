module sprite;

[[
#define CLUTTER_VERSION_MIN_REQUIRED CLUTTER_VERSION_CUR_STABLE
#include "clutter/clutter.h"
#include "cogl/cogl.h"
#include "clutter_util.h"
#include "spritesheet.h"
#include "sprite_sheet.lb.h"
#include <glib.h>
]]

[[

struct SpriteBinding
{
    class SignalLoadedLater : public Action
    {
        SpriteBinding * self;

        public: SignalLoadedLater( SpriteBinding * self ) : self( self ) { g_assert( self ); };

        protected: bool run()
        {
            self->signal_loaded();
            self->can_fire = true;
            return false;
        }
    };
    
    SpriteBinding( ClutterActor * _actor ) : async( false ), loaded( false ), can_fire( true ), 
                                             actor( _actor ), sprite( NULL ), sheet( NULL ), id( NULL ) {}
    
    ~SpriteBinding()
    {
        if ( id ) free( id );
    }
    
    const char * get_id() { return id ? strdup( id ) : NULL; }
    
    void set_id( const char * new_id )
    {
        if ( !id || !new_id || strcmp( id, new_id ) )
        {
            if ( id ) free( id );
            id = new_id ? strdup( new_id ) : NULL;
            
            if ( id && sheet && !sheet->has_id( id ) )
            {
                g_warning( "Spritesheet does not contain the id '%s'", id );
            }
            
            update_sprite();
        }
    }
    
    void set_sheet( SpriteSheet * _sheet )
    {
        sheet = _sheet;
        update_sprite();
    };
    
    void update()
    {
        static CoglHandle null_texture = cogl_texture_new_with_size( 1, 1, COGL_TEXTURE_NONE, COGL_PIXEL_FORMAT_A_8 );
        
        clutter_texture_set_cogl_texture( CLUTTER_TEXTURE( actor ), sprite ? sprite->get_texture() : null_texture );
        clutter_actor_queue_redraw( actor );
        
        loaded = sprite && sprite->is_real();
        
        signal_loaded_later();
    }
    
    void signal_loaded()
    {
        if ( async && id && sheet )
        {
            GError * error = NULL;
            
            if ( !sprite || sprite->is_failed() || !sprite->is_real() )
            {
                g_set_error( &error, CLUTTER_TEXTURE_ERROR, CLUTTER_TEXTURE_ERROR_BAD_FORMAT, "?" );
            }
            
            g_signal_emit_by_name( G_OBJECT( actor ), "load-finished", error );
        }
    }
    
    void signal_loaded_later()
    {
        if ( async && can_fire )
        {
            can_fire = false;
            Action::post( new SignalLoadedLater( this ) );
        }
    }
    
    bool async;
    bool loaded;
    bool can_fire;
    
private:
    static void on_ping( PushTexture * source, void * target )
    {
        SpriteBinding * self = (SpriteBinding *) target;
        self->update();
    };

    void update_sprite()
    {
        sprite = sheet ? sheet->get_sprite( id ) : NULL;
        ping.set( sprite, SpriteBinding::on_ping, this, !async );
    }

    PushTexture::PingMe   ping;
    ClutterActor        * actor;
    
    SpriteSheet::Sprite * sprite;
    SpriteSheet         * sheet;
    char * id;
};

void set_sheet_first( lua_State * L , int table )
{
    assert( table );
    lua_newtable( L );
    lua_getfield( L , table , "sheet" );
    lua_setfield( L , -2, "sheet" );
    
    ClutterUtil::set_props_from_table( L , lua_gettop( L ) );
    
    lua_pop( L, 1 );
}

#define get_binding( self ) ( (SpriteBinding *) g_object_get_data( G_OBJECT( self ), "tp-binding" ) )
#define get_ref( self ) ( (int *) g_object_get_data( G_OBJECT( self ), "tp-sheet-ref" ) )

void Sprite_on_loaded( ClutterTexture * self, gpointer error, lua_State * L );

]]

/*
    Class: Sprite
    
    The Sprite class will draw a single sprite from a <SpriteSheet> as if it were an Image that had been loaded seperately. Instead of a 'src' property, Sprite objects have 'sheet' and 'id' properties, indicating what SpriteSheet to draw from and which sprite in that sheet to draw.
    
    In addition to the properties and functions described on this page, the Sprite type also supports all the properties and functions defined in the <UIElement> interface.
*/

class Sprite [[ClutterActor*]] actor
{

    /*
        Constructor: Sprite
        
        The Sprite() constructor creates a new Sprite object.
        
        *Arguments:*
        
        props - table defining the object's construction
        
        *Return Value:* new Sprite object
    */
    
    Sprite( table props = 0 )
        [[
            self = lb_construct_gobject( ClutterActor, ClutterUtil::make_actor( clutter_texture_new ) );
            ClutterUtil::initialize_actor( L, self, SPRITE_METATABLE );
            
            g_object_set_data( G_OBJECT( self ), "tp-binding", new SpriteBinding( self ) );
            g_object_set_data_full( G_OBJECT( self ), "tp-sheet-ref", g_new0( int, 1 ), g_free );
            * get_ref( self ) = LUA_REFNIL;
            
            if ( props )
            {
                set_sheet_first( L, props );
                ClutterUtil::set_props_from_table( L, props );
            }
            
            g_object_unref( self );
        ]];

    ~Sprite()
        [[
            if ( * get_ref( self ) ) lb_strong_unref( L, * get_ref( self ) );
            delete get_binding( self );
        ]];

    /*
        Property: sheet
        
        The sheet property is a SpriteSheet object from which the Sprite will be drawn. The sheet property can be changed even if the current id does not exist in the sheet; in this case, the Sprite will simply draw nothing.
        
        When both the sheet and id need to be changed at once, the sheet should be set first and then the id.
        
        *See Also:* <id> property
    */

    SpriteSheet sheet
        [[
            lb_strong_deref( L, * get_ref( self ) );
        ]]
        [[
            SpriteBinding * binding = get_binding( self );
            if ( * get_ref( self ) ) lb_strong_unref( L, * get_ref( self ) );
            
            SpriteSheet * new_sheet = LB_GET_SPRITESHEET( L, 2 );
            
            if ( new_sheet )
            {
                binding->set_sheet( new_sheet );
                * get_ref( self ) = lb_strong_ref( L );
            }
            else
            {
                g_warning( "Failed to set 'sheet': not a SpriteSheet." );
                binding->set_sheet( NULL );
                * get_ref( self ) = LUA_REFNIL;
            }
        ]];

    /*
        Property: id
        
        The id property is a string specfifying which sprite to draw from the current sheet. Specifying an id that does not exist in the current sheet will throw an error.
        
        When both the sheet and id need to be changed at once, the sheet should be set first and then the id.
        
        *See Also:* <sheet> property
    */

    string id
        [[
            id = get_binding( self )->get_id();
        ]]
        [[
            SpriteBinding * binding = get_binding( self );
            const char * new_id = lua_tostring( L , -1 );
            
            g_object_set_data_full( G_OBJECT( self ), "tp-src",
                g_strdup_printf( "(Sprite) \"%s\"", new_id ? new_id : "" ), g_free );
                
            binding->set_id( new_id );
        ]];
        
    /*
        Property: async
        
        The async property is a boolean value that determines whether the source image of the Sprite (managed by its SpriteSheet) is loaded asynchronously or not.
        
        When either the <sheet> or <id> changes, if a new source image needs to be loaded, it will also be loaded according to this value.
        
        *Default Setting:* false, i.e., the source image is loaded synchronously
        
        *See Also:* the <on_loaded> event
    */
        
    bool async
        [[
            async = get_binding( self )->async;
        ]]
        [[
            get_binding( self )->async = async;
        ]];
        
    /*
        Property: loaded
        
        The loaded property is a boolean value indicating if the source image currently in use by the Sprite was loaded successfully.
        
        *Default Setting:* false
        
        *See Also:* the <id> property
    */
        
    readonly bool loaded
        [[
            loaded = get_binding( self )->loaded;
        ]];
        
    /*
        Function: add_onloaded_listener
        
        The add_onloaded_listener() function registers a handler function for <on_loaded> events.
        
        *Arguments*
        
            fn - reference to handler function. The function prototype is described below.

        *Return Value:* Handle to the registered handler. Pass this handle to the <remove_onloaded_listener> function to unregister the handler.

        *Handler Prototype:*

        (code)
        fn( Sprite self, boolean failed )
        (end)

        *Handler Arguments:*

            self - the Sprite object that has finished loading
            failed - boolean value indicating failure or success of the load operation (true=failure)
        
        *Handler Return Value:* None
        
        *See Also:* the <on_loaded> event and the <remove_onloaded_listener> function
    */
        
    int add_onloaded_listener( function fn )
        [[
            result = UserData::get( L )->add_callback( (char *) "on_loaded" , L );
            UserData::get( L )->connect_signal( "on_loaded",
                "load-finished", (GCallback) Sprite_on_loaded, L );
        ]];
        
    /*
        Function: remove_onloaded_listener

        The remove_onloaded_listener() function unregisters the specified event handler.

        *Arguments:*

            ref - handle for event handler to unregister. This handle is returned by the <add_onloaded_listener> function.

        *Return Value:* None

        *See Also:* the <add_onloaded_listener> function
    */

    remove_onloaded_listener( int ref )
        [[
            UserData::get( L )->remove_callback( (char *) "on_loaded" , L );
        ]];

    /*
        Event: on_loaded

        The on_loaded event occurs when an asynchronously-loaded source image has finished loading.

        *See Also:* the <add_onloaded_listener> function
    */

    function on_loaded
        [[
            return UserData::get( L )->get_last_callback( (char *) "on_loaded" , L );
        ]]
        [[
            UserData::get( L )->set_last_callback( (char *) "on_loaded" , L );
            UserData::get( L )->connect_signal( "on_loaded",
                "load-finished", (GCallback) Sprite_on_loaded, L );
        ]];

    /*
        This makes sure sheet is set first.
    */

    UIElement set( table props )
        [[
            luaL_checktype( L, -1, LUA_TTABLE );
            
            set_sheet_first( L, props );
            ClutterUtil::set_props_from_table( L, props );
            
            lua_pushvalue( L, 1 );
        ]];
}

[[

void Sprite_on_loaded( ClutterTexture * self, gpointer failed, lua_State * L )
{
    if ( get_binding( self )->async )
    {
        lua_pushboolean( L, !!failed );
        UserData::invoke_callbacks( G_OBJECT( self ), "on_loaded", 1, 0, L );
    }
}

]]

module sprite;

[[
#define CLUTTER_VERSION_MIN_REQUIRED CLUTTER_VERSION_CUR_STABLE
#include "clutter/clutter.h"
#include "cogl/cogl.h"
#include "clutter_util.h"
#include "spritesheet.h"
#include <glib.h>

#include "sprite_sheet.lb.h"

#ifdef CLUTTER_VERSION_1_10
#define TP_COGL_TEXTURE(t) (COGL_TEXTURE(t))
#define TP_CoglTexture CoglTexture *
#else
#define TP_COGL_TEXTURE(t) (t)
#define TP_CoglTexture CoglHandle
#endif
]]

[[
void push_lua_sheet( lua_State * L , GObject * sprite )
{
    LSG;

    int * sheet_ref = (int*) g_object_get_data( sprite , "tp-sheet-ref" );

    if ( sheet_ref )
    {
        lb_strong_deref( L , *sheet_ref );
    }
    else
    {
        lua_pushnil( L );
    }

    LSG_CHECK( 1 );
}

SpriteSheet * get_sheet( lua_State * L , GObject * sprite )
{
    LSG;

    SpriteSheet * sheet = 0;

    int * sheet_ref = (int *) g_object_get_data( sprite , "tp-sheet-ref" );

    if ( sheet_ref )
    {
        lb_strong_deref( L , * sheet_ref );
        sheet = (SpriteSheet *) UserData::get_client( L , -1 );
        lua_pop( L , 1 );
    }

    LSG_END( 0 );

    return sheet;
}

void refresh_texture( GObject * g_self, SpriteSheet * sheet, const char * new_id )
{
    const char * id = new_id;
    SpriteSheet::Sprite * sprite = (SpriteSheet::Sprite *) g_object_get_data( g_self, "tp-sprite" );
    
    if ( sprite )
    {
        if ( !id )
        {
            id = sprite->get_id();
        }
        sprite->deref_texture();
        g_object_set_data( g_self, "tp-sprite", NULL );
    }
    
    if ( id )
    {
        g_object_set_data_full( g_self, "tp-id", strdup( id ), g_free );
    }
    else
    {
        id = (char *) g_object_get_data( g_self, "tp-id" );
    }
    
    if ( sheet )
    {
        if (( sprite = sheet->get_sprite( id ) ))
        {
            g_object_set_data( g_self, "tp-sprite", sprite );
            clutter_texture_set_cogl_texture( CLUTTER_TEXTURE( g_self ), sprite->ref_texture() );
        }
        else if ( new_id )
        {
            g_warning( "Sprite's sheet does not contain the id '%s' (If you are trying to change both, change the sheet first).", id );
        }
        else
        {
            clutter_texture_set_cogl_texture( CLUTTER_TEXTURE( g_self ), cogl_texture_new_with_size( 1, 1, COGL_TEXTURE_NONE, COGL_PIXEL_FORMAT_A_8 ) );
        }
    }
    else if ( new_id )
    {
        g_warning( "Trying to set the id '%s' on a Sprite without first specifying a SpriteSheet.", id );
    }
}

void set_sheet_first( lua_State * L , int table )
{
    if ( table )
    {
        lua_newtable( L );
        lua_pushstring( L , "sheet" );
        lua_getfield( L , table , "sheet" );
        if ( ! lua_isnil( L , -1 ) )
        {
            lua_rawset( L , -3 );
            ClutterUtil::set_props_from_table( L , lua_gettop( L ) );
        }
        else
        {
            lua_pop( L , 2 );
        }

        lua_pop( L , 1 );
    }
}

]]

/*
    Class: Sprite
    
    The Sprite class will draw a single sprite from a <SpriteSheet> as if it were an Image that had been loaded seperately. Instead of a 'src' property, Sprite objects have 'sheet' and 'id' properties, indicating what SpriteSheet to draw from and which sprite in that sheet to draw.
    
    In addition to the properties and functions described on this page, the Image data type also supports all the properties and functions defined in the <UIElement> interface.
*/

class Sprite [[ClutterActor*]] actor
{

    /*
        Constructor: Sprite
        
        The Sprite() constructor creates a new Sprite object.
        
        *Arguments:*
        
        props - table defining the object's construction
        
        *Return Value:* new Sprite object
    */
    
    Sprite(table props = 0 )
        [[
            self = lb_construct_gobject( ClutterActor , ClutterUtil::make_actor( clutter_texture_new ) );
            ClutterUtil::initialize_actor( L, self, SPRITE_METATABLE );

            lua_pushvalue( L , -1 );
            set_sheet_first( L , props );
            lua_pop( L , 1 );

            ClutterUtil::set_props_from_table( L, props );
            g_object_unref( self );
        ]];

    ~Sprite()
        [[
            int * sheet_ref = (int *) g_object_get_data( G_OBJECT( self ), "tp-sheet-ref" );
            if(sheet_ref) lb_strong_unref( L , * sheet_ref );
        ]];

    /*
        Property: sheet
        
        The sheet property is a SpriteSheet object from which the Sprite will be drawn. The sheet property can be changed even if the current id does not exist in the sheet; in this case, the Sprite will simply draw nothing.
        
        When both the sheet and id need to be changed at once, the sheet should be set first and then the id.
        
        *See Also:* <id> property
    */

    SpriteSheet sheet
        [[
            push_lua_sheet( L , G_OBJECT( self ) );
        ]]
        [[
            SpriteSheet * new_sheet;
            if (( new_sheet = LB_GET_SPRITESHEET( L, 2 ) ))
            {
                GObject * g_self = G_OBJECT( self );
                
                SpriteSheet * old_sheet = get_sheet( L, g_self );
                
                if ( old_sheet != new_sheet )
                {
                    int * new_sheet_ref = g_new( int, 1 );
                    * new_sheet_ref = lb_strong_ref( L );
                        
                    g_object_set_data_full( g_self, "tp-sheet-ref", new_sheet_ref, (GDestroyNotify) g_free );
                    
                    refresh_texture( g_self, new_sheet, NULL );
                }
            }
            else
            {
                g_warning( "Failed to set 'sheet': not a SpriteSheet." );
            }
        ]];

    /*
        Property: id
        
        The id property is a string specfifying which sprite to draw from the current sheet. Specifying an id that does not exist in the current sheet will throw an error.
        
        When both the sheet and id need to be changed at once, the sheet should be set first and then the id.
        
        *See Also:* <sheet> property
    */

    string id
        [[
            SpriteSheet::Sprite *sprite = (SpriteSheet::Sprite *)g_object_get_data( G_OBJECT( self ), "tp-sprite" );
            if(sprite)
            {
                id = (char *)sprite->get_id();
            }
            else
            {
                id = NULL;
                g_warning("SPRITE HAS NO ID AT: %s", Util::where_am_i_lua(L).c_str());
            }
        ]]
        [[
            GObject * g_self = G_OBJECT( self );
            SpriteSheet::Sprite * sprite = (SpriteSheet::Sprite *) g_object_get_data( g_self, "tp-sprite" );
            
            char * new_id = (char *) lua_tostring( L , -1 );
            
            if ( !sprite || strcmp( new_id, sprite->get_id() ) != 0 )
            {
                g_object_set_data_full( g_self , "tp-src" , g_strdup_printf( "(Sprite) \"%s\"", new_id ) , g_free );
                refresh_texture( g_self, get_sheet( L, g_self ), new_id );
            }
        ]];

    /*
        This makes sure sheet is set first.
    */

    UIElement set(table props)
        [[
            luaL_checktype( L, -1, LUA_TTABLE );

            lua_pushvalue( L, -2 );
            set_sheet_first( L, props );
            lua_pop( L, 1 );

            ClutterUtil::set_props_from_table( L, props );
            lua_pushvalue( L, 1 );
        ]];
}

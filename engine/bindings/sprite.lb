module sprite;

[[
#include "clutter/clutter.h"
#include "cogl/cogl.h"
#include "clutter_util.h"
#include "spritesheet.h"
#include <glib.h>

#include "sprite_sheet.lb.h"

#ifdef CLUTTER_VERSION_1_10
#define TP_COGL_TEXTURE(t) (COGL_TEXTURE(t))
#define TP_CoglTexture CoglTexture *
#else
#define TP_COGL_TEXTURE(t) (t)
#define TP_CoglTexture CoglHandle
#endif
]]

[[
void push_lua_sheet( lua_State * L , GObject * sprite )
{
    LSG;

    int * sheet_ref = (int*) g_object_get_data( sprite , "tp-sheet-ref" );

    if ( sheet_ref )
    {
        lb_strong_deref( L , *sheet_ref );
    }
    else
    {
        lua_pushnil( L );
    }

    LSG_CHECK( 1 );
}

SpriteSheet * get_sheet( lua_State * L , GObject * sprite )
{
    LSG;

    SpriteSheet * sheet = 0;

    int * sheet_ref = (int*) g_object_get_data( sprite , "tp-sheet-ref" );

    if ( sheet_ref )
    {
        lb_strong_deref( L , *sheet_ref );
        sheet = (SpriteSheet*) UserData::get_client( L , -1 );
        lua_pop( L , 1 );
    }

    LSG_END( 0 );

    return sheet;
}

int refresh_texture( lua_State * L , GObject * sprite , int check_validity , char ** error_message )
{
    char * id = (char*) g_object_get_data( sprite , "tp-id" );

    SpriteSheet * sheet = get_sheet( L , sprite );

    if ( id && sheet )
    {
        CoglHandle sprite_texture = sheet->get_subtexture( id );
        if ( cogl_is_texture( sprite_texture ) )
        {
            if ( sprite_texture != clutter_texture_get_cogl_texture( CLUTTER_TEXTURE( sprite ) ) )
            {
                clutter_texture_set_cogl_texture( CLUTTER_TEXTURE( sprite ) , TP_COGL_TEXTURE( sprite_texture ) );

                char * sheet_src = (char*) g_object_get_data( sheet->extra , "tp-src" );

                char * sprite_src = (char*) malloc( snprintf( NULL, 0, "(Sprite) \"%s\"", sheet_src ) + 1 );
                sprintf( sprite_src , "(Sprite) \"%s\"", sheet_src );

                g_object_set_data_full( sprite , "tp-src" , strdup( sprite_src ) , g_free );
            }
        }
        else if ( check_validity )
        {
            *error_message = (char*) "Invalid sheet/id combination.  (If you are trying to change both, change the sheet first)";
            return 0;
        }
    }
    else if ( check_validity )
    {
        *error_message = (char*) "Invalid sheet/id combination.  (If you are trying to change both, change the sheet first)";
        return 0;
    }

    return 1;
}

void set_sheet_first( lua_State * L , int table )
{
    if ( table )
    {
        lua_newtable( L );
        lua_pushstring( L , "sheet" );
        lua_getfield( L , table , "sheet" );
        if ( ! lua_isnil( L , -1 ) )
        {
            lua_rawset( L , -3 );
            ClutterUtil::set_props_from_table( L , lua_gettop( L ) );
        }
        else
        {
            lua_pop( L , 2 );
        }

        lua_pop( L , 1 );
    }
}

]]

/*
    Class: Sprite
    
    The Sprite class will draw a single sprite from a <SpriteSheet> as if it were an Image that had been loaded seperately. Instead of a 'src' property, Sprite objects have 'sheet' and 'id' properties, indicating what SpriteSheet to draw from and which sprite in that sheet to draw.
    
    In addition to the properties and functions described on this page, the Image data type also supports all the properties and functions defined in the <UIElement> interface.
*/

class Sprite [[ClutterActor*]] actor
{

    /*
        Constructor: Sprite
        
        The Sprite() constructor creates a new Sprite object.
        
        *Arguments:*
        
        props - table defining the object's construction
        
        *Return Value:* new Sprite object
    */
    
    Sprite(table props = 0 )
        [[
            self = lb_construct_gobject( ClutterActor , ClutterUtil::make_actor( clutter_texture_new ) );
            ClutterUtil::initialize_actor( L, self, SPRITE_METATABLE );

            lua_pushvalue( L , -1 );
            set_sheet_first( L , props );
            lua_pop( L , 1 );

            ClutterUtil::set_props_from_table( L, props );
            g_object_unref( self );
        ]];

    ~Sprite()
        [[
            int *sheet_ref = (int *)g_object_get_data( G_OBJECT( self ), "tp-sheet-ref" );
            lb_strong_unref( L , *sheet_ref );
        ]];

    /*
        Property: sheet
        
        The sheet property is a SpriteSheet object from which the Sprite will be drawn. The sheet property can be changed even if the current id does not exist in the sheet; in this case, the Sprite will simply draw nothing.
        
        When both the sheet and id need to be changed at once, the sheet should be set first and then the id.
        
        *See Also:* <id> property
    */

    SpriteSheet sheet
        [[
            push_lua_sheet( L , G_OBJECT( self ) );
        ]]
        [[
            if ( SpriteSheet * new_sheet = LB_GET_SPRITESHEET( L, 2 ) )
            {
                GObject * g_self = G_OBJECT( self );
    
                SpriteSheet * old_sheet = get_sheet( L , g_self );
    
                if ( old_sheet != new_sheet )
                {
                    int * new_sheet_ref = g_new( int , 1 );
                    *new_sheet_ref = lb_strong_ref( L );

                    g_object_set_data_full( g_self , "tp-sheet-ref" , new_sheet_ref , (GDestroyNotify)g_free );

                    refresh_texture( L , g_self , 0 , 0 );
                }
            }
            else
            {
                g_warning( "Failed to set 'sheet': not a SpriteSheet." );
            }
        ]];

    /*
        Property: id
        
        The id property is a string specfifying which sprite to draw from the current sheet. Specifying an id that does not exist in the current sheet will throw an error.
        
        When both the sheet and id need to be changed at once, the sheet should be set first and then the id.
        
        *See Also:* <sheet> property
    */

    string id
        [[
            id = (char*) g_object_get_data( G_OBJECT( self ) , "tp-id" );
        ]]
        [[
            GObject * g_self = G_OBJECT( self );

            char * old_id = (char*) g_object_get_data( g_self , "tp-id" );
            char * new_id = (char*) lua_tostring( L , -1 );

            if ( ! old_id || strcmp( old_id , new_id ) != 0 )
            {
                char * error_message;
                char * old_id_copy = old_id ? strdup( old_id ) : 0;

                g_object_set_data_full( g_self , "tp-id" , strdup( id ) , g_free );

                if ( ! refresh_texture( L , g_self , 1 , &error_message ) )
                {
                    if ( old_id_copy ) g_object_set_data_full( g_self , "tp-id" , old_id_copy , g_free );
                    luaL_error( L , error_message );
                }
                else if ( old_id_copy )
                {
                    g_free( old_id_copy );
                }
            }
        ]];

    /*
        This makes sure sheet is set first.
    */

    UIElement set(table props)
        [[
            luaL_checktype(L,-1,LUA_TTABLE);

            lua_pushvalue( L , -2 );
            set_sheet_first( L , props );
            lua_pop( L , 1 );

            ClutterUtil::set_props_from_table(L,props);
            lua_pushvalue(L,1);
        ]];
}

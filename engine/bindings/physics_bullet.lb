
module physics_bullet;

[[
#include "physics_bullet.h"
#include "clutter_util.h"

static btVector3 btVector3FromTable( lua_State * L , int t )
{
    lua_rawgeti( L , t , 1 );
    lua_rawgeti( L , t , 2 );
    lua_rawgeti( L , t , 3 );
    
    btVector3 result( lua_tonumber( L , -3 ) , lua_tonumber( L , -2 ) , lua_tonumber( L , -1 ) );
    
    lua_pop( L , 3 );
    
    return result;
}

static void TableFrombtVector3( lua_State * L , int t , const btVector3 & v )
{
    if ( 0 == t )
    {
        lua_newtable( L );
        t = lua_gettop( L );
    }
    else
    {
        t = abs_index( L , t );
    }
    
    g_assert( lua_istable( L , t ) );
    
    lua_pushnumber( L , v.getX() );
    lua_rawseti( L , t , 1 );
    lua_pushnumber( L , v.getY() );
    lua_rawseti( L , t , 2 );
    lua_pushnumber( L , v.getZ() );
    lua_rawseti( L , t , 3 );
}

]]

interface PBBody [[ void * ]]
{
}

interface PBShape [[ btCollisionShape * ]]
{
    PBShape()
        [[
            self = lb_construct( btCollisionShape , lua_touserdata( L , -2 ) );
        ]];
        
    ~PBShape()
        [[
            // Not deleted because they are owned by the world
        ]];
        
    table local_scaling
        [[
            TableFrombtVector3( L , 0 , self->getLocalScaling() );
        ]]
        [[
            self->setLocalScaling( btVector3FromTable( L , 2 ) ); 
        ]];        
        
    double margin
        [[
            margin = self->getMargin();
        ]]
        [[
            self->setMargin( margin );
        ]];        
}

interface PBBody3d [[ btCollisionObject * ]]
{
    PBBody3d()
        [[
            self = lb_construct( btCollisionObject , lua_touserdata( L , -2 ) );
        ]];
        
    ~PBBody3d()
        [[
            // Not deleted because they are owned by the world
        ]];
        
    readonly int handle
        [[
            handle = GPOINTER_TO_INT( self->getUserPointer() );
        ]];
        
    bool awake
        [[
            awake = self->isActive();
        ]]
        [[
            self->activate( true );
        ]];

    bool active
        [[
            if ( btRigidBody * body = btRigidBody::upcast( self ) )
            {
                active = body->isInWorld();
            }
            else
            {
                active = false;
            }
        ]]
        [[
            // FIXME: To de-activate a body, we have to remove it from 
            // its world. Right now, this would cause the body pointer to
            // leak because we only delete the ones that are listed in the
            // world. 
            
            g_assert( false );
        ]];

    table linear_velocity
        [[
            lua_newtable( L );
            
            if ( btRigidBody * body = btRigidBody::upcast( self ) )
            {
                TableFrombtVector3( L , -1 , body->getLinearVelocity() ); 
            }
        ]]
        [[
            if ( btRigidBody * body = btRigidBody::upcast( self ) )
            {
                body->setLinearVelocity( btVector3FromTable( L , 2 ) );
            }
        ]];

    table angular_velocity
        [[
            lua_newtable( L );
            
            if ( btRigidBody * body = btRigidBody::upcast( self ) )
            {
                TableFrombtVector3( L , -1 , body->getAngularVelocity() ); 
            }
        ]]
        [[
            if ( btRigidBody * body = btRigidBody::upcast( self ) )
            {
                body->setAngularVelocity( btVector3FromTable( L , 2 ) );
            }
        ]];
        
    double linear_damping
        [[
            if ( btRigidBody * body = btRigidBody::upcast( self ) )
            {
                linear_damping = body->getLinearDamping();
            }
            else
            {
                linear_damping = 0;
            }
        ]]
        [[
            if ( btRigidBody * body = btRigidBody::upcast( self ) )
            {
                body->setDamping( linear_damping , body->getAngularDamping() );
            }
        ]];

    double angular_damping
        [[
            if ( btRigidBody * body = btRigidBody::upcast( self ) )
            {
                angular_damping = body->getAngularDamping();
            }
            else
            {
                angular_damping = 0;
            }
        ]]
        [[
            if ( btRigidBody * body = btRigidBody::upcast( self ) )
            {
                body->setDamping( body->getLinearDamping() , angular_damping );
            }
        ]];
        
    table linear_factor
        [[
            lua_newtable( L );
            
            if ( btRigidBody * body = btRigidBody::upcast( self ) )
            {
                TableFrombtVector3( L , -1 , body->getLinearFactor() ); 
            }            
        ]]
        [[
            if ( btRigidBody * body = btRigidBody::upcast( self ) )
            {
                body->setLinearFactor( btVector3FromTable( L , 2 ) );
            }            
        ]];
        
    table angular_factor
        [[
            lua_newtable( L );
            
            if ( btRigidBody * body = btRigidBody::upcast( self ) )
            {
                TableFrombtVector3( L , -1 , body->getAngularFactor() ); 
            }            
        ]]
        [[
            if ( btRigidBody * body = btRigidBody::upcast( self ) )
            {
                body->setAngularFactor( btVector3FromTable( L , 2 ) );
            }            
        ]];
        
    table gravity
        [[
            lua_newtable( L );
            
            if ( btRigidBody * body = btRigidBody::upcast( self ) )
            {
                TableFrombtVector3( L , -1 , body->getGravity() ); 
            }            
        ]]
        [[
            if ( btRigidBody * body = btRigidBody::upcast( self ) )
            {
                body->setGravity( btVector3FromTable( L , 2 ) );
            }            
        ]];

    apply_force( table force , table point = 0 )
        [[
            if ( btRigidBody * body = btRigidBody::upcast( self ) )
            {
                btVector3 f( btVector3FromTable( L , force ) );

                if ( 0 == point )
                {
                    body->applyCentralForce( f );
                }
                else
                {
                    body->applyForce( f , btVector3FromTable( L , point ) ); 
                }
            }            
        ]];        

    apply_torque( table torque )
        [[
            if ( btRigidBody * body = btRigidBody::upcast( self ) )
            {
                body->applyTorque( btVector3FromTable( L , torque ) );
            }            
        ]];        

    apply_linear_impulse( table force , table point = 0 )
        [[
            if ( btRigidBody * body = btRigidBody::upcast( self ) )
            {
                btVector3 f( btVector3FromTable( L , force ) );

                if ( 0 == point )
                {
                    body->applyCentralImpulse( f );
                }
                else
                {
                    body->applyImpulse( f , btVector3FromTable( L , point ) ); 
                }
            }            
        ]];        
        
    apply_angular_impulse( table torque )
        [[
            if ( btRigidBody * body = btRigidBody::upcast( self ) )
            {
                body->applyTorqueImpulse( btVector3FromTable( L , torque ) );
            }
        ]];        
        
    clear_forces()
        [[
            if ( btRigidBody * body = btRigidBody::upcast( self ) )
            {
                body->clearForces();
            }
        ]];
        
    /*
        Copies its transform matrix into the one provided and returns it.
        
        This is for performance reasons - instead of creating a new one every
        time.
    */
        
    Matrix get_transform( Matrix matrix )
        [[
            if ( UserData * ud = UserData::get_check( L , matrix ) )
            {
                // FIXME - NOT CHECKING THE TYPE OF THE UDATA. 
                // BAD-MEMORY CORRUPTION VERY EASILY
                // GOOD-PERFORMANCE
                
                CoglMatrix * matrix = ( CoglMatrix * ) ud->get_client();
        
                float m[16];
                m[15]=1;
        
                self->getWorldTransform().getOpenGLMatrix( m );
        
                cogl_matrix_init_from_array( matrix , m );
            }
            
            lua_pushvalue( L , matrix );
        ]];
        
    Matrix set_transform( Matrix matrix )
        [[
            if ( UserData * ud = UserData::get_check( L , matrix ) )
            {
                // FIXME - NOT CHECKING THE TYPE OF THE UDATA. 
                // BAD-MEMORY CORRUPTION VERY EASILY
                // GOOD-PERFORMANCE
                
                CoglMatrix * matrix = ( CoglMatrix * ) ud->get_client();
        
                btTransform transform;
                
                transform.setFromOpenGLMatrix( & matrix->xx );
                
                self->setWorldTransform( transform );
            }
            
            lua_pushvalue( L , matrix );
        ]];
        
    Matrix get_center_of_mass_transform( Matrix matrix )
        [[
            if ( btRigidBody * body = btRigidBody::upcast( self ) )
            {
                if ( UserData * ud = UserData::get_check( L , matrix ) )
                {
                    // FIXME - NOT CHECKING THE TYPE OF THE UDATA. 
                    // BAD-MEMORY CORRUPTION VERY EASILY
                    // GOOD-PERFORMANCE
                    
                    CoglMatrix * matrix = ( CoglMatrix * ) ud->get_client();
            
                    float m[16];
                    m[15]=1;
            
                    body->getCenterOfMassTransform().getOpenGLMatrix( m );

                    cogl_matrix_init_from_array( matrix , m );
                }
            }
                        
            lua_pushvalue( L , matrix );
        ]];
       
        
    Matrix set_center_of_mass_transform( Matrix matrix )
        [[
            if ( btRigidBody * body = btRigidBody::upcast( self ) )
            {
                if ( UserData * ud = UserData::get_check( L , matrix ) )
                {
                    // FIXME - NOT CHECKING THE TYPE OF THE UDATA. 
                    // BAD-MEMORY CORRUPTION VERY EASILY
                    // GOOD-PERFORMANCE
                    
                    CoglMatrix * matrix = ( CoglMatrix * ) ud->get_client();
            
                    btTransform transform;
                    
                    transform.setFromOpenGLMatrix( & matrix->xx );
                    
                    body->setCenterOfMassTransform( transform );
                }
            }
                        
            lua_pushvalue( L , matrix );
        ]];                
}

global pb [[ Bullet::World * ]] 
{
    pb()
        [[
            self = lb_construct( Bullet::World , new Bullet::World( L , 64 ) );
        ]];
        
    ~pb()
        [[
            delete self;
        ]];
        
    table gravity
        [[
            TableFrombtVector3( L , 0 , self->get_world()->getGravity() ); 
        ]]
        [[
            self->get_world()->setGravity( btVector3FromTable( L , 2 ) ); 
        ]];        
        
    step( double time_step = 1.0f/60.0f , int max_sub_steps = 1 , double fixed_time_step = 1.0f/60.0f )
        [[
            self->step( time_step , max_sub_steps , fixed_time_step );
        ]];
        
    table get_contacts( double max_distance = 0 , PBBody3d body1 = 0 , PBBody3d body2 = 0 )
        [[
            btCollisionObject * co1 = body1 ? ( btCollisionObject * ) UserData::get_client_check( L , body1 ) : 0;
            btCollisionObject * co2 = body2 ? ( btCollisionObject * ) UserData::get_client_check( L , body2 ) : 0;
            
            self->get_contacts( max_distance , co1 , co2 );
        ]];          
        
    PBBody Body( UIElement element , table properties )
        [[
            lb_check_udata_type( L , element , "actor" );

            int n = self->create_body( element , properties , PBBODY_METATABLE );

            if ( ! n )
            {
                lua_pushnil( L );
            }
            else
            {
                ClutterUtil::set_props_from_table( L , properties );
            }
        ]];
        
    PBBody3d Body3d( table properties )
        [[
            if ( ! self->create_body_3d( properties ) )
            {
                lua_pushnil( L );
            }
        ]];
        
/*        
    PBBody3d Sensor3d( table properties )
        [[
            if ( ! self->create_sensor( properties ) )
            {
                lua_pushnil( L );
            }
        ]];
*/

    PBShape BoxShape( double half_width , double half_height , double half_depth )
        [[
            self->create_shape( new btBoxShape( btVector3( half_width , half_height , half_depth ) ) );              
        ]];                 
        
    PBShape StaticPlaneShape( double normal_x , double normal_y , double normal_z , double plane_constant )
        [[
            self->create_shape( new btStaticPlaneShape( btVector3( normal_x , normal_y , normal_z ) , plane_constant ) );
        ]];
        
    PBShape SphereShape( double radius )
        [[
            self->create_shape( new btSphereShape( radius ) );
        ]];
        
    callback on_step( double seconds );
}
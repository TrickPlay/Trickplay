
module physics_bullet;

[[
#include "BulletCollision/CollisionShapes/btTriangleShape.h"
#include <BulletDynamics/ConstraintSolver/btGeneric6DofConstraint.h>

#include "physics_bullet.h"
#include "clutter_util.h"

#include "matrix.lb.h"
#include "physics_bullet.lb.h"

extern int new_Matrix( lua_State * L );

//.............................................................................

static btVector3 btVector3FromTable( lua_State * L , int t )
{
    if ( 0 == t )
    {
        return btVector3();
    }
    
    t = abs_index( L , t );
    
    lua_rawgeti( L , t , 1 );
    lua_rawgeti( L , t , 2 );
    lua_rawgeti( L , t , 3 );
        
    btVector3 result( lua_tonumber( L , -3 ) , lua_tonumber( L , -2 ) , lua_tonumber( L , -1 ) );
    
    lua_pop( L , 3 );
    
    return result;
}

static void TableFrombtVector3( lua_State * L , int t , const btVector3 & v )
{
    if ( 0 == t )
    {
        lua_createtable( L , 3 , 0 );
        t = lua_gettop( L );
    }
    else
    {
        t = abs_index( L , t );
    }
    
    g_assert( lua_istable( L , t ) );
    
    lua_pushnumber( L , v.getX() );
    lua_rawseti( L , t , 1 );
    lua_pushnumber( L , v.getY() );
    lua_rawseti( L , t , 2 );
    lua_pushnumber( L , v.getZ() );
    lua_rawseti( L , t , 3 );
}

static void TableFrombtQuaternion( lua_State * L , int t , const btQuaternion & v )
{
    if ( 0 == t )
    {
        lua_createtable( L , 4 , 0 );
        t = lua_gettop( L );
    }
    else
    {
        t = abs_index( L , t );
    }
    
    g_assert( lua_istable( L , t ) );
    
    lua_pushnumber( L , v.x() );
    lua_rawseti( L , t , 1 );
    lua_pushnumber( L , v.y() );
    lua_rawseti( L , t , 2 );
    lua_pushnumber( L , v.z() );
    lua_rawseti( L , t , 3 );
    lua_pushnumber( L , v.w() );
    lua_rawseti( L , t , 4 );
}

static bool btTransformToMatrix( lua_State * L , const btTransform & transform , int matrix )
{
    if ( CoglMatrix * cm = LB_GET_MATRIX( L , matrix ) )
    {
        float m[16];
        m[15] = 1;
        
        transform.getOpenGLMatrix( m );
        
        cogl_matrix_init_from_array( cm , m );
        
        return true;                 
    }
    return false;
}

static bool btTransformFromMatrix( lua_State * L , int matrix , btTransform & transform )
{
    if ( CoglMatrix * cm = LB_GET_MATRIX( L , matrix ) )
    {
        transform.setFromOpenGLMatrix( & cm->xx );
        
        return true;
    }
    return false;
}

static btRigidBody * get_rigid_body( lua_State * L , int body )
{
    if ( btCollisionObject * co = LB_GET_PBBODY3D( L , body ) )
    {
        return btRigidBody::upcast( co );
    }
    
    return 0;
}

]]

interface PBBody [[ void * ]]
{
}

interface PBShape [[ btCollisionShape * ]]
{
    PBShape()
        [[
            self = lb_construct( btCollisionShape , lua_touserdata( L , -2 ) );
        ]];
        
    ~PBShape()
        [[
            // Not deleted because they are owned by the world
        ]];
    
    readonly string name
        [[
            name = self->getName();
        ]];        
        
    table local_scaling
        [[
            TableFrombtVector3( L , 0 , self->getLocalScaling() );
        ]]
        [[
            self->setLocalScaling( btVector3FromTable( L , 2 ) ); 
        ]];        
        
    double margin
        [[
            margin = self->getMargin();
        ]]
        [[
            self->setMargin( margin );
        ]];
        
    readonly table aabb
        [[
            btTransform t;
            t.setIdentity();
            btVector3 mi , ma;
            
            self->getAabb( t , mi , ma );
            
            lua_newtable( L );
            
            TableFrombtVector3( L , 0 , mi );
            lua_rawseti( L , -2 , 1 );
            TableFrombtVector3( L , 0 , ma );
            lua_rawseti( L , -2 , 2 );
        ]];                    
}

interface PBCompoundShape [[ btCollisionShape * ]] PBShape
{
    PBCompoundShape()
        [[
            self = lb_construct( btCollisionShape , lua_touserdata( L , -2 ) );
        ]];
        
    ~PBCompoundShape()
        [[
            // Not deleted because they are owned by the world
        ]];
        
    readonly int count
        [[
            btCompoundShape * me = static_cast<btCompoundShape*>(self);
            
            count = me->getNumChildShapes();
        ]];        

    # Expects a table of tables with two elements, a matrix and a shape
    
    table children
        [[
            float m[16];
            m[15] = 1;
            
            btCompoundShape * me = static_cast<btCompoundShape*>(self);
            
            int count = me->getNumChildShapes();
            
            lua_newtable( L );
            
            int i = 1;
            
            for ( btCompoundShapeChild * s = me->getChildList(); count; s++ , count-- , i++ )
            {
                lua_newtable( L );
                
                new_Matrix( L );
                
                (void) btTransformToMatrix( L , s->m_transform , -1 );
                
                lua_rawseti( L , -2 , 1 );

                lua_pushlightuserdata( L , s->m_childShape );
                                
                if ( s->m_childShapeType == COMPOUND_SHAPE_PROXYTYPE )
                {
                    new_PBCompoundShape( L );
                }    
                else
                {
                    new_PBShape( L );
                }
                lua_remove( L , -2 );
                                
                lua_rawseti( L , -2 , 2 );
                
                lua_rawseti( L , -2 , i );                                
            }
        ]]
        [[
            btCompoundShape * me = static_cast<btCompoundShape*>(self);
            
            // Clear all existing child shapes
            
            while ( int count = me->getNumChildShapes() )
            {
                me->removeChildShapeByIndex( count - 1 );
            }

            lua_pushnil( L );
            
            while( lua_next( L , 2 ) )
            {
                if ( lua_istable( L , -1 ) )
                {
                    int t = lua_gettop( L );
                    
                    // Get the matrix, from index 1 of this table and
                    // convert it to a transform.
                    
                    lua_rawgeti( L , t , 1 );
                    
                    btTransform transform;
                    
                    if ( ! btTransformFromMatrix( L , -1 , transform ) )
                    {
                        return luaL_error( L , "Transform for shape is not a matrix." );
                    }
                    
                    lua_pop( L , 1 );

                    // Get the shape from index 2
                    
                    lua_rawgeti( L , t , 2 );
                    
                    btCollisionShape * shape = LB_GET_PBSHAPE( L , -1 );
                    
                    if ( ! shape )
                    {
                        return luaL_error( L , "Invalid shape for compound shape child" );
                    }
                    
                    me->addChildShape( transform , shape );
                    
                    lua_pop( L , 1 );
                }
                lua_pop( L , 1 );
            }            
        ]];        
        
    add( Matrix transform , PBShape shape )
        [[
            btCompoundShape * me = static_cast<btCompoundShape*>(self);

            btTransform t;
            
            if ( ! btTransformFromMatrix( L , transform , t ) )
            {
                return luaL_error( L , "Invalid matrix" );
            }
             
            btCollisionShape * s = LB_GET_PBSHAPE( L , shape );
            
            if ( ! s )
            {
                return luaL_error( L , "Invalid shape" );
            }
            
            me->addChildShape( t , s );
        ]];
        
    remove( any shape_or_index )
        [[
            btCompoundShape * me = static_cast<btCompoundShape*>(self);
            
            if ( lua_isnumber( L , shape_or_index ) )
            {
                me->removeChildShapeByIndex( lua_tonumber( L , shape_or_index ) );
            } 
            else
            {
                btCollisionShape * s = LB_GET_PBSHAPE( L , shape_or_index );
                
                if ( ! s )
                {
                    return luaL_error( L , "Invalid shape or index" );
                }
                
                me->removeChildShape( s );
            }
        ]];                    
        
    clear()
        [[
            btCompoundShape * me = static_cast<btCompoundShape*>(self);
            
            // Clear all existing child shapes
            
            while ( int count = me->getNumChildShapes() )
            {
                me->removeChildShapeByIndex( count - 1 );
            }
        ]];        
        
    update_child_transform( int child_index , Matrix transform )
        [[
            btCompoundShape * me = static_cast<btCompoundShape*>(self);

            btTransform t;
            
            if ( ! btTransformFromMatrix( L , transform , t ) )
            {
                luaL_error( L , "Invalid matrix" ); 
            }
            
            me->updateChildTransform( child_index , t );             
        ]];        
}


interface PBPointToPointConstraint [[ btPoint2PointConstraint * ]]
{
    PBPointToPointConstraint( any world , PBBody3d bodyA , table pivotA , PBBody3d bodyB = 0 , table pivotB = 0 )
        [[
            Bullet::World * w = static_cast<Bullet::World*>( lua_touserdata( L , world ) );

            btRigidBody * ba = get_rigid_body( L , bodyA );
                        
            if ( 0 == ba )
            {
                return luaL_error( L , "Invalid first body" ); 
            }                        
            
            btVector3 pa( btVector3FromTable( L , pivotA ) );
            
            btPoint2PointConstraint * c = 0;
            
            if ( 0 == bodyB )
            {
                c = new btPoint2PointConstraint( * ba , pa );    
            }
            else
            {
                btRigidBody * bb = get_rigid_body( L , bodyB );
                
                if ( 0 == bb )
                {
                    return luaL_error( L , "Invalid second body" );
                }
                
                btVector3 pb( btVector3FromTable( L , pivotB ) );
                
                c = new btPoint2PointConstraint( * ba , * bb , pa , pb );
            }
            
            g_assert( c );
            
            self = lb_construct( btPoint2PointConstraint , c );
            
            // TODO: need to support the disableCollisionsBetweenLinkedBodies 
            // flag. Perhaps by not adding the constraint when it is created,
            // but having an explicit add_constraint function on the world 
            // that includes that flag.
            
            w->get_world()->addConstraint( c );
        ]];

    ~PBPointToPointConstraint()
        [[
            // Not deleted because they are owned by the world
        ]];
}

interface PBGeneric6DOFConstraint [[ btGeneric6DofConstraint * ]]
{
    PBGeneric6DOFConstraint( any world , PBBody3d bodyA , Matrix frameA , bool use_linear_reference_frame , PBBody3d bodyB = 0 , Matrix frameB = 0 )
        [[
            Bullet::World * w = static_cast<Bullet::World*>( lua_touserdata( L , world ) );

            btRigidBody * ba = get_rigid_body( L , bodyA );
                        
            if ( 0 == ba )
            {
                return luaL_error( L , "Invalid first body" ); 
            }
            
            btTransform ta;
            
            if ( ! btTransformFromMatrix( L , frameA , ta ) )
            {
                return luaL_error( L , "Invalid matrix for first frame" );
            }                         
            
            btGeneric6DofConstraint * c = 0;
            
            if ( 0 == bodyB )
            {
                c = new btGeneric6DofConstraint( * ba , ta , use_linear_reference_frame );    
            }
            else
            {
                btRigidBody * bb = get_rigid_body( L , bodyB );
                
                if ( 0 == bb )
                {
                    return luaL_error( L , "Invalid second body" );
                }
                
                btTransform tb;
                
                if ( ! btTransformFromMatrix( L , frameB , tb ) )
                {
                    return luaL_error( L , "Invalid matrix for second frame" );
                }             
                            
                c = new btGeneric6DofConstraint( * ba , * bb , ta , tb , use_linear_reference_frame );
            }
            
            g_assert( c );
            
            self = lb_construct( btGeneric6DofConstraint , c );
            
            // TODO: need to support the disableCollisionsBetweenLinkedBodies 
            // flag. Perhaps by not adding the constraint when it is created,
            // but having an explicit add_constraint function on the world 
            // that includes that flag.
            
            w->get_world()->addConstraint( c );
        ]];

    ~PBGeneric6DOFConstraint()
        [[
            // Not deleted because they are owned by the world
        ]];
        
    set_linear_lower_limit( table limit )
        [[
            self->setLinearLowerLimit( btVector3FromTable( L , limit ) );
        ]];
                
    set_linear_upper_limit( table limit )
        [[
            self->setLinearUpperLimit( btVector3FromTable( L , limit ) );
        ]];
                
    set_angular_lower_limit( table limit )
        [[
            self->setAngularLowerLimit( btVector3FromTable( L , limit ) );
        ]];
                
    set_angular_upper_limit( table limit )
        [[
            self->setAngularUpperLimit( btVector3FromTable( L , limit ) );
        ]];
        
    get_frame_offsets( Matrix offsetA , Matrix offsetB )
        [[
            if ( ! btTransformToMatrix( L , self->getFrameOffsetA() , offsetA ) )
            {
                luaL_error( L , "Invalid matrix for first offset" );
            }

            if ( ! btTransformToMatrix( L , self->getFrameOffsetB() , offsetB ) )
            {
                luaL_error( L , "Invalid matrix for second offset" );
            }
        ]];        
}

interface PBHingeConstraint [[ btHingeConstraint * ]]
{
    PBHingeConstraint( any world , PBBody3d bodyA , table pivotA , table axisA , bool use_reference_frame , PBBody3d bodyB = 0 , table pivotB = 0 , table axisB )
        [[
            Bullet::World * w = static_cast<Bullet::World*>( lua_touserdata( L , world ) );

            btRigidBody * ba = get_rigid_body( L , bodyA );
                        
            if ( 0 == ba )
            {
                return luaL_error( L , "Invalid first body" ); 
            }                        
            
            btVector3 pa( btVector3FromTable( L , pivotA ) );
            btVector3 aa( btVector3FromTable( L , axisA ) );
            
            btHingeConstraint * c = 0;
            
            if ( 0 == bodyB )
            {
                c = new btHingeConstraint( * ba , pa , aa , use_reference_frame );    
            }
            else
            {
                btRigidBody * bb = get_rigid_body( L , bodyB );
                
                if ( 0 == bb )
                {
                    return luaL_error( L , "Invalid second body" );
                }
                
                btVector3 pb( btVector3FromTable( L , pivotB ) );
                btVector3 ab( btVector3FromTable( L , axisB ) );
                
                c = new btHingeConstraint( * ba , * bb , pa , pb , aa , ab , use_reference_frame );
            }
            
            g_assert( c );
            
            self = lb_construct( btHingeConstraint , c );
            
            // TODO: need to support the disableCollisionsBetweenLinkedBodies 
            // flag. Perhaps by not adding the constraint when it is created,
            // but having an explicit add_constraint function on the world 
            // that includes that flag.
            
            w->get_world()->addConstraint( c );
        ]];

    ~PBHingeConstraint()
        [[
            // Not deleted because they are owned by the world
        ]];    
        
        
    bool angular_only
        [[
            angular_only = self->getAngularOnly();
        ]]
        [[
            self->setAngularOnly( angular_only );
        ]];        
        
    enable_angular_motor( bool enable , double target_velocity , double max_motor_impulse )
        [[
            self->enableAngularMotor( enable , target_velocity , max_motor_impulse );
        ]];        
        
    enable_motor( bool enable )
        [[
            self->enableMotor( enable );
        ]];
        
    set_motor_target( double angle , double dt )
        [[
            self->setMotorTarget( angle , dt );
        ]];        
        
    set_limit( double low , double high , double softness = 0.9 , double bias_factor = 0.3 , double relaxation_factor = 1.0 )
        [[
            self->setLimit( low , high , softness , bias_factor , relaxation_factor );
        ]];        
}

interface PBSliderConstraint [[ btSliderConstraint * ]]
{
    PBSliderConstraint( any world , PBBody3d bodyA , Matrix frameA , bool use_linear_reference_frame , PBBody3d bodyB = 0 , Matrix frameB = 0 )
        [[
            Bullet::World * w = static_cast<Bullet::World*>( lua_touserdata( L , world ) );

            btRigidBody * ba = get_rigid_body( L , bodyA );
                        
            if ( 0 == ba )
            {
                return luaL_error( L , "Invalid first body" ); 
            }
            
            btTransform ta;
            
            if ( ! btTransformFromMatrix( L , frameA , ta ) )
            {
                return luaL_error( L , "Invalid matrix for first frame" );
            }                         
            
            btSliderConstraint * c = 0;
            
            if ( 0 == bodyB )
            {
                c = new btSliderConstraint( * ba , ta , use_linear_reference_frame );    
            }
            else
            {
                btRigidBody * bb = get_rigid_body( L , bodyB );
                
                if ( 0 == bb )
                {
                    return luaL_error( L , "Invalid second body" );
                }
                
                btTransform tb;
                
                if ( ! btTransformFromMatrix( L , frameB , tb ) )
                {
                    return luaL_error( L , "Invalid matrix for second frame" );
                }             
                            
                c = new btSliderConstraint( * ba , * bb , ta , tb , use_linear_reference_frame );
            }
            
            g_assert( c );
            
            self = lb_construct( btSliderConstraint , c );
            
            // TODO: need to support the disableCollisionsBetweenLinkedBodies 
            // flag. Perhaps by not adding the constraint when it is created,
            // but having an explicit add_constraint function on the world 
            // that includes that flag.
            
            w->get_world()->addConstraint( c );
        ]];

    ~PBSliderConstraint()
        [[
            // Not deleted because they are owned by the world
        ]];
        
    double linear_lower_limit
        [[
            linear_lower_limit = self->getLowerLinLimit();    
        ]]
        [[
            self->setLowerLinLimit( linear_lower_limit );
        ]];        

    double linear_upper_limit
        [[
            linear_upper_limit = self->getUpperLinLimit();    
        ]]
        [[
            self->setUpperLinLimit( linear_upper_limit );
        ]];
                
    double angular_lower_limit
        [[
            angular_lower_limit = self->getLowerAngLimit();    
        ]]
        [[
            self->setLowerAngLimit( angular_lower_limit );
        ]];        

    double angular_upper_limit
        [[
            angular_upper_limit = self->getUpperAngLimit();    
        ]]
        [[
            self->setUpperAngLimit( angular_upper_limit );
        ]];


    get_frame_offsets( Matrix offsetA , Matrix offsetB )
        [[
            if ( ! btTransformToMatrix( L , self->getFrameOffsetA() , offsetA ) )
            {
                luaL_error( L , "Invalid matrix for first offset" );
            }

            if ( ! btTransformToMatrix( L , self->getFrameOffsetB() , offsetB ) )
            {
                luaL_error( L , "Invalid matrix for second offset" );
            }
        ]];        
}        

interface PBBody3d [[ btCollisionObject * ]]
{
    PBBody3d()
        [[
            self = lb_construct( btCollisionObject , lua_touserdata( L , -2 ) );
        ]];
        
    ~PBBody3d()
        [[
            Bullet::BodyData::destroy_object( self , true );
        ]];
        
    readonly int handle
        [[
            handle = Bullet::BodyData::get( self )->get_handle();
        ]];
        
    bool awake
        [[
            awake = self->isActive();
        ]]
        [[
            self->activate( true );
        ]];

    readonly bool in_world
        [[
            in_world = Bullet::BodyData::get( self )->is_in_world();
        ]];
        
    readonly table center_of_mass_position
        [[
            lua_createtable( L , 3 , 0 );
            
            if ( btRigidBody * body = btRigidBody::upcast( self ) )
            {
                TableFrombtVector3( L , -1 , body->getCenterOfMassPosition() ); 
            }             
        ]];
        
    readonly table orientation
        [[
            lua_createtable( L , 4 , 0 );
            
            if ( btRigidBody * body = btRigidBody::upcast( self ) )
            {
                TableFrombtQuaternion( L , -1 , body->getOrientation() ); 
            }             
        ]];

    table linear_velocity
        [[
            lua_createtable( L , 3 , 0 );
            
            if ( btRigidBody * body = btRigidBody::upcast( self ) )
            {
                TableFrombtVector3( L , -1 , body->getLinearVelocity() ); 
            }
        ]]
        [[
            if ( btRigidBody * body = btRigidBody::upcast( self ) )
            {
                body->setLinearVelocity( btVector3FromTable( L , 2 ) );
            }
        ]];

    table angular_velocity
        [[
            lua_createtable( L , 3 , 0 );
            
            if ( btRigidBody * body = btRigidBody::upcast( self ) )
            {
                TableFrombtVector3( L , -1 , body->getAngularVelocity() ); 
            }
        ]]
        [[
            if ( btRigidBody * body = btRigidBody::upcast( self ) )
            {
                body->setAngularVelocity( btVector3FromTable( L , 2 ) );
            }
        ]];
        
    double linear_damping
        [[
            if ( btRigidBody * body = btRigidBody::upcast( self ) )
            {
                linear_damping = body->getLinearDamping();
            }
            else
            {
                linear_damping = 0;
            }
        ]]
        [[
            if ( btRigidBody * body = btRigidBody::upcast( self ) )
            {
                body->setDamping( linear_damping , body->getAngularDamping() );
            }
        ]];

    double angular_damping
        [[
            if ( btRigidBody * body = btRigidBody::upcast( self ) )
            {
                angular_damping = body->getAngularDamping();
            }
            else
            {
                angular_damping = 0;
            }
        ]]
        [[
            if ( btRigidBody * body = btRigidBody::upcast( self ) )
            {
                body->setDamping( body->getLinearDamping() , angular_damping );
            }
        ]];
        
    table linear_factor
        [[
            lua_createtable( L , 3 , 0 );
            
            if ( btRigidBody * body = btRigidBody::upcast( self ) )
            {
                TableFrombtVector3( L , -1 , body->getLinearFactor() ); 
            }            
        ]]
        [[
            if ( btRigidBody * body = btRigidBody::upcast( self ) )
            {
                body->setLinearFactor( btVector3FromTable( L , 2 ) );
            }            
        ]];
        
    table angular_factor
        [[
            lua_createtable( L , 3 , 0 );
            
            if ( btRigidBody * body = btRigidBody::upcast( self ) )
            {
                TableFrombtVector3( L , -1 , body->getAngularFactor() ); 
            }            
        ]]
        [[
            if ( btRigidBody * body = btRigidBody::upcast( self ) )
            {
                body->setAngularFactor( btVector3FromTable( L , 2 ) );
            }            
        ]];
        
    table gravity
        [[
            lua_createtable( L , 3 , 0 );
            
            if ( btRigidBody * body = btRigidBody::upcast( self ) )
            {
                TableFrombtVector3( L , -1 , body->getGravity() ); 
            }            
        ]]
        [[
            if ( btRigidBody * body = btRigidBody::upcast( self ) )
            {
                body->setGravity( btVector3FromTable( L , 2 ) );
            }            
        ]];

    apply_force( table force , table point = 0 )
        [[
            if ( btRigidBody * body = btRigidBody::upcast( self ) )
            {
                btVector3 f( btVector3FromTable( L , force ) );

                if ( 0 == point )
                {
                    body->applyCentralForce( f );
                }
                else
                {
                    body->applyForce( f , btVector3FromTable( L , point ) ); 
                }
            }            
        ]];        

    apply_torque( table torque )
        [[
            if ( btRigidBody * body = btRigidBody::upcast( self ) )
            {
                body->applyTorque( btVector3FromTable( L , torque ) );
            }            
        ]];        

    apply_linear_impulse( table force , table point = 0 )
        [[
            if ( btRigidBody * body = btRigidBody::upcast( self ) )
            {
                btVector3 f( btVector3FromTable( L , force ) );

                if ( 0 == point )
                {
                    body->applyCentralImpulse( f );
                }
                else
                {
                    body->applyImpulse( f , btVector3FromTable( L , point ) ); 
                }
            }            
        ]];        
        
    apply_angular_impulse( table torque )
        [[
            if ( btRigidBody * body = btRigidBody::upcast( self ) )
            {
                body->applyTorqueImpulse( btVector3FromTable( L , torque ) );
            }
        ]];        
        
    clear_forces()
        [[
            if ( btRigidBody * body = btRigidBody::upcast( self ) )
            {
                body->clearForces();
            }
        ]];
        
    /*
        Copies its transform matrix into the one provided and returns it.
        
        This is for performance reasons - instead of creating a new one every
        time.
    */
        
    Matrix get_transform( Matrix matrix )
        [[
            btTransformToMatrix( L , self->getWorldTransform() , matrix );
            
            lua_pushvalue( L , matrix );
        ]];
        
    Matrix set_transform( Matrix matrix )
        [[
            btTransform t;
            
            if ( btTransformFromMatrix( L , matrix , t ) )
            {
                self->setWorldTransform( t );
            }
            
            lua_pushvalue( L , matrix );
        ]];
        
    Matrix get_center_of_mass_transform( Matrix matrix )
        [[
            if ( btRigidBody * body = btRigidBody::upcast( self ) )
            {
                btTransformToMatrix( L , body->getCenterOfMassTransform() , matrix );
            }
                        
            lua_pushvalue( L , matrix );
        ]];
       
        
    Matrix set_center_of_mass_transform( Matrix matrix )
        [[
            if ( btRigidBody * body = btRigidBody::upcast( self ) )
            {
                btTransform t;
                
                if ( btTransformFromMatrix( L , matrix , t ) )
                {
                    body->setCenterOfMassTransform( t );
                }
            }
                        
            lua_pushvalue( L , matrix );
        ]];                
}

global pb [[ Bullet::World * ]] 
{
    pb()
        [[
            self = lb_construct( Bullet::World , new Bullet::World( L , 64 ) );
        ]];
        
    ~pb()
        [[
            delete self;
        ]];
        
    table gravity
        [[
            TableFrombtVector3( L , 0 , self->get_world()->getGravity() ); 
        ]]
        [[
            self->get_world()->setGravity( btVector3FromTable( L , 2 ) ); 
        ]];        
        
    step( double time_step = 1.0f/60.0f , int max_sub_steps = 1 , double fixed_time_step = 1.0f/60.0f )
        [[
            self->step( time_step , max_sub_steps , fixed_time_step );
        ]];
        
    table get_contacts( double max_distance = 0 , PBBody3d body1 = 0 , PBBody3d body2 = 0 )
        [[
            btCollisionObject * co1 = LB_GET_PBBODY3D( L , body1 );
            btCollisionObject * co2 = LB_GET_PBBODY3D( L , body2 );
            
            self->get_contacts( max_distance , co1 , co2 );
        ]];          
        
    PBBody Body( UIElement element , table properties )
        [[
#if 0
            lb_check_udata_type( L , element , "actor" );

            int n = self->create_body( element , properties , PBBODY_METATABLE );

            if ( ! n )
            {
                lua_pushnil( L );
            }
            else
            {
                ClutterUtil::set_props_from_table( L , properties );
            }
#else
            lua_pushnil( L );
#endif
        ]];
        
    PBBody3d Body3d( table properties )
        [[
            if ( ! self->create_body_3d( properties ) )
            {
                lua_pushnil( L );
            }
        ]];
        
/*        
    PBBody3d Sensor3d( table properties )
        [[
            if ( ! self->create_sensor( properties ) )
            {
                lua_pushnil( L );
            }
        ]];
*/

    # Takes any number of bodies
    
    add( ... )
        [[
            for ( int i = 2; i <= lua_gettop( L ); ++i )
            {
                if ( btCollisionObject * co = LB_GET_PBBODY3D( L , i ) )
                {
                    Bullet::BodyData::add_object( co );
                }
            }
        ]];
        
    remove( ... )
        [[
            for ( int i = 2; i <= lua_gettop( L ); ++i )
            {
                if ( btCollisionObject * co = LB_GET_PBBODY3D( L , i ) )
                {
                    Bullet::BodyData::remove_object( co );
                }
            }
        ]]; 

    PBShape BoxShape( double half_width , double half_height , double half_depth )
        [[
            self->create_shape( new btBoxShape( btVector3( half_width , half_height , half_depth ) ) , new_PBShape );              
        ]];                 
        
    PBShape StaticPlaneShape( double normal_x , double normal_y , double normal_z , double plane_constant )
        [[
            self->create_shape( new btStaticPlaneShape( btVector3( normal_x , normal_y , normal_z ) , plane_constant ) , new_PBShape );
        ]];
        
    PBShape SphereShape( double radius )
        [[
            self->create_shape( new btSphereShape( radius ) , new_PBShape );
        ]];
        
    PBShape CapsuleShapeX( double radius , double height )
        [[
            self->create_shape( new btCapsuleShapeX( radius , height ) , new_PBShape );
        ]];
                
    PBShape CapsuleShapeY( double radius , double height )
        [[
            self->create_shape( new btCapsuleShape( radius , height ) , new_PBShape );
        ]];        
        
    PBShape CapsuleShapeZ( double radius , double height )
        [[
            self->create_shape( new btCapsuleShapeZ( radius , height ) , new_PBShape );
        ]];

    PBShape ConeShapeX( double radius , double height )
        [[
            self->create_shape( new btConeShapeX( radius , height ) , new_PBShape );
        ]];
                
    PBShape ConeShapeY( double radius , double height )
        [[
            self->create_shape( new btConeShape( radius , height ) , new_PBShape );
        ]];        
        
    PBShape ConeShapeZ( double radius , double height )
        [[
            self->create_shape( new btConeShapeZ( radius , height ) , new_PBShape );
        ]];

    PBShape CylinderShapeX( double half_width , double half_height , double half_depth )
        [[
            self->create_shape( new btCylinderShapeX( btVector3( half_width , half_height , half_depth ) ) , new_PBShape );
        ]];
                
    PBShape CylinderShapeY( double half_width , double half_height , double half_depth )
        [[
            self->create_shape( new btCylinderShape( btVector3( half_width , half_height , half_depth ) ) , new_PBShape );
        ]];

    PBShape CylinderShapeZ( double half_width , double half_height , double half_depth )
        [[
            self->create_shape( new btCylinderShapeZ( btVector3( half_width , half_height , half_depth ) ) , new_PBShape );
        ]];
        
    PBShape TriangleShape( table point0 , table point1 , table point2 )
        [[
            btVector3 p0( btVector3FromTable( L , point0 ) );
            btVector3 p1( btVector3FromTable( L , point1 ) );
            btVector3 p2( btVector3FromTable( L , point2 ) );
            
            self->create_shape( new btTriangleShape( p0 , p1 , p2 ) , new_PBShape );
        ]];
        
    # Expects a table of tables with 3 elements each, for x,y and z
    
    PBShape ConvexHullShape( table points )
        [[
            btConvexHullShape * shape = new btConvexHullShape();
            
            lua_pushnil( L );
            
            while( lua_next( L , points ) )
            {
                if ( lua_istable( L , -1 ) )
                {
                    shape->addPoint( btVector3FromTable( L , -1 ) );
                }
                
                lua_pop( L , 1 );
            }
            
            self->create_shape( shape , new_PBShape );
        ]];
    
    # Expects a table of tables with 4 elements each, for x,y,z and radius.
        
    PBShape MultiSphereShape( table positions_and_radi )
        [[
            btAlignedObjectArray<btVector3> positions;
            btAlignedObjectArray<btScalar>  radi;
            
            lua_pushnil( L );
            
            while( lua_next( L , positions_and_radi ) )
            {
                if ( lua_istable( L , -1 ) )
                {
                    positions.push_back( btVector3FromTable( L , -1 ) );
                    lua_rawgeti( L , -1 , 4 );
                    radi.push_back( lua_tonumber( L , -1 ) );
                    lua_pop( L , 1 );
                }
                lua_pop( L , 1 );
            }
            
            if ( 0 == positions.size() )
            {
                lua_pushnil( L );
            }
            else
            {
                self->create_shape( new btMultiSphereShape( & positions[0] , & radi[0] , positions.size() ) , new_PBShape );
            } 
        ]];

    # Expects a table of tables with 2 elements each, a matrix and a shape
    
    PBShape CompoundShape( table children = 0 )
        [[
            self->create_shape( new btCompoundShape() , new_PBCompoundShape );
            
            if ( children )
            {
                lua_pushcfunction( L , set_PBCompoundShape_children );
                lua_pushvalue( L , -2 );
                lua_pushvalue( L , children );
                lua_call( L , 2 , 0 );
            }
        ]];
        
    PBShape TriangleMeshShape( table vertices , table indices , table scaling = 0 )
        [[
            btTriangleMesh * tm = new btTriangleMesh();
            
            btVector3 v[3];
            
            lua_pushnil( L );
            
            int n = 0;
            int c = 0;
            
            while( lua_next( L , indices ) )
            {
                int i = lua_tonumber( L , -1 );
                
                lua_rawgeti( L , vertices , ( 3 * i ) + 1 );
                lua_rawgeti( L , vertices , ( 3 * i ) + 2 );
                lua_rawgeti( L , vertices , ( 3 * i ) + 3 );
                
                v[n].setX( lua_tonumber( L , -3 ) );
                v[n].setY( lua_tonumber( L , -2 ) );
                v[n].setZ( lua_tonumber( L , -1 ) );
                
 //               g_debug( "TRIANGLE %d.%d : %3.1f , %3.1f , %3.1f" , c , n , v[n].x() , v[n].y() , v[n].z() );
                 
                lua_pop( L , 4 );
                
                n += 1;
                
                if ( n == 3 )
                {
                    tm->addTriangle( v[0] , v[1] , v[2] );
                    
                    n = 0;
                    ++c;
                }
            }
            
            btBvhTriangleMeshShape * ts = new btBvhTriangleMeshShape( tm , true );
            
            btCollisionShape * shape = ts; 

            if ( scaling )
            {
//                g_debug( "SCALED!" ); 
                
                btVector3 vs = btVector3FromTable( L , scaling );
                
                shape = new btScaledBvhTriangleMeshShape( ts , vs );                
            }
            
            self->create_shape( shape , new_PBShape );
        ]];        
        
    PBPointToPointConstraint PointToPointConstraint( PBBody3d bodyA , table pivotA , PBBody3d bodyB = 0 , table pivotB = 0 )
        [[
            lua_pushcfunction( L , new_PBPointToPointConstraint );
            lua_pushlightuserdata( L , self );
            lua_pushvalue( L , bodyA );
            lua_pushvalue( L , pivotA );
            
            if ( 0 == bodyB || 0 == pivotB )
            {
                lua_pushnil( L );
                lua_pushnil( L );
            }
            else
            {
                lua_pushvalue( L , bodyB );
                lua_pushvalue( L , pivotB );
            }
            
            lua_call( L , 5 , 1 );
        ]];

    PBGeneric6DOFConstraint Generic6DOFConstraint( PBBody3d bodyA , Matrix frameA , bool use_linear_reference_frame , PBBody3d bodyB = 0 , Matrix frameB = 0 )
        [[
            lua_pushcfunction( L , new_PBGeneric6DOFConstraint );
            lua_pushlightuserdata( L , self );
            lua_pushvalue( L , bodyA );
            lua_pushvalue( L , frameA );
            lua_pushboolean( L , use_linear_reference_frame );
            
            if ( 0 == bodyB || 0 == frameB )
            {
                lua_pushnil( L );
                lua_pushnil( L );
            }
            else
            {
                lua_pushvalue( L , bodyB );
                lua_pushvalue( L , frameB );
            }
            
            lua_call( L , 6 , 1 );
        ]];
        
    PBHingeConstraint HingeConstraint( PBBody3d bodyA , table pivotA , table axisA , bool use_reference_frame , PBBody3d bodyB = 0 , table pivotB = 0 , table axisB = 0 )
        [[
            lua_pushcfunction( L , new_PBHingeConstraint );
            lua_pushlightuserdata( L , self );
            lua_pushvalue( L , bodyA );
            lua_pushvalue( L , pivotA );
            lua_pushvalue( L , axisA );
            lua_pushboolean( L , use_reference_frame );
            
            if ( 0 == bodyB || 0 == pivotB || 0 == axisB )
            {
                lua_pushnil( L );
                lua_pushnil( L );
                lua_pushnil( L );
            }
            else
            {
                lua_pushvalue( L , bodyB );
                lua_pushvalue( L , pivotB );
                lua_pushvalue( L , axisB );
            }
            
            lua_call( L , 8 , 1 );
        ]];

    PBSliderConstraint SliderConstraint( PBBody3d bodyA , Matrix frameA , bool use_linear_reference_frame , PBBody3d bodyB = 0 , Matrix frameB = 0 )
        [[
            lua_pushcfunction( L , new_PBSliderConstraint );
            lua_pushlightuserdata( L , self );
            lua_pushvalue( L , bodyA );
            lua_pushvalue( L , frameA );
            lua_pushboolean( L , use_linear_reference_frame );
            
            if ( 0 == bodyB || 0 == frameB )
            {
                lua_pushnil( L );
                lua_pushnil( L );
            }
            else
            {
                lua_pushvalue( L , bodyB );
                lua_pushvalue( L , frameB );
            }
            
            lua_call( L , 6 , 1 );
        ]];

    callback on_step( double seconds );
}
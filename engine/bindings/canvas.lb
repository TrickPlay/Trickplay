module canvas;

[[
#include <cstring>

#include "pango/pangocairo.h"

#include "common.h"
#include "clutter_util.h"
#include "bitmap.h"

#define degrees_to_radians( degrees ) ( degrees * ( G_PI / 180.0 ) )

#if G_BYTE_ORDER == G_LITTLE_ENDIAN
#define CLUTTER_CAIRO_TEXTURE_PIXEL_FORMAT COGL_PIXEL_FORMAT_BGRA_8888_PRE
#else
#define CLUTTER_CAIRO_TEXTURE_PIXEL_FORMAT COGL_PIXEL_FORMAT_ARGB_8888_PRE
#endif

]]

/*
    Class: Canvas
    
    The Canvas class provides an in-memory vector-based drawing surface. Various drawing tools and operations are supported.
    
    A Canvas object cannot be displayed directly on the screen, but it can be converted to an Image object which can then be displayed on-screen.
    
    The Canvas class uses the <Cairo Vector Graphics library at http://www.cairographics.org>, but you do not need to understand that library before using the Canvas class. All the information you need to create and manipulate a Canvas object is described in this documentation. If you desire additional information about Cairo, refer to the <Cairo documentation at http://www.cairographics.org/documentation>.
    
    

    Canvas lets you create a bitmap and use various drawing operations on it. It is
    based on the <Cairo graphics library at http://cairographics.org/manual/> and offers a similar API, with some slight
    modifications for ease of use.

    You typically use it by creating one, drawing into it and then creating an <Image> object from it.
    Then, you can use the image object like any other <UIElement>.

    Introduction:

    You start by creating a Canvas with a given size.

    (code)
    local canvas = Canvas( 200 , 200 )
    (end)

    Now, you create a path. You can use <move_to>, <line_to>, <rectangle>, <round_rectangle>,
    <curve_to>, <arc>, <arc_negative> or <text_path> for this. At this point, a path exists,
    but it is not visible.

    (code)
    canvas:rectangle( 20 , 20 , 160 , 160 )
    (end)

    You can use the path in several ways. You can call <clip> to use it as a clipping region
    for <paint>, you can <fill> it, or you can <stroke> it.

    If you choose to fill it or stroke it, you first have to choose a brush; which is called a source.
    You can use <set_source_color> to use a solid color, <set_source_linear_pattern> to use a linear color
    gradient as your brush or <set_source_radial_pattern> to use a radial gradient. You can also use
    <set_source_bitmap> to use another image as your brush. You can even use <push_group> and <pop_group>
    to draw yourself a brush.

    (code)
    canvas:set_source_color( "FF0000" )
    (end)

    Finally, you can fill it. This will fill the rectangle with red.

    (code)
    canvas:fill( true )
    (end)

    Fill and stroke let you keep (preserve) your path, so you can still use it. Since we passed
    true to <fill> above, the path is still there. Now, we change the source to solid green and
    stroke the same path.

    (code)
    canvas:set_source_color( "00FF00" )
    canvas:stroke()
    (end)

    In between these calls, you can use transformations like <translate>, <scale> and <rotate> to achieve
    different results. You can also change the operator using the <op> property.

    When you are happy with your Canvas, you can create an Image from it and add it to the screen.

    (code)
    screen:add( canvas:Image() )
    (end)
*/

class Canvas [[ cairo_t * ]]
{
    /*
        Constructor: Canvas
        
        The Canvas constructor creates an empty in-memory drawing surface. Each pixel on the surface contains a Red, a Green, and a Blue color component and an Alpha transparency value.

		*Prototype:*
		
		(code)
		Canvas( width, height )
		(end)
		
        *Arguments:*
        
        width - width of the Canvas surface in pixels
        height - height of the Canvas surface in pixels

        *Return Value:*
        
        canvas - a Canvas object whose surface is empty (i.e., all zeros)
        
    */

    Canvas( ... )
        [[
            int width = 0;
            int height = 0;

            if ( lua_gettop( L ) >= 1 && lua_type( L , 1 ) == LUA_TTABLE )
            {
                lua_getfield( L , 1 , "size" );

                if ( lua_type( L , -1 ) == LUA_TTABLE )
                {
                    lua_rawgeti( L , -1 , 1 );
                    width = lua_tonumber( L , -1 );
                    lua_pop( L , 1 );
                    lua_rawgeti( L , -1 , 2 );
                    height = lua_tonumber( L , -1 );
                    lua_pop( L , 1 );
                }
                else
                {
                    lua_rawgeti( L , 1 , 1 );
                    width = lua_tonumber( L , -1 );
                    lua_pop( L , 1 );
                    lua_rawgeti( L , 1 , 2 );
                    height = lua_tonumber( L , -1 );
                    lua_pop( L , 1 );
                }

                lua_pop( L , 1 );
            }
            else if ( lua_gettop( L ) >= 2 && lua_type( L , 1 ) == LUA_TNUMBER && lua_type( L , 2 ) == LUA_TNUMBER )
            {
                width = lua_tonumber( L , 1 );
                height = lua_tonumber( L , 2 );
            }

            if ( width == 0 || height == 0 )
            {
                luaL_error( L , "Invalid arguments to Canvas()" );
            }

            cairo_surface_t * surface = cairo_image_surface_create( CAIRO_FORMAT_ARGB32 , width , height );

            self = lb_construct( cairo_t , cairo_create( surface ) );

            cairo_surface_destroy( surface );
        ]];

    ~Canvas()
        [[
            cairo_destroy( self );
        ]];

    /*
        Property: ok

        Lets you know whether the Canvas is usable. This can change if you perform an invalid operation
        on the canvas, like calling <restore> without calling <save>.
    */

    readonly bool ok
        [[
            ok = cairo_status( self ) == CAIRO_STATUS_SUCCESS;
        ]];

    /*
        Property: width

        The width of the Canvas.
    */

    readonly int width
        [[
            width = cairo_image_surface_get_width( cairo_get_target( self ) );
        ]];

    /*
        Property: w

        The width of the Canvas.
    */

    readonly int w
        [[
            w = cairo_image_surface_get_width( cairo_get_target( self ) );
        ]];

    /*
        Property: height

        The height of the Canvas.
    */

    readonly int height
        [[
            height = cairo_image_surface_get_height( cairo_get_target( self ) );
        ]];

    /*
        Property: h

        The height of the Canvas.
    */

    readonly int h
        [[
            h = cairo_image_surface_get_height( cairo_get_target( self ) );
        ]];

    /*
        Property: size

        A table containing the width and height of the Canvas.
    */

    readonly table size
        [[
            lua_newtable( L );
            lua_pushinteger( L , cairo_image_surface_get_width( cairo_get_target( self ) ) );
            lua_rawseti( L , -2 , 1 );
            lua_pushinteger( L , cairo_image_surface_get_height( cairo_get_target( self ) ) );
            lua_rawseti( L , -2 , 2 );
        ]];

    /*
        Property: current_point

        A table containing the coordinates of the current point.
    */

    readonly table current_point
        [[
            double x;
            double y;

            cairo_get_current_point( self , & x , & y );

            lua_newtable( L );
            lua_pushnumber( L , x );
            lua_rawseti( L , -2 , 1 );
            lua_pushnumber( L , y );
            lua_rawseti( L , -2 , 2 );
        ]];

    /*
        Property: path_extents

        A table of coordinates for a bounding box around the current path.
    */

    readonly table path_extents
        [[
            double x1;
            double y1;
            double x2;
            double y2;

            cairo_path_extents( self , & x1 , & y1 , & x2 , & y2 );

            lua_newtable( L );
            lua_pushnumber( L , x1 );
            lua_rawseti( L , -2 , 1 );
            lua_pushnumber( L , y1 );
            lua_rawseti( L , -2 , 2 );
            lua_pushnumber( L , x2 );
            lua_rawseti( L , -2 , 3 );
            lua_pushnumber( L , y2 );
            lua_rawseti( L , -2 , 4 );
        ]];

    /*
        Property: antialias

        Lets you get or set the antialiasing mode used by the Canvas.

        Values:

            DEFAULT - The default mode.
            NONE - No antialiasing.
            GRAY - Single color.
            SUBPIXEL - Subpixel antialiasing.
    */

    string antialias
        [[
            switch( cairo_get_antialias( self ) )
            {
                case CAIRO_ANTIALIAS_DEFAULT: antialias = "DEFAULT"; break;
                case CAIRO_ANTIALIAS_NONE: antialias = "NONE"; break;
                case CAIRO_ANTIALIAS_GRAY: antialias = "GRAY"; break;
                case CAIRO_ANTIALIAS_SUBPIXEL: antialias = "SUBPIXEL"; break;
                default: antialias = "DEFAULT"; break;
            }
        ]]
        [[
            cairo_antialias_t a = cairo_get_antialias( self );

            if ( ! strcmp( antialias , "DEFAULT" ) )
            {
                a = CAIRO_ANTIALIAS_DEFAULT;
            }
            else if ( ! strcmp( antialias , "NONE" ) )
            {
                a = CAIRO_ANTIALIAS_NONE;
            }
            else if ( ! strcmp( antialias , "GRAY" ) )
            {
                a = CAIRO_ANTIALIAS_GRAY;
            }
            else if ( ! strcmp( antialias , "SUBPIXEL" ) )
            {
                a = CAIRO_ANTIALIAS_SUBPIXEL;
            }
            else
            {
                luaL_error( L , "Invalid canvas antialias '%s'" , antialias );
            }

            cairo_set_antialias( self , a );
        ]];

    /*
        Property: fill_rule
        
        The fill_rule property specifies the method used to determine which regions of a path are inside the path (and therefore filled) and which regions are outside (and not filled). The fill_rule becomes important when the path intersects itself and thereby creates closed regions within the shape. The fill_rule can determine whether or not these internal closed regions are filled. The code example below demonstrates an example.
        
        The fill_rule affects the fill() and clip() operations only.
        
        *Supported Settings:* The string settings are case-sensitive.
        
        "EVEN_ODD" - NEED MORE INFORMATION ON THIS
        "WINDING" - NEED MORE INFORMATION ON THIS
        
        *Default Setting:* WINDING
        
        *Code Example:* Create a path/shape using intersecting lines which create an internal region. Fill the shape using different fill_rule settings.
        
        (code)
        -- Create a Canvas object
        canvas = Canvas( 1920, 1080 )
        canvas:set_source_color( "ffffffff" )
        canvas.line_width = 10
        
        -- Draw a star with intersecting lines
        canvas:move_to( 100, 170 )
        canvas:line_to( 300, 170 )
        canvas:line_to( 100, 300 )
        canvas:line_to( 200, 100 )
        canvas:line_to( 300, 300 )
        canvas:close_path()
        
        -- Draw the lines, saving the path
        canvas:stroke( true )
        
        -- Set the fill rule
        canvas.fill_rule = "WINDING"
        
        -- Fill the shape, using a fill color
        canvas:set_source_color( "ff0000ff" )
        canvas:fill()
        
        -- Draw the same shape in another location
        canvas:move_to( 400, 170 )
        canvas:line_to( 600, 170 )
        canvas:line_to( 400, 300 )
        canvas:line_to( 500, 100 )
        canvas:line_to( 600, 300 )
        canvas:close_path()
        
        -- Draw the lines, saving the path
        canvas:set_source_color( "ffffffff" )
        canvas:stroke( true )
        
        -- Set the fill rule
        canvas.fill_rule = "EVEN_ODD"
        
        -- Fill the shape, using a fill color
        canvas:set_source_color( "ff0000ff" )
        canvas:fill()
        
        -- Convert Canvas to Image for display and show onscreen
        image = canvas:Image()
        screen:add( image)
        screen:show()
        (end)
        
        The resulting shapes from the example code are shown below.
        
        (see canvasFillRules.png)
        
		*See Also:* the <fill> and <clip> functions
    */

    string fill_rule
        [[
            switch( cairo_get_fill_rule( self ) )
            {
                case CAIRO_FILL_RULE_EVEN_ODD: fill_rule = "EVEN_ODD"; break;
                default: fill_rule = "WINDING"; break;
            }
        ]]
        [[
            if ( ! strcmp( fill_rule , "WINDING" ) )
            {
                cairo_set_fill_rule( self , CAIRO_FILL_RULE_WINDING );
            }
            else if ( ! strcmp( fill_rule , "EVEN_ODD" ) )
            {
                cairo_set_fill_rule( self , CAIRO_FILL_RULE_EVEN_ODD );
            }
            else
            {
                luaL_error( L , "Invalid fill_rule '%s'" , fill_rule );
            }
        ]];

    /*
        Property: filter

        Get or set the filter used for resizing the source pattern.

        Values:

            FAST - Fast.
            GOOD - Good.
            BEST - Best.
            NEAREST - Nearest.
            BILINEAR - Bilinear.
    */

    string filter
        [[
            switch( cairo_pattern_get_filter( cairo_get_source( self  ) ) )
            {
                case CAIRO_FILTER_FAST: filter = "FAST"; break;
                case CAIRO_FILTER_GOOD: filter = "GOOD"; break;
                case CAIRO_FILTER_BEST: filter = "BEST"; break;
                case CAIRO_FILTER_NEAREST: filter = "NEAREST"; break;
                case CAIRO_FILTER_BILINEAR: filter = "BILINEAR"; break;
                case CAIRO_FILTER_GAUSSIAN: filter = "GAUSSIAN"; break;
                default: filter = ""; break;
            }
        ]]
        [[
            if ( ! strcmp( filter , "FAST" ) )
            {
                cairo_pattern_set_filter( cairo_get_source( self ) , CAIRO_FILTER_FAST );
            }
            else if ( ! strcmp( filter , "GOOD" ) )
            {
                cairo_pattern_set_filter( cairo_get_source( self ) , CAIRO_FILTER_GOOD );
            }
            else if ( ! strcmp( filter , "BEST" ) )
            {
                cairo_pattern_set_filter( cairo_get_source( self ) , CAIRO_FILTER_BEST );
            }
            else if ( ! strcmp( filter , "NEAREST" ) )
            {
                cairo_pattern_set_filter( cairo_get_source( self ) , CAIRO_FILTER_NEAREST );
            }
            else if ( ! strcmp( filter , "BILINEAR" ) )
            {
                cairo_pattern_set_filter( cairo_get_source( self ) , CAIRO_FILTER_BILINEAR );
            }
            else if ( ! strcmp( filter , "GAUSSIAN" ) )
            {
                cairo_pattern_set_filter( cairo_get_source( self ) , CAIRO_FILTER_GAUSSIAN );
            }
            else
            {
                luaL_error( L , "Invalid filter '%s'" , filter );
            }
        ]];

    /*
        Property: extend

        Get or set how patterns extend beyond their natural area.

        Values:

            NONE - Pixels outside the pattern's area are fully transparent.
            REPEAT - The pattern is tiled by repeating.
            REFLECT - The pattern is tiled by reflecting.
            PAD - Pixels outside the pattern copy the nearest pixel.
    */

    string extend

        [[
            switch( cairo_pattern_get_extend( cairo_get_source( self  ) ) )
            {
              case CAIRO_EXTEND_REPEAT: extend = "REPEAT"; break;
              case CAIRO_EXTEND_REFLECT: extend = "REFLECT"; break;
              case CAIRO_EXTEND_PAD: extend = "PAD"; break;
              default: extend = "NONE"; break;
            }
        ]]
        [[
            if ( ! strcmp( extend , "NONE" ) )
            {
              cairo_pattern_set_extend( cairo_get_source( self ) , CAIRO_EXTEND_NONE );
            }
            else if ( ! strcmp( extend , "REPEAT" ) )
            {
              cairo_pattern_set_extend( cairo_get_source( self ) , CAIRO_EXTEND_REPEAT );
            }
            else if ( ! strcmp( extend , "REFLECT" ) )
            {
              cairo_pattern_set_extend( cairo_get_source( self ) , CAIRO_EXTEND_REFLECT );
            }
            else if ( ! strcmp( extend , "PAD" ) )
            {
              cairo_pattern_set_extend( cairo_get_source( self ) , CAIRO_EXTEND_PAD );
            }
            else
            {
              luaL_error( L , "Invalid extend '%s'" , extend );
            }
        ]];

    /*
        Property: line_cap
        
        The line_cap property is a string that specifies the type of path-ends to render when performing a stroke operation.
        
        The line_cap property is used only by the Canvas <stroke> function.
        
        *Supported Settings:* The line_cap setting is case-sensitive.
        
        "BUTT" - start and stop the line at the path's exact end points (default)
        "ROUND" - use a rounded end; the path's end points specify the center of the circle
        "SQUARE" - use a squared end; the path's end points specify the center of the square
        
        *Default Setting:* "BUTT"
        
        Notice that the "ROUND" and "SQUARE" settings add a rounded or squared end to each endpoint of the path. This will cause the generated line to extend slightly beyond the path's specified endpoints. The extra distance added to each endpoint is determined by the line's width specified in the Canvas object's line_width property. Specifically, each endpoint is extended line_width/2 pixels, i.e., line_width pixels for the entire line.
        
        *Code Example:* Demonstrate line_cap settings
        
        (code)
        -- Create a Canvas object
        canvas = Canvas( 1920, 1080 )
        canvas:set_source_color( "#ffffffff" )
        
        -- Set a large line_width
        canvas.line_width = 100
        
        -- Set a path
        canvas:move_to( 500, 100 )
        canvas:line_to( 1000, 100 )

        -- Explicitly set line_cap
        canvas.line_cap = "BUTT"
        
        -- Make a line
        canvas:stroke()
        
        -- Do the same for ROUND line_cap
        canvas:move_to( 500, 300 )
        canvas:line_to( 1000, 300 )
        canvas.line_cap = "ROUND"
        canvas:stroke()
        
        -- Once more for SQUARE
        canvas:move_to( 500, 500 )
        canvas:line_to( 1000, 500 )
        canvas.line_cap = "SQUARE"
        canvas:stroke()
        
        -- Convert Canvas to Image for display and show onscreen
        image = canvas:Image()
        screen:add( image)
        screen:show()
        (end)
        
        The lines generated by the code example are shown below.
        
        (see canvasLineCaps.png)
        
        *See Also:* the <stroke> function

    */

    string line_cap
        [[
            switch( cairo_get_line_cap( self ) )
            {
                case CAIRO_LINE_CAP_ROUND: line_cap = "ROUND"; break;
                case CAIRO_LINE_CAP_SQUARE: line_cap = "SQUARE"; break;
                default: line_cap = "BUTT"; break;
            }
        ]]
        [[
            if ( ! strcmp( line_cap , "BUTT" ) )
            {
                cairo_set_line_cap( self , CAIRO_LINE_CAP_BUTT );
            }
            else if ( ! strcmp( line_cap , "ROUND" ) )
            {
                cairo_set_line_cap( self , CAIRO_LINE_CAP_ROUND );
            }
            else if ( ! strcmp( line_cap , "SQUARE" ) )
            {
                cairo_set_line_cap( self , CAIRO_LINE_CAP_SQUARE );
            }
            else
            {
                luaL_error( L , "Invalid line_cap '%s'" , line_cap );
            }
        ]];

    /*
        Property: line_join

		The line_join property is a string specifying the manner in which lines are joined when performing a stroke operation.
		
		The line_join property is used only by the Canvas <stroke> function.
		
		*Supported Settings:* The line_join setting is case-sensitive.
		
		"BEVEL" - join lines using a beveled joint
		"MITER" - join lines using a mitered joint
		"ROUND" - join lines using a rounded joint
		
		*Default Setting:* "MITER"
		
		*Code Example:* Demonstrate line_join settings
		
		(code)
        -- Create a Canvas object
        canvas = Canvas( 1920, 1080 )
        canvas:set_source_color( "#ffffffff" )
        
        -- Set a large line_width
        canvas.line_width = 75
        
		-- Draw a rectangle using the BEVEL line_join
		canvas.line_join = "BEVEL"
		canvas:rectangle( 100, 100, 200, 200 )
		canvas:stroke()
		
        -- Draw a rectangle using the MITER line_join
        canvas.line_join = "MITER"
        canvas:rectangle( 400, 100, 200, 200 )
        canvas:stroke()

		-- Draw a rectangle using the ROUND line_join
		canvas.line_join = "ROUND"
		canvas:rectangle( 700, 100, 200, 200 )
		canvas:stroke()
		
		-- Show the rectangles
		image = canvas:Image()
		screen:add( image )
		screen:show()
		(end)

        The rectangles generated by the code example are shown below.
        
        (see canvasLineJoins.png)

		*See Also:* the <stroke> function
		
    */

    string line_join
        [[
            switch( cairo_get_line_join( self ) )
            {
                case CAIRO_LINE_JOIN_ROUND: line_join = "ROUND"; break;
                case CAIRO_LINE_JOIN_BEVEL: line_join = "BEVEL"; break;
                default: line_join = "MITER"; break;
            }
        ]]
        [[
            if ( ! strcmp( line_join , "MITER" ) )
            {
                cairo_set_line_join( self , CAIRO_LINE_JOIN_MITER );
            }
            else if ( ! strcmp( line_join , "ROUND" ) )
            {
                cairo_set_line_join( self , CAIRO_LINE_JOIN_ROUND );
            }
            else if ( ! strcmp( line_join , "BEVEL" ) )
            {
                cairo_set_line_join( self , CAIRO_LINE_JOIN_BEVEL );
            }
            else
            {
                luaL_error( L , "Invalid line_join '%s'" , line_join );
            }
        ]];

    /*
        Property: line_width
        
        The line_width property specifies the diameter in pixels of the circular pen to use during the stroke operation.
        
        *Default Setting:* 2.0
        
        *Code Example:* see <this example at http://cairographics.org/FAQ/#sharp_lines> for possible example code
        
        *See Also:* the <stroke> function

    */

    double line_width
        [[
            line_width = cairo_get_line_width( self );
        ]]
        [[
            cairo_set_line_width( self , line_width );
        ]];

    /*
        Property: miter_limit
        
        The miter_limit property is a double value that specifies the maximum miter limit possible when joining lines. The miter_limit property is used only when the Canvas object's <line_join> property is set to "MITER". When lines are miter-joined, if the length of the resulting miter would exceed the miter_limit setting, the lines are joined using a bevel instead of a miter.

		To determine if the miter_limit has been exceeded, the would-be miter length is divided by the line width. If the result is larger than the miter_limit setting then the lines are bevel-joined.
		
		The default setting of 10.0 results in lines with interior angles of less than 11 degrees being converted to bevel-joins. A miter_limit of 2.0 will bevel any interior angle less than 60 degrees. A miter_limit value of 1.414 bevels any angle less than 90 degrees.
		
		A miter_limit for a desired angle can be calculated with the following equation: miter_limit = 1 / sin( angle / 2 )
		
		*Default Setting:* 10.0 (lines with interior angles less than 11 degrees will be converted to bevels)
		
		*See Also:* the <line_join> property
    */

    double miter_limit
        [[
            miter_limit = cairo_get_miter_limit( self );
        ]]
        [[
            cairo_set_miter_limit( self , miter_limit );
        ]];

    /*
        Property: op

        The operator used to combine the source pattern with the destination.
        For details, see <this article at http://cairographics.org/operators/>.

        Values:

            CLEAR - Clear the destination.
            SOURCE - Source.
            OVER - Over.
            IN - In.
            OUT - Out.
            ATOP - Atop.
            DEST - Destination.
            DEST_OVER - Destination over.
            DEST_IN - Destination in.
            DEST_OUT - Destination out.
            DEST_ATOP - Destination atop.
            XOR - XOR.
            ADD - Add.
            SATURATE - Saturate.
    */

    string op
        [[
            switch ( cairo_get_operator( self ) )
            {
                case CAIRO_OPERATOR_CLEAR:      op = "CLEAR"; break;
                case CAIRO_OPERATOR_SOURCE:     op = "SOURCE"; break;
                case CAIRO_OPERATOR_OVER:       op = "OVER"; break;
                case CAIRO_OPERATOR_IN:         op = "IN"; break;
                case CAIRO_OPERATOR_OUT:        op = "OUT"; break;
                case CAIRO_OPERATOR_ATOP:       op = "ATOP"; break;
                case CAIRO_OPERATOR_DEST:       op = "DEST"; break;
                case CAIRO_OPERATOR_DEST_OVER:  op = "DEST_OVER"; break;
                case CAIRO_OPERATOR_DEST_IN:    op = "DEST_IN"; break;
                case CAIRO_OPERATOR_DEST_OUT:   op = "DEST_OUT"; break;
                case CAIRO_OPERATOR_DEST_ATOP:  op = "DEST_ATOP"; break;
                case CAIRO_OPERATOR_XOR:        op = "XOR"; break;
                case CAIRO_OPERATOR_ADD:        op = "ADD"; break;
                case CAIRO_OPERATOR_SATURATE:   op = "SATURATE"; break;
                default:                        op = "SOURCE";
            }
        ]]
        [[
            static std::map< String , cairo_operator_t > op_map;

            if ( op_map.empty() )
            {
                op_map[ "CLEAR" ] = CAIRO_OPERATOR_CLEAR;
                op_map[ "SOURCE" ] = CAIRO_OPERATOR_SOURCE;
                op_map[ "OVER" ] = CAIRO_OPERATOR_OVER;
                op_map[ "IN" ] = CAIRO_OPERATOR_IN;
                op_map[ "OUT" ] = CAIRO_OPERATOR_OUT;
                op_map[ "ATOP" ] = CAIRO_OPERATOR_ATOP;
                op_map[ "DEST" ] = CAIRO_OPERATOR_DEST;
                op_map[ "DEST_OVER" ] = CAIRO_OPERATOR_DEST_OVER;
                op_map[ "DEST_IN" ] = CAIRO_OPERATOR_DEST_IN;
                op_map[ "DEST_OUT" ] = CAIRO_OPERATOR_DEST_OUT;
                op_map[ "DEST_ATOP" ] = CAIRO_OPERATOR_DEST_ATOP;
                op_map[ "XOR" ] = CAIRO_OPERATOR_XOR;
                op_map[ "ADD" ] = CAIRO_OPERATOR_ADD;
                op_map[ "SATURATE" ] = CAIRO_OPERATOR_SATURATE;
            }

            std::map< String, cairo_operator_t >::const_iterator it = op_map.find( op );

            if ( it == op_map.end() )
            {
                luaL_error(L,"Invalid canvas op '%s'", op );
            }

            cairo_set_operator( self , it->second );
        ]];

    /*
        Property: tolerance

        Get or set the tolerance used when converting paths into trapezoids.
    */

    double tolerance
        [[
            tolerance = cairo_get_tolerance( self );
        ]]
        [[
            cairo_set_tolerance( self , tolerance );
        ]];

    /*
        Function: set_dash

		The set_dash() function defines the dash pattern used by the Canvas stroke function when generating lines.
		
		The dash pattern is used only by the Canvas <stroke> function.
		
		*Arguments:*
		
		offset - number of leading empty pixels before dash begins
		dashes - table of positive double values that define the dash pattern. Each value specifies the length in pixels for alternating ON and OFF portions of the line. If the dashes argument is nil then dashes are disabled. If the dashes table contains a single value then a symmetric pattern of equal ON and OFF lengths is generated, and the single value specifies the segment length. The table may contain the value 0, but all values in the table cannot be 0.
		
		*Default Setting:* Dashes are disabled.
		
		*Code Example:* Create some sample dashed lines
		
		(code)
        -- Create a Canvas object
        canvas = Canvas( 1920, 1080 )
        canvas:set_source_color( "#ffffffff" )
        canvas.line_width = 10
        
		-- Define some dash patterns
		dash_regular = { 16.0, 4.0 }
		dash_dash_dash_dot = { 16.0, 4.0, 16.0 }
		dash_small = { 4.0 }

		-- Set the dash pattern
		canvas:set_dash( 0, dash_regular )
		
        -- Set a path and make a line
        canvas:move_to( 500, 100 )
        canvas:line_to( 1000, 100 )
        canvas:stroke()

		-- Make another line using a different dash pattern
		canvas:set_dash( 0, dash_dash_dash_dot )
		canvas:move_to( 500, 200 )
		canvas:line_to( 1000, 200 )
		canvas:stroke()
		
		-- Make a final line with another dash pattern
		canvas:set_dash( 0, dash_small )
		canvas:move_to( 500, 300 )
		canvas:line_to( 1000, 300 )
		canvas:stroke()
		
        -- Convert Canvas to Image for display and show onscreen
        image = canvas:Image()
        screen:add( image)
        screen:show()
		(end)

        The dashed lines generated by the code example are shown below.
        
        (see canvasDashes.png)

		*See Also:* the <stroke> function

    */

    set_dash( double offset, table dashes )
        [[
            std::vector< double > d;

            lua_pushnil( L );

            while( lua_next( L , dashes ) )
            {
                if ( lua_isnumber( L , -1 ) )
                {
                    d.push_back( lua_tonumber( L , -1 ) );
                }

                lua_pop( L , 1 );
            }

            cairo_set_dash( self , & d[ 0 ] , d.size() , offset );
        ]];

    /*
        Function: save
        
        The save() function saves the current state of the Canvas object on an internal stack. Multiple Canvas states can be saved. The restore() function pops the last saved state from the internal stack.
        
        *Arguments:* None.
        
        *Return Value:* None.

		*Code Example:* Save Canvas state upon function entry and restore upon exit
		
		(code)
		-- It is common to save a Canvas state upon entry to a function and then restore it upon exit
		function transformCanvas( canvas )
			-- Save initial Canvas state
			canvas:save()
			
			-- ...Change Canvas state and perform some transformations...
			
			-- Restore original Canvas state
			canvas:restore()
		end
		(end)
		
		*See Also:* the <restore> function
    */

    save()
        [[
            cairo_save( self );
        ]];

    /*
        Function: restore
        
        The restore() function pops the last saved Canvas state from an internal stack.
        
        If you mistakenly perform a restore with an empty stack, the Canvas object becomes corrupted. You can check the Canvas object's <ok> property at any time to verify that the Canvas object is still valid.
        
        *Arguments:* None.
        
        *Return Value:* None.
        
        *See Also:* the <save> function and the <ok> property
    */

    restore()
        [[
            cairo_restore( self );
        ]];

    /*
        Function: translate

        Modifies the transformation matrix of the Canvas by translating the origin by tx and ty.

    */

    translate( double tx , double ty )
        [[
            cairo_translate( self , tx , ty );
        ]];

    /*
        Function: rotate

        Rotates the transformation matrix by the given angle (in degrees).
    */

    rotate( double angle )
        [[
            cairo_rotate( self , degrees_to_radians( angle ) );
        ]];

    /*
        Function: scale

        Scales the transformation matrix by the given ratios in x and y.
    */


    scale( double sx , double sy )
        [[
            cairo_scale( self , sx , sy );
        ]];

    /*
        Function: push_group

        Temporarily redirects drawing operations to a new pattern until you call pop_group.
    */

    push_group()
        [[
            cairo_push_group( self );
        ]];

    /*
        Function: pop_group

        Pops the current group and sets it as the source pattern.
    */

    pop_group()
        [[
            cairo_pop_group_to_source( self );
        ]];

    /*
        Function: clip

        Clips the Canvas to the current path.

        Arguments:

            preserve - If true, the path is preserved.
    */

    clip( bool preserve = false )
        [[
            if ( ! preserve )
            {
                cairo_clip( self );
            }
            else
            {
                cairo_clip_preserve( self );
            }
        ]];

    /*
        Function: reset_clip

        Removes clipping.
    */

    reset_clip()
        [[
            cairo_reset_clip( self );
        ]];

    /*
        Function: fill

        Fills the current path with the current source.
        
        *Arguments:*
        
        preserve - boolean flag indicating whether or not to preserve the path after the fill operation. Default value is false, i.e., the path is not preserved.
        
        *Return Value:* None.
        
        The source can be a solid color, a linear gradient, a radial pattern or a bitmap image. The source is set by one of the Canvas's set_source_* functions listed below.
        
        set_source_bitmap() - sets source to a bitmapped image
        set_source_color() - sets source to a solid color with optional alpha/transparency
        set_source_linear_pattern() - sets source to a linear gradient
        set_source_radial_pattern() - sets source to a radial pattern

		*See Also:* the <set_source_bitmap>, <set_source_color>, <set_source_linear_pattern> and <set_source_radial_pattern> functions
    */

    fill( bool preserve = false )
        [[
            if(preserve)
            {
                cairo_fill_preserve( self );
            }
            else
            {
                cairo_fill( self );
            }
        ]];

    /*
        Function: paint

        Paints the current source inside the clipping region.

        Arguments:

            alpha - An alpha value (0-255) to apply to the source while painting.
    */

    paint( int alpha = 255 )
        [[
            if ( alpha == 255 )
            {
                cairo_paint( self );
            }
            else
            {
                cairo_paint_with_alpha( self , alpha / 255.0 );
            }
        ]];

    /*
        Function: stroke
        
        The stroke function draws the current path using the settings of the line_width, line_join, line_cap and dash pattern.

        *Arguments:*

        preserve - boolean flag indicating whether or not the current path should be saved after it has been drawn. Default value is false, i.e., the path will not be saved.

        *See Also:* the <line_width>, <line_join> and <line_cap> properties and the <set_dash> function
    */

    stroke( bool preserve = false )
        [[
            if(preserve)
            {
                cairo_stroke_preserve( self );
            }
            else
            {
                cairo_stroke( self );
            }
        ]];


    /*
        Function: new_path

        Starts a new path.
    */

    new_path()
        [[
            cairo_new_path( self );
        ]];

    /*
        Function: new_sub_path

        Starts a new sub-path.
    */

    new_sub_path()
        [[
            cairo_new_sub_path( self );
        ]];

    /*
        Function: close_path

        Closes the current path.
    */

    close_path()
        [[
            cairo_close_path( self );
        ]];

    /*
        Function: arc

        Adds an arc to the current path.

        Arguments:

            xc - The x coordinate for the center of the arc.
            yc - The y coordinate for the center of the arc.
            radius - The radius of the arc.
            angle1 - The starting angle in degrees.
            angle2 - The ending andle in degrees.

        Example:

        This can be used to draw circles. The code below will create a Canvas that is
        100x100 and draw a red-filled circle in the middle of it.

        (code)

            local canvas = Canvas( 100 , 100 )
            canvas:arc( 50 , 50 , 50 , 0 , 360 )
            canvas:set_source_color( "FF0000" )
            canvas:fill()
            screen:add( canvas:Image() )

        (end)

    */

    arc( double xc , double yc , double radius , double angle1 , double angle2 )
        [[
            cairo_arc( self , xc , yc , radius , degrees_to_radians( angle1 ) , degrees_to_radians( angle2 ) );
        ]];

    /*
        Function: arc_negative

        Adds an arc to the path, just like <arc>, but the arc goes in decreasing angles from angle1 to angle2.

        Arguments:

            xc - The x coordinate for the center of the arc.
            yc - The y coordinate for the center of the arc.
            radius - The radius of the arc.
            angle1 - The starting angle in degrees.
            angle2 - The ending andle in degrees.

    */

    arc_negative( double xc , double yc , double radius , double angle1 , double angle2 )
        [[
            cairo_arc_negative( self , xc , yc , radius , degrees_to_radians( angle1 ) , degrees_to_radians( angle2 ) );
        ]];

    /*
        Function: curve_to

        Adds a cubic Bezier spline to the current path from the current point to x3,y3 using x1,y1 and x2,y2 as the control points.
        If relative is true, the coordinates are interpreted as relative to the current point.

        Arguments:

            x1,y1 - The coordinates of the first control point.
            x2,y2 - The coordinates of the second control point.
            x3,y3 - The coordinates of the end point.
            relative - If true, all coordinates are relative to the current point.
    */

    curve_to( double x1 , double y1 , double x2 , double y2 , double x3, double y3 , bool relative = false )
        [[
            if ( relative )
            {
                cairo_rel_curve_to( self , x1 , y1 , x2 , y2 , x3 , y3 );
            }
            else
            {
                cairo_curve_to( self , x1 , y1 , x2 , y2 , x3 , y3 );
            }
        ]];

    /*
        Function: line_to
        
        The line_to() function draws a straight line from the path's current point to the X and Y coordinates specified in the function's arguments. The function's X, Y coordinates also become the path's new current point. The path's starting point is typically set by the <move_to> function.

        *Arguments:*
        
        x - double value specifying the ending X coordinate
        y - double value specifying the ending Y coordinate
        relative - boolean value indicating whether or not the specified coordinates are relative to the path's starting point. Default value is false, i.e., the coordinates are absolute to the Canvas.
        
        *Return Value:* None.

		*Code Example:* Draw some lines
		
		(code)
        -- Create a Canvas object
        canvas = Canvas( 1920, 1080 )
        canvas:set_source_color( "#ffffffff" )
        canvas.line_width = 75
        canvas.line_cap = "SQUARE"
        
        -- Define a triangular path
        canvas:move_to( 500, 100 )
        canvas:line_to( 1000, 100 )
        canvas:line_to( 500, 750 )
        canvas:close_path()			-- Same as canvas:line_to( 500, 100 )
        
        -- Draw the lines on the path
        canvas:stroke()
                
        -- Convert Canvas to Image for display and show onscreen
        image = canvas:Image()
        screen:add( image)
        screen:show()
		(end)
		
		*See Also:* the <move_to> and <stroke> functions
    */

    line_to( double x, double y, bool relative = false )
        [[
            if ( relative )
            {
                cairo_rel_line_to( self , x , y );
            }
            else
            {
                cairo_line_to( self , x , y );
            }
        ]];

    /*
        Function: move_to

		The move_to() function sets the current X, Y coordinates. Use the move_to() function to define a path's starting point for lines generated by the <stroke> function.
		
		*Arguments:*
		
		x - double value specifying the X coordinate
		y - double value specifying the Y coordinate
		relative - boolean value indicating whether or not the specified coordinates are relative to the current starting point. Default value is false, i.e., the coordinates are absolute to the Canvas.
		
		*Return Value:* None.

		*See Also:* the <line_to>, <rectangle> and <stroke> functions
		
    */

    move_to( double x, double y, bool relative = false )
        [[
            if ( relative )
            {
                cairo_rel_move_to( self , x , y );
            }
            else
            {
                cairo_move_to( self , x , y );
            }
        ]];

    /*
        Function: rectangle
        
        The rectangle() function adds a rectangle to the current path. The rectangle's <line_width>, <line_cap>, <line_join> and dash properties are defined by their respective values at the time the path is drawn by the <stroke> function.

        *Arguments:*
        
        x - X coordinate of rectangle's top left corner
        y - Y coordinate of rectangle's top left corner
        width - rectangle's width in pixels
        height - rectangle's height in pixels
        
        *Return Value:* None.

		The rectangle() function is logically equivalent to the following code statements.
		
		(code)
		move_to( x, y )				-- Begin the path
		line_to( width, 0, true )	-- Define top line using relative values
		line_to( 0, height, true )	-- Define right edge
		line_to( -width, 0, true )	-- Define bottom line 
		close_path()				-- Define left edge
		(end)
		
		*See Also:* the <line_width>, <line_cap> and <line_join> properties and the <set_dash> function
    */

    rectangle( double x, double y, double width, double height )
        [[
            cairo_rectangle( self , x , y , width , height );
        ]];

    /*
        Function: round_rectangle
        
        The round_rectangle() function creates a rectangular path with rounded corners. The rectangle's <line_width>, <line_cap>, <line_join> and dash properties are defined by their respective values at the time the path is drawn by the <stroke> function.
        
        A rectangle with rounded corners can also be generated by setting the <line_join> property to "ROUND" and calling the <rectangle> function.

        *Arguments:*
        
        x - X coordinate of rectangle's top left corner
        y - Y coordinate of rectangle's top left corner
        width - rectangle's width in pixels
        height - rectangle's height in pixels
        
        *Return Value:* None.

		*Code Example:* Create two rectangles with rounded corners
		
		(code)
		-- Create a Canvas object
        canvas = Canvas( 1920, 1080 )
        canvas:set_source_color( "#ffffffff" )
        canvas.line_width = 75
        
        -- Draw a rounded rectangle
        canvas:round_rectangle( 100, 100, 200, 200, canvas.line_width/2 )
        
        -- Draw a rectangle with rounded line joins
        canvas.line_join = "ROUND"
        canvas:rectangle( 400, 100, 200, 200 )
        
        -- Draw the rectangles
        canvas:stroke()
		
		-- Show the rectangles
		image = canvas:Image()
		screen:add( image )
		screen:show()
		(end)
    */

    round_rectangle( double x, double y, double w, double h, double r )
        [[
            cairo_move_to(self,x+r,y);
            cairo_line_to(self,x+w-r,y);
            cairo_curve_to(self,x+w,y,x+w,y,x+w,y+r);
            cairo_line_to(self,x+w,y+h-r);
            cairo_curve_to(self,x+w,y+h,x+w,y+h,x+w-r,y+h);
            cairo_line_to(self,x+r,y+h);
            cairo_curve_to(self,x,y+h,x,y+h,x,y+h-r);
            cairo_line_to(self,x,y+r);
            cairo_curve_to(self,x,y,x,y,x+r,y);
        ]];

    /*
        Function: text_path

        Adds a text path to the current path.

        Arguments:

            font - A font describing the font family, style and point size.
            text - The text.
            markup - If true, the text can contain Pango markup.
    */

    text_path( string font , string text , bool markup = true )
        [[
            PangoLayout * layout = pango_cairo_create_layout( self );

            if ( markup )
            {
                pango_layout_set_markup( layout , text , -1 );
            }
            else
            {
                pango_layout_set_text( layout , text , -1 );
            }

            PangoFontDescription * fd = pango_font_description_from_string( font );

            pango_layout_set_font_description( layout , fd );

            pango_font_description_free( fd );

            pango_cairo_layout_path( self , layout );

            g_object_unref( G_OBJECT( layout ) );
        ]];

    /*
        Function: text_element_path

        This function lets you use a Text element as the source for a path.

        Arguments:

            text - A Text UI Element.
    */

    text_element_path( Text text )
        [[
            if ( ClutterActor * actor = ClutterUtil::user_data_to_actor( L , text ) )
            {
                if ( CLUTTER_IS_TEXT( actor ) )
                {
                    if ( PangoLayout * layout = clutter_text_get_layout( CLUTTER_TEXT( actor ) ) )
                    {
                        layout = pango_layout_copy( layout );

                        pango_cairo_update_layout( self , layout );

                        pango_cairo_layout_path( self , layout );

                        g_object_unref( G_OBJECT( layout ) );
                    }
                }
            }
        ]];

    /*
        Function: text_element_fill

        This function lets you use a Text element as the source for a path. The path is filled
        with the text element's color, unless you pass 'use_text_color' as false.

        Arguments:

            text - A Text UI Element.

            use_text_color - If true, the color specified in the Text element will be used as the
                             default color for the text. If false, the current source of the Canvas
                             will be used to fill the text path.
    */

    text_element_fill( Text text , bool use_text_color = true )
        [[
          if ( ClutterActor * actor = ClutterUtil::user_data_to_actor( L , text ) )
          {
              if ( CLUTTER_IS_TEXT( actor ) )
              {
                  if ( PangoLayout * layout = clutter_text_get_layout( CLUTTER_TEXT( actor ) ) )
                  {
                      layout = pango_layout_copy( layout );

                      pango_cairo_update_layout( self , layout );

                      if ( use_text_color )
                      {
                          cairo_save( self );

                          ClutterColor color;

                          clutter_text_get_color( CLUTTER_TEXT( actor ) , & color );

                          cairo_set_source_rgba( self , color.red / 255.0 , color.green / 255.0 , color.blue / 255.0 , color.alpha / 255.0 );
                      }

                      pango_cairo_show_layout( self , layout );

                      g_object_unref( G_OBJECT( layout ) );

                      if ( use_text_color )
                      {
                          cairo_restore( self );
                      }
                  }
              }
          }
        ]];

    /*
        Function: add_string_path

        This function lets you use an SVG-like syntax to add segments to the current path.

        M - Tells the path to move to the coordinates, expects 1 set of coordinates.
        L - Adds a line to the path. Expects 1 set of coordinates.
        C - Adds a curve to the path. Expects 3 sets of coordinates.
        z - Closes the path. Expects no coordinates.

        You can also use lower case for M, L and C; which implies the coordinates are
        relative.

    */

    add_string_path( string path_text )
        [[
            ClutterPath * clutter_path = clutter_path_new();

            clutter_path_add_string( clutter_path , path_text );

            clutter_path_to_cairo_path( clutter_path , self );

            g_object_unref( G_OBJECT( clutter_path ) );

        ]];

    /*
        Function: set_source_color

		The set_source_color() function sets the color and alpha/transparency for subsequent drawing operations. If the color is not explicitly set, the default starting color is black and transparent.
		
		*Prototype:*
		
		(code)
		set_source_color( color )
		(end)

        *Arguments:*

        color - color and alpha/transparency specified as three RGB (Red/Green/Blue) integer values and an optional alpha/transparency integer value. The format of the color argument is described in <RGB/Alpha Color Formats>.
        
        *Return Value:* None.
        
        *Code Example:* Demonstrate various methods of setting the color and alpha
        
        (code)
        -- Specify color and alpha in a table
        canvas.set_source_color( { 0, 255, 0, 255 } )
        
        -- Equivalent settings using a string
        canvas.set_source_color( "00ff00ff" )
        canvas.set_source_color( "#00ff00ff" )
        (end)
    */

    set_source_color( ... )
        [[
            ClutterColor c;
            ClutterUtil::to_clutter_color( L , 2 , & c );
            cairo_set_source_rgba( self , c.red / 255.0 , c.green / 255.0 , c.blue / 255.0 , c.alpha / 255.0 );
        ]];

    /*
        Function: set_source_linear_pattern

        The set_source_linear_pattern() function sets subsequent drawing operations to a linear gradient pattern along the line defined by (x1, y1) and (x2, y2).
        
        Before using the linear pattern, gradient points should be defined by calling the <add_source_pattern_color_stop> function.

        *Arguments:*

        x1, y1 - coordinates for start of gradient line
        x2, y2 - coordinates for end of gradient line
        
        *Return Value:* None
        
        *Code Example:* Create a gradient pattern and use it to fill a rectangle
        
        (code)
        -- Create a Canvas object
        canvas = Canvas( 1920, 1080 )
        canvas.line_width = 10
        canvas.line_cap = "SQUARE"
        
		-- Define the gradient pattern line
		canvas:set_source_linear_pattern( 100, 100, 700, 700 )
		
		-- Define 10 gradient color-stops from black to red
		
        
        -- Draw the lines on the path
        canvas:stroke()
                
        -- Convert Canvas to Image for display and show onscreen
        image = canvas:Image()
        screen:add( image)
        screen:show()       
        (end)
        
        
    */

    set_source_linear_pattern( double x1, double y1, double x2, double y2 )
        [[
            cairo_pattern_t * p = cairo_pattern_create_linear( x1 , y1 , x2 , y2 );
            cairo_set_source( self , p );
            cairo_pattern_destroy( p );
        ]];

    /*
        Function: set_source_radial_pattern

        Sets the source to a radial pattern between two circles.

        Arguments:

            cx0,cy0 - The coordinates for the center of the first circle.
            radius0 - The radius of the first circle.
            cx1,cy1 - The coordinates for the center of the second circle.
            radius1 - The radius of the second circle.
    */

    set_source_radial_pattern( double cx0 , double cy0 , double radius0 , double cx1 , double cy1 , double radius1 )
        [[
            cairo_pattern_t * p = cairo_pattern_create_radial( cx0 , cy0 , radius0 , cx1 , cy1 , radius1 );
            cairo_set_source( self , p );
            cairo_pattern_destroy( p );
        ]];

    /*
        Function: add_source_pattern_color_stop

        When the source is a linear or radial gradient, this function lets you add color stops to it. Each color
        stop has an offset that varies from 0 (the start) to 1 (the end) and the color for the gradient at that
        offset.

        Arguments:

            offset - A number between 0 and 1.
            color - A color, either as a hex RGBA string or a table with 3 or 4 components.
    */

    add_source_pattern_color_stop( double offset , ... )
        [[
            if ( cairo_pattern_t * p = cairo_get_source( self ) )
            {
                ClutterColor c;
                ClutterUtil::to_clutter_color( L , 3 , & c );
                cairo_pattern_add_color_stop_rgba( p , offset , c.red / 255.0 , c.green / 255.0 , c.blue / 255.0 , c.alpha / 255.0 );
            }
        ]];

    /*
        Function: set_source_bitmap

        Sets the source to a bitmap. This lets you use other images as brushes.

        Arguments:

            bitmap - A <Bitmap>.
            x,y - Coordinates for the top left corner of the bitmap.
    */

    set_source_bitmap( Bitmap bitmap , double x = 0 , double y = 0 )
        [[
            if ( Image * image = Bitmap::get_image( L , bitmap ) )
            {
                if ( cairo_surface_t * surface = image->cairo_surface() )
                {
                    cairo_set_source_surface( self , surface , x , y );

                    cairo_surface_destroy( surface );
                }
            }
        ]];

    /*
        Function: Image

        Creates a new <Image> using the current contents of the Canvas. After the
        image is created, the Canvas is no longer needed.

        Arguments:

            props - A table of properties to pass to the Image constructor.

        Returns:

            image - A newly created Image.
    */

    Image Image( table props = 0 )
        [[
            if ( cairo_status( self ) != CAIRO_STATUS_SUCCESS )
            {
                lua_pushnil( L );
            }
            else
            {
                lua_getglobal( L , "Image" );

                if ( props )
                {
                    lua_pushvalue( L , props );
                }

                lua_call( L , props ? 1 : 0 , 1 );

                ClutterTexture * t = CLUTTER_TEXTURE( UserData::get( L , lua_gettop( L ) )->get_master() );

                cairo_surface_t * surface = cairo_get_target( self );

                CoglHandle cogl_texture = cogl_texture_new_from_data (
                        cairo_image_surface_get_width( surface),
                        cairo_image_surface_get_height( surface ),
                        COGL_TEXTURE_NONE,
                        CLUTTER_CAIRO_TEXTURE_PIXEL_FORMAT,
                        COGL_PIXEL_FORMAT_ANY,
                        cairo_image_surface_get_stride( surface ),
                        cairo_image_surface_get_data( surface ) );

                clutter_texture_set_cogl_texture ( t , cogl_texture );
                cogl_handle_unref( cogl_texture );
            }
        ]];

    set_line_width( double line_width )
        [[
            // For compatibility with old canvas
            cairo_set_line_width( self , line_width );
        ]];

    begin_painting()
        [[
            // Does nothing - only for compatibility with the old canvas
        ]];

    finish_painting()
        [[
            // Does nothing - only for compatibility with the old canvas
        ]];
}        Sets the dash pattern used for lines. The table dashes contains a list of

module url_request;

[[
#include "app.h"
#include "network.h"
]]

# Interface: URLResponse
# URLResponse contains the results of a <URLRequest>.
# URLResponse objects cannot be created, instead they are either returned by
# <URLRequest.perform> or passed as the second parameter in <URLRequest.on_complete>.

interface URLResponse [[Network::Response*]]
{
    URLResponse()
        [[
            self=lb_construct(Network::Response,lua_touserdata(L,-2));
        ]];
        
    ~URLResponse()
        [[
            delete self;
        ]];
        
    # Property: code
    # This can either be an HTTP status code (such as 200) or an error code if
    # the request failed.
    
    readonly int code
        [[code=self->code;]];
    
    # Property: status
    # This can either be an HTTP status message (such as "OK") or an error message
    # if the request failed.
    
    readonly string status
        [[status=self->status.c_str();]];
    
    # Property: failed
    # This property is set to true if the request failed. Note that an HTTP 404
    # or other HTTP status code is not considered a failure - since the request
    # succeeded (it came back).
    
    readonly bool failed
        [[failed=self->failed;]];
        
    # Property: body
    # This is the body of the response; it is a string that may contain embedded
    # NULLs.
    #
    # Note that if you call <URLRequest.stream>, the response body will only
    # contain one chunk in calls to <URLRequest.on_response_chunk> and will be nil in the call
    # to <URLRequest.on_complete>.

    readonly lstring body
        [[
	    body = (const char*) self->body->data;
	    body_len = self->body->len;
        ]];
    
    # Property: length
    # The length of the body in bytes, so you don't have to measure the body.
    
    readonly int length
        [[length=self->body->len;]];
    
    # Property: headers
    # The response headers. This is a table of tables, each of which has two
    # elements: the header name and its value, for example:
    # > { { "Content-Length" , 12 } , { "Set-Cookie" , "blahblah" } }
    # If you plan on working with the headers, it is best to assign them to a local
    # variable first, like this:
    # > local headers = response.headers
    # > print( #headers ) 
    
    readonly table headers
        [[
            int i=1;
            lua_newtable(L);
            for(StringMultiMap::const_iterator it=self->headers.begin();
                it!=self->headers.end();++it)
            {
                lua_newtable(L);
                lua_pushstring(L,it->first.c_str());
                lua_rawseti(L,-2,1);
                lua_pushstring(L,it->second.c_str());
                lua_rawseti(L,-2,2);
                
                lua_rawseti(L,-2,i);
                ++i;
            }
        ]];
}

[[
void URLRequest_response_callback(const Network::Response & response , gpointer info );
bool URLRequest_incremental_response_callback( const Network::Response & response, gpointer body, guint len, bool finished, gpointer _handle );

]]

# Interface: URLRequestCancel
# When you call <URLRequest.send> or <URLRequest.stream>, they return a URLRequestCancel
# object that you can use later to cancel the request.

interface URLRequestCancel [[guint*]]
{
    URLRequestCancel()
        [[
            self=lb_construct(guint,new guint);
            *self=lua_tonumber(L,-2);
        ]];

    ~URLRequestCancel()
        [[
            delete self;
        ]];

    # Function: cancel
    # Cancels the request. When you cancel a request, <URLRequest.on_complete> will not be called.

    cancel()
        [[
            App::get( L )->get_network()->cancel_async_request( * self );
        ]];
}

# Class: URLRequest

class URLRequest [[Network::Request*]]
{
    # Constructor: URLRequest
    # Lets you create a new URLRequest object. You can do this in several ways.
    # The most common is to specify a URL as the single parameter, like this:
    # > request = URLRequest( "http://www.trickplay.com" )
    #
    # You can also omit the URL parameter and create an empty URLRequest object
    # and set its properties one by one, like this:
    #
    # > request = URLRequest()
    # > request.url = "http://www.trickplay.com"
    #
    # Finally, you can create a URLRequest by passing a table which contains values
    # for any of its properties, like this:
    # > request = URLRequest{ url="http://www.trickplay.com" , method="PUT" }
    
    URLRequest(string url=NULL)
        [[
            self=lb_construct( Network::Request , new Network::Request(App::get(L)->get_user_agent()) );
            
            if (lua_gettop(L)==2 && lua_istable(L,-2))
            {
                lua_pushvalue(L,-2);
                lb_set_props_from_table(L);
                lua_pop(L,1);
            }
		    else if (url)
		    {
			    self->url=url;		    
		    }
        ]];
    
    ~URLRequest()
        [[
            delete self;
        ]];
    
    # Property: url
    # Lets you get and set the URL associated with this request
    
    string url
        [[url=self->url.c_str();]]
        [[self->url=url;]];
    
    # Property: method
    # Lets you specify the HTTP method for this request (GET,PUT,etc.). The
    # default value is "GET"
    
    string method
        [[method=self->method.c_str();]]
        [[self->method=method;]];
        
    # Property: timeout
    # Lets you specify a timeout (in seconds) after which an unfinished request will
    # fail. The default value is 30 seconds.
    
    double timeout
        [[timeout=self->timeout_s;]]
        [[self->timeout_s=timeout;]];
    
    # Property: redirect
    # If set to true, the request will automatically follow redirects and return
    # the headers and content for the final location. Otherwise, redirects will
    # not be followed.
    
    bool redirect
        [[redirect=self->redirect;]]
        [[self->redirect=redirect;]];
    
    # Property: body
    # Lets you set the body of the request as a string.
    
    string body
        [[body=self->body.c_str();]]
        [[self->body=body;]];

    # Property: user_agent
    # Lets you set the user agent for the request.
    
    string user_agent
        [[user_agent=self->user_agent.c_str();]]
        [[self->user_agent=user_agent;]];
    
    # Property: certificate
    # If you are using HTTPS and your server requires client authentication, you
    # can set this property to the required client certificate in PEM format.
    
    string certificate
        [[certificate=self->client_certificate_pem.c_str();]]
        [[self->client_certificate_pem=certificate;]];

    # Property: private_key
    # If you are using HTTPS and your server requires client authentication, you
    # can set this property to the required private key in PEM format.
    
    string private_key
        [[private_key=self->client_private_key_pem.c_str();]]
        [[self->client_private_key_pem=private_key;]];
    
    # Property: headers
    # Lets you get and set the request's headers. Headers are set using a table
    # with the header name as the key. Like this:
    # > request.headers = { ["Content-Length"] = 12 , ["X-My-Header"] = "Hello!" }
    #
    # Note that you cannot modify this property in place; you can either get
    # a table with all headers or replace all headers with a table of your own.
    # You can use regular Lua table functions to create a complete list of headers
    # and then hand that to the request.
    
    table headers
        [[
            lua_newtable(L);
            for(StringMap::const_iterator it=self->headers.begin();
                it!=self->headers.end();++it)
            {
                lua_pushstring(L,it->first.c_str());
                lua_pushstring(L,it->second.c_str());
                lua_rawset(L,-3);
            }
        ]]
        [[
            self->headers.clear();
            lua_pushnil(L);
            while(lua_next(L,2))
            {
                self->headers[std::string(lua_tostring(L,-2))]=std::string(lua_tostring(L,-1));
                lua_pop(L,1);
            }
        ]];
    
    # Function: perform
    # If you wish to execute the request synchronously, blocking execution of all
    # other code, you can use this function. Once the request is finished (or fails),
    # it will return a <URLResponse> object that will let you get the results.
    # For example:
    # > response = URLRequest( "http://www.trickplay.com" ):perform()
    
    URLResponse perform()
        [[
	    	App * app=App::get(L);

            Network::Response response=app->get_network()->perform_request(
				*self,
				app->get_cookie_jar());

            lua_pushlightuserdata(L,new Network::Response(response));
            new_URLResponse(L);
            lua_remove(L,-2);
        ]];
    
    # Function: send
    # To execute the request asynchronously (in the background), you call send.
    # Once the request is finished or fails, you will receive the response in
    # a call to the <on_complete> event handler.
    # This function returns a <URLRequestCancel> object that you can keep and use
    # to cancel the request before it finishes.
    #
    # Returns:
    # cancel - A <URLRequestCancel> object.
    
    URLRequestCancel send()
        [[
	    	App * app=App::get(L);

            guint id = app->get_network()->perform_request_async(
				*self,
				app->get_cookie_jar(),
				URLRequest_response_callback,
				UserData::Handle::make(L,1,self),
				UserData::Handle::destroy);

            lua_pushnumber( L , id );
            new_URLRequestCancel( L );
            lua_remove( L , -2 );
        ]];
        
    # Function: stream
    # This starts executing the request asynchronously. Unlike <send>, when you
    # call stream, TrickPlay will not wait until the entire response is received.
    # Instead, it will call the <on_response_chunk> event every time a piece of the
    # response body is received. This lets you process the response in
    # chunks rather than as a whole. If the request fails, or it finishes, <on_complete>
    # will be called.
    #
    # Returns:
    # cancel - A <URLRequestCancel> object.

    URLRequestCancel stream()
        [[
          App * app=App::get(L);

          guint id = app->get_network()->perform_request_async_incremental(
              *self,
              app->get_cookie_jar(),
              URLRequest_incremental_response_callback,
              UserData::Handle::make(L,1,self),
              UserData::Handle::destroy,
              true );

          lua_pushnumber( L , id );
          new_URLRequestCancel( L );
          lua_remove( L , -2 );
        ]];

    # Event: on_complete
    # This property holds a function that is called when a request is finished
    # or fails. The function receives as its parameters, the request as well as
    # a <URLResponse> object.
    #
    # Arguments:
    # request - The <URLRequest>
    # response - A <URLResponse> object with the results
    #
    # Example:
    # > request.on_complete = function( request , response ) print( "done!" ) end
    #
    # You can also do it like this
    # > function request.on_complete( request , response )
    # >   if response.failed then
    # >     print( "FAILED" )
    # >   else
    # >     print( "DONE" , response.code , response.status )
    # >   end
    # > end
    
    callback on_complete( URLRequest request , URLResponse response );

    # Event: on_response_chunk
    #
    # If you called <stream>, this function will get called every time a chunk of
    # the response body is received. Note that during this call, response.body will
    # only contain the newly received chunk - not the entire body of the response.
    # If you want to keep the entire body, you are responsible for accumulating it.
    #
    # Arguments:
    # request - The <URLRequest>
    # response - A <URLResponse> object with the results
    
    callback on_response_chunk( URLRequest request , URLResponse response );
}

[[
void URLRequest_response_callback(const Network::Response&response,gpointer _handle)
{
	UserData::Handle * handle = UserData::Handle::get( _handle );
	
	lua_State * L = handle->get_lua_state();
	
	if ( L )
	{
    	lua_pushlightuserdata(L,new Network::Response(response));
    	new_URLResponse(L);
    	lua_remove(L,-2);
    
    	invoke_URLRequest_on_complete(L,(Network::Request*)handle->get_user(),1,0);
    }    
}

bool URLRequest_incremental_response_callback( const Network::Response & response, gpointer body, guint len, bool finished, gpointer _handle )
{
    UserData::Handle * handle = UserData::Handle::get( _handle );

    lua_State * L = handle->get_lua_state();

    if ( ! L )
    {
        return false;
    }

    if ( ! finished )
    {
        // We got a chunk of data

        lua_pushlightuserdata( L , new Network::Response( response ) );
        new_URLResponse( L );
        lua_remove( L , -2 );

        invoke_URLRequest_on_response_chunk( L , ( Network::Request * ) handle->get_user() , 1 , 0 );
    }
    else
    {
        lua_pushlightuserdata( L , new Network::Response( response ) );
        new_URLResponse( L );
        lua_remove( L , -2 );

        invoke_URLRequest_on_complete( L , ( Network::Request * ) handle->get_user() , 1 , 0 );
    }

    return true;
}

]]

module url_request;

[[
#include "context.h"
#include "network.h"
]]

# Interface: URLResponse
# URLResponse contains the results of a <URLRequest>.
# URLResponse objects cannot be created, instead they are either returned by
# <URLRequest.perform> or passed as the second parameter in <URLRequest.on_complete>.

interface URLResponse [[Network::Response*]]
{
    URLResponse()
        [[
            *self=(Network::Response*)lua_touserdata(L,-2);
        ]];
        
    ~URLResponse()
        [[
            delete self;
        ]];
        
    # Property: code
    # This can either be an HTTP status code (such as 200) or an error code if
    # the request failed.
    
    readonly int code
        [[code=self->code;]];
    
    # Property: status
    # This can either be an HTTP status message (such as "OK") or an error message
    # if the request failed.
    
    readonly string status
        [[status=self->status.c_str();]];
    
    # Property: failed
    # This property is set to true if the request failed. Note that an HTTP 404
    # or other HTTP status code is not considered a failure - since the request
    # succeeded (it came back).
    
    readonly bool failed
        [[failed=self->failed;]];
        
    # Property: body
    # This is the body of the response; it is a string that may contain embedded
    # NULLs.
    
    readonly lstring body
        [[
	    body = (const char*) self->body->data;
	    body_len = self->body->len;
        ]];
    
    # Property: length
    # The length of the body in bytes, so you don't have to measure the body.
    
    readonly int length
        [[length=self->body->len;]];
    
    # Property: headers
    # The response headers. This is a table of tables, each of which has two
    # elements: the header name and its value, for example:
    # > { { "Content-Length" , 12 } , { "Set-Cookie" , "blahblah" } }
    # If you plan on working with the headers, it is best to assign them to a local
    # variable first, like this:
    # > local headers = response.headers
    # > print( #headers ) 
    
    readonly table headers
        [[
            int i=1;
            lua_newtable(L);
            for(Network::StringMultiMap::const_iterator it=self->headers.begin();
                it!=self->headers.end();++it)
            {
                lua_newtable(L);
                lua_pushstring(L,it->first.c_str());
                lua_rawseti(L,-2,1);
                lua_pushstring(L,it->second.c_str());
                lua_rawseti(L,-2,2);
                
                lua_rawseti(L,-2,i);
                ++i;
            }
        ]];
}

[[
struct RequestInfo
{
    RequestInfo(Network::Request*r,lua_State*l) : self(r),L(l) {}
    Network::Request * self;
    lua_State * L;
};

void URLRequest_response_callback(const Network::Response&response,gpointer info);
]]

# Class: URLRequest

class URLRequest [[Network::Request*]]
{
    # Constructor: URLRequest
    # Lets you create a new URLRequest object. You can do this in several ways.
    # The most common is to specify a URL as the single parameter, like this:
    # > request = URLRequest( "http://www.trickplay.com" )
    #
    # You can also omit the URL parameter and create an empty URLRequest object
    # and set its properties one by one, like this:
    #
    # > request = URLRequest()
    # > request.url = "http://www.trickplay.com"
    #
    # Finally, you can create a URLRequest by passing a table which contains values
    # for any of its properties, like this:
    # > request = URLRequest{ url="http://www.trickplay.com" , method="PUT" }
    
    URLRequest(string url=NULL)
        [[
            *self=new Network::Request(TPContext::get_from_lua(L));
            
            if (lua_gettop(L)==2 && lua_istable(L,-2))
            {
                lua_pushvalue(L,-2);
                lb_set_props_from_table(L);
                lua_pop(L,1);
            }
	    else
	    {
		if (url)
		    (*self)->url=url;		    
	    }
        ]];
    
    ~URLRequest()
        [[
            delete self;
        ]];
    
    # Property: url
    # Lets you get and set the URL associated with this request
    
    string url
        [[url=self->url.c_str();]]
        [[self->url=url;]];
    
    # Property: method
    # Lets you specify the HTTP method for this request (GET,PUT,etc.). The
    # default value is "GET"
    
    string method
        [[method=self->method.c_str();]]
        [[self->method=method;]];
        
    # Property: timeout
    # Lets you specify a timeout (in seconds) after which an unfinished request will
    # fail. The default value is 30 seconds.
    
    double timeout
        [[timeout=self->timeout_s;]]
        [[self->timeout_s=timeout;]];
    
    # Property: redirect
    # If set to true, the request will automatically follow redirects and return
    # the headers and content for the final location. Otherwise, redirects will
    # not be followed.
    
    bool redirect
        [[redirect=self->redirect;]]
        [[self->redirect=redirect;]];
    
    # Property: body
    # Lets you set the body of the request as a string.
    
    string body
        [[body=self->body.c_str();]]
        [[self->body=body;]];

    # Property: user_agent
    # Lets you set the user agent for the request.
    
    string user_agent
        [[user_agent=self->user_agent.c_str();]]
        [[self->user_agent=user_agent;]];
    
    # Property: certificate
    # If you are using HTTPS and your server requires client authentication, you
    # can set this property to the required client certificate in PEM format.
    
    string certificate
        [[certificate=self->client_certificate_pem.c_str();]]
        [[self->client_certificate_pem=certificate;]];

    # Property: private_key
    # If you are using HTTPS and your server requires client authentication, you
    # can set this property to the required private key in PEM format.
    
    string private_key
        [[private_key=self->client_private_key_pem.c_str();]]
        [[self->client_private_key_pem=private_key;]];
    
    # Property: headers
    # Lets you get and set the request's headers. Headers are set using a table
    # with the header name as the key. Like this:
    # > request.headers = { ["Content-Length"] = 12 , ["X-My-Header"] = "Hello!" }
    #
    # Note that you cannot modify this property in place; you can either get
    # a table with all headers or replace all headers with a table of your own.
    # You can use regular Lua table functions to create a complete list of headers
    # and then hand that to the request.
    
    table headers
        [[
            lua_newtable(L);
            for(Network::StringMap::const_iterator it=self->headers.begin();
                it!=self->headers.end();++it)
            {
                lua_pushstring(L,it->first.c_str());
                lua_pushstring(L,it->second.c_str());
                lua_rawset(L,-3);
            }
        ]]
        [[
            self->headers.clear();
            lua_pushnil(L);
            while(lua_next(L,2))
            {
                self->headers[std::string(lua_tostring(L,-2))]=std::string(lua_tostring(L,-1));
                lua_pop(L,1);
            }
        ]];
    
    # Function: perform
    # If you wish to execute the request synchronously, blocking execution of all
    # other code, you can use this function. Once the request is finished (or fails),
    # it will return a <URLResponse> object that will let you get the results.
    # For example:
    # > response = URLRequest( "http://www.trickplay.com" ):perform()
    
    udata perform()
        [[
	    Network::Request request(*self);
	    
	    bool is_uri;
	    String path=TPContext::get_from_lua(L)->normalize_app_path(request.url.c_str(),&is_uri);
	    
	    if (!is_uri)
		request.url = "file://" + path;
	    
            Network::Response response=Network::perform_request(request);
            lua_pushlightuserdata(L,new Network::Response(response));
            new_URLResponse(L);
            lua_remove(L,-2);
        ]];
    
    # Function: send
    # To execute the request asynchronously (in the background), you call send.
    # Once the request is finished or fails, you will receive the response in
    # a call to the <on_complete> event handler.
    
    send()
        [[
	    Network::Request request(*self);
	    
	    bool is_uri;
	    String path=TPContext::get_from_lua(L)->normalize_app_path(request.url.c_str(),&is_uri);
	    
	    if (!is_uri)
		request.url = "file://" + path;

            Network::perform_request_async(request,URLRequest_response_callback,new RequestInfo(self,L));
        ]];
        
    # Event: on_complete
    # This property holds a function that is called when a request is finished
    # or fails. The function receives as its parameters, the request as well as
    # a <URLResponse> object.
    #
    # Arguments:
    # request - The <URLRequest>
    # response - A <URLResponse> object with the results
    #
    # Example:
    # > request.on_complete = function( request , response ) print( "done!" ) end
    #
    # You can also do it like this
    # > function request.on_complete( request , response )
    # >   if response.failed then
    # >     print( "FAILED" )
    # >   else
    # >     print( "DONE" , response.code , response.status )
    # >   end
    # > end
    
    
    callback on_complete;    
}

[[
void URLRequest_response_callback(const Network::Response&response,gpointer info)
{
    RequestInfo * ri=(RequestInfo*)info;
    lua_pushlightuserdata(ri->L,new Network::Response(response));
    new_URLResponse(ri->L);
    lua_remove(ri->L,-2);
    
    invoke_URLRequest_on_complete(ri->L,ri->self,1,0);
    
    delete ri;
}

]]
module url_request;

[[
#include "app.h"
#include "network.h"
]]

#
# The URLResponse interface is documented in the url_response.lb file
#
interface URLResponse [[Network::Response*]]
{
    URLResponse()
        [[
            self=lb_construct(Network::Response,lua_touserdata(L,-2));
        ]];

    ~URLResponse()
        [[
            delete self;
        ]];

    # This property is documented in the url_response.lb file
    readonly int code
        [[code=self->code;]];

    # This property is documented in the url_response.lb file
    readonly string status
        [[status=self->status.c_str();]];

    # This property is documented in the url_response.lb file
    readonly bool failed
        [[failed=self->failed;]];

	# This property is documented in the url_response.lb file
    readonly lstring body
        [[
	    body = (const char*) self->body->data;
	    body_len = self->body->len;
        ]];

    # This property is documented in the url_response.lb file
    readonly int length
        [[length=self->body->len;]];

    # This property is documented in the url_response.lb file
    readonly table headers
        [[
            int i=1;
            lua_newtable(L);
            for(StringMultiMap::const_iterator it=self->headers.begin();
                it!=self->headers.end();++it)
            {
                lua_newtable(L);
                lua_pushstring(L,it->first.c_str());
                lua_rawseti(L,-2,1);
                lua_pushstring(L,it->second.c_str());
                lua_rawseti(L,-2,2);

                lua_rawseti(L,-2,i);
                ++i;
            }
        ]];
}

[[
void URLRequest_response_callback(const Network::Response & response , gpointer info );
bool URLRequest_incremental_response_callback( const Network::Response & response, gpointer body, guint len, bool finished, gpointer _handle );

]]

#
# The URLRequestCancel interface is documented in the url_request_cancel.lb file
#
interface URLRequestCancel [[guint*]]
{
    URLRequestCancel()
        [[
            self=lb_construct(guint,new guint);
            *self=lua_tonumber(L,-2);
        ]];

    ~URLRequestCancel()
        [[
            delete self;
        ]];

	# This function is documented in the url_request_cancel.lb file
    cancel()
        [[
            App::get( L )->get_network()->cancel_async_request( * self );
        ]];
}

/*
   Class: URLRequest

   The URLRequest class enables a TrickPlay application to submit HTML requests using the standard methods of GET, PUT, etc..
 */

class URLRequest [[Network::Request*]]
{

	/*
		Constructor: URLRequest

		The URLRequest() constructor creates a new URLRequest object. The request is not sent upon construction; use the object's <perform>, <send> or <stream> functions to send the request.

		*Arguments:*

		The constructor can accept an optional argument that specifies the URL string address. If the URL string is not specified in the constructor, it can be set by assigning the string to the object's <url> property. Both techniques are shown below.

		(code)
		-- Create URLRequest object, specifying URL in constructor
		request1 = URLRequest( "http://www.trickplay.com" )

		-- Create URLRequest object, specifying URL in url property
		request2     = URLRequest()
		request2.url = "http://www.trickplay.com"
		(end)

		The constructor will also accept a Lua table of property/value settings. This method of initialization is shown below.

		(code)
		-- Create URLRequest object, specifying properties in table
		request3 = URLRequest( { url    = "http://www.trickplay.com",
		                         method = "GET",
		                       } )
		(end)

		*Return Value:* newly-created URLRequest object

		*See Also:* the <url> property and the <perform> and <send> functions
	*/

    URLRequest(string url=NULL)
        [[
            self=lb_construct( Network::Request , new Network::Request(App::get(L)->get_user_agent()) );

            if (lua_gettop(L)==2 && lua_istable(L,-2))
            {
                lua_pushvalue(L,-2);
                lb_set_props_from_table(L);
                lua_pop(L,1);
            }
		    else if (url)
		    {
			    self->url=url;
		    }
        ]];

    ~URLRequest()
        [[
            delete self;
        ]];

    /*
    	Property: url

    	The url property specifies the request's URL address.

    	*Default Setting:* None

    	*Code Example:* Set the object's URL address

    	(code)
    	request.url = "http://www.trickplay.com"
    	(end)

    	*See Also:* the <perform> and <send> functions
    */

    string url
        [[url=self->url.c_str();]]
        [[self->url=url;]];

    /*
    	Property: method

    	The method property specifies the object's HTTP submission method, such as "GET" or "PUT".

    	*Default Setting:* "GET"

    	*See Also:* the <perform> and <send> functions
    */

    string method
        [[method=self->method.c_str();]]
        [[self->method=method;]];


    /*
    	Property: timeout

    	The timeout property specifies the amount of time in seconds to wait for a response. If a response is not received within the specified time, the request will fail and generate an HTTP 408-Request timeout error.

    	*Default Setting:* 30 seconds

    	*See Also:* the <URLResponse.code> property
	*/

    double timeout
        [[timeout=self->timeout_s;]]
        [[self->timeout_s=timeout;]];

    /*
    	Property: redirect

    	The redirect property is a boolean flag indicating whether or not the request should automatically follow redirections (true=follow redirections).

    	*Default Setting:* true (follow redirections)

    	*See Also:* the <url> property
    */

    bool redirect
        [[redirect=self->redirect;]]
        [[self->redirect=redirect;]];

    /*
    	Property: headers

    	The headers property is a table containing the request's HTTP header fields. Each table entry is a header/value pair. For example, the header "Content-Length: 432" would be specified in the headers table as shown below.

    	(code)
    	request.headers = { ["Content-Length"] = 432 }
    	(end)

    	The headers table cannot be modified in place. Instead, the table must be constructed in its entirety prior to assigning it to the headers property.

    	*Default Setting:* None

    	*See Also:* the <body> property
    */

    table headers
        [[
            lua_newtable(L);
            for(StringMap::const_iterator it=self->headers.begin();
                it!=self->headers.end();++it)
            {
                lua_pushstring(L,it->first.c_str());
                lua_pushstring(L,it->second.c_str());
                lua_rawset(L,-3);
            }
        ]]
        [[
            self->headers.clear();
            lua_pushnil(L);
            while(lua_next(L,2))
            {
                self->headers[std::string(lua_tostring(L,-2))]=std::string(lua_tostring(L,-1));
                lua_pop(L,1);
            }
        ]];

    /*
    	Property: body

    	The body property contains the string to be sent as the request's body data.

    	*Default Setting:* None

    	*See Also:* the <headers> property
    */

    string body
        [[body=self->body.c_str();]]
        [[self->body=body;]];

	/*
		Property: user_agent

		The user_agent property is a string that specifies the request's user agent.

		*Default Setting:* a constructed string that spoofs "Mozilla/5.0" and includes the TrickPlay SDK version number and other data

		*See Also:* the <url> property
	*/

    string user_agent
        [[user_agent=self->user_agent.c_str();]]
        [[self->user_agent=user_agent;]];


    /*
    	Property: certificate

    	The certificate property is a string containing an X.509 certificate in PEM (Privacy Enhanced Mail) format. The certificate may be necessary for authentication when using a secure connection, such as HTTPS.

    	*Default Setting:* None

    	*See Also:* the <private_key> property
    */

    string certificate
        [[certificate=self->client_certificate_pem.c_str();]]
        [[self->client_certificate_pem=certificate;]];

	/*
		Property: private_key

		The private_key property is a string containing an X.509 private key in PEM (Privacy Enhanced Mail) format.	The private key may be necessary for authentication when using a secure connection, such as HTTPS.

		*Default Setting:* None

		*See Also:* the <certificate> property
	*/

    string private_key
        [[private_key=self->client_private_key_pem.c_str();]]
        [[self->client_private_key_pem=private_key;]];


	/*
		Function: perform

		The perform() function sends the HTTP request and blocks further program execution until a response is received. To process the HTTP request asynchronously, use the <send> function.

		*Arguments:* None

		*Return Value:* a <URLResponse> object

		*Code Example:* Define an HTTP request object and send it immediately, waiting for a response

		(code)
		response = URLRequest( { url = "http://www.trickplay.com",
		                         timeout = 5,
		                         headers = { ["Accept"] = "text/plain", ["Accept-Charset"] = "utf-8" },
		                       } ):perform()
		-- Check response
		if( response.failed )then
			print( "HTTP Request failed. Error code:", response.code )
		else
			print( "HTTP Request succeeded." )
		end
		(end)

		*See Also:* the <send> and <stream> functions
	*/

    URLResponse perform()
        [[
	    	App * app=App::get(L);

            Network::Response response=app->get_network()->perform_request(
				*self,
				app->get_cookie_jar());

            lua_pushlightuserdata(L,new Network::Response(response));
            new_URLResponse(L);
            lua_remove(L,-2);
        ]];

    /*
    	Function: send

    	The send() function sends the HTTP request and continues program execution without waiting for a response. When either a response is received or the request fails (for example, due to a timeout), the object is notified by invoking its <on_complete> event handler.

    	*Arguments:* None

    	*Return Value:* a <URLRequestCancel> object. This object can be used to cancel an in-progress request by calling the object's <URLRequestCancel.cancel> function.

    	*Code Example:* Create and send a URLRequest object, process it asynchronously, and handle its response

    	(code)
    	-- Define on_complete() event handler
    	function handleResponse( httpRequest, httpResponse )
    		print( "Response received, code =", httpResponse.code )
    	end

    	-- Create HTTP Request object and send it, processing it asynchronously
    	URLRequest( { url = "http://www.trickplay.com",
    			      on_complete = handleResponse,
    			    } ):send()
    	print( "Sent HTTP Request" )
    	(end)

    	*See Also:* the <perform> and <stream> functions and the <on_complete> event handler
    */

    URLRequestCancel send()
        [[
	    	App * app=App::get(L);

            guint id = app->get_network()->perform_request_async(
				*self,
				app->get_cookie_jar(),
				URLRequest_response_callback,
				UserData::Handle::make(L,1,self),
				UserData::Handle::destroy);

            lua_pushnumber( L , id );
            new_URLRequestCancel( L );
            lua_remove( L , -2 );
        ]];

	/*
		Function: stream

		The stream() function sends the HTTP request and continues program execution without waiting for a response. Whenever a partial response is received, the object is notified by invoking its <on_response_chunk> event handler. When either the response is complete or the request fails, the object's <on_complete> event handler is called. The TrickPlay SDK libraries do not accumulate the received partial responses; if response accumulation is desired, it is the responsibility of the application program to implement it.

		*Arguments:* None

    	*Return Value:* a <URLRequestCancel> object. This object can be used to cancel an in-progress request by calling the object's <URLRequestCancel.cancel> function.

    	*Code Example:* Create and send a URLRequest object, process it asynchronously in chucks, and handle its response(s)

    	(code)
    	-- Define on_complete() event handler
    	function handleResponse( httpRequest, httpResponse )
    		print( "Response received, code =", httpResponse.code )
    	end

    	-- Define on_response_chunk() event handler
    	function handlerResponseChunk( httpRequest, httpResponse )
    		print( "Response Chunk received, code =", httpResponse.code )
    	end

    	-- Create HTTP Request object and send it, processing it asynchronously in chunks
    	URLRequest( { url = "http://www.trickplay.com",
    			      on_complete       = handleResponse,
    			      on_response_chunk = handlerResponseChunk,
    			    } ):stream()
    	print( "Sent HTTP Request" )
    	(end)

    	*See Also:* the <perform> and <send> functions and the <on_complete> and <on_response_chunk> event handlers
	*/

    URLRequestCancel stream()
        [[
          App * app=App::get(L);

          guint id = app->get_network()->perform_request_async_incremental(
              *self,
              app->get_cookie_jar(),
              URLRequest_incremental_response_callback,
              UserData::Handle::make(L,1,self),
              UserData::Handle::destroy,
              true );

          lua_pushnumber( L , id );
          new_URLRequestCancel( L );
          lua_remove( L , -2 );
        ]];

	/*
		Event Handler: on_complete

		The on_complete() event handler is invoked after an HTTP request sent via the <send> or <stream> functions has finished or failed.

		*Prototype:*

			(code)
			on_complete( URLRequest request, URLResponse response )
			(end)

		*Arguments:*

			request - URLRequest object that initiated the HTTP request
			response - <URLResponse> object that contains the response information for the request

		*Return Value:* None

		*Code Example:* See the code examples for the <send> and <stream> functions for demonstrations of hooking the on_complete() event handler

		*See Also:* the <send> function
	*/

    function on_complete
        [[
            return UserData::get( L )->get_last_callback( (char*) "on_complete" , L );
        ]]
        [[
            UserData::get( L )->set_last_callback( (char*) "on_complete" , L );
        ]];

    int add_oncomplete_listener( function f )
        [[
            result = UserData::get( L )->add_callback( (char*) "on_complete" , L );
        ]];

    remove_oncomplete_listener( int ref )
        [[
            UserData::get( L )->remove_callback( (char*) "on_complete" , L );
        ]];

	/*
		Event Handler: on_response_chunk

		The on_response_chunk() event handler is invoked upon receipt of a portion of a response to an HTTP request sent via the <stream> function. Each invocation of on_response_chunk() contains a new portion; chunks do not accumulate with each invocation. When the final portion is received, the <on_complete> event handler is invoked.

		*Prototype:*

			(code)
			on_response_chunk( URLRequest request, URLResponse response )
			(end)

		*Arguments:*

			request - URLRequest object that initiated the HTTP request
			response - <URLResponse> object that contains the response chunk for the request

		*Return Value:* None

		*Code Example:* See the code example for the <stream> function for a demonstration of hooking the on_response_chunk() event handler

		*See Also:* the <stream> function and the <on_complete> event handler
	*/

    function on_response_chunk
        [[
            return UserData::get( L )->get_last_callback( (char*) "on_response_chunk" , L );
        ]]
        [[
            UserData::get( L )->set_last_callback( (char*) "on_response_chunk" , L );
        ]];

    int add_onresponsechunk_listener( function f )
        [[
            result = UserData::get( L )->add_callback( (char*) "on_response_chunk" , L );
        ]];

    remove_onresponsechunk_listener( int ref )
        [[
            UserData::get( L )->remove_callback( (char*) "on_response_chunk" , L );
        ]];
}

[[
void URLRequest_response_callback(const Network::Response&response,gpointer _handle)
{
	UserData::Handle * handle = UserData::Handle::get( _handle );

	lua_State * L = handle->get_lua_state();

	if ( L )
	{
    	lua_pushlightuserdata(L,new Network::Response(response));
    	new_URLResponse(L);
    	lua_remove(L,-2);

        lb_invoke_callbacks(L,(Network::Request*)handle->get_user(),"URLREQUEST_METATABLE","on_complete",1,0);
    }
}

bool URLRequest_incremental_response_callback( const Network::Response & response, gpointer body, guint len, bool finished, gpointer _handle )
{
    UserData::Handle * handle = UserData::Handle::get( _handle );

    lua_State * L = handle->get_lua_state();

    if ( ! L )
    {
        return false;
    }

    if ( ! finished )
    {
        // We got a chunk of data

        lua_pushlightuserdata( L , new Network::Response( response ) );
        new_URLResponse( L );
        lua_remove( L , -2 );

        lb_invoke_callbacks(L,(Network::Request*)handle->get_user(),"URLREQUEST_METATABLE","on_response_chunk",1,0);
    }
    else
    {
        lua_pushlightuserdata( L , new Network::Response( response ) );
        new_URLResponse( L );
        lua_remove( L , -2 );

        lb_invoke_callbacks(L,(Network::Request*)handle->get_user(),"URLREQUEST_METATABLE","on_complete",1,0);
    }

    return true;
}

]]

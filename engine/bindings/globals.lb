module globals;

[[
#include "common.h"
#include "util.h"
#include "app.h"
#include "context.h"
#include "actions.h"

struct DoLater
{
	static void add(lua_State * L,int function_ref,int args_table_ref)
	{
		DoLater * dl = g_new0( DoLater , 1 );
		
		dl->lsp = App::get(L)->ref_lua_state_proxy();
		dl->function_ref = function_ref;
		dl->args_table_ref = args_table_ref;
		
		g_idle_add_full( G_PRIORITY_DEFAULT_IDLE, (GSourceFunc) do_it, dl, (GDestroyNotify)  destroy ); 
	}  
	
	static gboolean do_it( DoLater * self )
	{
		lua_State * L = self->lsp->get_lua_state();
		
		if ( L )
		{
			// Get the function
			
			lua_rawgeti(L,LUA_REGISTRYINDEX,self->function_ref);
			
			// Count and push the arguments
			
			int nargs = 0;
			
			if ( self->args_table_ref != LUA_NOREF )
			{
				lua_rawgeti(L,LUA_REGISTRYINDEX,self->args_table_ref);
				
				if ( lua_type(L,-1) == LUA_TTABLE )
				{
					lua_pushnil(L);
					
					while( lua_next(L,-2) )
					{
						// Move the value below the table
						lua_insert(L,-3);
						++nargs;
					}
				}
				
				// Pop the table
				
				lua_pop(L,1);
			}
			
			// Now call it
			
			lua_call(L,nargs,0);
		}
		
		return FALSE;
	} 
	
	static void destroy( DoLater * self )
	{
		lua_State * L = self->lsp->get_lua_state();
		
		if ( L )
		{
			luaL_unref(L,LUA_REGISTRYINDEX,self->function_ref);
			luaL_unref(L,LUA_REGISTRYINDEX,self->args_table_ref);
		}
		
		self->lsp->unref();
		
		g_free( self );
	}

private:

	LuaStateProxy * lsp;
	int 			function_ref;
	int				args_table_ref;
};

#if 0
void pb( void * s , int l )
{
	String o;
	
	for( int i = 0; i < l; ++i )
	{
		gchar * t = g_strdup_printf( "%s%d" , i == 0 ? "" : "," , ((guint8*)s)[i] );
		o += t;
		g_free(t);
	}
	g_debug( "%s" , o.c_str() );
}
#endif
]]

globals
{
    print()
        [[
            std::string result;
            int n = lua_gettop(L);  /* number of arguments */
            int i;
            lua_getglobal(L, "tostring");
            for (i=1; i<=n; i++)
            {
              const char *s;
              lua_pushvalue(L, -1);  /* function to be called */
              lua_pushvalue(L, i);   /* value to print */
              lua_call(L, 1, 1);
              s = lua_tostring(L, -1);  /* get result */
              if (s == NULL)
                return luaL_error(L, LUA_QL("tostring") " must return a string to "
                                     LUA_QL("print"));
              if (i>1)
                result += ' ';
              result += s;
              lua_pop(L, 1);  /* pop result */
            }
            g_message("%s",result.c_str());                
        ]];
    
    multi dofile(string file_name)
        [[
            bool is_uri=false;
            char * path=App::get(L)->normalize_path(file_name,&is_uri);

            FreeLater free_later(path);
            
            if (!path || is_uri)
            {
                return luaL_error(L,"Invalid path '%s'",file_name);
            }
            
            if (!g_str_has_suffix(path,".lua"))
            {
            	path = g_strdup_printf( "%s.lua",path);
            	free_later( path );
            }
            
            int n = lua_gettop(L);
            if (luaL_loadfile(L,path) != 0)
                lua_error(L);
            lua_call(L,0,LUA_MULTRET);
            return lua_gettop(L) - n;            
        ]];
        
    multi loadfile(string file_name)
        [[
            bool is_uri=false;
            char * path=App::get(L)->normalize_path(file_name,&is_uri);
            
            FreeLater free_later(path);
                        
            if (!path || is_uri)
            {
                lua_pushnil(L);
                lua_pushfstring(L,"Invalid path '%s'",file_name);
                return 2;
            }
            
            if (!g_str_has_suffix(path,".lua"))
            {
            	path = g_strdup_printf( "%s.lua",path);
            	free_later( path );
            }

            if (luaL_loadfile(L,path)==0)
            {
                return 1;
            }
            else
            {
                lua_pushnil(L);
                lua_insert(L, -2);  
                return 2;  
            }            
        ]];
        
	lstring readfile(string file_name )
		[[
			result = NULL;
			result_len = 0;
			
            bool is_uri=false;
            
            char * path=App::get(L)->normalize_path(file_name,&is_uri);
            
            FreeLater free_later(path);
            
            if ( path && ! is_uri )
            {
            	gsize length = 0;
            	
            	gchar * contents = NULL;
            	
            	if ( g_file_get_contents( path, & contents, & length, NULL ) )
            	{
            		result = contents;
            		result_len = length;
            		
            		free_later( contents );
            	} 
            }                        
		]];       
        
    exit()
        [[
            App::get(L)->get_context()->close_app();        
        ]];
        
    multi launch_action( string app_id = NULL, string action = NULL, string uri = NULL, string type = NULL , table parameters = 0 )
    	[[
    		String serialized_parameters;
    		
    		if ( parameters )
    		{
            	lua_getglobal( L, "serialize" );
            	lua_pushvalue( L, parameters );
            	lua_call( L, 1, 1 );
            	if ( lua_isstring( L, -1 ) )
            	{
            		size_t len = 0;
            		const char * s = lua_tolstring( L, -1, &len );
            		
            		serialized_parameters = String( s, len );
            	}
            	lua_pop( L, 1 );
    		}
    		
    		
    		Actions actions( App::get( L )->get_context() );
    		String caller( App::get( L )->get_id() );
    		
    		SystemDatabase::AppActionMap matches;
    		
    		bool result = actions.launch_action( 
    			caller.c_str(), 
    			app_id, 
    			action, 
    			uri, 
    			type, 
    			serialized_parameters.empty() ? NULL : serialized_parameters.c_str(), 
    			matches );
    		
    		lua_pushboolean( L, result );
    		
			lua_newtable( L );
			
			int i = 1;
			
			for ( SystemDatabase::AppActionMap::const_iterator it = matches.begin(); it != matches.end(); ++it )
			{
				for ( App::Action::Map::const_iterator ait = it->second.begin(); ait != it->second.end(); ++ait, ++i )
				{
					lua_newtable( L );
					
					lua_pushstring( L, it->first.c_str() );
					lua_setfield( L, -2, "app" );
					
					lua_pushstring( L, ait->first.c_str() );
					lua_setfield( L, -2, "action" );
					
					lua_pushstring( L, ait->second.description.c_str() );
					lua_setfield( L, -2, "description" );
					
					lua_rawseti( L, -2, i );
				} 
			}
			
			
			return 2;
    		
    	]];
        
    multi choose()
        [[
            if (lua_gettop(L)<3)
            {
                lua_pushnil(L);
            }
            else
            {
                lua_pushvalue(L,lua_toboolean(L,1)?2:3);
            }
            return 1;
        ]];

    string serialize()
        [[
            String buffer;

            int n=1;
            
            bool pretty=false;
            int level=0;
            
            if (lua_gettop(L)>1)
            {
                pretty=lua_toboolean(L,2);
                level=lua_tointeger(L,2);                
            }
            
            switch(lua_type(L,n))
            {
                case LUA_TNUMBER:
                {
                    buffer=lua_tostring(L,n);
                    break;
                }
                
                case LUA_TSTRING:
                {
                    LSG;
                    lua_getglobal(L,"string");
                    lua_getfield(L,-1,"format");
                    lua_pushstring(L,"%q");
                    lua_pushvalue(L,n);
                    lua_call(L,2,1);
                    buffer=lua_tostring(L,-1);
                    lua_pop(L,2);
                    LSG_END(0);
                    break;
                }
                
                case LUA_TBOOLEAN:
                {
                    buffer=lua_toboolean(L,n)?"true":"false";
                    break;
                }
                
                case LUA_TTABLE:
                {
                    if (pretty)
                    {
                        buffer += "\n" + String(2*level,' ');
                    }
                    
                    buffer+="{";
                    
                    if (pretty)
                    {
                        buffer += "\n";
                    }
                    
                    // Lookup the serialize function only once
                    lua_getglobal(L,"serialize");
                    int ser=lua_gettop(L);
                    
                    // Prepare to iterate over the table
                    lua_pushnil(L);
                    
                    bool first=true;
                    
                    while (lua_next(L,n)!=0)
                    {
                        if (first)
                        {
                            first=false;
                        }
                        else
                        {
                            buffer+=",";
                            
                            if (pretty)
                            {
                                buffer += "\n";
                            }
                        }
                        
                        if (pretty)
                        {
                            buffer += String(2*(level+1),' ');                            
                        }
                        
                        // Serialize the key
                        buffer+="[";
                        lua_pushvalue(L,ser);
                        lua_pushvalue(L,-3);
                        lua_call(L,1,1);
                        buffer+=lua_isnil(L,-1)?"nil":lua_tostring(L,-1);
                        lua_pop(L,1);
                        buffer+="]=";

                        // Serialize the value
                        lua_pushvalue(L,ser);
                        lua_pushvalue(L,-2);
                        if (pretty)
                        {
                            lua_pushinteger(L,level+1);
                            lua_call(L,2,1);
                        }
                        else
                        {
                            lua_call(L,1,1);
                        }
                        buffer+=lua_isnil(L,-1)?"nil":lua_tostring(L,-1);
                        // Pop both the result of the call as well as the value
                        // from lua_next
                        lua_pop(L,2);
                    }
                    
                    if (pretty)
                    {
                        buffer += "\n" + String(2*level,' ');
                    }

                    buffer+="}";
                    
                    lua_pop(L,1);
                    
                    break;
                }
                
                default:
                    break;
            }
            
            result=buffer.empty()?NULL:buffer.c_str();
        ]];

    string md5( lstring s )
        [[
            result = g_compute_checksum_for_string( G_CHECKSUM_MD5, s, s_len );
            FreeLater free_later( ( char * )result );
        ]];
        
    string sha1( lstring s )
        [[
            result = g_compute_checksum_for_string( G_CHECKSUM_SHA1, s, s_len );
            FreeLater free_later( ( char * )result );
        ]];

    string sha256( lstring s )
        [[
            result = g_compute_checksum_for_string( G_CHECKSUM_SHA256, s, s_len );
            FreeLater free_later( ( char * )result );
        ]];
        
    string hmac_sha1( lstring key , lstring message )
    	[[
    		static guint BLOCK_SIZE = 64;
    		static guint HASH_SIZE  = 20;
    		
    		guint8 key_buffer[ BLOCK_SIZE ];
    		
    		memset( key_buffer , 0 , BLOCK_SIZE );
    		 
    		if ( key_len > BLOCK_SIZE )
    		{
    			GChecksum * cs = g_checksum_new( G_CHECKSUM_SHA1 );
    			g_checksum_update( cs , (const guchar *) key , key_len );
    			gsize size = BLOCK_SIZE;
    			g_checksum_get_digest( cs , key_buffer , &size );
    			g_assert( size == HASH_SIZE );
    			g_checksum_free( cs ); 	
    		}
    		else
    		{
    			g_memmove( key_buffer , key , key_len );	
    		}
    		
    		guint8 o_pad[ BLOCK_SIZE ];
    		guint8 i_pad[ BLOCK_SIZE ];
    		
    		for( guint i = 0; i < BLOCK_SIZE; ++i )
    		{
    			o_pad[ i ] = key_buffer[ i ] ^ 0x5c;
    			i_pad[ i ] = key_buffer[ i ] ^ 0x36;
    		}
    		
    		guint8 message_hash[ HASH_SIZE ];
    		
    		{
				GChecksum * cs = g_checksum_new( G_CHECKSUM_SHA1 );
				g_checksum_update( cs , ( const guchar * ) i_pad , BLOCK_SIZE );
				g_checksum_update( cs , ( const guchar * ) message , message_len );
				gsize size = BLOCK_SIZE;
				g_checksum_get_digest( cs , message_hash , & size );
				g_assert( size == HASH_SIZE );
				g_checksum_free( cs );
			} 	
    		
			gchar * r = 0;
    		
    		{
				GChecksum * cs = g_checksum_new( G_CHECKSUM_SHA1 );
				g_checksum_update( cs , ( const guchar * ) o_pad , BLOCK_SIZE );
				g_checksum_update( cs , ( const guchar * ) message_hash , HASH_SIZE );
				r = g_strdup( g_checksum_get_string( cs ) );
				g_checksum_free( cs );
    		}
    		
    		FreeLater free_later( r );
    		
    		result = r;
    	]];
        
    string hmac_sha256( lstring key , lstring message )
    	[[
    		static guint BLOCK_SIZE = 64;
    		static guint HASH_SIZE  = 32;
    		
    		guint8 key_buffer[ BLOCK_SIZE ];
    		
    		memset( key_buffer , 0 , BLOCK_SIZE );
    		 
    		if ( key_len > BLOCK_SIZE )
    		{
    			GChecksum * cs = g_checksum_new( G_CHECKSUM_SHA256 );
    			g_checksum_update( cs , (const guchar *) key , key_len );
    			gsize size = BLOCK_SIZE;
    			g_checksum_get_digest( cs , key_buffer , &size );
    			g_assert( size == HASH_SIZE );
    			g_checksum_free( cs ); 	
    		}
    		else
    		{
    			g_memmove( key_buffer , key , key_len );	
    		}
    		
    		guint8 o_pad[ BLOCK_SIZE ];
    		guint8 i_pad[ BLOCK_SIZE ];
    		
    		for( guint i = 0; i < BLOCK_SIZE; ++i )
    		{
    			o_pad[ i ] = key_buffer[ i ] ^ 0x5c;
    			i_pad[ i ] = key_buffer[ i ] ^ 0x36;
    		}
    		
    		guint8 message_hash[ HASH_SIZE ];
    		
    		{
				GChecksum * cs = g_checksum_new( G_CHECKSUM_SHA256 );
				g_checksum_update( cs , ( const guchar * ) i_pad , BLOCK_SIZE );
				g_checksum_update( cs , ( const guchar * ) message , message_len );
				gsize size = BLOCK_SIZE;
				g_checksum_get_digest( cs , message_hash , & size );
				g_assert( size == HASH_SIZE );
				g_checksum_free( cs );
			} 	
    		
			gchar * r = 0;
    		
    		{
				GChecksum * cs = g_checksum_new( G_CHECKSUM_SHA256 );
				g_checksum_update( cs , ( const guchar * ) o_pad , BLOCK_SIZE );
				g_checksum_update( cs , ( const guchar * ) message_hash , HASH_SIZE );
				r = g_strdup( g_checksum_get_string( cs ) );
				g_checksum_free( cs );
    		}
    		
    		FreeLater free_later( r );
    		
    		result = r;
    	]];
        
	lstring uint32_to_be( int n )
		[[
			guint32 i = GUINT32_TO_BE( n );
			
			result = ( char * ) & i;
			result_len = 4;
		]];
		
	lstring uint32_to_le( int n )
		[[
			guint32 i = GUINT32_TO_LE( n );
			
			result = ( char * ) & i;
			result_len = 4;
		]];       
		
	int uint32_from_be( lstring s )
		[[
			if ( s_len >= 4 )
			{
				// TODO: Could have alignment problems
				
				result = GUINT32_FROM_BE( * ( ( guint32 * ) s ) );
			}
			else
			{
				result = 0;
			} 
		]];		

	int uint32_from_le( lstring s )
		[[
			if ( s_len >= 4 )
			{
				// TODO: Could have alignment problems
				
				result = GUINT32_FROM_LE( * ( ( guint32 * ) s ) );
			}
			else
			{
				result = 0;
			} 
		]];		

	debug()
		[[
		    if ( Debugger * debugger = App::get( L )->get_debugger() )
		    {
		        debugger->break_next_line();
		    }		
		]];
		
	detach( udata o )
		[[
			UserData::clear_callbacks( L , o );
		]];		       
		
	dolater( function f , ... )
		[[
			int nargs = lua_gettop(L)-f;
			int args = LUA_NOREF;
			
			// If there are args, we put them into a table and
			// get a ref to the table
			
			if ( nargs > 0 )
			{
				lua_newtable(L);
				for (int i=1; i<=nargs; ++i)
				{
					lua_pushvalue(L,i+f);
					lua_rawseti(L,-2,i);
				}
				args = luaL_ref(L,LUA_REGISTRYINDEX);
			}
			
			lua_pushvalue(L,f);
			int func = luaL_ref(L,LUA_REGISTRYINDEX);
			
			DoLater::add(L,func,args);
		]];
		
	table registry()
		[[
#ifdef TP_PRODUCTION		
			lua_pushnil( L );
#else
			lua_pushvalue( L , LUA_REGISTRYINDEX );
#endif			
		]];
		
	string uuid()
		[[
			String uuid( Util::make_v4_uuid() );
			
			result = uuid.c_str();
		]];
		

	dumptable( table t , function filter = 0 )
		[[
			lb_dump_table(L);
		]];						
}

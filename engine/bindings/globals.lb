module globals;

[[
#include "common.h"
#include "util.h"
#include "app.h"
#include "context.h"
#include "actions.h"

struct DoLater
{
    static void * nil()
    {
        static char nil=0;

        return & nil;
    }

	static void add(lua_State * L,int function_ref,int args_table_ref)
	{
		DoLater * dl = g_new0( DoLater , 1 );
		
		dl->lsp = App::get(L)->ref_lua_state_proxy();
		dl->function_ref = function_ref;
		dl->args_table_ref = args_table_ref;
		
		g_idle_add_full( G_PRIORITY_DEFAULT_IDLE, (GSourceFunc) do_it, dl, (GDestroyNotify)  destroy ); 
	}  
	
	static gboolean do_it( DoLater * self )
	{
		lua_State * L = self->lsp->get_lua_state();
		
		if ( L )
		{
			// Get the function
			
			lua_rawgeti(L,LUA_REGISTRYINDEX,self->function_ref);
			
			// Count and push the arguments
			
			int nargs = 0;
			
			if ( self->args_table_ref != LUA_NOREF )
			{
				lua_rawgeti(L,LUA_REGISTRYINDEX,self->args_table_ref);
				
				if ( lua_type(L,-1) == LUA_TTABLE )
				{
					lua_pushnil(L);
					
					while( lua_next(L,-2) )
					{
					    if ( lua_islightuserdata( L , -1 ) && lua_touserdata( L , -1 ) == nil() )
					    {
					        lua_pop( L , 1 );
					        lua_pushnil( L );
					    }
						// Move the value below the table
						lua_insert(L,-3);
						++nargs;
					}
				}
				
				// Pop the table
				
				lua_pop(L,1);
			}
			
			// Now call it
			
			lua_call(L,nargs,0);
		}
		
		return FALSE;
	} 
	
	static void destroy( DoLater * self )
	{
		lua_State * L = self->lsp->get_lua_state();
		
		if ( L )
		{
			luaL_unref(L,LUA_REGISTRYINDEX,self->function_ref);
			luaL_unref(L,LUA_REGISTRYINDEX,self->args_table_ref);
		}
		
		self->lsp->unref();
		
		g_free( self );
	}

private:

	LuaStateProxy * lsp;
	int 			function_ref;
	int				args_table_ref;
};

static int marker_gc( lua_State * L )
{
    g_info( "MARKER COLLECTED '%s'" , lua_tostring( L , lua_upvalueindex( 1 ) ) );
    return 0;
}

#if 0
void pb( void * s , int l )
{
	String o;
	
	for( int i = 0; i < l; ++i )
	{
		gchar * t = g_strdup_printf( "%s%d" , i == 0 ? "" : "," , ((guint8*)s)[i] );
		o += t;
		g_free(t);
	}
	g_debug( "%s" , o.c_str() );
}
#endif


String hash( GChecksumType type , const void * data , gsize length , bool binary )
{
	String result;
	
	GChecksum * cs = g_checksum_new( type );
	g_checksum_update( cs , ( const guchar * ) data , length );

	if ( binary ) 
	{
		gsize digest_length=g_checksum_type_get_length( type );
		guint8 digest[ digest_length  ];
		g_checksum_get_digest( cs , digest , & digest_length );
		result = String( ( const char * ) digest , digest_length ); 
	}
	else
	{
		result = g_checksum_get_string( cs );
	}
	
	g_checksum_free( cs );
	
	return result;
} 

String hmac( GChecksumType type , const void * key , gsize key_len , const void * message , gsize message_len , bool binary )
{
	static guint BLOCK_SIZE = 64; // This could be incorrect if new checksum types are used
	
	guint HASH_SIZE = g_checksum_type_get_length( type );
	
	guint8 key_buffer[ BLOCK_SIZE ];
	
	memset( key_buffer , 0 , BLOCK_SIZE );
	 
	if ( key_len > BLOCK_SIZE )
	{
		GChecksum * cs = g_checksum_new( type );
		g_checksum_update( cs , (const guchar *) key , key_len );
		gsize size = BLOCK_SIZE;
		g_checksum_get_digest( cs , key_buffer , & size );
		g_assert( size == HASH_SIZE );
		g_checksum_free( cs ); 	
	}
	else
	{
		g_memmove( key_buffer , key , key_len );	
	}
	
	guint8 o_pad[ BLOCK_SIZE ];
	guint8 i_pad[ BLOCK_SIZE ];
	
	for( guint i = 0; i < BLOCK_SIZE; ++i )
	{
		o_pad[ i ] = key_buffer[ i ] ^ 0x5c;
		i_pad[ i ] = key_buffer[ i ] ^ 0x36;
	}
	
	guint8 message_hash[ HASH_SIZE ];
	
	{
		GChecksum * cs = g_checksum_new( type );
		g_checksum_update( cs , ( const guchar * ) i_pad , BLOCK_SIZE );
		g_checksum_update( cs , ( const guchar * ) message , message_len );
		gsize size = HASH_SIZE;
		g_checksum_get_digest( cs , message_hash , & size );
		g_assert( size == HASH_SIZE );
		g_checksum_free( cs );
	} 	
	
	String result;
	
	{
		GChecksum * cs = g_checksum_new( type );
		g_checksum_update( cs , ( const guchar * ) o_pad , BLOCK_SIZE );
		g_checksum_update( cs , ( const guchar * ) message_hash , HASH_SIZE );
		
		if ( binary )
		{
			guint8 digest[ HASH_SIZE ];
			gsize size = HASH_SIZE;
			g_checksum_get_digest( cs , digest , & size );
			g_assert( size == HASH_SIZE );
			result = String( ( const char * ) digest , HASH_SIZE );
		}
		else
		{
			result = g_checksum_get_string( cs );
		}
		g_checksum_free( cs );
	}

	return result;	
}


]]

/*
	File: global functions
*/

globals
{
	/*
		Function: print
		
		Prints all the arguments to the console.
	*/
	
    print()
        [[
            std::string result;
            int n = lua_gettop(L);  /* number of arguments */
            int i;
            lua_getglobal(L, "tostring");
            for (i=1; i<=n; i++)
            {
              const char *s;
              lua_pushvalue(L, -1);  /* function to be called */
              lua_pushvalue(L, i);   /* value to print */
              lua_call(L, 1, 1);
              s = lua_tostring(L, -1);  /* get result */
              if (s == NULL)
                return luaL_error(L, LUA_QL("tostring") " must return a string to "
                                     LUA_QL("print"));
              if (i>1)
                result += ' ';
              result += s;
              lua_pop(L, 1);  /* pop result */
            }
            g_message("%s",result.c_str());                
        ]];
    
    /*
    	Function: dofile
    	
    	Opens the named file and executes it as a Lua chunk.
    	
    	Arguments:
    	
    		file_name - The name of the file (in your app bundle).
    		
    	Returns:
    	
    		values - All values returned by the chunk.
    */
    
    multi dofile(string file_name)
        [[
            bool is_uri=false;
            char * path=App::get(L)->normalize_path(file_name,&is_uri);

            FreeLater free_later(path);
            
            if (!path || is_uri)
            {
                return luaL_error(L,"Invalid path '%s'",file_name);
            }
            
            if (!g_str_has_suffix(path,".lua"))
            {
            	path = g_strdup_printf( "%s.lua",path);
            	free_later( path );
            }
            
            int n = lua_gettop(L);
            if (luaL_loadfile(L,path) != 0)
                lua_error(L);
            lua_call(L,0,LUA_MULTRET);
            return lua_gettop(L) - n;            
        ]];
        
    /*
    	Function: loadfile
    	
    	Loads the file as a Lua chunk and returns its contents as a function. If there
    	is an error, returns nil and an error message.
    	
    	Arguments: 
    	
    		file_name - The name of the file (in your app bundle).
    		
    	Returns:
    	
    		a function - That can be called to execute the chunk.
    		nil , error message - If there is something wrong.
    */
    
    multi loadfile(string file_name)
        [[
            bool is_uri=false;
            char * path=App::get(L)->normalize_path(file_name,&is_uri);
            
            FreeLater free_later(path);
                        
            if (!path || is_uri)
            {
                lua_pushnil(L);
                lua_pushfstring(L,"Invalid path '%s'",file_name);
                return 2;
            }
            
            if (!g_str_has_suffix(path,".lua"))
            {
            	path = g_strdup_printf( "%s.lua",path);
            	free_later( path );
            }

            if (luaL_loadfile(L,path)==0)
            {
                return 1;
            }
            else
            {
                lua_pushnil(L);
                lua_insert(L, -2);  
                return 2;  
            }            
        ]];
        
    /*
    	Function: readfile
    	
    	Loads the contents of the given file and returns them as a string. If
    	there are any problems, it returns nil.
    	
    	Arguments:
    	
    		file_name - The name of the file to read (in your app bundle).
    		
    	Returns:
    	
    		string - The contents of the file or
    		nil - If something went wrong.
    */
    
	lstring readfile(string file_name )
		[[
			result = NULL;
			result_len = 0;
			
            bool is_uri=false;
            
            char * path=App::get(L)->normalize_path(file_name,&is_uri);
            
            FreeLater free_later(path);
            
            if ( path && ! is_uri )
            {
            	gsize length = 0;
            	
            	gchar * contents = NULL;
            	
            	if ( g_file_get_contents( path, & contents, & length, NULL ) )
            	{
            		result = contents;
            		result_len = length;
            		
            		free_later( contents );
            	} 
            }                        
		]];       
        
    /*
    	Function: exit
    	
    	Exits/closes the app. This does not happen immediately, so exit does return control to
    	you. Your app will exit the next time through TrickPlay's event loop.
    */
    
    exit()
        [[
            App::get(L)->get_context()->close_app();        
        ]];
        
    reload()
    	[[
    		App::get(L)->get_context()->reload_app();
    	]];
        
    /*    
    	Function: launch_action
    	
    	TODO
    */
    
    multi launch_action( string app_id = NULL, string action = NULL, string uri = NULL, string type = NULL , table parameters = 0 )
    	[[
    		String serialized_parameters;
    		
    		if ( parameters )
    		{
            	lua_getglobal( L, "serialize" );
            	lua_pushvalue( L, parameters );
            	lua_call( L, 1, 1 );
            	if ( lua_isstring( L, -1 ) )
            	{
            		size_t len = 0;
            		const char * s = lua_tolstring( L, -1, &len );
            		
            		serialized_parameters = String( s, len );
            	}
            	lua_pop( L, 1 );
    		}
    		
    		
    		Actions actions( App::get( L )->get_context() );
    		String caller( App::get( L )->get_id() );
    		
    		SystemDatabase::AppActionMap matches;
    		
    		bool result = actions.launch_action( 
    			caller.c_str(), 
    			app_id, 
    			action, 
    			uri, 
    			type, 
    			serialized_parameters.empty() ? NULL : serialized_parameters.c_str(), 
    			matches );
    		
    		lua_pushboolean( L, result );
    		
			lua_newtable( L );
			
			int i = 1;
			
			for ( SystemDatabase::AppActionMap::const_iterator it = matches.begin(); it != matches.end(); ++it )
			{
				for ( App::Action::Map::const_iterator ait = it->second.begin(); ait != it->second.end(); ++ait, ++i )
				{
					lua_newtable( L );
					
					lua_pushstring( L, it->first.c_str() );
					lua_setfield( L, -2, "app" );
					
					lua_pushstring( L, ait->first.c_str() );
					lua_setfield( L, -2, "action" );
					
					lua_pushstring( L, ait->second.description.c_str() );
					lua_setfield( L, -2, "description" );
					
					lua_rawseti( L, -2, i );
				} 
			}
			
			
			return 2;
    		
    	]];
      
    /*
    	Function: choose
    	
    	Receives 3 parameters. If the first one is true, it returns the second one, 
    	otherwise, it returns the third one.  Equivalent to ((expression)?(a):(b)) in C.
    	
    	Arguments:
    	
    		expression - An expression. Remember that in Lua, only false and nil evaluate to false.
    		a - The value to return if the expression is true.
    		b - The value to return if the expression is false.
    		
    	Returns:
    	
    		a - If the expression is true.
    		b - If the expression is false.
    		nil - If you pass less than 3 arguments. 
    */
      
    multi choose()
        [[
            if (lua_gettop(L)<3)
            {
                lua_pushnil(L);
            }
            else
            {
                lua_pushvalue(L,lua_toboolean(L,1)?2:3);
            }
            return 1;
        ]];

	/*
		Function: serialize
		
		Converts some Lua values to a string.  
		
		TODO cycles
		
		Arguments:
		
			value - A number, string, boolean or table.
			
		Returns:
		
			string - A string representation of the value.
	*/
	
    string serialize()
        [[
            String buffer;

            int n=1;
            
            bool pretty=false;
            int level=0;
            
            if (lua_gettop(L)>1)
            {
                pretty=lua_toboolean(L,2);
                level=lua_tointeger(L,2);                
            }
            
            switch(lua_type(L,n))
            {
                case LUA_TNUMBER:
                {
                    buffer=lua_tostring(L,n);
                    break;
                }
                
                case LUA_TSTRING:
                {
                    LSG;
                    lua_getglobal(L,"string");
                    lua_getfield(L,-1,"format");
                    lua_pushstring(L,"%q");
                    lua_pushvalue(L,n);
                    lua_call(L,2,1);
                    buffer=lua_tostring(L,-1);
                    lua_pop(L,2);
                    LSG_END(0);
                    break;
                }
                
                case LUA_TBOOLEAN:
                {
                    buffer=lua_toboolean(L,n)?"true":"false";
                    break;
                }
                
                case LUA_TTABLE:
                {
                    if (pretty)
                    {
                        buffer += "\n" + String(2*level,' ');
                    }
                    
                    buffer+="{";
                    
                    if (pretty)
                    {
                        buffer += "\n";
                    }
                    
                    // Lookup the serialize function only once
                    lua_getglobal(L,"serialize");
                    int ser=lua_gettop(L);
                    
                    // Prepare to iterate over the table
                    lua_pushnil(L);
                    
                    bool first=true;
                    
                    while (lua_next(L,n)!=0)
                    {
                        if (first)
                        {
                            first=false;
                        }
                        else
                        {
                            buffer+=",";
                            
                            if (pretty)
                            {
                                buffer += "\n";
                            }
                        }
                        
                        if (pretty)
                        {
                            buffer += String(2*(level+1),' ');                            
                        }
                        
                        // Serialize the key
                        buffer+="[";
                        lua_pushvalue(L,ser);
                        lua_pushvalue(L,-3);
                        lua_call(L,1,1);
                        buffer+=lua_isnil(L,-1)?"nil":lua_tostring(L,-1);
                        lua_pop(L,1);
                        buffer+="]=";

                        // Serialize the value
                        lua_pushvalue(L,ser);
                        lua_pushvalue(L,-2);
                        if (pretty)
                        {
                            lua_pushinteger(L,level+1);
                            lua_call(L,2,1);
                        }
                        else
                        {
                            lua_call(L,1,1);
                        }
                        buffer+=lua_isnil(L,-1)?"nil":lua_tostring(L,-1);
                        // Pop both the result of the call as well as the value
                        // from lua_next
                        lua_pop(L,2);
                    }
                    
                    if (pretty)
                    {
                        buffer += "\n" + String(2*level,' ');
                    }

                    buffer+="}";
                    
                    lua_pop(L,1);
                    
                    break;
                }
                
                default:
                    break;
            }
            
            result=buffer.empty()?NULL:buffer.c_str();
        ]];

	/*
		Function: md5
		
		Returns the MD5 hash of the string passed in.
		
		Arguments:
		
			string - A string to hash.
			binary - If true, the result is a binary string, otherwise, it is hex.
			
		Returns:
		
			string - The MD5 hash of the string. 
	*/
	
    lstring md5( lstring s , bool binary = false )
        [[
        	String h( hash( G_CHECKSUM_MD5 , s , s_len , binary ) );
        	result = h.data();
        	result_len = h.length();
        ]];
        
	/*
		Function: sha1
		
		Returns the SHA-1 hash of the string passed in.
		
		Arguments:
		
			string - A string to hash.
			binary - If true, the result is a binary string, otherwise, it is hex.
			
		Returns:
		
			string - The SHA-1 hash of the string. 
	*/
	
    lstring sha1( lstring s , bool binary = false )
        [[
        	String h( hash( G_CHECKSUM_SHA1 , s , s_len , binary ) );
        	result = h.data();
        	result_len = h.length();
        ]];

	/*
		Function: sha256
		
		Returns the SHA-256 hash of the string passed in.
		
		Arguments:
		
			string - A string to hash.
			binary - If true, the result is a binary string, otherwise, it is hex.
			
		Returns:
		
			string - The SHA-256 hash of the string. 
	*/
	
    lstring sha256( lstring s , bool binary = false )
        [[
        	String h( hash( G_CHECKSUM_SHA256 , s , s_len , binary ) );
        	result = h.data();
        	result_len = h.length();
        ]];
        
	/*
		Function: hmac_sha1
		
		Returns the HMAC/SHA-1 hash of the key and message.
		
		Arguments:
		
			key - The key.
			message - The message.
			binary - If true, the result is a binary string, otherwise, it is hex.
			
		Returns:
		
			string - The HMAC/SHA-1 hash. 
	*/
	
    lstring hmac_sha1( lstring key , lstring message , bool binary = false)
    	[[
    		String h( hmac( G_CHECKSUM_SHA1 , key , key_len , message , message_len , binary ) );
    		result = h.data();
    		result_len = h.length();
    	]];
        
	/*
		Function: hmac_sha256
		
		Returns the HMAC/SHA-256 hash of the key and message.
		
		Arguments:
		
			key - The key.
			message - The message.
			binary - If true, the result is a binary string, otherwise, it is hex.
			
		Returns:
		
			string - The HMAC/SHA-256 hash. 
	*/

    lstring hmac_sha256( lstring key , lstring message , bool binary = false )
    	[[
    		String h( hmac( G_CHECKSUM_SHA256 , key , key_len , message , message_len , binary ) );
    		result = h.data();
    		result_len = h.length();
    	]];
    	
    /*
    	Function: base64_encode
    	
    	Encodes a string to base 64.
    	
    	Arguments:
    	
    		s - The string to encode.
    		
    	Returns:
    		
    		string - The encoded result.
    */
    
    string base64_encode( lstring s )
    	[[
    		gchar * encoded = g_base64_encode( ( const guchar * ) s , s_len ); 
    		FreeLater free_later( encoded );
    		
    		result = encoded; 
    	]];
    	
    /*
    	Function: base64_decode
    	
    	Decodes a base 64 string.
    	
    	Arguments:
    	
    		s - The string to decode.
    		
    	Returns:
    		
    		string - The decoded result.
    */

    lstring base64_decode( string s )
    	[[
    		gsize length;
    		
    		guchar * decoded = g_base64_decode( ( const gchar * ) s , & length );
    		
    		FreeLater free_later( decoded );
    		
    		result = ( const char * ) decoded;
    		result_len = length;
    	]];
        
	lstring uint32_to_be( int n )
		[[
			guint32 i = GUINT32_TO_BE( n );
			
			result = ( char * ) & i;
			result_len = 4;
		]];
		
	lstring uint32_to_le( int n )
		[[
			guint32 i = GUINT32_TO_LE( n );
			
			result = ( char * ) & i;
			result_len = 4;
		]];       
		
	int uint32_from_be( lstring s )
		[[
			if ( s_len >= 4 )
			{
				// TODO: Could have alignment problems
				
				result = GUINT32_FROM_BE( * ( ( guint32 * ) s ) );
			}
			else
			{
				result = 0;
			} 
		]];		

	int uint32_from_le( lstring s )
		[[
			if ( s_len >= 4 )
			{
				// TODO: Could have alignment problems
				
				result = GUINT32_FROM_LE( * ( ( guint32 * ) s ) );
			}
			else
			{
				result = 0;
			} 
		]];		

	debug()
		[[
		    if ( Debugger * debugger = App::get( L )->get_debugger() )
		    {
		        debugger->break_next_line();
		    }		
		]];
		
	detach( udata o )
		[[
			UserData::clear_callbacks( L , o );
		]];		       
		
	/*
		Function: dolater
		
		Posts a function and arguments for execution during the next pass of the event loop. Note
		that there is no way to receive any values returned by the function. 
		
		Arguments:
		
			f - The function to execute.
			others - Any number of arguments to pass to the function. 
	*/
	
	dolater( function f , ... )
		[[
			int nargs = lua_gettop(L)-f;
			int args = LUA_NOREF;
			
			// If there are args, we put them into a table and
			// get a ref to the table
			
			if ( nargs > 0 )
			{
				lua_newtable(L);
				for (int i=1; i<=nargs; ++i)
				{
				    if ( lua_isnil( L , i+f ) )
				    {
				        lua_pushlightuserdata( L , DoLater::nil() );
				    }
				    else
				    {
				        lua_pushvalue(L,i+f);
				    }
					lua_rawseti(L,-2,i);
				}
				args = luaL_ref(L,LUA_REGISTRYINDEX);
			}
			
			lua_pushvalue(L,f);
			int func = luaL_ref(L,LUA_REGISTRYINDEX);
			
			DoLater::add(L,func,args);
		]];
		
	table registry()
		[[
#ifdef TP_PRODUCTION		
			lua_pushnil( L );
#else
			lua_pushvalue( L , LUA_REGISTRYINDEX );
#endif			
		]];
		
	/*
		Function: uuid
		
		Generates a random (v4) UUID.
		
		Returns:
		
			uuid - A new UUID.
			
	*/ 
	
	string uuid()
		[[
			String uuid( Util::make_v4_uuid() );
			
			result = uuid.c_str();
		]];
		
	/*
		Function: dumptable
		
		Prints a table to the console; for debugging purposes. It handles 
		cyclic references.
		
		Arguments:
		
			t - The table to print.
			filter - A function that receives the table, the current key and the
				recursion depth. If the function returns false, the key is not printed.
			 
	*/
	
	dumptable( table t , function filter = 0 )
		[[
			lb_dump_table(L);
		]];

	/*
        Marker is a thing that prints out its name when it is garbage collected. This
        lets us attach it to stuff and see when it goes away.
	*/

	udata marker( lstring name )
        [[
            lua_newuserdata( L , 1 );

            lua_newtable( L );
            lua_pushvalue( L , 1 );
            lua_pushcclosure( L , marker_gc , 1 );
            lua_setfield( L , -2 , "__gc" );
            lua_setmetatable( L , -2 );
        ]];
}

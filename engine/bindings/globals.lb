module globals;

[[
#include "common.h"
#include "util.h"
#include "app.h"
#include "context.h"
#include "actions.h"
#include "images.h"

struct DoLater
{
    static void * nil()
    {
        static char nil=0;

        return & nil;
    }

	static void add(lua_State * L,int delay,int function_ref,int args_table_ref)
	{
		DoLater * dl = g_new0( DoLater , 1 );
		
		dl->lsp = App::get(L)->ref_lua_state_proxy();
		dl->function_ref = function_ref;
		dl->args_table_ref = args_table_ref;
		
		if ( delay <= 0 )
		{
		    g_idle_add_full( TRICKPLAY_PRIORITY , (GSourceFunc) do_it, dl, (GDestroyNotify)  destroy );
		}
		else
		{
		    g_timeout_add_full( TRICKPLAY_PRIORITY , delay , (GSourceFunc) do_it, dl, (GDestroyNotify)  destroy );
		}
	}  
	
	static gboolean do_it( DoLater * self )
	{
		lua_State * L = self->lsp->get_lua_state();
		
		if ( L )
		{
			// Get the function
			
			lua_rawgeti(L,LUA_REGISTRYINDEX,self->function_ref);
			
			// Count and push the arguments
			
			int nargs = 0;
			
			if ( self->args_table_ref != LUA_NOREF )
			{
				lua_rawgeti(L,LUA_REGISTRYINDEX,self->args_table_ref);
				
				if ( lua_type(L,-1) == LUA_TTABLE )
				{
					lua_pushnil(L);
					
					while( lua_next(L,-2) )
					{
					    if ( lua_islightuserdata( L , -1 ) && lua_touserdata( L , -1 ) == nil() )
					    {
					        lua_pop( L , 1 );
					        lua_pushnil( L );
					    }
						// Move the value below the table
						lua_insert(L,-3);
						++nargs;
					}
				}
				
				// Pop the table
				
				lua_pop(L,1);
			}
			
			// Now call it
			
			lua_call(L,nargs,0);
		}
		
		return FALSE;
	} 
	
	static void destroy( DoLater * self )
	{
		lua_State * L = self->lsp->get_lua_state();
		
		if ( L )
		{
			luaL_unref(L,LUA_REGISTRYINDEX,self->function_ref);
			luaL_unref(L,LUA_REGISTRYINDEX,self->args_table_ref);
		}
		
		self->lsp->unref();
		
		g_free( self );
	}

private:

	LuaStateProxy * lsp;
	int 			function_ref;
	int				args_table_ref;
};

String hash( GChecksumType type , const void * data , gsize length , bool binary )
{
	String result;
	
	GChecksum * cs = g_checksum_new( type );
	g_checksum_update( cs , ( const guchar * ) data , length );

	if ( binary ) 
	{
		gsize digest_length=g_checksum_type_get_length( type );
		guint8 digest[ digest_length  ];
		g_checksum_get_digest( cs , digest , & digest_length );
		result = String( ( const char * ) digest , digest_length ); 
	}
	else
	{
		result = g_checksum_get_string( cs );
	}
	
	g_checksum_free( cs );
	
	return result;
} 

String hmac( GChecksumType type , const void * key , gsize key_len , const void * message , gsize message_len , bool binary )
{
	static guint BLOCK_SIZE = 64; // This could be incorrect if new checksum types are used
	
	guint HASH_SIZE = g_checksum_type_get_length( type );
	
	guint8 key_buffer[ BLOCK_SIZE ];
	
	memset( key_buffer , 0 , BLOCK_SIZE );
	 
	if ( key_len > BLOCK_SIZE )
	{
		GChecksum * cs = g_checksum_new( type );
		g_checksum_update( cs , (const guchar *) key , key_len );
		gsize size = BLOCK_SIZE;
		g_checksum_get_digest( cs , key_buffer , & size );
		g_assert( size == HASH_SIZE );
		g_checksum_free( cs ); 	
	}
	else
	{
		g_memmove( key_buffer , key , key_len );	
	}
	
	guint8 o_pad[ BLOCK_SIZE ];
	guint8 i_pad[ BLOCK_SIZE ];
	
	for( guint i = 0; i < BLOCK_SIZE; ++i )
	{
		o_pad[ i ] = key_buffer[ i ] ^ 0x5c;
		i_pad[ i ] = key_buffer[ i ] ^ 0x36;
	}
	
	guint8 message_hash[ HASH_SIZE ];
	
	{
		GChecksum * cs = g_checksum_new( type );
		g_checksum_update( cs , ( const guchar * ) i_pad , BLOCK_SIZE );
		g_checksum_update( cs , ( const guchar * ) message , message_len );
		gsize size = HASH_SIZE;
		g_checksum_get_digest( cs , message_hash , & size );
		g_assert( size == HASH_SIZE );
		g_checksum_free( cs );
	} 	
	
	String result;
	
	{
		GChecksum * cs = g_checksum_new( type );
		g_checksum_update( cs , ( const guchar * ) o_pad , BLOCK_SIZE );
		g_checksum_update( cs , ( const guchar * ) message_hash , HASH_SIZE );
		
		if ( binary )
		{
			guint8 digest[ HASH_SIZE ];
			gsize size = HASH_SIZE;
			g_checksum_get_digest( cs , digest , & size );
			g_assert( size == HASH_SIZE );
			result = String( ( const char * ) digest , HASH_SIZE );
		}
		else
		{
			result = g_checksum_get_string( cs );
		}
		g_checksum_free( cs );
	}

	return result;	
}

]]

/*
	File: Utility Functions
	
	This section describes utility functions provided by the TrickPlay SDK Libraries. A TrickPlay application can call any of the functions described here.
*/

globals
{
	/*
		Function: print
		
		The print() function outputs all its arguments to the TrickPlay Console.
		
		*Arguments:*
		
			... - the print() function accepts a variable number of arguments of any supported type
			
		*Return Value:* None, if successful, else returns string error message
		
		*Code Example:* Output various messages to the console
		
			(code)
			print( "Process completed" )
			print( "Code:", error_code, ", Message:", error_message )
			(end)
			
		*See Also:* the <dumptable> function
	*/
	
    print()
        [[
            std::string result;
            int n = lua_gettop(L);  /* number of arguments */
            int i;
            lua_getglobal(L, "tostring");
            for (i=1; i<=n; i++)
            {
              const char *s;
              lua_pushvalue(L, -1);  /* function to be called */
              lua_pushvalue(L, i);   /* value to print */
              lua_call(L, 1, 1);
              s = lua_tostring(L, -1);  /* get result */
              if (s == NULL)
                return luaL_error(L, LUA_QL("tostring") " must return a string to "
                                     LUA_QL("print"));
              if (i>1)
                result += ' ';
              result += s;
              lua_pop(L, 1);  /* pop result */
            }
            g_message("%s",result.c_str());                
        ]];
    
    /*
    	Function: dofile
    	
    	The dofile() function loads a file containing Lua source code and executes the code. If any error occurs during the running of the Lua code, an error is raised.
    	
		*Arguments:*
		
			file_name - name of Lua source file to load and execute. The file must be located within the application's app bundle directory structure. If a file extension is not specified, an extension of .lua is assumed.
    	
    	*Return Values:* Returns the value or values returned by the executed Lua code.
    	
    	*See Also:* the <loadfile> function	
    */
    
    multi dofile(string file_name)
        [[
            String path;
            
            if ( g_str_has_suffix( file_name , ".lua" ) )
            {
                path = file_name;
            }
            else
            {
                gchar * p = g_strdup_printf( "%s.lua" , file_name );
                path = p;
                g_free( p );
            }
            
            App * app = App::get( L );
            
            int n = lua_gettop(L);
            if (app->get_metadata().sandbox.lua_load_pi_child(L,path) != 0)
            {
                lua_error(L);
            }
            lua_call(L,0,LUA_MULTRET);
            return lua_gettop(L) - n;            
        ]];
        
    /*
    	Function: loadfile
    	
    	The loadfile() function loads a file containing Lua source code, compiles the code, and returns the compiled chunk as a function. If an error occurs, an error is not raised, but the function returns nil and an error message.
    	
    	*Arguments:*
    	
    		file_name - name of Lua source file to load. The file must be located within the application's app bundle directory structure. If a file extension is not specified, an extension of .lua is assumed.
    		
    	*Return Values:* Returns the compiled Lua code which can be called as a function. If an error occurred, returns nil and a descriptive string error message.

		*See Also:* the <dofile> function    	
    */
    
    multi loadfile(string file_name)
        [[
            String path;
            
            if ( g_str_has_suffix( file_name , ".lua" ) )
            {
                path = file_name;
            }
            else
            {
                gchar * p = g_strdup_printf( "%s.lua" , file_name );
                path = p;
                g_free( p );
            }

            App * app = App::get( L );
            
            if (app->get_metadata().sandbox.lua_load_pi_child(L,path) == 0)
            {
                return 1;
            }
            else
            {
                lua_pushnil(L);
                lua_insert(L, -2);  
                return 2;  
            }            
        ]];

    /*
    	Function: readfile
    	
    	The readfile() function loads a file and returns the contents in a Lua string. If an error occurs, the function returns nil.
    	
    	*Arguments:*
    	
    		file_name - name of file to load. The file must be located within the application's app bundle directory structure.
    		
    	*Return Value:* String containing the file's contents. If an error occurred, returns nil.
    	
    	*See Also:* the <loadfile> function
    */
    
	lstring readfile(string file_name )
		[[
			result = 0;
			result_len = 0;

            gsize length = 0;
            gchar * contents = App::get( L )->get_metadata().sandbox.get_pi_child_contents( file_name , length );
            
            FreeLater free_later;
            
            if ( contents )
            {
                free_later( contents );
                
                result = contents;
                result_len = length;
            }
		]];       
        
    /*
    	Function: exit
    	
    	The exit() function schedules the TrickPlay application for termination. The next time the TrickPlay event loop executes, the <app.on_closing> event handler will be invoked and, afterward, the application will terminate.
    	
    	*Arguments:* None
    	
    	*Return Value:* None
    	
    	*See Also:* the <reload> function
    */
    
    exit()
        [[
            App::get(L)->get_context()->close_app();        
        ]];

    /*
        Function: reload
        
        The reload() function restarts the application as if it had been freshly loaded and initialized.
        
        *Arguments:* None
        
        *Return Value:* None
        
        *See Also:* the <exit> function
    */

    reload()
    	[[
    		App::get(L)->get_context()->reload_app();
    	]];
        
    /*    
    	Undocumented_Function: launch_action
    	
    	The launch_action() function will remain undocumented until it is more fully fleshed out.
    */
    
    multi launch_action( string app_id = NULL, string action = NULL, string uri = NULL, string type = NULL , table parameters = 0 )
    	[[
    		String serialized_parameters;
    		
    		if ( parameters )
    		{
            	lua_getglobal( L, "serialize" );
            	lua_pushvalue( L, parameters );
            	lua_call( L, 1, 1 );
            	if ( lua_isstring( L, -1 ) )
            	{
            		size_t len = 0;
            		const char * s = lua_tolstring( L, -1, &len );
            		
            		serialized_parameters = String( s, len );
            	}
            	lua_pop( L, 1 );
    		}
    		
    		
    		Actions actions( App::get( L )->get_context() );
    		String caller( App::get( L )->get_id() );
    		
    		SystemDatabase::AppActionMap matches;
    		
    		bool result = actions.launch_action( 
    			caller.c_str(), 
    			app_id, 
    			action, 
    			uri, 
    			type, 
    			serialized_parameters.empty() ? NULL : serialized_parameters.c_str(), 
    			matches );
    		
    		lua_pushboolean( L, result );
    		
			lua_newtable( L );
			
			int i = 1;
			
			for ( SystemDatabase::AppActionMap::const_iterator it = matches.begin(); it != matches.end(); ++it )
			{
				for ( App::Action::Map::const_iterator ait = it->second.begin(); ait != it->second.end(); ++ait, ++i )
				{
					lua_newtable( L );
					
					lua_pushstring( L, it->first.c_str() );
					lua_setfield( L, -2, "app" );
					
					lua_pushstring( L, ait->first.c_str() );
					lua_setfield( L, -2, "action" );
					
					lua_pushstring( L, ait->second.description.c_str() );
					lua_setfield( L, -2, "description" );
					
					lua_rawseti( L, -2, i );
				} 
			}
			
			
			return 2;
    		
    	]];
      
    /*
    	Function: choose
    	
    	The choose() function accepts three arguments and applies an IF-THEN-ELSE operation to them; IF the first argument is true THEN it returns the second argument ELSE it returns the third argument.
    	
    	The first argument must evaluate to a Lua true or false condition. Note: In Lua, only false and nil evaluate to false.
    	
    	*Arguments:*
    	
    		expression - Lua code segment that evaluates to either true or false
    		a - value to return if expression is true
    		b - value to return if expression is false
    		
    	*Return Value:* If first argument evaluates to true, returns second argument, else returns third argument. If fewer than three arguments are passed to the function, returns nil.
    */
      
    multi choose()
        [[
            if (lua_gettop(L)<3)
            {
                lua_pushnil(L);
            }
            else
            {
                lua_pushvalue(L,lua_toboolean(L,1)?2:3);
            }
            return 1;
        ]];

	/*
		Function: serialize
		
		The serialize() function converts an explicit value or a variable value to a string. Variables of the following types can be converted: integer, boolean, string, and table. When a table is converted to a string, each table entry is preceded by the string "[n]=" where n is the entry's index value. Examples are shown in the Code Examples section below.
		
		*Arguments:*
		
			arg1 - variable or value to convert to string. The argument must be one of the following data types: integer, boolean, string or table
			
		*Return Value:* String representation of the converted value
		
		*Code Examples:* Demonstrate the serialize() function's output for various data types
		
		(code)
		-- Serialize some simple types
		x, y, z = 5, true, "hello"
		print( serialize( x ), serialize( y ), serialize( z ) )
		-- Outputs: 5 true "hello"
		
		-- Serialize a table
		print( serialize( { x, y, z } ) )
		-- Outputs: {[1]=5,[2]=true,[3]="hello"}
		
		-- Serialize a nested table
		print( serialize( { 10, { x, y, z } } ) )
		-- Outputs: {[1]=10,[2]={[1]=5,[2]=true,[3]="hello"}}
		(end)
		
		*See Also:* the <json.stringify> function
	*/
	
    string serialize()
        [[
            String buffer;

            int n=1;
            
            bool pretty=false;
            int level=0;
            
            if (lua_gettop(L)>1)
            {
                pretty=lua_toboolean(L,2);
                level=lua_tointeger(L,2);                
            }
            
            switch(lua_type(L,n))
            {
                case LUA_TNUMBER:
                {
                    buffer=lua_tostring(L,n);
                    break;
                }
                
                case LUA_TSTRING:
                {
                    LSG;
                    lua_getglobal(L,"string");
                    lua_getfield(L,-1,"format");
                    lua_pushstring(L,"%q");
                    lua_pushvalue(L,n);
                    lua_call(L,2,1);
                    buffer=lua_tostring(L,-1);
                    lua_pop(L,2);
                    LSG_END(0);
                    break;
                }
                
                case LUA_TBOOLEAN:
                {
                    buffer=lua_toboolean(L,n)?"true":"false";
                    break;
                }
                
                case LUA_TTABLE:
                {
                    if (pretty)
                    {
                        buffer += "\n" + String(2*level,' ');
                    }
                    
                    buffer+="{";
                    
                    if (pretty)
                    {
                        buffer += "\n";
                    }
                    
                    // Lookup the serialize function only once
                    lua_getglobal(L,"serialize");
                    int ser=lua_gettop(L);
                    
                    // Prepare to iterate over the table
                    lua_pushnil(L);
                    
                    bool first=true;
                    
                    while (lua_next(L,n)!=0)
                    {
                        if (first)
                        {
                            first=false;
                        }
                        else
                        {
                            buffer+=",";
                            
                            if (pretty)
                            {
                                buffer += "\n";
                            }
                        }
                        
                        if (pretty)
                        {
                            buffer += String(2*(level+1),' ');                            
                        }
                        
                        // Serialize the key
                        buffer+="[";
                        lua_pushvalue(L,ser);
                        lua_pushvalue(L,-3);
                        lua_call(L,1,1);
                        buffer+=lua_isnil(L,-1)?"nil":lua_tostring(L,-1);
                        lua_pop(L,1);
                        buffer+="]=";

                        // Serialize the value
                        lua_pushvalue(L,ser);
                        lua_pushvalue(L,-2);
                        if (pretty)
                        {
                            lua_pushinteger(L,level+1);
                            lua_call(L,2,1);
                        }
                        else
                        {
                            lua_call(L,1,1);
                        }
                        buffer+=lua_isnil(L,-1)?"nil":lua_tostring(L,-1);
                        // Pop both the result of the call as well as the value
                        // from lua_next
                        lua_pop(L,2);
                    }
                    
                    if (pretty)
                    {
                        buffer += "\n" + String(2*level,' ');
                    }

                    buffer+="}";
                    
                    lua_pop(L,1);
                    
                    break;
                }
                
                default:
                    break;
            }
            
            result=buffer.empty()?NULL:buffer.c_str();
        ]];

	/*
		Function: md5
		
		The md5() function calculates a string's checksum value using the MD5 (Message Digest) hashing algorithm. The checksum is returned as a string in either hexadecimal or binary format. When returned in hexadecimal format, all hex characters are returned in lower-case.
		
		Note: The MD5 algorithm is not as secure as the SHA-1 and SHA-256 hashing algorithms used by the <sha1> and <sha256> functions, respectively.
		
		*Arguments:*
		
			s - string to process
			binary - boolean flag indicating the calculated checksum string's format: hexadecimal or binary (true=binary). If not specified, the default string format is hexadecimal (binary=false).
			
		*Return Value:* String containing MD5 checksum value in either hexadecimal or binary format
		
		*See Also:* the <sha1> and <sha256> functions
	*/
	
    lstring md5( lstring s, bool binary = false )
        [[
        	String h( hash( G_CHECKSUM_MD5 , s , s_len , binary ) );
        	result = h.data();
        	result_len = h.length();
        ]];
        
	/*
		Function: sha1
		
		The sha1() function calculates a string's checksum value using the SHA-1 (Secure Hash Algorithm) hash function. The checksum is returned as a string in either hexadecimal or binary format. When returned in hexadecimal format, all hex characters are returned in lower-case.
		
		Note: The SHA-256 algorithm used by the <sha256> function is more secure than the SHA-1 function.
		
		*Arguments:*
		
			s - string to process
			binary - boolean flag indicating the calculated checksum string's format: hexadecimal or binary (true=binary). If not specified, the default string format is hexadecimal (binary=false).
			
		*Return Value:* String containing SHA-1 checksum value in either hexadecimal or binary format
		
		*See Also:* the <sha256> and <md5> functions
	*/
	
    lstring sha1( lstring s, bool binary = false )
        [[
        	String h( hash( G_CHECKSUM_SHA1 , s , s_len , binary ) );
        	result = h.data();
        	result_len = h.length();
        ]];

	/*
		Function: sha256
		
		The sha256() function calculates a string's checksum value using the SHA-256 (Secure Hash Algorithm) hash function. The checksum is returned as a string in either hexadecimal or binary format. When returned in hexadecimal format, all hex characters are returned in lower-case.
		
		*Arguments:*
		
			s - string to process
			binary - boolean flag indicating the calculated checksum string's format: hexadecimal or binary (true=binary). If not specified, the default string format is hexadecimal (binary=false).
			
		*Return Value:* String containing SHA-256 checksum value in either hexadecimal or binary format
		
		*See Also:* the <sha1> and <md5> functions
	*/
	
    lstring sha256( lstring s, bool binary = false )
        [[
        	String h( hash( G_CHECKSUM_SHA256 , s , s_len , binary ) );
        	result = h.data();
        	result_len = h.length();
        ]];
        
	/*
		Function: hmac_sha1
		
		The hmac_sha1() function accepts a message and secret key to construct an HMAC (Hash-based Message Authentication Code) using the SHA-1 (Secure Hash Algorithm) hash function. The MAC is returned as a string in either hexadecimal or binary format. When returned in hexadecimal format, all hex characters are returned in lower-case.
		
		*Arguments:*
		
			key - string containing the secret key
			message - string containing the message to process
			binary - boolean flag indicating the MAC string's format: hexadecimal or binary (true=binary). If not specified, the default string format is hexadecimal (binary=false).
			
		*Return Value:* String containing the HMAC-SHA-1 key/message in either hexadecimal or binary format
		
		*See Also:* the <hmac_sha256> function
	*/
	
    lstring hmac_sha1( lstring key, lstring message, bool binary = false)
    	[[
    		String h( hmac( G_CHECKSUM_SHA1 , key , key_len , message , message_len , binary ) );
    		result = h.data();
    		result_len = h.length();
    	]];
        
	/*
		Function: hmac_sha256
		
		The hmac_sha256() function accepts a message and secret key to construct an HMAC (Hash-based Message Authentication Code) using the SHA-256 (Secure Hash Algorithm) hash function. The MAC is returned as a string in either hexadecimal or binary format. When returned in hexadecimal format, all hex characters are returned in lower-case.
		
		*Arguments:*
		
			key - string containing the secret key
			message - string containing the message to process
			binary - boolean flag indicating the MAC string's format: hexadecimal or binary (true=binary). If not specified, the default string format is hexadecimal (binary=false).
			
		*Return Value:* String containing the HMAC-SHA-256 key/message in either hexadecimal or binary format
		
		*See Also:* the <hmac_sha1> function
	*/

    lstring hmac_sha256( lstring key, lstring message, bool binary = false )
    	[[
    		String h( hmac( G_CHECKSUM_SHA256 , key , key_len , message , message_len , binary ) );
    		result = h.data();
    		result_len = h.length();
    	]];
    	
    /*
    	Function: base64_encode
    	
    	The base64_encode() function translates a string of binary data to its radix-64 string representation. Base64 encoding is often used when binary data needs to be stored or transferred using methods that expect text data.
    	    	
    	*Arguments:*
    	
    		s - string containing data to encode
    		
    	*Return Value:*
    		
    		string - translated string in Base64 format
    		
    	*See Also:* the <base64_decode> function
    */
    
    string base64_encode( lstring s )
    	[[
    		gchar * encoded = g_base64_encode( ( const guchar * ) s , s_len ); 
    		FreeLater free_later( encoded );
    		
    		result = encoded; 
    	]];
    	
    /*
    	Function: base64_decode
    	
    	The base64_decode() function translates a Base64-encoded string to its original binary data format.
    	
    	*Arguments:*
    	
    		s - string containing Base64-encoded data to decode
    		
    	*Return Value:* string containing original binary data
    	
    	*See Also:* the <base64_encode> function
    */

    lstring base64_decode( string s )
    	[[
    		gsize length;
    		
    		guchar * decoded = g_base64_decode( ( const gchar * ) s , & length );
    		
    		FreeLater free_later( decoded );
    		
    		result = ( const char * ) decoded;
    		result_len = length;
    	]];

    /*
        Function: xml_escape
        
        The xml_escape() function escapes XML text, converting less than (<), greater than (>) and other characters to their corresponding HTML entity values, e.g., &lt; and &gt;. Also converted are all characters within the range of &x1; thru &x1f;, inclusive, except for tabstop, newline, and carriage return characters.
        
        *Argument:*
        
        	s - string to process
        	
        *Return Value:* Converted string with appropriate characters escaped
        
        *Code Example:* Escape relevant characters in source string
        
        (code)
		print( xml_escape( [=[<People>
								<Person>
									<ID>#001</ID>
									<Name>John Doe</Name>
									<email>john@doe.com</email>
								</Person>
							 </People>
						   ]=] ) )
		Outputs: 
			&lt;People&gt;
				&lt;Person&gt;
					&lt;ID&gt;#001&lt;/ID&gt;
					&lt;Name&gt;John Doe&lt;/Name&gt;
					&lt;email&gt;john@doe.com&lt;/email&gt;
				&lt;/Person&gt;
           &lt;/People&gt;
        (end)
        
        *See Also:* the <XMLParser> class
    */

    string xml_escape( lstring s )
        [[
            gchar * encoded = g_markup_escape_text( (const gchar *) s, s_len );
            
            FreeLater free_later( encoded );
            
            result = (const char *)encoded;
        ]];

    /*
        Function: regex_replace
        
        The regex_replace() function performs a text-replacement operation; the text to find and the text to be replaced are specified using <Perl-compatible regular expression patterns at http://perldoc.perl.org/perlre.html>.
        
        *Arguments:*
        
	        origin - string to process
	        pattern - regular expression string specifying text to search for
			replacement - regular expression string specifying replacement text. This string must be UTF-8 encoded.
			start_pos - zero-based index within origin argument at which to begin searching. This argument is optional. If not specified, the search begins with the first character in the origin argument (index 0).

        *Return Value:* modified string, if successful, else the original string. Note: The resulting string should not contain NUL characters.
        
        It is possible to use the regex_replace() function without knowing Perl regular expression syntax. The following code statement performs a simple search-and-replace operation.
        
        (code)
        -- Replace "Hello" with "Good-bye"
        print( regex_replace( "Hello World", "Hello", "Good-bye" ) )
        
        Outputs:
        	Good-bye World
        (end)
        
        For Perl programmers, the equivalent Perl code for the Lua-based regex_replace() function is shown below.
        
        (code)
        -- Lua version
        str = regex_replace( original, find, replacement )
        
        -- Perl version
        $_ = $original;
        s/$find/$replacement/;
        $str = $_;
        (end)
        
        There may be times when the matched text is variable (such as matching any digit between 0-9) and this variable match must be part of the replacement string. For example, to format some text, a regular expression can be used to parse the text into tokens. The tokens are then reorganized in the new format by including them in a replacement regular expression. In Perl terminology, you want to "capture" each token and then reference the captured text in the replacement regular expression. Perl stores captured text in "capture variables." The first group of captured text is stored in the variable $1. If multiple groups of text are captured, the capture variables $2, $3, etc. are used for each subsequent group. There is no upper limit on the number of capture variables.
        
        In the Lua-based regex_replace() function, the equivalent to Perl's $1 capture variable is \\1. (Note: The actual Lua capture variable is \1, but the backslash character must be escaped to be interpreted correctly.) Subsequent Lua capture variables use the names \\2, \\3, etc.. The capture variable \\0 is special; it contains the entire matched text, not just any captured subsections.
        
        The code sample below formats a raw telephone number using capture variables.
        
        (code)
        -- Format telephone number as (nnn) nnn - nnnn
        -- The search regular expression looks for sequences of 3 digits, 3 digits and 4 digits. Each sequence is captured in
        -- the capture variables \\1, \\2 and \\3 which are referenced in the replacement regular expression.
        print( regex_replace( "John Doe, phone: 4083063517",
                              "([0-9]{3})([0-9]{3})([0-9]{4})",
                              "(\\1) \\2 - \\3" ) )
        Outputs:
        	John Doe, phone: (408) 306 - 3517
        (end)
        
        Specifying capture variables using the \\1 syntax is sometimes insufficient. For example, say we want to change the second digit in any "nn" sequence to zero, such as changing "99" to "90 and "34" to "30". If we capture the first digit in capture variable \\1 (as in the regular expression of "([0-9])[1-9]") then the replacement regular expression to append a zero to the capture variable would be "\\10". However, this does not work because the ending zero is interpreted as being part of the capture variable, i.e., \\10. To reference the capture variable \\1 and append a '0' to the resulting string, we need to reference the capture variable using a different syntax.
        
        In Perl, the "\g{1}" syntax is an equivalent reference to the Perl $1 capture variable. In the Lua-based regex_replace() function, the "\\g<1>" syntax is equivalent to referencing the "\\1" capture variable. Subsequent capture variables (\\2, \\3, etc.) use the same syntax (\\g<2>, \\g<3>, etc.).
         
         The code segment below demonstrates this alternative syntax for capture variables with the regex_replace() function.

        (code)
        -- Replace ".dd" with ".d0" where 'd' is any digit 0-9
        print( regex_replace( "MSRP: $10.99, Sale Price: $6.45", ".([0-9])[1-9]", ".\\g<1>0" ) )
        
        Outputs:
        	MSRP: $10.90, Sale Price: $6.40
        (end)

		Captured text can also be assigned a name by using the syntax (?<name>...). The name can subsequently be used to reference the related capture variable (\\1, etc.). When referencing a capture name, the syntax is \\g<name>, as in \\g<Group1>. A version of the earlier phone-number formatting example that uses capture names is shown below.
		
		(code)
		-- Format a telephone number as (nnn) nnn - nnnn. Use capture names.
		print( regex_replace( "John Doe, phone: 4083063517",
                              "(?<area>[0-9]{3})(?<group1>[0-9]{3})(?<group2>[0-9]{4})",
                              "(\\g<area>) \\g<group1> - \\g<group2>" ) )
        Outputs:
        	John Doe, phone: (408) 306 - 3517
		(end)

        *See Also:* <Perl regular expression documentation at http://perldoc.perl.org/perlre.html>
    */

    string regex_replace( lstring origin, string pattern, string replacement, int start_pos = 0 )
        [[
            FreeLater free_later;

            GError * error = 0;

            GRegex * re_pat = g_regex_new( pattern, (GRegexCompileFlags) (G_REGEX_MULTILINE | G_REGEX_DOTALL), (GRegexMatchFlags) 0, &error );

            if (error)
            {
                g_warning("FAILED TO COMPILE REGEX '%s' : %s",pattern,error->message);
                g_clear_error(&error);
                result = origin;
            }
            else
            {
                gchar * replaced = g_regex_replace( re_pat, origin, origin_len, start_pos, replacement, (GRegexMatchFlags) 0, &error );

                if (error)
                {
                    g_warning("FAILED TO EXECUTE REGEX REPLACE '%s' : %s",pattern,error->message);
                    g_clear_error(&error);
                    result = origin;
                }
                else
                {
                    free_later( replaced );
                    
                    result = replaced;
                }
            }

            if ( re_pat )
            {            
                g_regex_unref( re_pat );
            }
        ]];

	lstring uint32_to_be( int n )
		[[
			guint32 i = GUINT32_TO_BE( n );
			
			result = ( char * ) & i;
			result_len = 4;
		]];

	lstring uint32_to_le( int n )
		[[
			guint32 i = GUINT32_TO_LE( n );
			
			result = ( char * ) & i;
			result_len = 4;
		]];       

	int uint32_from_be( lstring s )
		[[
			if ( s_len >= 4 )
			{
				// TODO: Could have alignment problems
				
				result = GUINT32_FROM_BE( * ( ( guint32 * ) s ) );
			}
			else
			{
				result = 0;
			} 
		]];		

	int uint32_from_le( lstring s )
		[[
			if ( s_len >= 4 )
			{
				// TODO: Could have alignment problems
				
				result = GUINT32_FROM_LE( * ( ( guint32 * ) s ) );
			}
			else
			{
				result = 0;
			} 
		]];		

	detach( udata o )
		[[
			UserData::clear_callbacks( L , o );
		]];		       
		
	/*
		Function: dolater
		
		The dolater() function schedules a function to execute at a later time during a subsequent pass through the TrickPlay Engine. By specifying the minimum amount of time to expire before executing, the dolater() function can simulate a simple timer operation. Note: It is not possible to receive return values from the scheduled function.
		
		*Arguments:*
		
			delay - minimum number of milliseconds to expire before executing function. This argument is optional. If not specified, the function will execute during the next pass through the TrickPlay Engine.
			func - function to execute
			args, ... - argument(s) to pass to func. These arguments are optional and there can be any number of them.
			
		*Return Value:* None
		
		*Code Examples:* Demonstrate various dolater() invocations
		
			(code)
			-- Execute sendMail() during next pass through the TrickPlay Engine
			dolater( sendMail )
			
			-- Execute sendMail( textMsg ) during next pass through the Engine
			dolater( sendMail, textMsg )
			
			-- Execute sendMail( textMsg ) in a second (or later)
			dolater( 1000, sendMail, textMsg )
			(end)
		
		*See Also:* the <Timer> class
	*/
	
	dolater( ... )
		[[
			int nargs = lua_gettop(L);

            if ( nargs > 0 )
            {
                int f = 1;
                int delay = 0;

                if ( lua_type( L , 1 ) == LUA_TNUMBER )
                {
                    delay = lua_tonumber( L , 1 );
                    ++f;
                    --nargs;
                }

                (void)lb_checkfunction( L , f );

                --nargs;

                int args = LUA_NOREF;

                // If there are args, we put them into a table and
                // get a ref to the table

                if ( nargs > 0 )
                {
                    lua_newtable(L);
                    for (int i=1; i<=nargs; ++i)
                    {
                        if ( lua_isnil( L , i+f ) )
                        {
                            lua_pushlightuserdata( L , DoLater::nil() );
                        }
                        else
                        {
                            lua_pushvalue(L,i+f);
                        }
                        lua_rawseti(L,-2,i);
                    }
                    args = luaL_ref(L,LUA_REGISTRYINDEX);
                }

                lua_pushvalue(L,f);
                int func = luaL_ref(L,LUA_REGISTRYINDEX);

                DoLater::add(L,delay,func,args);
            }
		]];
		
	/*
		Function: uuid
		
		The uuid() function generates a version 4 (random) UUID (universally unique identifier). Note: While the probability of producing duplicate UUIDs is extremely remote, UUIDs must be considered "practically unique" and not "guaranteed unique."
		
		*Arguments:* None
		
		*Return Value:* string containing a new UUID
	*/ 
	
	string uuid()
		[[
			String uuid( Util::make_v4_uuid() );
			
			result = uuid.c_str();
		]];
		
	/*
		Function: dumptable
		
		The dumptable() function outputs the contents of a table to the TrickPlay Console. Cyclic references are handled appropriately.
		
		This function is intended for debugging purposes and can be entered directly on the Console command line.
		
		*Arguments:*
		
			t - table to output
			filter - function that can be used to filter output. The function's prototype is: func( key, value, table_depth ). The function is invoked for each entry in the table. The key and value arguments are the current key/value pair from the table. The table_depth indicates the table level in which the key/value resides. The top-level table has a table_depth of 1; a table entry contained within the top-level table has a table_depth of 2, and so on. If the function returns false, the table entry is not output. The filter argument is optional. If not specified, no filter function will be called, and all the table's contents will be output.

		*Return Value:* None
		
		*See Also:* the <print> function
	*/
	
	dumptable( table t, function filter = 0 )
		[[
			lb_dump_table(L);
		]];

	/*
        Function: time
        
        The time() function returns the number of seconds since the Epoch (00:00:00 UTC, January 1, 1970). The precision of the seconds can go to microseconds (1/millionth of a second), depending on the capabilities of the underlying hardware. For example, in the value 10800.4507 seconds, the fractional portion specifies the number of microseconds.
        
        The time() function has finer resolution than the Lua library's os.time() function, which returns whole seconds.
        
        *Arguments:* None
        
        *Return Value:* Number of seconds, including fractional seconds, since the Epoch (00:00:00 UTC, January 1, 1970)

		*See Also:* the <timestamp> function
	*/

	double time()
        [[
            GTimeVal tv;

	        g_get_current_time( & tv );

	        result = tv.tv_sec + double( tv.tv_usec ) / G_USEC_PER_SEC;
        ]];

	/*
	    Function: timestamp
	    
	    The timestamp() function returns the number of milliseconds elapsed since the TrickPlay Engine started.
	    
	    *Arguments:* None
	    
	    *Return Value:* Number of milliseconds, including fractional milliseconds, since the TrickPlay Engine started

		*See Also:* the <time> function
	*/

	double timestamp()
        [[
            result = timestamp();
        ]];

	udata newudata( table metatable )
        [[
            lua_newuserdata( L , 4 );
	        lua_pushvalue( L , metatable );
	        lua_setmetatable( L , -2 );
        ]];

    /*
        Function: split
        
        The split() function parses a string into tokens separated by a specified delimiter character. Delimiters are not included in the generated token list, but non-delimiter whitespace is retained.
        
        *Arguments:*
        
        	source - string to parse
        	delimiter - character used to separate tokens. Only a single character may be specified.
        	max_tokens - maximum number of tokens to parse. If max_tokens is reached before the entire source has been parsed, the final entry in the returned token table will contain the remainder of the source. The max_tokens argument is optional; if not specified, all tokens will be parsed.
        	
        *Return Value:* table containing the parsed tokens with the delimiters removed

		*Code Example:* Parse some sample strings using the split() function
		
		(code)
		-- Use comma delimiter
		dumptable( split( "a, b, c, d:e:f", "," ) )     -- Outputs: { "a", " b", " c", " d:e:f" }
		
		-- Use colon delimiter
		dumptable( split( "a, b, c, d:e:f", ":" ) )     -- Outputs: { "a, b, c, d", "e", "f" }
		
		-- Use comma delimiter, parse first 3 tokens
		dumptable( split( "a, b, c, d:e:f", ",", 3 ) )  -- Outputs: { "a", " b", " c, d:e:f" }
		(end)        
    */

	table split( string source, string delimiter, int max_tokens = 0 )
        [[
            lua_newtable( L );

            if ( strlen( delimiter ) )
            {
                StringVector v = split_string( source , delimiter , max_tokens );

                int i = 1;

                for( StringVector::const_iterator it = v.begin(); it != v.end(); ++it , ++i )
                {
                    lua_pushstring( L , it->c_str() );
                    lua_rawseti( L , -2 , i );
                }
            }
        ]];

	string random_string( int length )
        [[
            String rs( "" );

            if ( length > 0 )
            {
                rs = Util::random_string( length );
            }

            result = rs.c_str();
        ]];
}

module globals;

[[
#include "common.h"
#include "util.h"
#include "app.h"
#include "context.h"
#include "actions.h"
#include "images.h"

struct DoLater
{
    static void * nil()
    {
        static char nil=0;

        return & nil;
    }

	static void add(lua_State * L,int delay,int function_ref,int args_table_ref)
	{
		DoLater * dl = g_new0( DoLater , 1 );
		
		dl->lsp = App::get(L)->ref_lua_state_proxy();
		dl->function_ref = function_ref;
		dl->args_table_ref = args_table_ref;
		
		if ( delay <= 0 )
		{
		    g_idle_add_full( TRICKPLAY_PRIORITY , (GSourceFunc) do_it, dl, (GDestroyNotify)  destroy );
		}
		else
		{
		    g_timeout_add_full( TRICKPLAY_PRIORITY , delay , (GSourceFunc) do_it, dl, (GDestroyNotify)  destroy );
		}
	}  
	
	static gboolean do_it( DoLater * self )
	{
		lua_State * L = self->lsp->get_lua_state();
		
		if ( L )
		{
			// Get the function
			
			lua_rawgeti(L,LUA_REGISTRYINDEX,self->function_ref);
			
			// Count and push the arguments
			
			int nargs = 0;
			
			if ( self->args_table_ref != LUA_NOREF )
			{
				lua_rawgeti(L,LUA_REGISTRYINDEX,self->args_table_ref);
				
				if ( lua_type(L,-1) == LUA_TTABLE )
				{
					lua_pushnil(L);
					
					while( lua_next(L,-2) )
					{
					    if ( lua_islightuserdata( L , -1 ) && lua_touserdata( L , -1 ) == nil() )
					    {
					        lua_pop( L , 1 );
					        lua_pushnil( L );
					    }
						// Move the value below the table
						lua_insert(L,-3);
						++nargs;
					}
				}
				
				// Pop the table
				
				lua_pop(L,1);
			}
			
			// Now call it
			
			lua_call(L,nargs,0);
		}
		
		return FALSE;
	} 
	
	static void destroy( DoLater * self )
	{
		lua_State * L = self->lsp->get_lua_state();
		
		if ( L )
		{
			luaL_unref(L,LUA_REGISTRYINDEX,self->function_ref);
			luaL_unref(L,LUA_REGISTRYINDEX,self->args_table_ref);
		}
		
		self->lsp->unref();
		
		g_free( self );
	}

private:

	LuaStateProxy * lsp;
	int 			function_ref;
	int				args_table_ref;
};

String hash( GChecksumType type , const void * data , gsize length , bool binary )
{
	String result;
	
	GChecksum * cs = g_checksum_new( type );
	g_checksum_update( cs , ( const guchar * ) data , length );

	if ( binary ) 
	{
		gsize digest_length=g_checksum_type_get_length( type );
		guint8 digest[ digest_length  ];
		g_checksum_get_digest( cs , digest , & digest_length );
		result = String( ( const char * ) digest , digest_length ); 
	}
	else
	{
		result = g_checksum_get_string( cs );
	}
	
	g_checksum_free( cs );
	
	return result;
} 

String hmac( GChecksumType type , const void * key , gsize key_len , const void * message , gsize message_len , bool binary )
{
	static guint BLOCK_SIZE = 64; // This could be incorrect if new checksum types are used
	
	guint HASH_SIZE = g_checksum_type_get_length( type );
	
	guint8 key_buffer[ BLOCK_SIZE ];
	
	memset( key_buffer , 0 , BLOCK_SIZE );
	 
	if ( key_len > BLOCK_SIZE )
	{
		GChecksum * cs = g_checksum_new( type );
		g_checksum_update( cs , (const guchar *) key , key_len );
		gsize size = BLOCK_SIZE;
		g_checksum_get_digest( cs , key_buffer , & size );
		g_assert( size == HASH_SIZE );
		g_checksum_free( cs ); 	
	}
	else
	{
		g_memmove( key_buffer , key , key_len );	
	}
	
	guint8 o_pad[ BLOCK_SIZE ];
	guint8 i_pad[ BLOCK_SIZE ];
	
	for( guint i = 0; i < BLOCK_SIZE; ++i )
	{
		o_pad[ i ] = key_buffer[ i ] ^ 0x5c;
		i_pad[ i ] = key_buffer[ i ] ^ 0x36;
	}
	
	guint8 message_hash[ HASH_SIZE ];
	
	{
		GChecksum * cs = g_checksum_new( type );
		g_checksum_update( cs , ( const guchar * ) i_pad , BLOCK_SIZE );
		g_checksum_update( cs , ( const guchar * ) message , message_len );
		gsize size = HASH_SIZE;
		g_checksum_get_digest( cs , message_hash , & size );
		g_assert( size == HASH_SIZE );
		g_checksum_free( cs );
	} 	
	
	String result;
	
	{
		GChecksum * cs = g_checksum_new( type );
		g_checksum_update( cs , ( const guchar * ) o_pad , BLOCK_SIZE );
		g_checksum_update( cs , ( const guchar * ) message_hash , HASH_SIZE );
		
		if ( binary )
		{
			guint8 digest[ HASH_SIZE ];
			gsize size = HASH_SIZE;
			g_checksum_get_digest( cs , digest , & size );
			g_assert( size == HASH_SIZE );
			result = String( ( const char * ) digest , HASH_SIZE );
		}
		else
		{
			result = g_checksum_get_string( cs );
		}
		g_checksum_free( cs );
	}

	return result;	
}


]]

/*
	File: global functions
*/

globals
{
	/*
		Function: print
		
		Prints all the arguments to the console.
	*/
	
    print()
        [[
            std::string result;
            int n = lua_gettop(L);  /* number of arguments */
            int i;
            lua_getglobal(L, "tostring");
            for (i=1; i<=n; i++)
            {
              const char *s;
              lua_pushvalue(L, -1);  /* function to be called */
              lua_pushvalue(L, i);   /* value to print */
              lua_call(L, 1, 1);
              s = lua_tostring(L, -1);  /* get result */
              if (s == NULL)
                return luaL_error(L, LUA_QL("tostring") " must return a string to "
                                     LUA_QL("print"));
              if (i>1)
                result += ' ';
              result += s;
              lua_pop(L, 1);  /* pop result */
            }
            g_message("%s",result.c_str());                
        ]];
    
    /*
    	Function: dofile
    	
    	Opens the named file and executes it as a Lua chunk.
    	
    	Arguments:
    	
    		file_name - The name of the file (in your app bundle).
    		
    	Returns:
    	
    		values - All values returned by the chunk.
    */
    
    multi dofile(string file_name)
        [[
            bool is_uri=false;
            char * path=App::get(L)->normalize_path(file_name,&is_uri);

            FreeLater free_later(path);
            
            if (!path || is_uri)
            {
                return luaL_error(L,"Invalid path '%s'",file_name);
            }
            
            if (!g_str_has_suffix(path,".lua"))
            {
            	path = g_strdup_printf( "%s.lua",path);
            	free_later( path );
            }
            
            int n = lua_gettop(L);
            if (luaL_loadfile(L,path) != 0)
                lua_error(L);
            lua_call(L,0,LUA_MULTRET);
            return lua_gettop(L) - n;            
        ]];
        
    /*
    	Function: loadfile
    	
    	Loads the file as a Lua chunk and returns its contents as a function. If there
    	is an error, returns nil and an error message.
    	
    	Arguments: 
    	
    		file_name - The name of the file (in your app bundle).
    		
    	Returns:
    	
    		a function - That can be called to execute the chunk.
    		nil , error message - If there is something wrong.
    */
    
    multi loadfile(string file_name)
        [[
            bool is_uri=false;
            char * path=App::get(L)->normalize_path(file_name,&is_uri);
            
            FreeLater free_later(path);
                        
            if (!path || is_uri)
            {
                lua_pushnil(L);
                lua_pushfstring(L,"Invalid path '%s'",file_name);
                return 2;
            }
            
            if (!g_str_has_suffix(path,".lua"))
            {
            	path = g_strdup_printf( "%s.lua",path);
            	free_later( path );
            }

            if (luaL_loadfile(L,path)==0)
            {
                return 1;
            }
            else
            {
                lua_pushnil(L);
                lua_insert(L, -2);  
                return 2;  
            }            
        ]];

    /*
    	Function: readfile
    	
    	Loads the contents of the given file and returns them as a string. If
    	there are any problems, it returns nil.
    	
    	Arguments:
    	
    		file_name - The name of the file to read (in your app bundle).
    		
    	Returns:
    	
    		string - The contents of the file or
    		nil - If something went wrong.
    */
    
	lstring readfile(string file_name )
		[[
			result = NULL;
			result_len = 0;
			
            bool is_uri=false;
            
            char * path=App::get(L)->normalize_path(file_name,&is_uri);
            
            FreeLater free_later(path);
            
            if ( path && ! is_uri )
            {
            	gsize length = 0;
            	
            	gchar * contents = NULL;
            	
            	if ( g_file_get_contents( path, & contents, & length, NULL ) )
            	{
            		result = contents;
            		result_len = length;
            		
            		free_later( contents );
            	} 
            }                        
		]];       
        
    /*
    	Function: exit
    	
    	Exits/closes the app. This does not happen immediately, so exit does return control to
    	you. Your app will exit the next time through TrickPlay's event loop.
    */
    
    exit()
        [[
            App::get(L)->get_context()->close_app();        
        ]];

    /*
        Function: reload
        
        Reloads the app, as though it had been shutdown then restarted
    */

    reload()
    	[[
    		App::get(L)->get_context()->reload_app();
    	]];
        
    /*    
    	Function: launch_action
    	
    	TODO
    */
    
    multi launch_action( string app_id = NULL, string action = NULL, string uri = NULL, string type = NULL , table parameters = 0 )
    	[[
    		String serialized_parameters;
    		
    		if ( parameters )
    		{
            	lua_getglobal( L, "serialize" );
            	lua_pushvalue( L, parameters );
            	lua_call( L, 1, 1 );
            	if ( lua_isstring( L, -1 ) )
            	{
            		size_t len = 0;
            		const char * s = lua_tolstring( L, -1, &len );
            		
            		serialized_parameters = String( s, len );
            	}
            	lua_pop( L, 1 );
    		}
    		
    		
    		Actions actions( App::get( L )->get_context() );
    		String caller( App::get( L )->get_id() );
    		
    		SystemDatabase::AppActionMap matches;
    		
    		bool result = actions.launch_action( 
    			caller.c_str(), 
    			app_id, 
    			action, 
    			uri, 
    			type, 
    			serialized_parameters.empty() ? NULL : serialized_parameters.c_str(), 
    			matches );
    		
    		lua_pushboolean( L, result );
    		
			lua_newtable( L );
			
			int i = 1;
			
			for ( SystemDatabase::AppActionMap::const_iterator it = matches.begin(); it != matches.end(); ++it )
			{
				for ( App::Action::Map::const_iterator ait = it->second.begin(); ait != it->second.end(); ++ait, ++i )
				{
					lua_newtable( L );
					
					lua_pushstring( L, it->first.c_str() );
					lua_setfield( L, -2, "app" );
					
					lua_pushstring( L, ait->first.c_str() );
					lua_setfield( L, -2, "action" );
					
					lua_pushstring( L, ait->second.description.c_str() );
					lua_setfield( L, -2, "description" );
					
					lua_rawseti( L, -2, i );
				} 
			}
			
			
			return 2;
    		
    	]];
      
    /*
    	Function: choose
    	
    	Receives 3 parameters. If the first one is true, it returns the second one, 
    	otherwise, it returns the third one.  Equivalent to ((expression)?(a):(b)) in C.
    	
    	Arguments:
    	
    		expression - An expression. Remember that in Lua, only false and nil evaluate to false.
    		a - The value to return if the expression is true.
    		b - The value to return if the expression is false.
    		
    	Returns:
    	
    		a - If the expression is true.
    		b - If the expression is false.
    		nil - If you pass less than 3 arguments. 
    */
      
    multi choose()
        [[
            if (lua_gettop(L)<3)
            {
                lua_pushnil(L);
            }
            else
            {
                lua_pushvalue(L,lua_toboolean(L,1)?2:3);
            }
            return 1;
        ]];

	/*
		Function: serialize
		
		Converts some Lua values to a string.  
		
		TODO cycles
		
		Arguments:
		
			value - A number, string, boolean or table.
			
		Returns:
		
			string - A string representation of the value.
	*/
	
    string serialize()
        [[
            String buffer;

            int n=1;
            
            bool pretty=false;
            int level=0;
            
            if (lua_gettop(L)>1)
            {
                pretty=lua_toboolean(L,2);
                level=lua_tointeger(L,2);                
            }
            
            switch(lua_type(L,n))
            {
                case LUA_TNUMBER:
                {
                    buffer=lua_tostring(L,n);
                    break;
                }
                
                case LUA_TSTRING:
                {
                    LSG;
                    lua_getglobal(L,"string");
                    lua_getfield(L,-1,"format");
                    lua_pushstring(L,"%q");
                    lua_pushvalue(L,n);
                    lua_call(L,2,1);
                    buffer=lua_tostring(L,-1);
                    lua_pop(L,2);
                    LSG_END(0);
                    break;
                }
                
                case LUA_TBOOLEAN:
                {
                    buffer=lua_toboolean(L,n)?"true":"false";
                    break;
                }
                
                case LUA_TTABLE:
                {
                    if (pretty)
                    {
                        buffer += "\n" + String(2*level,' ');
                    }
                    
                    buffer+="{";
                    
                    if (pretty)
                    {
                        buffer += "\n";
                    }
                    
                    // Lookup the serialize function only once
                    lua_getglobal(L,"serialize");
                    int ser=lua_gettop(L);
                    
                    // Prepare to iterate over the table
                    lua_pushnil(L);
                    
                    bool first=true;
                    
                    while (lua_next(L,n)!=0)
                    {
                        if (first)
                        {
                            first=false;
                        }
                        else
                        {
                            buffer+=",";
                            
                            if (pretty)
                            {
                                buffer += "\n";
                            }
                        }
                        
                        if (pretty)
                        {
                            buffer += String(2*(level+1),' ');                            
                        }
                        
                        // Serialize the key
                        buffer+="[";
                        lua_pushvalue(L,ser);
                        lua_pushvalue(L,-3);
                        lua_call(L,1,1);
                        buffer+=lua_isnil(L,-1)?"nil":lua_tostring(L,-1);
                        lua_pop(L,1);
                        buffer+="]=";

                        // Serialize the value
                        lua_pushvalue(L,ser);
                        lua_pushvalue(L,-2);
                        if (pretty)
                        {
                            lua_pushinteger(L,level+1);
                            lua_call(L,2,1);
                        }
                        else
                        {
                            lua_call(L,1,1);
                        }
                        buffer+=lua_isnil(L,-1)?"nil":lua_tostring(L,-1);
                        // Pop both the result of the call as well as the value
                        // from lua_next
                        lua_pop(L,2);
                    }
                    
                    if (pretty)
                    {
                        buffer += "\n" + String(2*level,' ');
                    }

                    buffer+="}";
                    
                    lua_pop(L,1);
                    
                    break;
                }
                
                default:
                    break;
            }
            
            result=buffer.empty()?NULL:buffer.c_str();
        ]];

	/*
		Function: md5
		
		Returns the MD5 hash of the string passed in.
		
		Arguments:
		
			string - A string to hash.
			binary - If true, the result is a binary string, otherwise, it is hex.
			
		Returns:
		
			string - The MD5 hash of the string. 
	*/
	
    lstring md5( lstring s , bool binary = false )
        [[
        	String h( hash( G_CHECKSUM_MD5 , s , s_len , binary ) );
        	result = h.data();
        	result_len = h.length();
        ]];
        
	/*
		Function: sha1
		
		Returns the SHA-1 hash of the string passed in.
		
		Arguments:
		
			string - A string to hash.
			binary - If true, the result is a binary string, otherwise, it is hex.
			
		Returns:
		
			string - The SHA-1 hash of the string. 
	*/
	
    lstring sha1( lstring s , bool binary = false )
        [[
        	String h( hash( G_CHECKSUM_SHA1 , s , s_len , binary ) );
        	result = h.data();
        	result_len = h.length();
        ]];

	/*
		Function: sha256
		
		Returns the SHA-256 hash of the string passed in.
		
		Arguments:
		
			string - A string to hash.
			binary - If true, the result is a binary string, otherwise, it is hex.
			
		Returns:
		
			string - The SHA-256 hash of the string. 
	*/
	
    lstring sha256( lstring s , bool binary = false )
        [[
        	String h( hash( G_CHECKSUM_SHA256 , s , s_len , binary ) );
        	result = h.data();
        	result_len = h.length();
        ]];
        
	/*
		Function: hmac_sha1
		
		Returns the HMAC/SHA-1 hash of the key and message.
		
		Arguments:
		
			key - The key.
			message - The message.
			binary - If true, the result is a binary string, otherwise, it is hex.
			
		Returns:
		
			string - The HMAC/SHA-1 hash. 
	*/
	
    lstring hmac_sha1( lstring key , lstring message , bool binary = false)
    	[[
    		String h( hmac( G_CHECKSUM_SHA1 , key , key_len , message , message_len , binary ) );
    		result = h.data();
    		result_len = h.length();
    	]];
        
	/*
		Function: hmac_sha256
		
		Returns the HMAC/SHA-256 hash of the key and message.
		
		Arguments:
		
			key - The key.
			message - The message.
			binary - If true, the result is a binary string, otherwise, it is hex.
			
		Returns:
		
			string - The HMAC/SHA-256 hash. 
	*/

    lstring hmac_sha256( lstring key , lstring message , bool binary = false )
    	[[
    		String h( hmac( G_CHECKSUM_SHA256 , key , key_len , message , message_len , binary ) );
    		result = h.data();
    		result_len = h.length();
    	]];
    	
    /*
    	Function: base64_encode
    	
    	Encodes a string to base 64.
    	
    	Arguments:
    	
    		s - The string to encode.
    		
    	Returns:
    		
    		string - The encoded result.
    */
    
    string base64_encode( lstring s )
    	[[
    		gchar * encoded = g_base64_encode( ( const guchar * ) s , s_len ); 
    		FreeLater free_later( encoded );
    		
    		result = encoded; 
    	]];
    	
    /*
    	Function: base64_decode
    	
    	Decodes a base 64 string.
    	
    	Arguments:
    	
    		s - The string to decode.
    		
    	Returns:
    		
    		string - The decoded result.
    */

    lstring base64_decode( string s )
    	[[
    		gsize length;
    		
    		guchar * decoded = g_base64_decode( ( const gchar * ) s , & length );
    		
    		FreeLater free_later( decoded );
    		
    		result = ( const char * ) decoded;
    		result_len = length;
    	]];

	lstring uint32_to_be( int n )
		[[
			guint32 i = GUINT32_TO_BE( n );
			
			result = ( char * ) & i;
			result_len = 4;
		]];

	lstring uint32_to_le( int n )
		[[
			guint32 i = GUINT32_TO_LE( n );
			
			result = ( char * ) & i;
			result_len = 4;
		]];       

	int uint32_from_be( lstring s )
		[[
			if ( s_len >= 4 )
			{
				// TODO: Could have alignment problems
				
				result = GUINT32_FROM_BE( * ( ( guint32 * ) s ) );
			}
			else
			{
				result = 0;
			} 
		]];		

	int uint32_from_le( lstring s )
		[[
			if ( s_len >= 4 )
			{
				// TODO: Could have alignment problems
				
				result = GUINT32_FROM_LE( * ( ( guint32 * ) s ) );
			}
			else
			{
				result = 0;
			} 
		]];		

	detach( udata o )
		[[
			UserData::clear_callbacks( L , o );
		]];		       
		
	/*
		Function: dolater
		
		Posts a function and arguments for execution during the next pass of the event loop. Note
		that there is no way to receive any values returned by the function. 
		
		If the first argument is a number, it is interpreted as a number of milliseconds to wait
		before executing the function, which must be the second argument. This can act as a simple
		alternative to a timer.

		Arguments:
		
            delay - Otional. A number of milliseconds to wait.
			f - The function to execute.
			others - Any number of arguments to pass to the function.

        Example:

	    (code)

	      dolater( print , 1 ) -- Will call print as soon as it can and pass 1 as a parameter

	      dolater( 1000 , print , 1 ) -- Will call print in a second, with 1 as a parameter

	    (end)

	*/
	
	dolater( ... )
		[[
			int nargs = lua_gettop(L);

            if ( nargs > 0 )
            {
                int f = 1;
                int delay = 0;

                if ( lua_type( L , 1 ) == LUA_TNUMBER )
                {
                    delay = lua_tonumber( L , 1 );
                    ++f;
                    --nargs;
                }

                (void)lb_checkfunction( L , f );

                --nargs;

                int args = LUA_NOREF;

                // If there are args, we put them into a table and
                // get a ref to the table

                if ( nargs > 0 )
                {
                    lua_newtable(L);
                    for (int i=1; i<=nargs; ++i)
                    {
                        if ( lua_isnil( L , i+f ) )
                        {
                            lua_pushlightuserdata( L , DoLater::nil() );
                        }
                        else
                        {
                            lua_pushvalue(L,i+f);
                        }
                        lua_rawseti(L,-2,i);
                    }
                    args = luaL_ref(L,LUA_REGISTRYINDEX);
                }

                lua_pushvalue(L,f);
                int func = luaL_ref(L,LUA_REGISTRYINDEX);

                DoLater::add(L,delay,func,args);
            }
		]];
		
	/*
		Function: uuid
		
		Generates a random (v4) UUID.
		
		Returns:
		
			uuid - A new UUID.
			
	*/ 
	
	string uuid()
		[[
			String uuid( Util::make_v4_uuid() );
			
			result = uuid.c_str();
		]];
		
	/*
		Function: dumptable
		
		Prints a table to the console; for debugging purposes. It handles 
		cyclic references.
		
		Arguments:
		
			t - The table to print.
			filter - A function that receives the table, the current key and the
				recursion depth. If the function returns false, the key is not printed.
			 
	*/
	
	dumptable( table t , function filter = 0 )
		[[
			lb_dump_table(L);
		]];

	/*
        Function: time

        Returns the current time, but includes microseconds, so it has more resolution than
        os.time.

        Returns:

        time - Fractional number of seconds since the Epoch.
	*/

	double time()
        [[
            GTimeVal tv;

	        g_get_current_time( & tv );

	        result = tv.tv_sec + double( tv.tv_usec ) / G_USEC_PER_SEC;
        ]];

	/*
	    Function: timestamp

	    Returns the number of milliseconds elapsed since Trickplay was started.
	*/

	double timestamp()
        [[
            result = timestamp();
        ]];

	udata newudata( table metatable )
        [[
            lua_newuserdata( L , 4 );
	        lua_pushvalue( L , metatable );
	        lua_setmetatable( L , -2 );
        ]];

    /*
        Function: split
        
        Split the given string using delimiters, returning the result in a Lua table
        
        Arguments:
        source - The string to tokenize
        delimiter - The delimiter on which to split up the source string
        max_tokens - Optional parameter limiting the number of tokens returned.  If the limit is exceeded, the final element of the table will contain the remainder of the source String
        
        Returns:
        strings - a Lua table containing the split elements of the string, with the delimiters removed.
        
        eg. split("a,b,c,d,e",",",3) ==> { "a","b","c,d,e" }
    */

	table split( string source , string delimiter , int max_tokens = 0 )
        [[
            lua_newtable( L );

            if ( strlen( delimiter ) )
            {
                StringVector v = split_string( source , delimiter , max_tokens );

                int i = 1;

                for( StringVector::const_iterator it = v.begin(); it != v.end(); ++it , ++i )
                {
                    lua_pushstring( L , it->c_str() );
                    lua_rawseti( L , -2 , i );
                }
            }
        ]];

	string random_string( int length )
        [[
            String rs( "" );

            if ( length > 0 )
            {
                rs = Util::random_string( length );
            }

            result = rs.c_str();
        ]];
}

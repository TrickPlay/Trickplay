module bitmap;

[[
#include "common.h"
#include "images.h"
#include "app.h"
#include "network.h"

static Debug_ON log( "BITMAP" );

class Bitmap : public RefCounted
{
public:

    Bitmap( lua_State * L , const char * _src , bool _async )
    :
        src( _src ),
        image( 0 ),
        lsp( 0 )
    {
        App * app = App::get( L );

        g_assert( app );

        lsp = app->ref_lua_state_proxy();

        if ( ! _async )
        {
            image = app->load_image( _src );
        }
        else
        {
            log( "LOADING ASYNC '%s'" , _src );

            RefCounted::ref( this );

            if ( ! app->load_image_async( _src , callback , this , destroy_notify ) )
            {
                RefCounted::unref( this );
            }
        }
    }

    guint width() const
    {
        return image ? image->width() : 0;
    }

    guint height() const
    {
        return image ? image->height() : 0;
    }

    bool loaded() const
    {
        return image ? true : false;
    }

protected:

    virtual ~Bitmap()
    {
        log( "DESTROYING BITMAP %p" , this );

        if ( image )
        {
            delete image;
        }

        lsp->unref();
    }

private:

    static void callback( Image * image , gpointer me )
    {
        log( "  ASYNC DECODE COMPLETED FOR %p : %s" , me , image ? "SUCCESS" : "FAILED" );

        Bitmap * self = ( Bitmap * ) me;

        // Image will be null when it failed, otherwise, we take ownership of it

        self->image = image;

        if ( lua_State * L = self->lsp->get_lua_state() )
        {
            lua_pushboolean( L , image ? false : true );
            UserData::invoke_callback( self , "on_loaded" , 1 , 0 , L );
        }
    }

    static void destroy_notify( gpointer me )
    {
        log( "  UNREF %p" , me );

        RefCounted::unref( ( RefCounted * ) me );
    }

    String          src;
    Image *         image;
    LuaStateProxy * lsp;
};

]]

class Bitmap [[ Bitmap * ]]
{
    Bitmap( string src , bool async = false )
        [[
            self = lb_construct( Bitmap , new Bitmap( L , src , async ) );
        ]];

    ~Bitmap()
        [[
            self->unref();
        ]];

    readonly int width
        [[
            width = self->width();
        ]];

    readonly int w
        [[
            w = self->width();
        ]];

    readonly int height
        [[
            height = self->height();
        ]];

    readonly int h
        [[
            h = self->height();
        ]];

    readonly bool loaded
        [[
            loaded = self->loaded();
        ]];

    callback on_loaded( Bitmap bitmap , bool failed );
}

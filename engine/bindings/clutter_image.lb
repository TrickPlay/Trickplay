module clutter_image;

[[
#include "clutter/clutter.h"

#include "network.h"
#include "util.h"
#include "images.h"
#include "clutter_util.h"
#include "context.h"
#include "sysdb.h"
#include "thread_pool.h"
]]

[[

//-----------------------------------------------------------------------------
// A structure we attach to the image to keep track of extra stuff

struct ImageExtra
{
	static ImageExtra * get( gpointer texture )
	{
		ImageExtra * result = ( ImageExtra * ) g_object_get_data( G_OBJECT( texture ), "tp-image-extra" );
		
		if ( ! result )
		{
			result = g_new0( ImageExtra , 1 );
			
			g_object_set_data_full( G_OBJECT( texture ), "tp-image-extra", result, g_free );
		}
		
		return result;
	}
	
	int constructing;
	int loaded;
	int async;
};

//-----------------------------------------------------------------------------

static void image_load_callback( Image * image , gpointer _texture )
{
    ClutterTexture * texture = CLUTTER_TEXTURE( _texture );

    if ( ! image )
    {
        GError * error = NULL;

        g_set_error( & error,
            CLUTTER_TEXTURE_ERROR,
            CLUTTER_TEXTURE_ERROR_BAD_FORMAT,
            "Failed to load texture data");

        g_warning("FAILED TO LOAD IMAGE : %s",error->message);

        g_signal_emit_by_name( G_OBJECT( texture ), "load-finished", error );

        g_clear_error( & error );
    }
    else
    {
        ImageExtra::get( texture )->loaded = TRUE;

        Images::load_texture( texture, image );

        delete image;
    }
}

bool load_image( lua_State * L, ClutterTexture * texture )
{
	g_assert( L );
	g_assert( texture );
	
	ImageExtra * extra = ImageExtra::get( texture );
	
	//.........................................................................
	// If we are constructing, we don't load - because not all
	// properties may have been set yet.
	
	if ( extra->constructing )
	{
		return false;
	}
	
	//.........................................................................
	// Get the image source 
	
	char * src = ( char * ) g_object_get_data( G_OBJECT( texture ), "tp-src" );
	
	if ( ! src )
	{
		return false;
	}
	
	//.........................................................................
	// Synchronous loading
	
	if ( ! extra->async )
	{
	    Image * image = App::get( L )->load_image( src );

		bool result = image != 0;
		
		if ( result )
		{
		    Images::load_texture( texture , image );

		    delete image;
		}
		
		extra->loaded = result;
		
		return result;
	}

	//.........................................................................
	// Asynchronous loading
	
    extra->loaded = false;

    g_object_ref( texture );

	if ( ! App::get( L )->load_image_async( src , image_load_callback , texture , g_object_unref ) )
	{
	    g_object_unref( texture );

	    return false;
	}

	return true;
} 

void Image_on_loaded(ClutterTexture*self,gpointer error,lua_State*L);
void Image_on_size_changed(ClutterTexture*self,gint width,gint height,lua_State*L);
]]

/*
    Class: Image
    
    Images let you load and display images...wether from local files or URIs. They have
    all the functions and methods of <UIElement>.
    
    All images are, by default, loaded synchronously; you have to set the <async> property
    to true if you want to override that behavior. If you do, you can attach a function to
    the <on_loaded> event. This will tell you when, and if, the image data is loaded.   
*/

class Image [[ClutterActor*]] actor
{
    Image(table props = 0 )
        [[
            self = lb_construct_gobject( ClutterActor , ClutterUtil::make_actor( clutter_texture_new ) );
	    	ClutterUtil::initialize_actor( L, self, IMAGE_METATABLE );

	    	ImageExtra * extra = ImageExtra::get( self );
	    	 
	    	extra->constructing = TRUE;
	    	
	    	ClutterUtil::set_props_from_table( L, props );

	    	extra->constructing = FALSE;
	    	
			load_image( L, CLUTTER_TEXTURE( self ) );
			
			g_object_unref( self );	    	
        ]];
	
    ~Image()
		[[
		]];
    
    /*
    
    	Property: src
    	
    	This is a string that specifies where the image will be loaded from. It can
    	be a path into your app bundle or a URI. 
    	
    	If the <async> property is not set or is false, the image will be loaded 
    	immediately after you set this property. You can then consult the <loaded> 
    	property to make sure it was loaded succesfully.
    	
    	If the <async> property is set to true, the image will begin loading in 
    	the background and the <on_loaded> event will fire when it is finished. In the
    	meantime, the <loaded> property will be false. If you set the src more than once
    	before you receive the <on_loaded> event, there are no guarantees as to which 
    	one will be loaded last, so be careful.
    	
    	(code)
    	local my_image = Image()
    	my_image.src = "assets/foo.png"
    	(end)
    	
    	or
    	
    	(code)
    	local my_image = Image{ src = "assets/foo.png" }
    	(end)
    
    */
    
    string src
		[[
		    src=( char * ) g_object_get_data( G_OBJECT( self ), "tp-src" );
		]]
		[[
			g_object_set_data_full( G_OBJECT( self ), "tp-src", g_strdup( src ), g_free);
			
			load_image( L, CLUTTER_TEXTURE( self ) );
		]];
	
	/*
		Property: base_size
		
		This is a table containing the width and height of the image as it was when 
		you loaded it; not its current dimension on screen.
	*/
	
    readonly table base_size
		[[
		    gint w;
		    gint h;
		    clutter_texture_get_base_size(CLUTTER_TEXTURE(self),&w,&h);
		    lua_newtable(L);
		    lua_pushnumber(L,w);
		    lua_rawseti(L,-2,1);
		    lua_pushnumber(L,h);
		    lua_rawseti(L,-2,2);
		]];
	
    bool sync_size
		[[
			sync_size=clutter_texture_get_sync_size(CLUTTER_TEXTURE(self));
		]]
		[[
			clutter_texture_set_sync_size(CLUTTER_TEXTURE(self),sync_size);
		]];
	
	/*
		Property: tile
		
		This property is a table of two boolean values which determine whether the
		image will be tiled horizontally and vertically to fill its width and height.
		
		So, for example, if you load an image that is 50 pixels wide, set its
		width to 200 and tile to { true, fale }, the image will be tiled 4 times, to fill
		the 200 pixels. 
	*/
	
    table tile
		[[
		    gboolean rx;
		    gboolean ry;
		    clutter_texture_get_repeat(CLUTTER_TEXTURE(self),&rx,&ry);
		    lua_newtable(L);
		    lua_pushboolean(L,rx);
		    lua_rawseti(L,-2,1);
		    lua_pushboolean(L,ry);
		    lua_rawseti(L,-2,2);
		]]
		[[
		    (void)lb_checktable(L,2);
		    lua_rawgeti(L,2,1);
		    lua_rawgeti(L,2,2);
		    clutter_texture_set_repeat(CLUTTER_TEXTURE(self),lua_toboolean(L,-2),lua_toboolean(L,-1));
		    lua_pop(L,2);
		]];
	
    bool keep_aspect_ratio
		[[
			keep_aspect_ratio=clutter_texture_get_keep_aspect_ratio(CLUTTER_TEXTURE(self));
		]]
		[[
			clutter_texture_set_keep_aspect_ratio(CLUTTER_TEXTURE(self),keep_aspect_ratio);
		]];
	
	/*
		Property: async
		
		This is a boolean value that determines how the image is loaded. If set to true, the
		image will be loaded in the background. You should set this before you set the <src> 
		property.
	*/
	
    bool async
		[[
			async=ImageExtra::get( self )->async;
		]]
		[[
			ImageExtra::get( self )->async = async;
		]];
	
	/*
		Property: loaded
		
		This will be true if an image was loaded successfully. It can be false if the last image
		failed to load or while a new image is being loaded asynchronously. 
	*/	
	
	readonly bool loaded
		[[
			loaded = ImageExtra::get( self )->loaded;
		]];
	
    bool load_from_data(lstring data)
		[[
		    result = Images::load_texture(CLUTTER_TEXTURE(self),(gpointer)data,data_len);
		]];
	
    /*
        This one lets you get an image from another app. We may want to leave it
        undocumented. I don't think it is dangerous because we are not returning
        the data to Lua, we are just sticking it into an image.
    */

    bool load_app_icon( string app_id, string file_name )
        [[
            result = false;

            TPContext * context = App::get( L )->get_context();

            String app_path=context->get_db()->get_app_path(app_id);

            if ( !app_path.empty() )
            {
                gchar * path=Util::rebase_path( app_path.c_str() , file_name );                
	            FreeLater free_later( path );
	
                if ( path )
                {
					Image * image = context->load_icon( path );
					
	                if ( image )
	                {
	                	Images::load_texture( CLUTTER_TEXTURE( self ), image );
	                	
	                	delete image;
	
	                    result = true;
	                }
				}	              
            }

        ]];
	
	/*
		Event: on_loaded
		
		If an image is loaded asynchronously, this event will fire when it is done loading
		or if it fails to load.
		
		It is recommended that you detach this event when you are done with it by setting
		it to nil.
		
		Arguments:
		
			image - The image that finished loading.
			failed - A boolean value that is true if the image failed to load.
	*/
	
    callback on_loaded
		[[
		    UserData::get(L)->connect_signal_if(
				on_loaded,
				"on_loaded",
				"load-finished",
				G_CALLBACK(Image_on_loaded),
				L);
		]];
	
	/*
		Event: on_size_changed
		
		This event fires every time the image size changes.
		
		Arguments:
		
			image - The image that the event applies to.
			width - The new width of the image.
			height - The new height of the image.
	*/
	
    callback on_size_changed
		[[
		    UserData::get(L)->connect_signal_if(
				on_size_changed,
				"on_size_changed",
				"size-change",
				G_CALLBACK(Image_on_size_changed),
				L);	    
		]];	
}

[[
void Image_on_loaded(ClutterTexture*self,gpointer error,lua_State*L)
{
	if ( ImageExtra::get( self )->async )
	{
    	lua_pushboolean(L,error?1:0);
    	UserData::invoke_callback(G_OBJECT(self),"on_loaded",1,0,L);
    }
}

void Image_on_size_changed(ClutterTexture*self,gint width,gint height,lua_State*L)
{
    lua_pushinteger(L,width);
    lua_pushinteger(L,height);
  	UserData::invoke_callback(G_OBJECT(self),"on_size_changed",2,0,L);
}
]]


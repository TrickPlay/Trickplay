module clutter_image;

[[
#include "clutter/clutter.h"

#include "network.h"
#include "util.h"
#include "images.h"
#include "signal_collector.h"
#include "clutter_util.h"
#include "context.h"
#include "sysdb.h"
]]

[[
static void Image_destroy_image_closure(gpointer texture)
{
    g_object_unref(G_OBJECT(texture));
}

void Image_response_callback(const Network::Response & response,gpointer texture)
{
    GError * error=NULL;
    
    if (response.failed)
    {
		g_set_error(&error,
		    CLUTTER_TEXTURE_ERROR,
		    CLUTTER_TEXTURE_ERROR_BAD_FORMAT,
		    "Request failed : %s" , response.status.c_str() );	
    }
    else
    {
    	const char * content_type = NULL;
    	
    	StringMultiMap::const_iterator it = response.headers.find( "Content-Type" );
    	
    	if ( it != response.headers.end() )
    	{
    		content_type = it->second.c_str();
    	}
    	    	
		if ( ! Images::load_texture(CLUTTER_TEXTURE(texture),response.body->data,response.body->len, content_type ) )
		{
		    g_set_error(&error,
			CLUTTER_TEXTURE_ERROR,
			CLUTTER_TEXTURE_ERROR_BAD_FORMAT,
			"Failed to load texture data");
		}
    }
    
    if (error)
    {
	g_warning("Failed to load image : %s",error->message);
	g_signal_emit_by_name(G_OBJECT(texture),"load-finished",error);
	
	g_clear_error(&error);
    }
}

]]

[[
void Image_on_loaded(ClutterTexture*self,gpointer error,lua_State*L);
void Image_on_size_changed(ClutterTexture*self,gint width,gint height,lua_State*L);
]]

/*
    Class: Image 
*/

class Image [[ClutterActor*]] actor
{
    Image(table props = 0 )
        [[
            *self = clutter_texture_new();
	    ClutterUtil::initialize_actor(L,*self,IMAGE_METATABLE);
	    ClutterUtil::set_props_from_table(L,props);
	    g_object_ref_sink(G_OBJECT(*self));
        ]];
	
    ~Image()
	[[
	    g_object_unref(G_OBJECT(self));
	]];
    
    string src
	[[
	    src=(char*)g_object_get_data(G_OBJECT(self),"tp-src");
	]]
	[[
	    bool is_uri;
	    
	    App * app=App::get(L);
	    
	    char * path=app->normalize_path(src,&is_uri);
	    
	    if (path)
	    {
		Util::GFreeLater free_path(path);
    
		if (is_uri)
		{
		    Network::Request request(app->get_user_agent());
		    request.url = path;
		    
		    g_object_ref(G_OBJECT(self));
		    
		    app->get_network()->perform_request_async(
			request,
			app->get_cookie_jar(),
			Image_response_callback,
			self,
			Image_destroy_image_closure);		    
		}
		else
		{
		    if (!Images::load_texture(CLUTTER_TEXTURE(self),path))
		    {
			GError * error=NULL;

			g_set_error(&error,
			    CLUTTER_TEXTURE_ERROR,
			    CLUTTER_TEXTURE_ERROR_BAD_FORMAT,
			    "Failed to load texture data");
			
			g_signal_emit_by_name(G_OBJECT(self),"load-finished",error);
			
			g_clear_error(&error);
		    }
		}
		g_object_set_data_full(G_OBJECT(self),"tp-src",g_strdup(src),g_free);
	    }
	]];
	
    readonly table base_size
	[[
	    gint w;
	    gint h;
	    clutter_texture_get_base_size(CLUTTER_TEXTURE(self),&w,&h);
	    lua_newtable(L);
	    lua_pushnumber(L,w);
	    lua_rawseti(L,-2,1);
	    lua_pushnumber(L,h);
	    lua_rawseti(L,-2,2);
	]];
	
    bool sync_size
	[[sync_size=clutter_texture_get_sync_size(CLUTTER_TEXTURE(self));]]
	[[clutter_texture_set_sync_size(CLUTTER_TEXTURE(self),sync_size);]];
	
    table tile
	[[
	    gboolean rx;
	    gboolean ry;
	    clutter_texture_get_repeat(CLUTTER_TEXTURE(self),&rx,&ry);
	    lua_newtable(L);
	    lua_pushboolean(L,rx);
	    lua_rawseti(L,-2,1);
	    lua_pushboolean(L,ry);
	    lua_rawseti(L,-2,2);
	]]
	[[
	    lb_checktable(L,2);
	    lua_rawgeti(L,2,1);
	    lua_rawgeti(L,2,2);
	    clutter_texture_set_repeat(CLUTTER_TEXTURE(self),lua_toboolean(L,-2),lua_toboolean(L,-1));
	    lua_pop(L,2);
	]];
	
    bool keep_aspect_ratio
	[[keep_aspect_ratio=clutter_texture_get_keep_aspect_ratio(CLUTTER_TEXTURE(self));]]
	[[clutter_texture_set_keep_aspect_ratio(CLUTTER_TEXTURE(self),keep_aspect_ratio);]];
	
    bool load_async
	[[load_async=clutter_texture_get_load_async(CLUTTER_TEXTURE(self));]]
	[[clutter_texture_set_load_async(CLUTTER_TEXTURE(self),load_async);]];
	
    bool load_from_data(lstring data)
	[[
	    result=Images::load_texture(CLUTTER_TEXTURE(self),(gpointer)data,data_len);
	]];

    /*
        This one lets you get an image from another app. We may want to leave it
        undocumented. I don't think it is dangerous because we are not returning
        the data to Lua, we are just sticking it into an image.
    */

    bool load_app_icon( string app_id, string file_name )
        [[
            result = false;

            TPContext * context = App::get( L )->get_context();

            String app_path=context->get_db()->get_app_path(app_id);

            if ( !app_path.empty() )
            {
                gchar * path=Util::rebase_path( app_path.c_str() , file_name );
                Util::GFreeLater free_path( path );

                gsize length;
                int width;
                int height;
                int pitch;
                int depth;
                int bgr;

                guchar * pixels = context->load_icon( path, length, width, height, pitch, depth, bgr );

                if ( pixels )
                {
                    clutter_texture_set_from_rgb_data(
                        CLUTTER_TEXTURE( self ),
                        pixels,
                        depth == 4,
                        width,
                        height,
                        pitch,
                        depth,
                        bgr ? CLUTTER_TEXTURE_RGB_FLAG_BGR : CLUTTER_TEXTURE_NONE,
                        NULL );

                    g_free( pixels );

                    result = true;
                }
            }

        ]];
	
    callback on_loaded
	[[
	    SignalCollector::get(L)->connect_if(
		on_loaded,"on_loaded",
		self,"load-finished",G_CALLBACK(Image_on_loaded),L);
	]];
	
    callback on_size_changed
	[[
	    SignalCollector::get(L)->connect_if(
		on_size_changed,"on_size_changed",
		self,"size-change",G_CALLBACK(Image_on_size_changed),L);	    
	]];	
}

[[
void Image_on_loaded(ClutterTexture*self,gpointer error,lua_State*L)
{
    lua_pushboolean(L,error?1:0);
    invoke_Image_on_loaded(L,CLUTTER_ACTOR(self),1,0);
}

void Image_on_size_changed(ClutterTexture*self,gint width,gint height,lua_State*L)
{
    lua_pushinteger(L,width);
    lua_pushinteger(L,height);
    invoke_Image_on_size_changed(L,CLUTTER_ACTOR(self),2,0);
}
]]




module clutter_image;

[[
#include "clutter/clutter.h"

#include "network.h"
#include "util.h"
#include "images.h"
#include "clutter_util.h"
#include "context.h"
#include "sysdb.h"
#include "thread_pool.h"
]]

[[

//-----------------------------------------------------------------------------
// A structure we attach to the image to keep track of extra stuff

struct ImageExtra
{
	static ImageExtra * get( gpointer texture )
	{
		ImageExtra * result = ( ImageExtra * ) g_object_get_data( G_OBJECT( texture ), "tp-image-extra" );
		
		if ( ! result )
		{
			result = g_new0( ImageExtra , 1 );
			
			g_object_set_data_full( G_OBJECT( texture ), "tp-image-extra", result, g_free );
		}
		
		return result;
	}
	
	int constructing;
	int loaded;
	int async;
};

//-----------------------------------------------------------------------------

static void image_load_callback( Image * image , gpointer _texture )
{
    ClutterTexture * texture = CLUTTER_TEXTURE( _texture );

    if ( ! image )
    {
        GError * error = NULL;

        g_set_error( & error,
            CLUTTER_TEXTURE_ERROR,
            CLUTTER_TEXTURE_ERROR_BAD_FORMAT,
            "Failed to load texture data");

        g_warning("FAILED TO LOAD IMAGE : %s",error->message);

        g_signal_emit_by_name( G_OBJECT( texture ), "load-finished", error );

        g_clear_error( & error );
    }
    else
    {
        ImageExtra::get( texture )->loaded = TRUE;

        Images::load_texture( texture, image );

        delete image;
    }
}

bool load_image( lua_State * L, ClutterTexture * texture )
{
	g_assert( L );
	g_assert( texture );
	
	ImageExtra * extra = ImageExtra::get( texture );
	
	//.........................................................................
	// If we are constructing, we don't load - because not all
	// properties may have been set yet.
	
	if ( extra->constructing )
	{
		return false;
	}
	
	//.........................................................................
	// Get the image source 
	
	char * src = ( char * ) g_object_get_data( G_OBJECT( texture ), "tp-src" );
	
	if ( ! src )
	{
		return false;
	}
	
	//.........................................................................
	// Synchronous loading
	
	if ( ! extra->async )
	{
	    Image * image = App::get( L )->load_image( src );

		bool result = image != 0;
		
		if ( result )
		{
		    Images::load_texture( texture , image );

		    delete image;
		}
		
		extra->loaded = result;
		
		return result;
	}

	//.........................................................................
	// Asynchronous loading
	
    extra->loaded = false;

    g_object_ref( texture );

	if ( ! App::get( L )->load_image_async( src , image_load_callback , texture , g_object_unref ) )
	{
	    g_object_unref( texture );

	    return false;
	}

	return true;
} 

void Image_on_loaded(ClutterTexture*self,gpointer error,lua_State*L);
void Image_on_size_changed(ClutterTexture*self,gint width,gint height,lua_State*L);
]]

/*
    Class: Image
    
    The Image data type handles operations associated with image files, such as 
    their loading and display.
    
    In addition to the properties and functions described on this page, the 
    Image data type also supports all the properties and functions defined in 
    the <UIElement> interface.

*/

class Image [[ClutterActor*]] actor
{
    Image(table props = 0 )
        [[
            self = lb_construct_gobject( ClutterActor , ClutterUtil::make_actor( clutter_texture_new ) );
	    	ClutterUtil::initialize_actor( L, self, IMAGE_METATABLE );

	    	ImageExtra * extra = ImageExtra::get( self );
	    	 
	    	extra->constructing = TRUE;
	    	
	    	ClutterUtil::set_props_from_table( L, props );

	    	extra->constructing = FALSE;
	    	
			load_image( L, CLUTTER_TEXTURE( self ) );
			
			g_object_unref( self );	    	
        ]];
	
    ~Image()
		[[
		]];
    
    /*
    
    	Property: src
    	
    	The src property is a string that references an image file. The string
    	may refer to either a path in your application bundle or a URI.
    	
    	Setting the src property also begins the process of loading the image.
    	By default, image loading is performed synchronously. To determine the
    	success or failure of a synchronous load, you can check the <loaded> 
    	property immediately after setting the src property.
    	
    	Asynchronous image loading is supported by setting the async
    	property prior to setting the src property. For instructions on 
    	handling asynchonous image loading, refer to the <async> property.
    	
    	*Default Setting:* nil
    	
    	*Examples:* Create an Image object and load its associated image synchronously
    	
    	(code)
    	local myImage = Image()
    	myImage.src = "assets/foo.png"		-- load image synchronously
    	if myImage.loaded == false then
    	  -- Image not loaded; insert error-handling code here
    	end
    	(end)
    	
    	(code)
    	-- Same as above, but combining object creation and
    	-- the setting of the src property in a single statement
    	local myImage = Image{ src = "assets/foo.png" }
    	if myImage.loaded == false then
    	  -- Insert error-handling code here
    	end
    	(end)
    	
    	*See Also:* the <loaded> property, the <async> property
    	    
    */
    
    string src
		[[
		    src=( char * ) g_object_get_data( G_OBJECT( self ), "tp-src" );
		]]
		[[
			g_object_set_data_full( G_OBJECT( self ), "tp-src", g_strdup( src ), g_free);
			
			load_image( L, CLUTTER_TEXTURE( self ) );
		]];
	
	/*
		Property: base_size
		
		The base_size is a table that contains two integer values that specify
		the image's original width and height, in that order, in pixels.
		
		The base_size property is set automatically as part of the image-loading
		operation. Its values can be retrieved, but they cannot be set.
		
		Notice that the image's display width and height may change during
		the execution of your application, but the base_size values will remain
		set to the image's original size.
		
		*Default Setting:* Before the image has been loaded: nil.
		
		*See Also:* the <src> property
		
	*/
	
    readonly table base_size
		[[
		    gint w;
		    gint h;
		    clutter_texture_get_base_size(CLUTTER_TEXTURE(self),&w,&h);
		    lua_newtable(L);
		    lua_pushnumber(L,w);
		    lua_rawseti(L,-2,1);
		    lua_pushnumber(L,h);
		    lua_rawseti(L,-2,2);
		]];
	
    bool sync_size
		[[
			sync_size=clutter_texture_get_sync_size(CLUTTER_TEXTURE(self));
		]]
		[[
			clutter_texture_set_sync_size(CLUTTER_TEXTURE(self),sync_size);
		]];
	
	/*
		Property: tile
		
		The tile property is a table containing two boolean values that specify 
		whether the image should be tiled horizontally and/or vertically. An 
		image may be tiled if its actual size is less than the size of the area 
		it needs to fill.
		
		The image area to fill is defined by setting the Image object's 
		width and height properties.

		If tiling is activated, the image will tile as many times as necessary 
		to fill the area. For example, an image that is 50 pixels wide and 
		whose width property is 200 pixels will tile four times to fill the 
		entire width. Given the same scenario, but with tiling not activated, 
		the image will display one time and the remaining space will remain 
		empty.
		
		*Default Settings:* tile = { false, false }
		
		*Example:* Activate horizontal tiling
		
		(code)
		mImage.tile = { true, false }	-- horizontal tiling active, vertical tiling inactive
		(end)
		
		*See Also:* the <UIElement.width> and <UIElement.height> properties
		
	*/
	
    table tile
		[[
		    gboolean rx;
		    gboolean ry;
		    clutter_texture_get_repeat(CLUTTER_TEXTURE(self),&rx,&ry);
		    lua_newtable(L);
		    lua_pushboolean(L,rx);
		    lua_rawseti(L,-2,1);
		    lua_pushboolean(L,ry);
		    lua_rawseti(L,-2,2);
		]]
		[[
		    (void)lb_checktable(L,2);
		    lua_rawgeti(L,2,1);
		    lua_rawgeti(L,2,2);
		    clutter_texture_set_repeat(CLUTTER_TEXTURE(self),lua_toboolean(L,-2),lua_toboolean(L,-1));
		    lua_pop(L,2);
		]];
	
    bool keep_aspect_ratio
		[[
			keep_aspect_ratio=clutter_texture_get_keep_aspect_ratio(CLUTTER_TEXTURE(self));
		]]
		[[
			clutter_texture_set_keep_aspect_ratio(CLUTTER_TEXTURE(self),keep_aspect_ratio);
		]];
	
	/*
		Property: async
		
		The async property is a boolean value that determines whether the image
		is loaded synchronously (async == nil or async == false) or 
		asynchronously (async == true).
		
		Asynchronously-loaded images enable your application to continue to run 
		while the image is loading. After the image is completely loaded, your 
		application is notified by firing the Image object's on_loaded() event 
		handler. The event handler can then perform any applicable operations, 
		such as resize or display the image.
		
		After starting one asynchronous load, it is possible for your 
		application to begin a second image-load  (synchronous or 
		asynchronous) before the first load completes. There is no guarantee, 
		however, that load operations will complete in the same order in which 
		they were started; it is possible that the second load will finish 
		before the first load. Therefore, your code should not contain any
		assumptions about the order in which images finish loading.
		
		To load the image asynchronously, the async property must be initialized
		prior to beginning the load operation. The load operation is then started
		by setting the src property. The example code below demonstrates the required
		operations.
		
		*Default Setting:* false, i.e., images are loaded synchronously
		
		*Example:* Load an image asynchronously
		
		(code)
		-- Create an Image object
		local myImage = Image()
		myImage.async = true		-- will load image asynchronously

		-- Define event handler
		function on_loadedHandler( loadedImage, failed )
		  -- Best practice is to unhook the handler after it has served its purpose
		  loadedImage.on_loaded = nil

		  if failed then
		    -- Image did not load; insert handling code here
		  else
		    -- Image is loaded; insert any applicable operations here
		  end
		end

		-- Hook our event handler to the Image object
		myImage.on_loaded = on_loadedHandler

		-- Start loading the image asynchronously
		myImage.src = "images/SplashScreen.png"
		(end)
		
		*See Also:* the <on_loaded> event handler, the <src> property
	*/
	
    bool async
		[[
			async=ImageExtra::get( self )->async;
		]]
		[[
			ImageExtra::get( self )->async = async;
		]];
	
	/*
		Property: loaded
		
		The boolean loaded property indicates the success/true or failure/false
		of the image's synchronous-load operation.
		
		The loaded property will also be set to false while an image is loading
		asynchronously. This may make it tempting to intermittently poll the 
		loaded property to determine if the image has finished loading, but you 
		should not do this because the loaded property can also be set to false 
		due to the load operation failing; in such a scenario, your polling 
		application will wait forever for the property to become true. Instead, 
		you should set up an on_loaded() event handler to notify your 
		application when an asynchronous-load operation has completed.
		
		*Default Setting:* false
		
		*Example:* To see the loaded property in use, check the code example 
		given in the <src> property.
		
		*See Also:* the <src> property
	*/	
	
	readonly bool loaded
		[[
			loaded = ImageExtra::get( self )->loaded;
		]];
	
    bool load_from_data(lstring data)
		[[
		    result = Images::load_texture(CLUTTER_TEXTURE(self),(gpointer)data,data_len);
		]];
	
    /*
        This one lets you get an image from another app. We may want to leave it
        undocumented. I don't think it is dangerous because we are not returning
        the data to Lua, we are just sticking it into an image.
    */

    bool load_app_icon( string app_id, string file_name )
        [[
            result = false;

            TPContext * context = App::get( L )->get_context();

            String app_path=context->get_db()->get_app_path(app_id);

            if ( !app_path.empty() )
            {
                gchar * path=Util::rebase_path( app_path.c_str() , file_name );                
	            FreeLater free_later( path );
	
                if ( path )
                {
					Image * image = context->load_icon( path );
					
	                if ( image )
	                {
	                	Images::load_texture( CLUTTER_TEXTURE( self ), image );
	                	
	                	delete image;
	
	                    result = true;
	                }
				}	              
            }

        ]];
	
	/*
		Event: on_loaded
		
		The on_loaded() event handler is fired when an asynchronously-loaded 
		image has finished loading.
		
		*Prototype:*
		
		(code)
		void on_loaded( Image loadedImage, boolean failed )
		(end)
		
		*Arguments:*
		
		loadedImage - the Image object that has finished loading
		failed - boolean value indicating failure/true or success/false of the 
		load operation
		
		*Return Value:* None
		
		When you are finished with the event handler, it is a recommended best
		practice to set it to nil.
		
		*Default Setting:* nil
		
		*Example:* To see a code sample that uses the on_loaded() event handler,
	    refer to the <async> property.
		
		*See Also:* the <async> property, the <src> property
		
	*/
	
    callback on_loaded
		[[
		    UserData::get(L)->connect_signal_if(
				on_loaded,
				"on_loaded",
				"load-finished",
				G_CALLBACK(Image_on_loaded),
				L);
		]];
	
	/*
		Event: on_size_changed
		
		The on_size_changed() event handler is fired in the following 
		situations: (1) after the object's first image is loaded, and (2) after 
		the object loads a subsequent image whose size differs from the 
		previously-loaded image.
		
		The event handler is *not* fired by changing the image's display size, 
		for example, by scaling the image or altering its width or height 
		properties in any way. The handler is also not fired if a 
		subsequently-loaded image is the same size as the previously-loaded 
		image.
		
		*Prototype:*
		
		(code)
		void on_size_changed( Image changedImage, int newWidth, int newHeight )
		(end)
		
		*Arguments:*
		
		changedImage - the Image object that has changed size
		newWidth - integer width in pixels of the loaded image
		newHeight - integer height in pixels of the loaded image

		*Return Value:* None
		
		*Default Setting:* nil
		
		*Example:*

		(code)
		-- Create an Image object
		local myImage = Image()

		-- Define event handler
		function on_changeHandler( changedImage, newWidth, newHeight )
		  -- Perform any desired operations here. For example...

		  -- Get current tile settings
		  local tile = changedImage.tile

		  -- Will new size fit horizontally in display area?
		  if( newWidth < changedImage.width )then
		    -- No, image is too small, so tile the image horizontally
		    tile[ 1 ] = true
		  end

		  -- Will image fit vertically?
		  if( newHeight < changedImage.height )then
		    -- No, so tile the image vertically
		    tile[ 2 ] = true
		  end

		  -- Apply any changed tile settings
		  changedImage.tile = tile
		end

		-- Hook our event handler into the Image object
		myImage.on_size_changed = on_changeHandler
        (end)
	*/
	
    callback on_size_changed
		[[
		    UserData::get(L)->connect_signal_if(
				on_size_changed,
				"on_size_changed",
				"size-change",
				G_CALLBACK(Image_on_size_changed),
				L);	    
		]];	
}

[[
void Image_on_loaded(ClutterTexture*self,gpointer error,lua_State*L)
{
	if ( ImageExtra::get( self )->async )
	{
    	lua_pushboolean(L,error?1:0);
    	UserData::invoke_callback(G_OBJECT(self),"on_loaded",1,0,L);
    }
}

void Image_on_size_changed(ClutterTexture*self,gint width,gint height,lua_State*L)
{
    lua_pushinteger(L,width);
    lua_pushinteger(L,height);
  	UserData::invoke_callback(G_OBJECT(self),"on_size_changed",2,0,L);
}
]]


module clutter_image;

[[
#include "clutter/clutter.h"

#include "network.h"
#include "util.h"
#include "images.h"
#include "signal_collector.h"
#include "clutter_util.h"
#include "context.h"
#include "sysdb.h"
#include "thread_pool.h"
]]

[[

//-----------------------------------------------------------------------------
// A structure we attach to the image to keep track of extra stuff

struct ImageExtra
{
	static ImageExtra * get( gpointer texture )
	{
		ImageExtra * result = ( ImageExtra * ) g_object_get_data( G_OBJECT( texture ), "tp-image-extra" );
		
		if ( ! result )
		{
			result = g_new0( ImageExtra , 1 );
			
			g_object_set_data_full( G_OBJECT( texture ), "tp-image-extra", result, g_free );
		}
		
		return result;
	}
	
	int constructing;
	int loaded;
	int async;
};

//-----------------------------------------------------------------------------
// ThreadPool task that decodes images

class DecodeTask : public ThreadPool::Task
{
public:

	DecodeTask( const char * _path, ClutterTexture * _texture )
	:
		path( _path ),
		texture( _texture ),
		image( NULL )
	{
		g_object_ref( G_OBJECT( texture ) );		
	}

	DecodeTask( const Network::Response & _response, ClutterTexture * _texture )
	:
		response( _response ),
		texture( _texture ),
		image( NULL )
	{
		g_object_ref( G_OBJECT( texture ) );
	}
	
	~DecodeTask()
	{
		g_object_unref( G_OBJECT( texture ) );

		if ( image )
		{
			delete image;
		}
	}
	
	virtual void process()
	{
		if ( ! path.empty() )
		{
			image = Image::decode( path.c_str() ); 
		}
		else
		{
	    	image = Image::decode( response.body->data, response.body->len, response.get_header( "Content-Type" ) );
	    }
	}
	
	virtual void process_main_thread()
	{
		if ( ! image )
		{
			GError * error = NULL;
		
		    g_set_error(&error,
				CLUTTER_TEXTURE_ERROR,
				CLUTTER_TEXTURE_ERROR_BAD_FORMAT,
				"Failed to load texture data");
				
			g_warning("FAILED TO LOAD IMAGE : %s",error->message);
			
			g_signal_emit_by_name( G_OBJECT( texture ), "load-finished", error );
			
			g_clear_error( &error );
		}
		else
		{
			ImageExtra::get( texture )->loaded = TRUE;

			Images::load_texture( texture, image );
		}		
	} 
	
	static void push( DecodeTask * task )
	{
		static ThreadPool * thread_pool = NULL;
		
		if ( ! thread_pool )
		{
			thread_pool = new ThreadPool( 2 );
		}
		
		thread_pool->push( task );
	}
	
	String				path;
	Network::Response	response;
	ClutterTexture *  	texture;
	Image *		      	image;
};

//-----------------------------------------------------------------------------
// Callback for network requests

void Image_response_callback(const Network::Response & response,gpointer texture)
{
    if ( response.failed )
    {
    	GError * error=NULL;
    
		g_set_error(&error,
		    CLUTTER_TEXTURE_ERROR,
		    CLUTTER_TEXTURE_ERROR_BAD_FORMAT,
		    "Request failed : %s" , response.status.c_str() );	

		g_warning("FAILED TO LOAD IMAGE : %s",error->message);
	
		g_signal_emit_by_name(G_OBJECT(texture),"load-finished",error);
	
		g_clear_error(&error);    
    }
    else
    {
    	DecodeTask::push( new DecodeTask( response , CLUTTER_TEXTURE( texture ) ) );    			
    }
}

]]

[[

bool load_image( lua_State * L, ClutterTexture * texture )
{
	g_assert( L );
	g_assert( texture );
	
	ImageExtra * extra = ImageExtra::get( texture );
	
	//.........................................................................
	// If we are constructing, we don't load - because not all
	// properties may have been set yet.
	
	if ( extra->constructing )
	{
		return false;
	}
	
	//.........................................................................
	// Get the image source 
	
	char * src = ( char * ) g_object_get_data( G_OBJECT( texture ), "tp-src" );
	
	if ( ! src )
	{
		return false;
	}
	
	//.........................................................................
	// Sanitize it, convert it to an app path or determine whether it is a valid
	// uri.
	
    App * app = App::get( L );

    bool is_uri = false;
    
    char * path = app->normalize_path( src, & is_uri );
    
    if ( ! path ) 
    {
    	return false;
    }
    
    FreeLater free_later( path );

	//.........................................................................
	// Synchronous loading
	
	if ( ! extra->async )
	{
		bool result = false;
		
		if ( is_uri )
		{
			Network::Request request( app->get_user_agent(), path );

			Network::Response response = app->get_network()->perform_request( request, app->get_cookie_jar() );
			
			if ( ! response.failed )
			{
				result = Images::load_texture( texture, response.body->data, response.body->len, response.get_header( "Content-Type" ) );
			}
		}
		else
		{
			result = Images::load_texture( texture, path );
		}
		
		extra->loaded = result;
		
		return result;
	}

	//.........................................................................
	// Asynchronous loading
	
	if ( is_uri )
	{
		Network::Request request( app->get_user_agent(), path );
		
		g_object_ref( G_OBJECT( texture ) );
		    
		app->get_network()->perform_request_async(
			request,
			app->get_cookie_jar(),
			Image_response_callback,
			texture,
			g_object_unref );		    
	}
	else
	{
		DecodeTask::push( new DecodeTask( path, texture ) );
	} 
	
	extra->loaded = false;
	
	return true;
} 

void Image_on_loaded(ClutterTexture*self,gpointer error,lua_State*L);
void Image_on_size_changed(ClutterTexture*self,gint width,gint height,lua_State*L);
]]

/*
    Class: Image 
*/

class Image [[ClutterActor*]] actor
{
    Image(table props = 0 )
        [[
            *self = clutter_texture_new();
	    	g_object_ref_sink( G_OBJECT( *self ) );
	    	ClutterUtil::initialize_actor( L, *self, IMAGE_METATABLE );
	    	
	    	ImageExtra * extra = ImageExtra::get( *self );
	    	 
	    	extra->constructing = TRUE;
	    	
	    	ClutterUtil::set_props_from_table( L, props );

	    	extra->constructing = FALSE;
	    	
			load_image( L, CLUTTER_TEXTURE( * self ) );	    	
        ]];
	
    ~Image()
		[[
		    g_object_unref( G_OBJECT( self ) );
		]];
    
    string src
		[[
		    src=( char * ) g_object_get_data( G_OBJECT( self ), "tp-src" );
		]]
		[[
			g_object_set_data_full( G_OBJECT( self ), "tp-src", g_strdup( src ), g_free);
			
			load_image( L, CLUTTER_TEXTURE( self ) );
		]];
	
    readonly table base_size
		[[
		    gint w;
		    gint h;
		    clutter_texture_get_base_size(CLUTTER_TEXTURE(self),&w,&h);
		    lua_newtable(L);
		    lua_pushnumber(L,w);
		    lua_rawseti(L,-2,1);
		    lua_pushnumber(L,h);
		    lua_rawseti(L,-2,2);
		]];
	
    bool sync_size
		[[
			sync_size=clutter_texture_get_sync_size(CLUTTER_TEXTURE(self));
		]]
		[[
			clutter_texture_set_sync_size(CLUTTER_TEXTURE(self),sync_size);
		]];
	
    table tile
		[[
		    gboolean rx;
		    gboolean ry;
		    clutter_texture_get_repeat(CLUTTER_TEXTURE(self),&rx,&ry);
		    lua_newtable(L);
		    lua_pushboolean(L,rx);
		    lua_rawseti(L,-2,1);
		    lua_pushboolean(L,ry);
		    lua_rawseti(L,-2,2);
		]]
		[[
		    lb_checktable(L,2);
		    lua_rawgeti(L,2,1);
		    lua_rawgeti(L,2,2);
		    clutter_texture_set_repeat(CLUTTER_TEXTURE(self),lua_toboolean(L,-2),lua_toboolean(L,-1));
		    lua_pop(L,2);
		]];
	
    bool keep_aspect_ratio
		[[
			keep_aspect_ratio=clutter_texture_get_keep_aspect_ratio(CLUTTER_TEXTURE(self));
		]]
		[[
			clutter_texture_set_keep_aspect_ratio(CLUTTER_TEXTURE(self),keep_aspect_ratio);
		]];
	
    bool async
		[[
			async=ImageExtra::get( self )->async;
		]]
		[[
			ImageExtra::get( self )->async = async;
		]];
		
	readonly bool loaded
		[[
			loaded = ImageExtra::get( self )->loaded;
		]];
	
    bool load_from_data(lstring data)
		[[
		    result = Images::load_texture(CLUTTER_TEXTURE(self),(gpointer)data,data_len);
		]];
	
    /*
        This one lets you get an image from another app. We may want to leave it
        undocumented. I don't think it is dangerous because we are not returning
        the data to Lua, we are just sticking it into an image.
    */

    bool load_app_icon( string app_id, string file_name )
        [[
            result = false;

            TPContext * context = App::get( L )->get_context();

            String app_path=context->get_db()->get_app_path(app_id);

            if ( !app_path.empty() )
            {
                gchar * path=Util::rebase_path( app_path.c_str() , file_name );                
	            FreeLater free_later( path );
	
                if ( path )
                {
					Image * image = context->load_icon( path );
					
	                if ( image )
	                {
	                	Images::load_texture( CLUTTER_TEXTURE( self ), image );
	                	
	                	delete image;
	
	                    result = true;
	                }
				}	              
            }

        ]];
	
    callback on_loaded
		[[
		    SignalCollector::get(L)->connect_if(
				on_loaded,
				"on_loaded",
				self,
				"load-finished",
				G_CALLBACK(Image_on_loaded),
				L);
		]];
	
    callback on_size_changed
		[[
		    SignalCollector::get(L)->connect_if(
				on_size_changed,
				"on_size_changed",
				self,
				"size-change",
				G_CALLBACK(Image_on_size_changed),
				L);	    
		]];	
}

[[
void Image_on_loaded(ClutterTexture*self,gpointer error,lua_State*L)
{
	if ( ImageExtra::get( self )->async )
	{
    	lua_pushboolean(L,error?1:0);
    	invoke_Image_on_loaded(L,CLUTTER_ACTOR(self),1,0);
    }
}

void Image_on_size_changed(ClutterTexture*self,gint width,gint height,lua_State*L)
{
    lua_pushinteger(L,width);
    lua_pushinteger(L,height);
    invoke_Image_on_size_changed(L,CLUTTER_ACTOR(self),2,0);
}
]]


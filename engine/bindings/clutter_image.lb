module clutter_image;

[[
#include "clutter/clutter.h"

#include "network.h"
#include "util.h"
#include "images.h"
#include "signal_collector.h"
#include "clutter_util.h"
]]

[[
#if TP_USE_GDK_PIXBUF

struct ImageClosure
{
    ImageClosure(ClutterTexture*i)
    :
	image(i),
	loader(gdk_pixbuf_loader_new()),
	error(NULL)
    {
	g_assert(image);
	g_assert(loader);
	g_object_ref(G_OBJECT(image));
    }
    
    ~ImageClosure()
    {
	g_object_unref(G_OBJECT(image));
	gdk_pixbuf_loader_close(loader,NULL);
	g_object_unref(G_OBJECT(loader));
	g_clear_error(&error);
    }
    
    ClutterTexture * 	image;
    GdkPixbufLoader * 	loader;
    GError * 		error;
};

static void Image_destroy_image_closure(gpointer ic)
{
    delete (ImageClosure*)ic;
}

// This one gets called directly by the network thread every time
// we get a piece of the body - we take advantage of the thread to
// decode the image one chunk at a time.

bool Image_incremental_response_callback(const Network::Response & response,gpointer body,guint len,bool finished,gpointer user)
{
    ImageClosure * closure=(ImageClosure*)user;
    
    // If it is finished, we are running in the main thread, otherwise, we are
    // running in the network thread.
    
    if (finished)
    {
	if (response.failed && !closure->error)
	{
	    g_set_error(&closure->error,
		CLUTTER_TEXTURE_ERROR,
		CLUTTER_TEXTURE_ERROR_BAD_FORMAT,
		"Request failed : %s" , response.status.c_str() );
	}
	
	// Close the loader. If there is an error already, we pass NULL
	// so that we retain the old error - the loader has to be closed
	// either way. Otherwise, we pass the error address so that close
	// has a chance to fail.
	
	gdk_pixbuf_loader_close(closure->loader,closure->error?NULL:&closure->error);

	if (!closure->error)
	{
	    GdkPixbuf * p = gdk_pixbuf_loader_get_pixbuf(closure->loader);
	    
	    if (p)
	    {
		if ( ! clutter_texture_set_from_rgb_data(closure->image,
		    gdk_pixbuf_get_pixels(p),
		    gdk_pixbuf_get_has_alpha(p),
		    gdk_pixbuf_get_width(p),
		    gdk_pixbuf_get_height(p),
		    gdk_pixbuf_get_rowstride(p),
		    gdk_pixbuf_get_has_alpha(p)?4:3,
		    CLUTTER_TEXTURE_NONE,NULL))
		{
		    g_set_error(&closure->error,
			CLUTTER_TEXTURE_ERROR,
			CLUTTER_TEXTURE_ERROR_BAD_FORMAT,
			"Failed to set texture data");
		}
	    }
	    else
	    {
		g_set_error(&closure->error,
		    CLUTTER_TEXTURE_ERROR,
		    CLUTTER_TEXTURE_ERROR_BAD_FORMAT,
		    "Failed to get pixbuf from loader");
	    }
	}
	
	if (closure->error)
	{
	    g_warning("Failed to load image : %s",closure->error->message);
	    g_signal_emit_by_name(G_OBJECT(closure->image),"load-finished",closure->error);	
	}
    }
    else
    {
	// If there was an error already, we do nothing
	
	if (!closure->error)
	{
	    gdk_pixbuf_loader_write(closure->loader,(const guchar*)body,len,&closure->error);    
	}
    }
    
    // If there is no error, we return true to carry on
    
    return !closure->error;
}
#else

static void Image_destroy_image_closure(gpointer texture)
{
    g_object_unref(G_OBJECT(texture));
}

void Image_response_callback(const Network::Response & response,gpointer texture)
{
    GError * error=NULL;
    
    if (response.failed)
    {
	g_set_error(&error,
	    CLUTTER_TEXTURE_ERROR,
	    CLUTTER_TEXTURE_ERROR_BAD_FORMAT,
	    "Request failed : %s" , response.status.c_str() );	
    }
    else
    {
	if (!Images::load_texture_from_data(CLUTTER_TEXTURE(texture),response.body->data,response.body->len))
	{
	    g_set_error(&error,
		CLUTTER_TEXTURE_ERROR,
		CLUTTER_TEXTURE_ERROR_BAD_FORMAT,
		"Failed to load texture data");
	}
    }
    
    if (error)
    {
	g_warning("Failed to load image : %s",error->message);
	g_signal_emit_by_name(G_OBJECT(texture),"load-finished",error);
	
	g_clear_error(&error);
    }
}

#endif


]]

[[
void Image_on_loaded(ClutterTexture*self,gpointer error,lua_State*L);
void Image_on_size_changed(ClutterTexture*self,gint width,gint height,lua_State*L);
]]

class Image [[ClutterActor*]] actor
{
    Image(table props = 0 )
        [[
            *self = clutter_texture_new();
	    ClutterUtil::initialize_actor(L,*self,IMAGE_METATABLE);
	    ClutterUtil::set_props_from_table(L,props);
	    g_object_ref_sink(G_OBJECT(*self));
        ]];
	
    ~Image()
	[[
	    g_object_unref(G_OBJECT(self));
	]];
    
    string src
	[[
	    src=(char*)g_object_get_data(G_OBJECT(self),"tp-src");
	]]
	[[
	    bool is_uri;
	    
	    App * app=App::get(L);
	    
	    char * path=app->normalize_path(src,&is_uri);
	    
	    if (path)
	    {
		Util::GFreeLater free_path(path);
    
		if (is_uri)
		{
		    Network::Request request(app->get_user_agent());
		    request.url = path;
		    
#if TP_USE_GDK_PIXBUF

		    app->get_network()->perform_request_async_incremental(
			request,
			app->get_cookie_jar(),
			Image_incremental_response_callback,
			new ImageClosure(CLUTTER_TEXTURE(self)),
			Image_destroy_image_closure);
#else

		    g_object_ref(G_OBJECT(self));
		    
		    app->get_network()->perform_request_async(
			request,
			app->get_cookie_jar(),
			Image_response_callback,
			self,
			Image_destroy_image_closure);
		    
#endif		    
		}
		else
		{
#if TP_USE_GDK_PIXBUF
		    clutter_texture_set_from_file(CLUTTER_TEXTURE(self),path,NULL);
#else
		    if (!Images::load_texture_from_file(CLUTTER_TEXTURE(self),path))
		    {
			GError * error=NULL;

			g_set_error(&error,
			    CLUTTER_TEXTURE_ERROR,
			    CLUTTER_TEXTURE_ERROR_BAD_FORMAT,
			    "Failed to load texture data");
			
			g_signal_emit_by_name(G_OBJECT(self),"load-finished",error);
			
			g_clear_error(&error);
		    }
#endif
		}
		g_object_set_data_full(G_OBJECT(self),"tp-src",g_strdup(src),g_free);
	    }
	]];
	
    readonly table base_size
	[[
	    gint w;
	    gint h;
	    clutter_texture_get_base_size(CLUTTER_TEXTURE(self),&w,&h);
	    lua_newtable(L);
	    lua_pushnumber(L,w);
	    lua_rawseti(L,-2,1);
	    lua_pushnumber(L,h);
	    lua_rawseti(L,-2,2);
	]];
	
    bool sync_size
	[[sync_size=clutter_texture_get_sync_size(CLUTTER_TEXTURE(self));]]
	[[clutter_texture_set_sync_size(CLUTTER_TEXTURE(self),sync_size);]];
	
    table tile
	[[
	    gboolean rx;
	    gboolean ry;
	    clutter_texture_get_repeat(CLUTTER_TEXTURE(self),&rx,&ry);
	    lua_newtable(L);
	    lua_pushboolean(L,rx);
	    lua_rawseti(L,-2,1);
	    lua_pushboolean(L,ry);
	    lua_rawseti(L,-2,2);
	]]
	[[
	    lb_checktable(L,2);
	    lua_rawgeti(L,2,1);
	    lua_rawgeti(L,2,2);
	    clutter_texture_set_repeat(CLUTTER_TEXTURE(self),lua_toboolean(L,-2),lua_toboolean(L,-1));
	    lua_pop(L,2);
	]];
	
    bool keep_aspect_ratio
	[[keep_aspect_ratio=clutter_texture_get_keep_aspect_ratio(CLUTTER_TEXTURE(self));]]
	[[clutter_texture_set_keep_aspect_ratio(CLUTTER_TEXTURE(self),keep_aspect_ratio);]];
	
    bool load_async
	[[load_async=clutter_texture_get_load_async(CLUTTER_TEXTURE(self));]]
	[[clutter_texture_set_load_async(CLUTTER_TEXTURE(self),load_async);]];
	
    bool load_from_data(lstring data)
	[[
#if TP_USE_GDK_PIXBUF
	    result = false;
	    
	    GdkPixbufLoader * loader = gdk_pixbuf_loader_new();
	    
	    if (loader)
	    {
		if (gdk_pixbuf_loader_write(loader,(const guchar *)data,data_len,NULL))
		{
		    if (gdk_pixbuf_loader_close(loader,NULL))
		    {	    
			GdkPixbuf * p = gdk_pixbuf_loader_get_pixbuf(loader);
			
			if (p)
			{
			    if ( clutter_texture_set_from_rgb_data(CLUTTER_TEXTURE(self),
				gdk_pixbuf_get_pixels(p),
				gdk_pixbuf_get_has_alpha(p),
				gdk_pixbuf_get_width(p),
				gdk_pixbuf_get_height(p),
				gdk_pixbuf_get_rowstride(p),
				gdk_pixbuf_get_has_alpha(p)?4:3,
				CLUTTER_TEXTURE_NONE,NULL))
			    {
				result=true;
			    }
			}
		    }
		}	
		else
		{
		    gdk_pixbuf_loader_close(loader,NULL);
		}
		
		g_object_unref(G_OBJECT(loader));
	    }
#else
	    result=Images::load_texture_from_data(CLUTTER_TEXTURE(self),data,data_len);
#endif	    
	]];
	
    callback on_loaded
	[[
	    SignalCollector::get(L)->connect_if(
		on_loaded,"on_loaded",
		self,"load-finished",G_CALLBACK(Image_on_loaded),L);
	]];
	
    callback on_size_changed
	[[
	    SignalCollector::get(L)->connect_if(
		on_size_changed,"on_size_changed",
		self,"size-change",G_CALLBACK(Image_on_size_changed),L);	    
	]];	
}

[[
void Image_on_loaded(ClutterTexture*self,gpointer error,lua_State*L)
{
    lua_pushboolean(L,error?1:0);
    invoke_Image_on_loaded(L,CLUTTER_ACTOR(self),1,0);
}

void Image_on_size_changed(ClutterTexture*self,gint width,gint height,lua_State*L)
{
    lua_pushinteger(L,width);
    lua_pushinteger(L,height);
    invoke_Image_on_size_changed(L,CLUTTER_ACTOR(self),2,0);
}
]]




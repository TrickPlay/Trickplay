module xml;

[[
#include <string>

#include "expat.h"

class Parser
{
public:
    
    Parser(bool expand_namespaces)
    {
        parser=expand_namespaces ? XML_ParserCreateNS(NULL,':') : XML_ParserCreate(NULL);
        reset();
    }
    
    ~Parser()
    {
        XML_ParserFree(parser);
    }
    
    void set_encoding(const char * e)
    {
        encoding=e;
        XML_SetEncoding(parser,e);
    }
    
    const char * get_encoding() const
    {
        return encoding.c_str();
    }
    
    void reset()
    {
        XML_ParserReset(parser,encoding.empty() ? NULL : encoding.c_str());
        XML_SetElementHandler(parser,start_element_handler,end_element_handler);
        XML_SetCharacterDataHandler(parser,character_data_handler);
        XML_SetNamespaceDeclHandler(parser,start_namespace_handler,end_namespace_handler);
        char_data.clear();
    }
    
    bool parse(UserData * ud,const char * xml,size_t xml_len,bool finished)
    {
    	UserData::Handle * handle = UserData::Handle::make(ud,this);
        XML_SetUserData(parser,handle);
        bool result = XML_Parse(parser,xml,xml_len,finished);
        UserData::Handle::destroy( handle );
        if (finished)
        {
        	reset();
        }
        return result;
    }
    
protected:
    
    void flush_character_data( lua_State * L );
    
    static void start_element_handler(void *userData,const XML_Char *name,const XML_Char **atts);
    static void end_element_handler(void *userData,const XML_Char *name);
    static void character_data_handler(void *userData,const XML_Char *s,int len);
    
	static void start_namespace_handler(void *userData,const XML_Char *prefix,const XML_Char *uri);
	static void end_namespace_handler(void *userData,const XML_Char *prefix);
    
    
private:
    
    std::string encoding;
    XML_Parser parser;
    std::string char_data;
};
]]

# Class: XMLParser
# This class lets you parse XML. You simply create one, connect handlers and
# call the <parse> function. This is done in the style of eXpat.

class XMLParser [[Parser*]]
{
    # Constructor: XMLParser
    # Create an XMLParser.
    # You can create an XMLParser by passing nothing, a string for the encoding
    # or a table with some or all of its properties, like this:
    #
    # > parser=XMLParser()
    # >
    # > parser=XMLParser("UTF-8")
    # >
    # > parser=XMLParser{ encoding="UTF-8" , on_start_element=some_function }
    #
    # If you want to enable processing of namespaces, you should pass 'true' for
    # the second argument, like this:
    #
    # > parser=XMLParser( nil , true )
    #
    # When you do so, the <on_start_namespace> and <on_end_namespace> callbacks
    # will be enabled. In <on_start_element> and <on_end_element>, the tag of
    # each element will include the full URI of its namespace.
    
    XMLParser(string encoding=NULL,bool expand_namespaces=false)
        [[
            self=lb_construct(Parser,new Parser(expand_namespaces));
            
            if (lua_gettop(L)==2 && lua_istable(L,-2))
            {
                lua_pushvalue(L,-2);
                lb_set_props_from_table(L);
                lua_pop(L,1);
            }
		    else if (encoding)
		    {
			    self->set_encoding(encoding);
		    }
        ]];
        
    ~XMLParser()
        [[
            delete self;
        ]];
    
    # Property: encoding
    # Lets you get and set the encoding used by the parser.
    
    string encoding
        [[
            encoding=self->get_encoding();       
        ]]
        [[
            self->set_encoding(encoding);
        ]];
    
    # Function: parse
    # Parses XML. If you wish to parse the XML in chunks, you can
    # pass false for the second parameter and the parser will remain open - you
    # can call parse again with another chunk.
    #
    # Parameters:
    # xml - A chunk of xml
    # finished - True (the default) if this chunk of XML is the last (or only)
    # one.
    #
    # Returns:
    # true - If the chunk was parsed successfully
    # false - Otherwise
    
    bool parse(lstring xml,bool finished=true)
        [[
            result=self->parse(UserData::get(L,1),xml,xml_len,finished);
        ]];
    
    # Function: finish
    # Tells the parser that there are no more chunks of XML to parse. 
    #
    # Returns:
    # true - If the XML document was parsed successfully
    # false - Otherwise
    
    bool finish()
        [[
            result=self->parse(UserData::get(L,1),NULL,0,true);
        ]];
        
    # Event: on_start_element
    # This function gets called every time a new element is found in the XML.
    #
    # Arguments:
    # parser - The XMLParser
    # tag - The name of the new element
    # attributes - A table containing all the attributes of the new element
    
    callback on_start_element( XMLParser parser , string tag , table attributes);
    
    # Event: on_end_element
    # This function gets called every time an element is closed.
    #
    # Arguments:
    # parser - The XMLParser
    # tag - The name of the element
    
    callback on_end_element( XMLParser parser , string tag );
    
    # Event: on_character_data
    # This function gets called when there is character data for an element.
    # Note that, unlike eXpat's default behavior, character data is accumulated
    # internally before the function is invoked.
    #
    # Arguments:
    # parser - The XMLParser
    # data - The character data
    
    callback on_character_data( XMLParser parser , string data );
    
    # Event: on_start_namespace
    # This function gets called when a new namespace is detected in the document.
    # It only happens when the parser is created with expand_namespaces set to true.
    #
    # Arguments:
    # parser - The XMLParser
    # prefix - The string prefix of the namespace
    # uri - The URI of the namespace
    
    callback on_start_namespace( XMLParser parser , string prefix , string uri );
    
    # Event: on_end_namespace
    # This function gets called when a namespace goes out of scope.
    # It only happens when the parser is created with expand_namespaces set to true.
    #
    # Arguments:
    # parser - The XMLParser
    # prefix - The string prefix of the namespace

    callback on_end_namespace( XMLParser parser , string prefix );
}

[[

void Parser::flush_character_data(lua_State * L)
{
    if (!char_data.empty())
    {
        lua_pushlstring(L,char_data.data(),char_data.length());
        invoke_XMLParser_on_character_data(L,this,1,0);
        char_data.clear();
    }    
}

void Parser::start_element_handler(void *userData,const XML_Char *name,const XML_Char **atts)
{
	UserData::Handle * handle = UserData::Handle::get( userData );
	
    Parser * self=( Parser * ) handle->get_user();
    
    lua_State * L = handle->get_lua_state();
    
    self->flush_character_data(L);
    
    lua_pushstring(L,name);
    lua_newtable(L);
    while (*atts)
    {
        lua_pushstring(L,*atts++);
        lua_pushstring(L,*atts++);
        lua_settable(L,-3);
    }
    invoke_XMLParser_on_start_element(L,self,2,0);
}

void Parser::end_element_handler(void *userData,const XML_Char *name)
{
	UserData::Handle * handle = UserData::Handle::get( userData );
	
    Parser * self=( Parser * ) handle->get_user();
    
    lua_State * L = handle->get_lua_state();

    self->flush_character_data(L);
    
    lua_pushstring(L,name);
    invoke_XMLParser_on_end_element(L,self,1,0);
}

void Parser::character_data_handler(void *userData,const XML_Char *s,int len)
{
	UserData::Handle * handle = UserData::Handle::get( userData );
	
    Parser * self=( Parser * ) handle->get_user();
    
    self->char_data.append(s,len);    
}

void Parser::start_namespace_handler(void *userData,const XML_Char *prefix,const XML_Char *uri)
{
	UserData::Handle * handle = UserData::Handle::get( userData );
	
    Parser * self=( Parser * ) handle->get_user();
    
    lua_State * L = handle->get_lua_state();

    lua_pushstring(L,prefix?prefix:"");
    lua_pushstring(L,uri);
    
    invoke_XMLParser_on_start_namespace(L,self,2,0);	
}

void Parser::end_namespace_handler(void *userData,const XML_Char *prefix)
{
	UserData::Handle * handle = UserData::Handle::get( userData );
	
    Parser * self=( Parser * ) handle->get_user();
    
    lua_State * L = handle->get_lua_state();

    lua_pushstring(L,prefix?prefix:"");
    
    invoke_XMLParser_on_end_namespace(L,self,1,0);	
}

]]
module clutter_score;

[[
#include "clutter/clutter.h"

#include "util.h"
#include "clutter_util.h"
]]

[[
void Score_on_started(ClutterScore*score,lua_State*L);
void Score_on_completed(ClutterScore*score,lua_State*L);
void Score_on_paused(ClutterScore*score,lua_State*L);

// We use these signal handlers to keep the timeline alive as long as
// it is running. There is still an issue with timelines that have
// delays...while the delay is ticking away, they can get collected.

void Score_started( ClutterScore * score , gpointer )
{
    g_object_ref( score );
}

void Score_paused( ClutterScore * score , gpointer )
{
    g_object_unref( score );
}

void Score_completed( ClutterScore * score , gpointer )
{
    if ( ! clutter_score_get_loop( score ) )
    {
        g_object_unref( score );
    }
}

]]

/*
    Class: Score
    
    The Score class choreographs multiple Timeline animations. By using a Score, multiple animations can begin at the same time or one or more animations can begin when another animation completes or reaches a marked point.
    
    To create a sequence of animations, each animation must be attached to the Score object using the append() or append_at_marker() function. Animations are arranged in a parent/child relationship. When the parent animation completes, its immediate children, if any, begin. Multiple levels of parent/child relationships can be defined. An animation with no parent begins running as soon as the Score starts. Scores can also loop, so following the completion of the last child animation, the initial parent animation will begin again. A Score can also be prematurely stopped or temporarily paused and then restarted or rewound to its beginning.
    
    The program is notified during various stages of the Score's running by the firing of event handlers. For example, when all the animations in the Score have completed, the object's on_completed() event handler is called. Additional event handlers are fired when the Score starts running and whenever the Score is paused.
    
    *Code Example:* The following example creates three Timeline animations and sequences them using a Score so that each animation runs one after the other. All of the code related to the Score is at the very end of the example.
    
(code)    
-- Create a screen background
bckgnd = Canvas( 1920, 1080 )
bckgnd:set_source_color( "ffffffFF" )
bckgnd:paint()
bckgndImage = bckgnd:Image()
bckgndImage.name = "Background"
screen:add( bckgndImage )

-- Create a rectangular demo area
demoArea = Rectangle {
				color = { 100, 100, 100, 255 },
				border_color = { 0, 0, 0, 255 },
				border_width = 4,
				name = "demoArea",
				position = { 96, 96, 0 },
				size = { 308, 308 },
				opacity = 255,
			}
screen:add( demoArea )

-- Create clone demo areas
demoArea2 = Clone { 
				source = demoArea,
				name = "demoArea2",
				position = { 421, 96, 0 },
			}
screen:add( demoArea2 )

demoArea3 = Clone {
				source = demoArea,
				name = "demoArea3",
				position = { 746, 96, 0 },
			}
screen:add( demoArea3 )

-- Create a sphere image using Canvas
sphere = Canvas( 40, 40 )
sphere:set_source_radial_pattern( 12, 12, 2, 20, 20, 20 )
sphere:add_source_pattern_color_stop( 0.0, "d00000FF" )
sphere:add_source_pattern_color_stop( 1.0, "000000FF" )
sphere:arc( 20, 20, 20, 0, 360 )
sphere:fill()

-- Convert Canvas object to Image object and show on the screen
sphereImage = sphere:Image()
sphereImage.position = { 100, 100 }
sphereImage.name = "Sphere"
screen:add( sphereImage )

-- Create clone sphere images
sphereImage2 = Clone {
				source = sphereImage,
				name = "Sphere2",
				position = { 555, 100, 0 },
			}
screen:add( sphereImage2 )

sphereImage3 = Clone {
				source = sphereImage,
				name = "Sphere3",
				position = { 880, 100, 0 },
			}
screen:add( sphereImage3 )

-- Define an Interval for our animation
sphereInterval  = Interval( 100, 400 - 40 )

-- Define an Alpha mode for our animation
sphereAlpha  = Alpha { mode = "EASE_IN_OUT_QUINT" }
sphereAlpha2 = Alpha { mode = "EASE_OUT_ELASTIC" }
sphereAlpha3 = Alpha { mode = "EASE_IN_OUT_ELASTIC" }

-- Animate the spheres with Timelines
sphereTL = Timeline { duration = 3000 }
sphereTL2 = Timeline { duration = 1500 }
sphereTL3 = Timeline { duration = 1500 }
			
-- Hook the Alphas to the Timelines
sphereAlpha.timeline  = sphereTL
sphereAlpha2.timeline = sphereTL2
sphereAlpha3.timeline = sphereTL3

--Define a Path for the first sphere
spherePath = Path( "M100 100 l30 0 l30 260 l30 -200 l30 200 l30 -100 l30 100 l30 -25 l30 25 L360 360" )

function sphereTL:on_new_frame( msecs, progress )
	sphereImage.position = spherePath:get_position( sphereAlpha.alpha )
end

function sphereTL2:on_new_frame( msecs, progress )
	sphereImage2.y = sphereInterval:get_value( sphereAlpha2.alpha )
end

function sphereTL3:on_new_frame( msecs, progress )
	sphereImage3.y = sphereInterval:get_value( sphereAlpha3.alpha )
end

-- ****** Score-related code ******
-- Create a looping Score with each animation running one after the other
sphereScore = Score{ loop = true }
sphereScore:append( nil, sphereTL )         -- start this Timeline first
sphereScore:append( sphereTL, sphereTL2 )   -- start this Timeline after first Timeline completes
sphereScore:append( sphereTL2, sphereTL3 )  -- start this Timeline after second Timeline completes

-- Start the Score
sphereScore:start()
(end)

The sequentially-running animations created by the example code are shown below.

(see scoreDemo.gif)

*/

class Score [[ClutterScore*]]
{
    Score(table props = 0)
	[[
		self=clutter_score_new();
		g_object_ref(self);
		self=lb_construct_gobject(ClutterScore,self);
    	ClutterUtil::set_props_from_table(L,props);

    	g_signal_connect( self , "started" , ( GCallback ) Score_started , 0 );
    	g_signal_connect( self , "paused" , ( GCallback ) Score_paused , 0 );
        g_signal_connect( self , "completed" , ( GCallback ) Score_completed , 0 );

    	g_object_unref(self);
	]];
	
    ~Score()
	[[
	]];
	
	/*
		Property: loop
		
		The loop property is a boolean flag indicating whether or not the Score should loop until it is explicitly stopped (true=loop infinitely).
		
		If the Score loops, the object's on_completed() event handler will be called at the completion of each cycle through the Score.
		
		*Default Setting:* false, i.e., do not loop
		
		*See Also:* the <on_completed> event handler
	*/
	
    bool loop
	[[loop=clutter_score_get_loop(self);]]
	[[clutter_score_set_loop(self,loop);]];
	
	/*
		Property: is_playing
		
		The is_playing property is a boolean flag indicating whether or not the Score is currently running (true=is running).
		
		During the period when the Score is paused, the is_playing property will be false until the Score is resumed.
		
		To start a Score or to resume a paused Score, call the object's start() function.
		
		*Default Setting:* false, i.e., Score is not running
		
		*See Also:* the <start> function
	*/
	
    readonly bool is_playing
	[[is_playing=clutter_score_is_playing(self);]];
	
	/*
		Function: start
		
		The start() function causes the Score to begin running. All the Score's Timeline animations that have no parent will begin running. If the Score has been paused, calling the start() function causes the Score to resume.
		
		Calling the start() function causes the Score's on_started() event handler to be called.
		
		*Arguments:* None
		
		*Return Value:* None
		
		*See Also:* the <pause> function and the <on_started> event handler
	*/
	
    start()
	[[
	  clutter_score_start(self);
    ]];
	
	/*
		Function: pause
		
		The pause() function halts a running Score at its current position and invokes the on_paused() event handler.
		
		To resume a paused Score, call the start() function again; the Score's animations will resume from the point at which they had been paused. Note: Calling start() to resume a paused Score causes the on_started() event handler to be called.
		
		*Arguments:* None
		
		*Return Value:* None
		
		*See Also:* the <start> function and the <on_paused> event handler
	*/
    pause()
	[[clutter_score_pause(self);]];
	
	/*
		Function: stop
		
		The stop() function halts a running Score and resets the Score to its starting position. The stop() function does *not* cause the on_completed() event handler to be called.
		
		*Arguments:* None
		
		*Return Value:* None
		
		*See Also:* the <start> and <pause> functions
	*/
	
    stop()
	[[clutter_score_stop(self);]];
	
	/*
		Function: rewind
		
		The rewind() function resets the Score back to its starting position. If the Score is running, it will continue running from its new position.
		
		*Arguments:* None
		
		*Return Value:* None
		
		*See Also:* the <start> and <stop> functions
	*/
	
    rewind()
	[[clutter_score_rewind(self);]];
	
	/*
		Function: append
		
		The append() function attaches a Timeline object to the Score and optionally defines a parent for the newly-attached Timeline. When the parent Timeline finishes running, it will trigger the running of the newly-attached Timeline. The specified parent Timeline must already be attached to the Score. If no parent is specified, the newly-attached Timeline will begin running when the Score is started by a call to start().
		
		*Arguments:*
		
			parent - Timeline object to act as "parent" to newly-attached Timeline. The parent Timeline must already be attached to the Score. If the newly-attached Timeline should begin running as soon as the Score starts running, the parent argument should be nil.
			timeline - Timeline object to attach to Score
		
		*Return Value:* None
		
		*See Also:* the <append_at_marker> and <start> functions
	*/

    append(Timeline parent=0, Timeline timeline)
	[[
	    ClutterTimeline *tl = ClutterUtil::user_data_to_timeline(L,timeline);
	    ClutterTimeline *p = ClutterUtil::user_data_to_timeline(L,parent);

        if(tl) clutter_score_append(self,p,tl);
    ]];

    /*
        Function: append_at_marker
        
        The append_at_marker() function attaches a Timeline object to the Score and defines a parent and marker within the parent for the newly-attached Timeline. When the marker in the parent Timeline is reached, it will trigger the running of the newly-attached Timeline. The specified parent Timeline must already be attached to the Score and the specified marker must exist in the parent Timeline.
        
        To start running a Timeline at the completion of another Timeline, use the append() function.
        
		*Arguments:*

			parent - Timeline object to act as "parent" to newly-attached Timeline. The parent Timeline must already be attached to the Score.
			marker - string name of marker in the parent Timeline. When marker is reached, the newly-attached Timeline (specified in the timeline argument) begins running.
			timeline - Timeline object to attach to Score
			
		*Return Value:* None
		
		*See Also:* the <append> and <start> function
    */

    append_at_marker(Timeline parent, string marker, Timeline timeline)
    [[
	    ClutterTimeline *tl = ClutterUtil::user_data_to_timeline(L,timeline);
	    ClutterTimeline *p = ClutterUtil::user_data_to_timeline(L,parent);

        if(tl && p) clutter_score_append_at_marker(self,p,marker,tl);
    ]];

    /*
        Function: remove_all
        
        The remove_all() function detaches all attached Timelines from the Score.
        
        *Arguments:* None
        
        *Return Value:* None
        
        *See Also:* the <append> and <append_at_marker> functions
    */
    
    remove_all()
    [[clutter_score_remove_all(self);]];

	/*
		Event Handler: on_started
		
		The on_started() event handler is invoked when the Score starts running or resumes running following a pause.

		*Arguments:*
		
			score - Score object the event applies to
			
		*Return Value:* None
		
		*See Also:* the <start> function
	*/
	
    callback on_started
	[[
	    UserData::get(L)->connect_signal_if(
			on_started,
			"on_started",
			"started",
			G_CALLBACK(Score_on_started),
			L);
	]];
    
    /*
    	Event Handler: on_completed
    	
    	The on_completed() event handler is called each time the Score completes a single iteration of all its attached Timelines. If the object's <loop> property is false, the Score will perform a single iteration; otherwise, it will loop infinitely or until it is stopped explicitly by calling the stop() function.

		*Arguments:*
		
			score - Score object the event applies to
			
		*Return Value:* None
		
		*See Also:* the <loop> property and the <start> function
    */
    
    callback on_completed
	[[
	    UserData::get(L)->connect_signal_if(
			on_completed,
			"on_completed",
			"completed",
			G_CALLBACK(Score_on_completed),
			L);	    	    
	]];
	
	/*
		Event Handler: on_paused
		
		The on_paused() event handler is called when a running Score is paused by calling its pause() function.
		
		Paused Scores can be resumed by calling the start() function.

		*Arguments:*
		
			score - Score object the event applies to
			
		*Return Value:* None
		
		*See Also:* the <pause> and <start> functions
	*/
	
    callback on_paused
	[[
	    UserData::get(L)->connect_signal_if(
			on_paused,
			"on_paused",
			"paused",
			G_CALLBACK(Score_on_paused),
			L);	    	    
	]];
	
}

[[
void Score_on_started(ClutterScore*score,lua_State*L)
{
    UserData::invoke_callback(G_OBJECT(score),"on_started",0,0,L);
}

void Score_on_completed(ClutterScore*score,lua_State*L)
{
    UserData::invoke_callback(G_OBJECT(score),"on_completed",0,0,L);
}

void Score_on_paused(ClutterScore*score,lua_State*L)
{
    UserData::invoke_callback(G_OBJECT(score),"on_paused",0,0,L);
}

]]

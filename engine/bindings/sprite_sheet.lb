module sprite_sheet;

[[
#include "spritesheet.h"
#include <glib.h>
#include <string.h>
#include "bitmap.h"
#include "json.h"
#include "app_resource.h"
#include "util.h"
]]

[[

//------------------------------------------------------------------------
// Emit signal "later"

class EmitLoadedSignalLater : public Action
{

public:
    EmitLoadedSignalLater( SpriteSheet * self , const char * error_message )
    {
        this->self = self;
        this->error_message = error_message;
    }

protected:
    bool run()
    {
        g_signal_emit_by_name( self->extra, "load-finished", error_message );
        return false;
    }

private:
    SpriteSheet * self;
    const char * error_message;
};

//------------------------------------------------------------------------
// Helper functions

int get_sprite_data_from_lua_table( lua_State * L , JSON::Array ** sprite_data )
{
    JSON::Value map_value = JSON::to_json( L , -1 );

    if ( map_value.get_type() == JSON::Value::T_NULL )
    {
        return 0;
    }

    if ( ! map_value.is<JSON::Object>() )
    {
        return 0;
    }

    JSON::Object map_obj = map_value.as<JSON::Object>();

    if ( ! map_obj.has( "sprites" ) )
    {
        return 0;
    }

    if ( ! map_obj["sprites"].is<JSON::Array>() )
    {
        // An empty table is converted to JSON::Object so this handles an empty array

        if ( map_obj["sprites"].is<JSON::Object>() )
        {
            JSON::Object sprite_data_obj = map_obj["sprites"].as<JSON::Object>();
            if ( sprite_data_obj.begin() != sprite_data_obj.end() )
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }

    *sprite_data = new JSON::Array( map_obj["sprites"].as<JSON::Array>() );

    return 1;
}

int get_image_src_from_lua_table( lua_State * L , const char ** image_src )
{
    JSON::Value map_value = JSON::to_json( L , -1 );

    if ( map_value.get_type() == JSON::Value::T_NULL )
    {
        return 0;
    }

    if ( ! map_value.is<JSON::Object>() )
    {
        return 0;
    }

    JSON::Object map_obj = map_value.as<JSON::Object>();

    if ( ! map_obj.has( "img" ) )
    {
        return 0;
    }

    if ( ! map_obj["img"].is<String>() )
    {
        return 0;
    }

    *image_src = strdup( map_obj["img"].as<String>().c_str() );

    return 1;
}

int get_bitmap_image_from_lua_table( lua_State * L , Image ** image , gchar ** error_message )
{
    lua_getfield( L , 1 , "img" );

    if ( lua_isnil( L , -1 ) )
    {
        *error_message = (char*) "Key 'img' not found.";
        lua_pop( L , 1 );
        return 0;
    }

    if ( ! lua_isuserdata( L , -1 ) )
    {
        *error_message = (char*) "Property 'img' must be a Bitmap.";
        lua_pop( L , 1 );
        return 0;
    }

    if ( ! luaL_getmetafield( L , -1 , "type" ) )
    {
        *error_message = (char*) "Property 'img' must be a Bitmap.";
        lua_pop( L , 1 );
        return 0;
    }

    if ( strcmp( lua_tostring( L , -1 ) , "Bitmap" ) != 0 )
    {
        *error_message = (char*) "Property 'img' must be a Bitmap.";
        lua_pop( L , 2 );
        return 0;
    }

    lua_pop( L , 1 );

    Bitmap * bitmap_image = (Bitmap*) UserData::get_client( L , -1 );

    Image * image_tmp = bitmap_image->get_image();

    if ( ! image_tmp )
    {
        *error_message = (char*) "Bitmap must have an associated Image.";
        return 0;
    }

    *image = image_tmp;

    lua_pop( L , 1 );

    return 1;
}

int parse_map( char * map_str , JSON::Array ** sprite_data , const char ** image_src , char ** error_message )
{
    lua_State * L = luaL_newstate();

    JSON::parse( L , map_str );

    if ( lua_isnil( L , -1 ) || ! lua_istable( L , -1 ) )
    {
        *error_message = (char*) "Unable to parse JSON file";
        return 0;
    }

    if ( ! get_sprite_data_from_lua_table( L , sprite_data ) )
    {
        *error_message = (char*) "Unable to parse JSON file";
        return 0;
    }

    if ( ! get_image_src_from_lua_table( L , image_src ) )
    {
        *error_message = (char*) "Unable to parse JSON file";
        return 0;
    }

    lua_close( L );

    return 1;
}

//------------------------------------------------------------------------
// Synchronous downloader

int download_map( App * app , AppResource resource , char ** contents )
{
    if ( resource.is_http() )
    {
        Network::Request request( app->get_user_agent() , resource.get_uri() );
        Network::Response response = app->get_network()->perform_request( request, app->get_cookie_jar() );

        if ( response.failed || response.body->len == 0 )
        {
            return 0;
        }

        guint8 null = '\0';
        *contents = strdup( (char*) g_byte_array_append( response.body, &null , 1 )->data );
    }
    else if ( resource.is_native() )
    {
        const char * path = resource.get_native_path().c_str();
        if ( ! g_file_test( path, G_FILE_TEST_IS_REGULAR ) )
        {
            return 0;
        }

        GError * error;
        if ( ! g_file_get_contents( path , contents , NULL , &error ) )
        {
            return 0;
        }
    }

    return 1;
}

//------------------------------------------------------------------------
// Initializer

void map_sprites( SpriteSheet * sheet , JSON::Array sprite_data )
{
    for (unsigned int i=0; i<sprite_data.size(); i++)
    {
        JSON::Object sprite_datum = sprite_data[i].as<JSON::Object>();

        if (
            sprite_datum.has( "id" )
            && sprite_datum.has( "x" )
            && sprite_datum.has( "y" )
            && sprite_datum.has( "w" )
            && sprite_datum.has( "h" )
            )
        {
            const char * id = sprite_datum["id"].as<String>().c_str();
            sheet->map_subtexture(
                strdup( id ) ,
                sprite_datum["x"].as<long long>() ,
                sprite_datum["y"].as<long long>() ,
                sprite_datum["w"].as<long long>() ,
                sprite_datum["h"].as<long long>() );
        }
    }
}

void initialize( SpriteSheet * sheet , JSON::Array sprite_data , Image * image )
{
    ClutterTexture * image_texture = CLUTTER_TEXTURE(clutter_texture_new());
    Images::load_texture( image_texture , image );
    sheet->set_texture( clutter_texture_get_cogl_texture( image_texture ) );

    char * img_src = (char*) g_object_get_data( sheet->extra , "tp-src" );
    g_object_set_data_full( G_OBJECT( image_texture ) , "tp-src" , (gpointer*) strdup( img_src ) , g_free );

    map_sprites( sheet , sprite_data );
}

//------------------------------------------------------------------------
// Async constructor helpers

void load_image_callback( Image * image , gpointer me )
{
    SpriteSheet * self = (SpriteSheet*) me;
    if ( ! image )
    {
        g_signal_emit_by_name( self->extra, "load-finished", "Could not load image." );
        return;
    }

    JSON::Array * sprite_data = (JSON::Array*) g_object_get_data( self->extra , "tp-sprite-data" );

    initialize( self , *sprite_data , image );

    g_signal_emit_by_name( self->extra, "load-finished", 0 );
}

void download_map_callback( const Network::Response & response , gpointer me )
{
    SpriteSheet * self = (SpriteSheet*) me;
    App * app = (App*) g_object_get_data( self->extra , "tp-app" );

    if ( response.failed || response.body->len == 0 )
    {
        g_signal_emit_by_name( self->extra, "load-finished", "Could not load SpriteSheet map" );
        return;
    }

    char * contents;
    const unsigned char null = '\0';
    contents = strdup( (char*) g_byte_array_append( response.body, &null , 1 )->data );

    JSON::Array * sprite_data;
    const char * image_src;
    char * error_message;

    if ( ! parse_map( contents , &sprite_data , &image_src , &error_message ) )
    {
        Action::post( new EmitLoadedSignalLater( self , error_message ) );
        return;
    }

    g_object_set_data_full( self->extra , "tp-sprite-data" , sprite_data , g_free );
    g_object_set_data_full( self->extra , "tp-src" , (gpointer*) image_src , g_free );

    app->load_image_async( image_src , false , load_image_callback , self , 0 );
}

//------------------------------------------------------------------------
// Async Constructor

void construct_async( SpriteSheet * self , AppResource resource )
{
    App * app = (App*) g_object_get_data( self->extra , "tp-app" );

    if ( resource.is_http() )
    {
        Network::Request request( app->get_user_agent() , resource.get_uri() );
        app->get_network()->perform_request_async(
            request,
            app->get_cookie_jar(),
            download_map_callback,
            self,
            0 );
    }
    else if ( resource.is_native() )
    {
        char * contents;
        const char * path = resource.get_native_path().c_str();

        if ( ! g_file_test( path, G_FILE_TEST_IS_REGULAR ) )
        {
            Action::post( new EmitLoadedSignalLater( self , "Could not open map file" ) );
            return;
        }

        if ( ! g_file_get_contents( path , &contents , NULL , 0 ) )
        {
            Action::post( new EmitLoadedSignalLater( self , "Could not open map file" ) );
            return;
        }

        JSON::Array * sprite_data;
        const char * image_src;
        char * error_message;

        if ( ! parse_map( contents , &sprite_data , &image_src , &error_message ) )
        {
            Action::post( new EmitLoadedSignalLater( self , "Could not parse map file" ) );
            return;
        }

        g_object_set_data_full( self->extra , "tp-sprite-data" , sprite_data , g_free );
        g_object_set_data_full( self->extra , "tp-src" , (gpointer*) image_src , g_free );

        app->load_image_async( image_src , false , load_image_callback , self , 0 );
    }
}

void Sprite_Sheet_on_loaded(GObject * extra , gpointer error , lua_State * L );
]]

/*
    Class: SpriteSheet
    
    The SpriteSheet class will load a single image containing many sprites. An app may want to do this to avoid loading possibly hundreds of small icons or sprites, or to simplify the management of many similar images onscreen at once. A SpriteSheet, once created, is a static userdata that can be referenced by <Sprite> or <NineSlice>. These objects can then draw sections from the SpriteSheet directly without creating copies or clones.
    
    In order to know what to draw, the SpriteSheet needs a map of where individual sprites appear in the texture. This map is specified in the SpriteSheet constructor with either a Lua table, or a .json file with the following structure.
    
    (code)
    
    (end)
    
    And the map is .
    
    (code)
    // assets.json
    {
        "sprites": [
            { "x": 0, "y": 0, "w": 16, "h": 16, "id": "sprite-1.png" },
            { "x": 16, "y": 0, "w": 16, "h": 16, "id": "subfolder/sprite-2.png },
            ...
        ],
        "img": "assets.png"
    }
    
    -- main.lua
    sheet1 = SpriteSheet { map = "assets.json" }
    sheet2 = SpriteSheet { map = {
        sprites = {
            { x = 0, y = 0, w = 16, h = 16, id = "sprite-1.png" },
            { x = 16, y = 0, w = 16, h = 16, id = "subfolder/sprite-2.png" },
            ...
        },
        imge = "assets.png"
    }}
    (end)
    
    Notice that the id strings look like path names; this is not stricly necessary, since ids can be any string at all, but since SpriteSheet textures are usually generated from seperate source images, using a path name as if the SpriteSheet is actually a folder of images is often clearer. By default, the SpriteSheet will load the image named by the "img" property in the .json file. This can be overridden by passing a different image along with the map to the SpriteSheet constructor, as below.
    
    (code)
    sheet = SpriteSheet { map = "assets.json", img = "other-assets.png" }
    (end)
    
    What if the app needs to download its assets from a URL? The SpriteSheet can take URI paths as well as local paths, and load its map and texture asynchronously.
    
    (code)
    sheet = SpriteSheet { map = "http://www.trickplay.com/resources/assets.json", async = true }
    (end)
    
    *See Also:* the <Sprite> class
    
*/

class SpriteSheet [[SpriteSheet*]]
{
    /*
        Constructor: SpriteSheet
        
        The SpriteSheet() constructor creates a new SpriteSheet object.
        
        *Arguments:*
        
        props - table defining the object's construction
        
        *Properties:*
        
        map - Lua table or path to a .json file of sprite definitions
        [img] - override souce image path
        [async] - load remote URIs asynchronously
        
        *Return Value:* new NineSlice object
    */
    
    SpriteSheet(table props = 0 )
        [[
            LSG;
            self = lb_construct( SpriteSheet , new SpriteSheet() );
            g_object_set_data( self->extra , "tp-app" , App::get( L ) );
            char * error_message;

            g_signal_connect_data(
                self->extra,
                "load-finished",
                G_CALLBACK(Sprite_Sheet_on_loaded),
                L,0,GConnectFlags( 0 )
            );

            if ( props )
            {
                bool async = false;

                lua_getfield( L , 1 , "async" );

                if ( ! lua_isnil( L , -1 ) && lua_isboolean( L , -1 ) && lua_toboolean( L , -1 ) )
                {
                    async = true;
                }

                lua_pop( L , 1 );

                lua_getfield( L , 1 , "map" );

                if ( lua_isnil( L , -1 ) )
                {
                    lua_pop( L , 1 );
                    luaL_error( L , "SpriteSheet initialization error: Key 'map' not found." );
                }

                if ( lua_type( L , -1 ) == LUA_TSTRING )
                {
                    App * app = App::get( L );

                    AppResource resource( app , lua_tostring( L , -1 ) );

                    char * map_str;

                    lua_pop( L , 1 );

                    if ( ! async )
                    {
                        if ( ! download_map( app , resource , &map_str ) )
                        {
                            luaL_error( L , "SpriteSheet initialization error: Unable to download map" );
                        }

                        JSON::Array * sprite_data;
                        const char * image_src;

                        if ( ! parse_map( map_str , &sprite_data , &image_src , &error_message ) )
                        {
                            luaL_error( L , "SpriteSheet initialization error: %s" , error_message );
                        }

                        Image * image = app->load_image( image_src , false );

                        if ( ! image )
                        {
                            luaL_error( L , "SpriteSheet initialization error: Could not load image '%s'" , image_src );
                        }

                        g_object_set_data_full( self->extra , "tp-src" , (gpointer*) image_src , g_free );

                        initialize( self , *sprite_data , image );

                        delete sprite_data;
                    }
                    else
                    {
                        construct_async( self , resource );
                    }
                }
                else if ( lua_type( L , -1 ) == LUA_TTABLE )
                {
                    JSON::Array * sprite_data;
                    Image * image;

                    if ( ! get_sprite_data_from_lua_table( L , &sprite_data ) )
                    {
                        lua_pop( L , 1 );
                        luaL_error( L , "SpriteSheet initialization error: Invalid sprite data." );
                    }

                    // done with map field

                    lua_pop( L , 1 );

                    if ( ! get_bitmap_image_from_lua_table( L , &image , &error_message ) )
                    {
                        luaL_error( L , "SpriteSheet initialization error: %s" , error_message );
                    }

                    g_object_set_data_full( self->extra , "tp-src" , (gpointer*) "(Bitmap)" , g_free );

                    initialize( self , *sprite_data , image );

                    if ( async )
                    {
                        Action::post( new EmitLoadedSignalLater( self , 0 ) );
                    }
                }
            } else {
                luaL_error( L , "SpriteSheet initialization error: Must pass a table to SpriteSheet constructor." );
            }

            LSG_END(0);
        ]];

    /*
        Function: get_ids()
        
        Returns a table of all the sprite ids in this SpriteSheet
    */

    table get_ids()
        [[
            GList * iter = self->get_ids();

            int index = 1;

            lua_newtable( L );

            for ( ; iter ; iter = iter->next )
            {
                lua_pushstring( L , (char*) iter->data );
                lua_rawseti( L , -2 , index );
                ++index;
            }
        ]];

    ~SpriteSheet()
        [[
        ]];

    dump()
        [[
            self->dump();
        ]];

    /*
        Callback: on_loaded
        
        The on_loaded() event handler is fired when an asynchronously-loaded SpriteSheet has finished loading. 
        
        *Prototype:*
        (code)
        void on_loaded( SpriteSheet *sheet )
        (end)
        
        *Return Value:* None
    */

    callback on_loaded
        [[
        ]];
}

[[
void Sprite_Sheet_on_loaded(GObject * extra , gpointer error , lua_State * L )
{
    lua_pushboolean(L,error?1:0);

    if ( error )
    {
        lua_pushstring( L , (char*) error );
    }
    else
    {
        lua_pushnil( L );
    }

    SpriteSheet * self = (SpriteSheet*) g_object_get_data( extra , "tp-sheet" );

    UserData::invoke_callback(self,"on_loaded",2,0,L);
}
]]

module sprite_sheet;

[[
#include "spritesheet.h"
#include <glib.h>
#include <string.h>
#include "bitmap.h"
#include "json.h"
#include "app_resource.h"
#include "util.h"
]]

[[

//------------------------------------------------------------------------
// Emit signal "later"

class EmitLoadedSignalLater : public Action
{

public:
    EmitLoadedSignalLater( SpriteSheet * self , const char * error_message )
    {
        this->self = self;
        this->error_message = error_message;
    }

protected:
    bool run()
    {
        g_signal_emit_by_name( self->extra, "load-finished", error_message );
        return false;
    }

private:
    SpriteSheet * self;
    const char * error_message;
};

//------------------------------------------------------------------------
// Helper functions

int get_sprite_data_from_lua_table( lua_State * L , JSON::Array ** sprite_data )
{
    JSON::Value map_value = JSON::to_json( L , -1 );

    if ( map_value.get_type() == JSON::Value::T_NULL )
    {
        return 0;
    }

    if ( ! map_value.is<JSON::Object>() )
    {
        return 0;
    }

    JSON::Object map_obj = map_value.as<JSON::Object>();

    if ( ! map_obj.has( "sprites" ) )
    {
        return 0;
    }

    if ( ! map_obj["sprites"].is<JSON::Array>() )
    {
        // An empty table is converted to JSON::Object so this handles an empty array

        if ( map_obj["sprites"].is<JSON::Object>() )
        {
            JSON::Object sprite_data_obj = map_obj["sprites"].as<JSON::Object>();
            if ( sprite_data_obj.begin() != sprite_data_obj.end() )
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }

    *sprite_data = new JSON::Array( map_obj["sprites"].as<JSON::Array>() );

    return 1;
}

int get_image_src_from_lua_table( lua_State * L , const char ** image_src )
{
    JSON::Value map_value = JSON::to_json( L , -1 );

    if ( map_value.get_type() == JSON::Value::T_NULL )
    {
        return 0;
    }

    if ( ! map_value.is<JSON::Object>() )
    {
        return 0;
    }

    JSON::Object map_obj = map_value.as<JSON::Object>();

    if ( ! map_obj.has( "img" ) )
    {
        return 0;
    }

    if ( ! map_obj["img"].is<String>() )
    {
        return 0;
    }

    *image_src = strdup( map_obj["img"].as<String>().c_str() );

    return 1;
}

int get_bitmap_image_from_lua_table( lua_State * L , Image ** image , gchar ** error_message )
{
    lua_getfield( L , 1 , "img" );

    if ( lua_isnil( L , -1 ) )
    {
        *error_message = (char*) "Key 'img' not found.";
        lua_pop( L , 1 );
        return 0;
    }

    if ( ! lua_isuserdata( L , -1 ) )
    {
        *error_message = (char*) "Property 'img' must be a Bitmap.";
        lua_pop( L , 1 );
        return 0;
    }

    if ( ! luaL_getmetafield( L , -1 , "type" ) )
    {
        *error_message = (char*) "Property 'img' must be a Bitmap.";
        lua_pop( L , 1 );
        return 0;
    }

    if ( strcmp( lua_tostring( L , -1 ) , "Bitmap" ) != 0 )
    {
        *error_message = (char*) "Property 'img' must be a Bitmap.";
        lua_pop( L , 2 );
        return 0;
    }

    lua_pop( L , 1 );

    Bitmap * bitmap_image = (Bitmap*) UserData::get_client( L , -1 );

    Image * image_tmp = bitmap_image->get_image();

    if ( ! image_tmp )
    {
        *error_message = (char*) "Bitmap must have an associated Image.";
        return 0;
    }

    *image = image_tmp;

    lua_pop( L , 1 );

    return 1;
}

int parse_map( char * map_str , JSON::Array ** sprite_data , const char ** image_src , char ** error_message )
{
    lua_State * L = luaL_newstate();

    JSON::parse( L , map_str );

    if ( lua_isnil( L , -1 ) || ! lua_istable( L , -1 ) )
    {
        *error_message = (char*) "Unable to parse JSON file";
        return 0;
    }

    if ( ! get_sprite_data_from_lua_table( L , sprite_data ) )
    {
        *error_message = (char*) "Unable to parse JSON file";
        return 0;
    }

    if ( ! get_image_src_from_lua_table( L , image_src ) )
    {
        *error_message = (char*) "Unable to parse JSON file";
        return 0;
    }

    lua_close( L );

    return 1;
}

//------------------------------------------------------------------------
// Synchronous downloader

int download_map( App * app , AppResource resource , char ** contents )
{
    if ( resource.is_http() )
    {
        Network::Request request( app->get_user_agent() , resource.get_uri() );
        Network::Response response = app->get_network()->perform_request( request, app->get_cookie_jar() );

        if ( response.failed || response.body->len == 0 )
        {
            return 0;
        }

        guint8 null = '\0';
        *contents = g_strdup( (char*) g_byte_array_append( response.body, &null , 1 )->data );
    }
    else if ( resource.is_native() )
    {
        const char * path = resource.get_native_path().c_str();
        if ( ! g_file_test( path, G_FILE_TEST_IS_REGULAR ) )
        {
            return 0;
        }

        GError * error;
        if ( ! g_file_get_contents( path , contents , NULL , &error ) )
        {
            return 0;
        }
    }

    return 1;
}

//------------------------------------------------------------------------
// Initializer

void map_sprites( SpriteSheet * sheet , JSON::Array sprite_data )
{
    for (unsigned int i=0; i<sprite_data.size(); i++)
    {
        JSON::Object sprite_datum = sprite_data[i].as<JSON::Object>();

        if (
            sprite_datum.has( "id" )
            && sprite_datum.has( "x" )
            && sprite_datum.has( "y" )
            && sprite_datum.has( "w" )
            && sprite_datum.has( "h" )
            )
        {
            const char * id = sprite_datum["id"].as<String>().c_str();
            sheet->map_subtexture(
                strdup( id ) ,
                sprite_datum["x"].as<long long>() ,
                sprite_datum["y"].as<long long>() ,
                sprite_datum["w"].as<long long>() ,
                sprite_datum["h"].as<long long>() );
        }
    }
}

void initialize( SpriteSheet * sheet , JSON::Array sprite_data , Image * image )
{
    ClutterTexture * image_texture = CLUTTER_TEXTURE(clutter_texture_new());
    Images::load_texture( image_texture , image );
    sheet->set_texture( clutter_texture_get_cogl_texture( image_texture ) );

    char * img_src = (char*) g_object_get_data( sheet->extra , "tp-src" );
    g_object_set_data_full( G_OBJECT( image_texture ) , "tp-src" , (gpointer*) strdup( img_src ) , g_free );

    map_sprites( sheet , sprite_data );
}

//------------------------------------------------------------------------
// Async constructor helpers

void load_image_callback( Image * image , gpointer me )
{
    SpriteSheet * self = (SpriteSheet*) me;
    if ( ! image )
    {
        g_signal_emit_by_name( self->extra, "load-finished", "Could not load image." );
        return;
    }

    JSON::Array * sprite_data = (JSON::Array*) g_object_get_data( self->extra , "tp-sprite-data" );

    initialize( self , *sprite_data , image );

    g_signal_emit_by_name( self->extra, "load-finished", 0 );
}

void download_map_callback( const Network::Response & response , gpointer me )
{
    SpriteSheet * self = (SpriteSheet*) me;
    App * app = (App*) g_object_get_data( self->extra , "tp-app" );

    if ( response.failed || response.body->len == 0 )
    {
        g_signal_emit_by_name( self->extra, "load-finished", "Could not load SpriteSheet map" );
        return;
    }

    char * contents;
    const unsigned char null = '\0';
    contents = strdup( (char*) g_byte_array_append( response.body, &null , 1 )->data );

    JSON::Array * sprite_data;
    const char * image_src;
    char * error_message;

    if ( ! parse_map( contents , &sprite_data , &image_src , &error_message ) )
    {
        Action::post( new EmitLoadedSignalLater( self , error_message ) );
        return;
    }

    g_object_set_data_full( self->extra , "tp-sprite-data" , sprite_data , g_free );
    g_object_set_data_full( self->extra , "tp-src" , (gpointer*) image_src , g_free );

    app->load_image_async( image_src , false , load_image_callback , self , 0 );
}

//------------------------------------------------------------------------
// Async Constructor

void construct_async( SpriteSheet * self , AppResource resource )
{
    App * app = (App*) g_object_get_data( self->extra , "tp-app" );

    if ( resource.is_http() )
    {
        Network::Request request( app->get_user_agent() , resource.get_uri() );
        app->get_network()->perform_request_async(
            request,
            app->get_cookie_jar(),
            download_map_callback,
            self,
            0 );
    }
    else if ( resource.is_native() )
    {
        char * contents;
        const char * path = resource.get_native_path().c_str();

        if ( ! g_file_test( path, G_FILE_TEST_IS_REGULAR ) )
        {
            Action::post( new EmitLoadedSignalLater( self , "Could not open map file" ) );
            return;
        }

        if ( ! g_file_get_contents( path , &contents , NULL , 0 ) )
        {
            Action::post( new EmitLoadedSignalLater( self , "Could not open map file" ) );
            return;
        }

        JSON::Array * sprite_data;
        const char * image_src;
        char * error_message;

        if ( ! parse_map( contents , &sprite_data , &image_src , &error_message ) )
        {
            Action::post( new EmitLoadedSignalLater( self , "Could not parse map file" ) );
            return;
        }

        g_object_set_data_full( self->extra , "tp-sprite-data" , sprite_data , g_free );
        g_object_set_data_full( self->extra , "tp-src" , (gpointer*) image_src , g_free );

        app->load_image_async( image_src , false , load_image_callback , self , 0 );
    }
}

void Sprite_Sheet_on_loaded(GObject * extra , gpointer error , lua_State * L );
]]

class SpriteSheet [[SpriteSheet*]]
{
    SpriteSheet(table props = 0 )
        [[
            LSG;
            self = lb_construct( SpriteSheet , new SpriteSheet() );
            g_object_set_data( self->extra , "tp-app" , App::get( L ) );
            char * error_message;

            g_signal_connect_data(
                self->extra,
                "load-finished",
                G_CALLBACK(Sprite_Sheet_on_loaded),
                L,0,GConnectFlags( 0 )
            );

            if ( props )
            {
                bool async = false;

                lua_getfield( L , 1 , "async" );

                if ( ! lua_isnil( L , -1 ) && lua_isboolean( L , -1 ) && lua_toboolean( L , -1 ) )
                {
                    async = true;
                }

                lua_pop( L , 1 );

                lua_getfield( L , 1 , "map" );

                if ( lua_isnil( L , -1 ) )
                {
                    lua_pop( L , 1 );
                    luaL_error( L , "SpriteSheet initialization error: Key 'map' not found." );
                }

                if ( lua_type( L , -1 ) == LUA_TSTRING )
                {
                    App * app = App::get( L );

                    AppResource resource( app , lua_tostring( L , -1 ) );

                    char * map_str;

                    lua_pop( L , 1 );

                    if ( ! async )
                    {
                        if ( ! download_map( app , resource , &map_str ) )
                        {
                            luaL_error( L , "SpriteSheet initialization error: Unable to download map" );
                        }

                        JSON::Array * sprite_data;
                        const char * image_src;

                        if ( ! parse_map( map_str , &sprite_data , &image_src , &error_message ) )
                        {
                            luaL_error( L , "SpriteSheet initialization error: %s" , error_message );
                        }

                        Image * image = app->load_image( image_src , false );

                        if ( ! image )
                        {
                            luaL_error( L , "SpriteSheet initialization error: Could not load image '%s'" , image_src );
                        }

                        g_object_set_data_full( self->extra , "tp-src" , (gpointer*) image_src , g_free );

                        initialize( self , *sprite_data , image );

                        delete sprite_data;
                    }
                    else
                    {
                        construct_async( self , resource );
                    }
                }
                else if ( lua_type( L , -1 ) == LUA_TTABLE )
                {
                    JSON::Array * sprite_data;
                    Image * image;

                    if ( ! get_sprite_data_from_lua_table( L , &sprite_data ) )
                    {
                        lua_pop( L , 1 );
                        luaL_error( L , "SpriteSheet initialization error: Invalid sprite data." );
                    }

                    // done with map field

                    lua_pop( L , 1 );

                    if ( ! get_bitmap_image_from_lua_table( L , &image , &error_message ) )
                    {
                        luaL_error( L , "SpriteSheet initialization error: %s" , error_message );
                    }

                    g_object_set_data_full( self->extra , "tp-src" , (gpointer*) "(Bitmap)" , g_free );

                    initialize( self , *sprite_data , image );

                    if ( async )
                    {
                        Action::post( new EmitLoadedSignalLater( self , 0 ) );
                    }
                }
            } else {
                luaL_error( L , "SpriteSheet initialization error: Must pass a table to SpriteSheet constructor." );
            }

            LSG_END(0);
        ]];

    table get_ids()
        [[
            GList * iter = self->get_ids();

            int index = 1;

            lua_newtable( L );

            for ( ; iter ; iter = iter->next )
            {
                lua_pushstring( L , (char*) iter->data );
                lua_rawseti( L , -2 , index );
                ++index;
            }
        ]];

    ~SpriteSheet()
        [[
        ]];

    dump()
        [[
            self->dump();
        ]];

    callback on_loaded
        [[
        ]];
}

[[
void Sprite_Sheet_on_loaded(GObject * extra , gpointer error , lua_State * L )
{
    lua_pushboolean(L,error?1:0);

    if ( error )
    {
        lua_pushstring( L , (char*) error );
    }
    else
    {
        lua_pushnil( L );
    }

    SpriteSheet * self = (SpriteSheet*) g_object_get_data( extra , "tp-sheet" );

    UserData::invoke_callback(self,"on_loaded",2,0,L);
}
]]

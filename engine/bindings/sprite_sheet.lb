module sprite_sheet;

[[
#include "spritesheet.h"
#include <glib.h>
#include <string.h>
#include "bitmap.h"
#include "json.h"
#include "app_resource.h"
]]

[[

int get_image_bitmap( lua_State * L , Image ** image , gchar ** error_message )
{
    lua_getfield( L , 1 , "img" );

    if ( lua_isnil( L , -1 ) )
    {
        *error_message = (char*) "SpriteSheet initialization error: Key 'img' not found.";
        lua_pop( L , 1 );
        return 0;
    }

    if ( ! lua_isuserdata( L , -1 ) )
    {
        *error_message = (char*) "SpriteSheet initialization error: Property 'img' must be a Bitmap.";
        lua_pop( L , 1 );
        return 0;
    }

    if ( ! luaL_getmetafield( L , -1 , "type" ) )
    {
        *error_message = (char*) "SpriteSheet initialization error: Property 'img' must be a Bitmap.";
        lua_pop( L , 1 );
        return 0;
    }

    if ( strcmp( lua_tostring( L , -1 ) , "Bitmap" ) != 0 )
    {
        *error_message = (char*) "SpriteSheet initialization error: Property 'img' must be a Bitmap.";
        lua_pop( L , 2 );
        return 0;
    }

    lua_pop( L , 1 );

    Bitmap * bitmap_image = (Bitmap*) UserData::get_client( L , -1 );

    Image * image_tmp = bitmap_image->get_image();

    if ( ! image_tmp )
    {
        *error_message = (char*) "SpriteSheet initialization error: Bitmap must have an associated Image.";
        return 0;
    }

    *image = image_tmp;

    lua_pop( L , 1 );

    return 1;
}

int map_sprites_from_lua_table( lua_State * L , SpriteSheet * sheet , char ** error_message )
{
    lua_getfield( L , -1 , "sprites" );

    if ( lua_isnil( L , -1 ) )
    {
        *error_message = (char*) "SpriteSheet initialization error: Map must contain the key 'sprites'.";
        lua_pop( L , 1 );
        return 0;
    }

    if ( ! lua_istable( L , -1 ) )
    {
        *error_message = (char*) "SpriteSheet initialization error: Map key 'sprites' must have a table value.";
        lua_pop( L , 1 );
        return 0;
    }

    lua_pushnil( L );

    while ( lua_next( L , -2 ) )
    {
        if ( lua_istable ( L , -1 ) )
        {
            lua_getfield( L , -1 , "id" );
            lua_getfield( L , -2 , "x" );
            lua_getfield( L , -3 , "y" );
            lua_getfield( L , -4 , "w" );
            lua_getfield( L , -5 , "h" );

            int h = lua_tointeger( L , -1 );
            int w = lua_tointeger( L , -2 );
            int y = lua_tointeger( L , -3 );
            int x = lua_tointeger( L , -4 );

            const gchar * id = strdup( lua_tostring( L , -5 ) );

            lua_pop( L , 5 );

            if ( id )
            {
                sheet->map_subtexture( id , x , y , w , h );
            }
        }

        lua_pop( L , 1 );
    }

    lua_pop( L , 1 );
    return 1;
}

int download_resource( App * app , AppResource * resource , char ** contents )
{
    Network::Request request( app->get_user_agent() , resource->get_uri() );
    Network::Response response = app->get_network()->perform_request( request, app->get_cookie_jar() );

    if ( response.failed || response.body->len == 0 )
    {
        return 0;
    }

    guint8 null = '\0';
    *contents = strdup( (char*) g_byte_array_append( response.body, &null , 1 )->data );

    return 1;
}

int get_local_resource( AppResource * resource , char ** contents )
{
    const char * path = resource->get_native_path().c_str();
    if ( ! g_file_test( path, G_FILE_TEST_IS_REGULAR ) )
    {
        return 0;
    }

    GError * error;
    if ( ! g_file_get_contents( path , contents , NULL , &error ) )
    {
        return 0;
    }

    return 1;
}

int construct( lua_State * L , SpriteSheet * sheet , char ** error_message )
{
    App * app = App::get( L );
    Image * image = 0;

    lua_getfield( L , 1 , "map" );

    if ( lua_isnil( L , -1 ) )
    {
        lua_pop( L , 1 );
        *error_message = (char*) "SpriteSheet initialization error: Key 'map' not found.";
        return 0;
    }

    if ( lua_type( L , -1 ) == LUA_TSTRING )
    {
        const char * json_file = lua_tostring( L , -1 );
        lua_pop( L , 1 );

        AppResource resource( App::get( L ) , json_file );

        if ( ! resource.good() )
        {
            *error_message = g_new( char , 100 );
            snprintf( *error_message , 100 , "SpriteSheet initialization error: JSON file %s does not exist." , json_file );
            return 0;
        }

        gchar * contents;

        if ( resource.is_http() )
        {
            if ( ! download_resource( app , &resource , &contents ) )
            {
                *error_message = g_new( char , 100 );
                snprintf( *error_message , 100 , "SpriteSheet initialization error: Could not download file %s." , json_file );
                return 0;
            }
        }
        else if ( resource.is_native() )
        {
            if ( ! get_local_resource( &resource , &contents ) )
            {
                *error_message = g_new( char , 100 );
                snprintf( *error_message , 100 , "SpriteSheet initialization error: Could not access file %s." , json_file );
                return 0;
            }
        }

        if ( ! contents )
        {
            *error_message = g_new( char , 100 );
            snprintf( *error_message , 100 , "SpriteSheet initialization error: Unable to open JSON file '%s'." , json_file );
            return 0;
        }

        JSON::parse( L , contents );

        if ( lua_isnil( L , -1 ) || ! lua_istable( L , -1 ) )
        {
            lua_pop( L , 1 );
            *error_message = g_new( char , 100 );
            snprintf( *error_message , 100 , "SpriteSheet initialization error: Unable to parse JSON file with contents: \n%s" , contents );
            return 0;
        }

        lua_getfield( L , -1 , "img" );

        if ( lua_isnil( L , -1 ) || ! lua_isstring( L , -1 ) )
        {
            lua_pop( L , 2 );
            *error_message = (char*) "SpriteSheet initialization error: Invalid image path.";
            return 0;
        }

        const char * image_src = lua_tostring( L , -1 );

        lua_pop( L , 1 );

        image = app->load_image( image_src , false );

        if ( ! image )
        {
            lua_pop( L , 1 );
            *error_message = g_new( char , 100 );
            snprintf( *error_message , 100 , "SpriteSheet initialization error: Image '%s' does not exist." , image_src );
            return 0;
        }

        g_free( contents );
    }

    if ( lua_type( L , -1 ) == LUA_TTABLE )
    {
        if ( ! image && ! get_image_bitmap( L , &image , error_message ) )
        {
            lua_pop( L , 1 );
            return 0;
        }

        ClutterTexture * imageClutterTexture = CLUTTER_TEXTURE(clutter_texture_new());
        Images::load_texture( imageClutterTexture , image );

        sheet->set_texture( clutter_texture_get_cogl_texture( imageClutterTexture ) );

        if ( ! map_sprites_from_lua_table( L , sheet , error_message ) )
        {
            lua_pop( L , 1 );
            return 0;
        }

        lua_pop( L , 1 );
    }
    else
    {
        lua_pop( L , 1 );
        *error_message = (char*) "SpriteSheet map must be a Lua table or a String location of a JSON file.";
        return 0;
    }

    return 1;
}

void Sprite_Sheet_on_loaded(SpriteSheet * self , gpointer error , lua_State * L );
]]

class SpriteSheet [[SpriteSheet*]]
{
    SpriteSheet(table props = 0 )
        [[
            LSG;
            SpriteSheet * sheet = new SpriteSheet();
            char * error_message;

            if ( props )
            {
                lua_getfield( L , 1 , "async" );

                if ( ! lua_isnil( L , -1 ) && lua_isboolean( L , -1 ) && lua_toboolean( L , -1 ) )
                {
                    lua_pop( L , 1 );

                    // run async action
                }
                else
                {
                    lua_pop( L , 1 );

                    if ( ! construct( L , sheet , &error_message ) )
                    {
                        self = lb_construct( SpriteSheet , 0 );
                        luaL_error( L , error_message );
                    }
                }
            } else {
                self = lb_construct( SpriteSheet , 0 );
                luaL_error( L , "SpriteSheet initialization error: Must pass a table to SpriteSheet constructor." );
            }

            self = lb_construct( SpriteSheet , sheet );

            LSG_END(0);
        ]];

    table get_ids()
        [[
            GList * iter = self->get_ids();

            int index = 1;

            lua_newtable( L );

            for ( ; iter ; iter = iter->next )
            {
                lua_pushstring( L , (char*) iter->data );
                lua_rawseti( L , -2 , index );
                ++index;
            }
        ]];

    ~SpriteSheet()
        [[
        ]];

    dump()
        [[
            self->dump();
        ]];

    callback on_loaded
        [[
            UserData::get(L)->connect_signal_if(
                on_loaded,
                "on_loaded",
                "load-finished",
                G_CALLBACK(Sprite_Sheet_on_loaded),
                L);
        ]];
}

[[
void Sprite_Sheet_on_loaded(SpriteSheet * self , gpointer error , lua_State * L )
{
    if ( ImageExtra::get( self )->async )
    {
        lua_pushboolean(L,error?1:0);
        UserData::invoke_callback(G_OBJECT(self),"on_loaded",1,0,L);
    }
}
]]

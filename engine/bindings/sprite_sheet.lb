module sprite_sheet;

[[
#include <glib.h>
#include "spritesheet.h"
#include "clutter_util.h"
#include <string.h>
#include "bitmap.h"
#include "bitmap.lb.h"
#include "json.h"
#include "app_resource.h"
#include "util.h"
]]

[[

//------------------------------------------------------------------------
// Emit signal "later"
/*
class EmitLoadedSignalLater : public Action
{

public:
    EmitLoadedSignalLater( SpriteSheet * self, const char * error_message )
    {
        this->self = self;
        this->error_message = error_message;
    }

protected:
    bool run()
    {
        g_signal_emit_by_name( self->extra, "load-finished", error_message );
        return false;
    }

private:
    SpriteSheet * self;
    const char  * error_message;
};
*/
//------------------------------------------------------------------------
// Helper functions

typedef void (* LFunc) ( lua_State * L, int index, gpointer user_data );
typedef SpriteSheet::Source Source;

void foreach_in_table ( lua_State * L, int index, LFunc func, gpointer user_data )
{
    index = index > 0 ? index : lua_gettop( L ) + index + 1;

    lua_pushnil( L );
    while ( lua_next( L, index ) )
    {
        func( L, lua_gettop( L ), user_data );
        lua_pop( L, 1 );
    }
}

void spritesheet_add_lua_sprite ( lua_State * L, int index, Source * source )
{
    LSG;

    if ( !lua_istable( L, index ) )
    {
        g_warning( "Couldn't understand that sprite definition." );
        return;
    }

    lua_getfield( L, index, "x" );
    lua_getfield( L, index, "y" );
    lua_getfield( L, index, "w" );
    lua_getfield( L, index, "h" );
    lua_getfield( L, index, "id" );

    source->sheet->add_sprite( source,
        strdup( (char *) lua_tostring( L, -1 ) ),
        (int) lua_tointeger( L, -5 ),
        (int) lua_tointeger( L, -4 ),
        (int) lua_tointeger( L, -3 ),
        (int) lua_tointeger( L, -2 )
    );

    lua_pop( L, 5 );

    LSG_END( 0 );
}

void spritesheet_add_lua_map ( lua_State * L, int index, SpriteSheet * self )
{
    if ( !lua_istable( L, index ) )
    {
        g_warning( "Map subsheet is not a table" );
        return;
    }
    
    Bitmap * bitmap;
    Source * source = self->add_source();
    
    
    lua_getfield( L, index, "img" );
    int img = lua_gettop( L );
    
    if ( lua_isstring( L, img ) )
    {
        source->set_source( lua_tostring( L, img ) );
    }
    else if (( bitmap = LB_GET_BITMAP( L, img ) ))
    {
        source->set_source( bitmap->get_image() );
    }
    else
    {
        g_warning( "Source image is not a URI or Bitmap" );
    }
    
    lua_pop( L, 1 );
    
    
    lua_getfield( L, index, "sprites" );
    int sprites = lua_gettop( L );

    if ( lua_istable( L, sprites ) )
    {
        foreach_in_table( L, sprites, (LFunc) spritesheet_add_lua_sprite, source );
    }
    else
    {
        g_warning( "List of sprites is not a table" );
    }
    
    lua_pop( L, 1 );
}
void SpriteSheet_on_loaded( GObject * extra, gpointer error, lua_State * L );

]]

/*
    Class: SpriteSheet

    The SpriteSheet class will load a set of large images containing many small sprites. An app may want to do this to avoid loading possibly hundreds of small icons or sprites, or to simplify the management of many similar images onscreen at once. A SpriteSheet, once created, is a static userdata that can be referenced by <Sprite> or <NineSlice>. These objects can then draw sprites from the SpriteSheet directly without creating copies or clones.

    In order to know what to draw, the SpriteSheet needs a map of where individual sprites appear in each source texture. This map is specified in the SpriteSheet constructor with either a Lua table, or a .json file with the following structure.

    (code)
    // assets.json
    [
        {
            "sprites": [
                { "x": 0, "y": 0, "w": 16, "h": 16, "id": "sprite-1.png" },
                { "x": 16, "y": 0, "w": 16, "h": 16, "id": "subfolder/sprite-2.png },
                ...
            ],
            "img": "assets.png"
        },
        ...
    ]

    -- main.lua
    sheet1 = SpriteSheet { map = "assets.json" }
    sheet2 = SpriteSheet { map = {
        {
            sprites = {
                { x = 0, y = 0, w = 16, h = 16, id = "sprite-1.png" },
                { x = 16, y = 0, w = 16, h = 16, id = "subfolder/sprite-2.png" },
                ...
            },
            img = Bitmap{ src = "assets.png" }
        },
        ...
    }
    (end)

    Notice that the id strings look like path names; this is not stricly necessary, since ids can be any string at all, but since SpriteSheets are usually generated from seperate source files, using a path name as if the SpriteSheet is actually a folder of images is often clearer.

    What if the app needs to download its assets from a URL? The SpriteSheet can take URI paths as well as local paths, and load its map and texture asynchronously.

    (code)
    sheet = SpriteSheet { map = "http://www.trickplay.com/resources/assets.json", async = true }
    (end)

    *See Also:* the <Sprite> class

*/

class SpriteSheet [[SpriteSheet*]]
{
    /*
        Constructor: SpriteSheet

        The SpriteSheet() constructor creates a new SpriteSheet object.

        *Arguments:*

        props - table defining the object's construction

        *Properties:*

        map - Lua table or path to a .json file of source-and-sprite definitions
        [async] - load remote URIs asynchronously

        *Return Value:* new NineSlice object
    */

    SpriteSheet( table props = 0 )
        [[
            LSG;
            self = lb_construct( SpriteSheet, new SpriteSheet() );
            
            g_signal_connect_data( self->extra, "load-finished",
                (GCallback) SpriteSheet_on_loaded,
                L, 0, GConnectFlags( 0 ) );
            
            self->app = App::get( L );
            
            if ( props )
            {
                ClutterUtil::set_props_from_table( L, props );
                
                lua_getfield( L, 1, "async" );
                lua_getfield( L, 1, "map" );
                
                self->async = lua_toboolean( L, -2 );
                
                if ( lua_isstring( L, -1 ) )
                {
                    self->load_json( lua_tostring( L, -1 ) );
                }
                else if ( lua_istable( L, -1 ) )
                {
                    foreach_in_table( L, -1, (LFunc) spritesheet_add_lua_map, self );
                }
                else
                {
                    luaL_error( L, "Key 'map' was not a table or URI string." );
                }
                
                lua_pop( L, 2 );
            }
            else
            {
                luaL_error( L, "Must pass a table to SpriteSheet constructor." );
            }
            
            LSG_END( 0 );
        ]];

    ~SpriteSheet()
        [[
        ]];

    /*
        Function: get_ids()

        Returns a table of all the sprite ids in this SpriteSheet
    */

    table get_ids()
        [[
            std::list< std::string > * ids = self->get_ids();

            lua_createtable( L, 0, ids->size() );
            int table = lua_gettop( L );

            for ( std::list< std::string >::iterator id = ids->begin(); id != ids->end(); ++id )
            {
                lua_pushboolean( L, true );
                lua_setfield( L, table, id->c_str() );
            }

            delete ids;
        ]];

    /*
        Callback: on_loaded

        The on_loaded() event handler is fired whenever SpriteSheet gets a result from an asynchronous load. A single SpriteSheet may load a map and/or one or more image files asynchronously.

        *Prototype:*
        (code)
        void on_loaded( SpriteSheet self, boolean success, string status )
        (end)

        *Status Strings:*

        FAILED_MAP_LOAD - Couldn't load the JSON map from a remote URI
        FAILED_MAP_PARSE - Couldn't parse the JSON map correctly
        FAILED_IMG_LOAD - Couldn't load one of the source images (remote or local)
        nil - Successfully loaded a source image (remote or local)
    */
    /*
    readonly bool loaded
        [[
            loaded = self->loaded;
        ]];
      */  
    int add_onloaded_listener( function f )
        [[
            result = UserData::get( L )->add_callback( (char *) "on_loaded" , L );
            //UserData::get( L )->connect_signal( "on_loaded",
             //   "load-finished", (GCallback) SpriteSheet_on_loaded, L );
        ]];

    remove_onloaded_listener( int ref )
        [[
            UserData::get( L )->remove_callback( (char *) "on_loaded" , L );
        ]];

    function on_loaded
        [[
            return UserData::get( L )->get_last_callback( (char *) "on_loaded" , L );
        ]]
        [[
            UserData::get( L )->set_last_callback( (char *) "on_loaded" , L );
            //UserData::get( L )->connect_signal( "on_loaded",
            //    "load-finished", (GCallback) SpriteSheet_on_loaded, L );
        ]];
}

[[

void SpriteSheet_on_loaded( GObject * extra, gpointer error, lua_State * L )
{
    //g_message( "here" );
    
    SpriteSheet * self = (SpriteSheet *) g_object_get_data( extra, "tp-sheet" );
    g_message( "SpriteSheet_on_loaded, self = %p, async = %i", self, self->async );
    if ( self->async )
    {
        lua_pushboolean( L, error ? 1 : 0 );
        UserData::invoke_callback( self, "on_loaded", 1, 0, L);
    }
}

]]

module sprite_sheet;

[[
#include "spritesheet.h"
#include <glib.h>
#include <string.h>
#include "bitmap.h"
#include "json.h"
#include "app_resource.h"
]]

[[

int get_image_bitmap( lua_State * L , Image ** image , gchar ** error_message )
{
    lua_getfield( L , 1 , "img" );

    if ( lua_isnil( L , -1 ) )
    {
        *error_message = (char*) "SpriteSheet initialization error: Key 'img' not found.";
        lua_pop( L , 1 );
        return 0;
    }

    if ( ! lua_isuserdata( L , -1 ) )
    {
        *error_message = (char*) "SpriteSheet initialization error: Property 'img' must be a Bitmap.";
        lua_pop( L , 1 );
        return 0;
    }

    if ( ! luaL_getmetafield( L , -1 , "type" ) )
    {
        *error_message = (char*) "SpriteSheet initialization error: Property 'img' must be a Bitmap.";
        lua_pop( L , 1 );
        return 0;
    }

    if ( strcmp( lua_tostring( L , -1 ) , "Bitmap" ) != 0 )
    {
        *error_message = (char*) "SpriteSheet initialization error: Property 'img' must be a Bitmap.";
        lua_pop( L , 2 );
        return 0;
    }

    lua_pop( L , 1 );

    Bitmap * bitmap_image = (Bitmap*) UserData::get_client( L , -1 );

    Image * image_tmp = bitmap_image->get_image();

    if ( ! image_tmp )
    {
        *error_message = (char*) "SpriteSheet initialization error: Bitmap must have an associated Image.";
        return 0;
    }

    *image = image_tmp;

    lua_pop( L , 1 );

    return 1;
}

int map_sprites_from_lua_table( lua_State * L , SpriteSheet * sheet , char ** error_message )
{
    lua_getfield( L , -1 , "sprites" );

    if ( lua_isnil( L , -1 ) )
    {
        *error_message = (char*) "SpriteSheet initialization error: Map must contain the key 'sprites'.";
        lua_pop( L , 1 );
        return 0;
    }

    if ( ! lua_istable( L , -1 ) )
    {
        *error_message = (char*) "SpriteSheet initialization error: Map key 'sprites' must have a table value.";
        lua_pop( L , 1 );
        return 0;
    }

    lua_pushnil( L );

    while ( lua_next( L , -2 ) )
    {
        if ( lua_istable ( L , -1 ) )
        {
            lua_getfield( L , -1 , "id" );
            lua_getfield( L , -2 , "x" );
            lua_getfield( L , -3 , "y" );
            lua_getfield( L , -4 , "w" );
            lua_getfield( L , -5 , "h" );

            int h = lua_tointeger( L , -1 );
            int w = lua_tointeger( L , -2 );
            int y = lua_tointeger( L , -3 );
            int x = lua_tointeger( L , -4 );

            const gchar * id = strdup( lua_tostring( L , -5 ) );

            lua_pop( L , 5 );

            if ( id )
            {
                sheet->map_subtexture( id , x , y , w , h );
            }
        }

        lua_pop( L , 1 );
    }

    lua_pop( L , 1 );
    return 1;
}

int download_resource( App * app , AppResource * resource , char ** contents )
{
    Network::Request request( app->get_user_agent() , resource->get_uri() );
    Network::Response response = app->get_network()->perform_request( request, app->get_cookie_jar() );

    if ( response.failed || response.body->len == 0 )
    {
        return 0;
    }

    guint8 null = '\0';
    *contents = strdup( (char*) g_byte_array_append( response.body, &null , 1 )->data );

    return 1;
}

int get_local_resource( AppResource * resource , char ** contents )
{
    const char * path = resource->get_native_path().c_str();
    if ( ! g_file_test( path, G_FILE_TEST_IS_REGULAR ) )
    {
        return 0;
    }

    GError * error;
    if ( ! g_file_get_contents( path , contents , NULL , &error ) )
    {
        return 0;
    }

    return 1;
}

int get_sprite_data_from_lua_table( lua_State * L , JSON::Array * sprite_data )
{
    JSON::Value map_value = JSON::to_json( L , -1 );

    if ( map_value.get_type() == JSON::Value::T_NULL )
    {
        return 0;
    }

    if ( ! map_value.is<JSON::Object>() )
    {
        return 0;
    }

    JSON::Object map_obj = map_value.as<JSON::Object>();

    if ( ! map_obj.has( "sprites" ) )
    {
        return 0;
    }

    if ( ! map_obj["sprites"].is<JSON::Array>() )
    {
        return 0;
    }

    *sprite_data = map_obj["sprites"].as<JSON::Array>();

    return 1;
}

int get_image_src_from_lua_table( lua_State * L , const char ** image_src )
{
    JSON::Value map_value = JSON::to_json( L , -1 );

    if ( map_value.get_type() == JSON::Value::T_NULL )
    {
        return 0;
    }

    if ( ! map_value.is<JSON::Object>() )
    {
        return 0;
    }

    JSON::Object map_obj = map_value.as<JSON::Object>();

    if ( ! map_obj.has( "img" ) )
    {
        return 0;
    }

    if ( ! map_obj["img"].is<String>() )
    {
        return 0;
    }

    *image_src = map_obj["img"].as<String>().c_str();

    return 1;
}

int retrieve_and_parse_map( App * app , const char * map_src , const char ** image_src , JSON::Array * sprite_data , char ** error_message )
{

    AppResource resource( app , map_src );

    if ( ! resource.good() )
    {
        *error_message = g_new( char , 100 );
        snprintf( *error_message , 100 , "SpriteSheet initialization error: JSON file %s does not exist." , map_src );
        return 0;
    }

    gchar * contents;

    if ( resource.is_http() )
    {
        if ( ! download_resource( app , &resource , &contents ) )
        {
            *error_message = g_new( char , 100 );
            snprintf( *error_message , 100 , "SpriteSheet initialization error: Could not download file %s." , map_src );
            return 0;
        }
    }
    else if ( resource.is_native() )
    {
        if ( ! get_local_resource( &resource , &contents ) )
        {
            *error_message = g_new( char , 100 );
            snprintf( *error_message , 100 , "SpriteSheet initialization error: Could not access file %s." , map_src );
            return 0;
        }
    }

    if ( ! contents )
    {
        *error_message = g_new( char , 100 );
        snprintf( *error_message , 100 , "SpriteSheet initialization error: Unable to open JSON file '%s'." , map_src );
        return 0;
    }

    lua_State * L = luaL_newstate();

    JSON::parse( L , contents );

    if ( lua_isnil( L , -1 ) || ! lua_istable( L , -1 ) )
    {
        *error_message = g_new( char , 100 );
        snprintf( *error_message , 100 , "SpriteSheet initialization error: Unable to parse JSON file with contents: \n%s" , contents );
        return 0;
    }

    if ( ! get_sprite_data_from_lua_table( L , sprite_data ) )
    {
        *error_message = g_new( char , 100 );
        snprintf( *error_message , 100 , "SpriteSheet initialization error: Unable to parse JSON file with contents: \n%s" , contents );
        return 0;
    }

    if ( ! get_image_src_from_lua_table( L , image_src ) )
    {
        *error_message = g_new( char , 100 );
        snprintf( *error_message , 100 , "SpriteSheet initialization error: Unable to parse JSON file with contents: \n%s" , contents );
        return 0;
    }

    lua_close( L );

    return 1;
}

void map_sprites( SpriteSheet * sheet , JSON::Array * sprite_data_ptr , char ** error_message )
{
    JSON::Array sprite_data = *sprite_data_ptr;
    for (unsigned int i=0; i<sprite_data.size(); i++)
    {
        JSON::Object sprite_datum = sprite_data[i].as<JSON::Object>();

        if (
            sprite_datum.has( "id" )
            && sprite_datum.has( "x" )
            && sprite_datum.has( "y" )
            && sprite_datum.has( "w" )
            && sprite_datum.has( "h" )
            )
        {
            const char * id = sprite_datum["id"].as<String>().c_str();
            sheet->map_subtexture(
                strdup( id ) ,
                sprite_datum["x"].as<long long>() ,
                sprite_datum["y"].as<long long>() ,
                sprite_datum["w"].as<long long>() ,
                sprite_datum["h"].as<long long>() );
        }
    }
}

int initialize( SpriteSheet * sheet , App * app , JSON::Array sprite_data , const char * image_src , Image * image , char ** error_message )
{
    if ( image_src )
    {
        image = app->load_image( image_src , false );
    }

    if ( ! image )
    {
        *error_message = (char*) "SpriteSheet initialization error: Invalid image.";
    }

    ClutterTexture * image_texture = CLUTTER_TEXTURE(clutter_texture_new());
    Images::load_texture( image_texture , image );
    sheet->set_texture( clutter_texture_get_cogl_texture( image_texture ) );

    if ( image_src )
    {
        delete image;
    }

    map_sprites( sheet , &sprite_data , error_message );

    return 1;
}

int initialize_with_map_src( SpriteSheet * sheet , App * app , const char * map_src , char ** error_message )
{
    JSON::Array sprite_data;
    const char * image_src;

    if ( ! retrieve_and_parse_map( app , map_src , &image_src , &sprite_data , error_message ) )
    {
        return 0;
    }

    if ( ! initialize( sheet , app , sprite_data , image_src , 0 , error_message ) )
    {
        return 0;
    }

    return 1;
}

void Sprite_Sheet_on_loaded(SpriteSheet * self , gpointer error , lua_State * L );
]]

class SpriteSheet [[SpriteSheet*]]
{
    SpriteSheet(table props = 0 )
        [[
            LSG;
            self = lb_construct( SpriteSheet , new SpriteSheet() );
            char * error_message;

            if ( props )
            {
                bool async = false;

                lua_getfield( L , 1 , "async" );

                if ( ! lua_isnil( L , -1 ) && lua_isboolean( L , -1 ) && lua_toboolean( L , -1 ) )
                {
                    async = true;
                }

                lua_pop( L , 1 );

                lua_getfield( L , 1 , "map" );

                if ( lua_isnil( L , -1 ) )
                {
                    lua_pop( L , 1 );
                    luaL_error( L , "SpriteSheet initialization error: Key 'map' not found." );
                }

                if ( lua_type( L , -1 ) == LUA_TSTRING )
                {
                    App * app = App::get( L );
                    const char * map_src = lua_tostring( L , -1 );

                    lua_pop( L , 1 );

                    if ( ! async )
                    {
                        if ( ! initialize_with_map_src( self , app , map_src , &error_message ) )
                        {
                            luaL_error( L , error_message );
                        }
                    }
                }
                else if ( lua_type( L , -1 ) == LUA_TTABLE )
                {
                    JSON::Array * sprite_data;
                    Image * image;

                    JSON::Array sprite_data_tmp;
                    if ( ! get_sprite_data_from_lua_table( L , &sprite_data_tmp ) )
                    {
                        lua_pop( L , 1 );
                        luaL_error( L , "SpriteSheet initialization error: Invalid sprite data." );
                    }

                    sprite_data = new JSON::Array( sprite_data_tmp );

                    lua_pop( L , 1 );

                    if ( ! get_image_bitmap( L , &image , &error_message ) )
                    {
                        luaL_error( L , error_message );
                    }

                    if ( ! initialize( self , 0 , *sprite_data , 0 , image , &error_message ) )
                    {
                        luaL_error( L , error_message );
                    }
                }
            } else {
                luaL_error( L , "SpriteSheet initialization error: Must pass a table to SpriteSheet constructor." );
            }

            LSG_END(0);
        ]];

    table get_ids()
        [[
            GList * iter = self->get_ids();

            int index = 1;

            lua_newtable( L );

            for ( ; iter ; iter = iter->next )
            {
                lua_pushstring( L , (char*) iter->data );
                lua_rawseti( L , -2 , index );
                ++index;
            }
        ]];

    ~SpriteSheet()
        [[
        ]];

    dump()
        [[
            self->dump();
        ]];

    callback on_loaded
        [[
            UserData::get(L)->connect_signal_if(
                on_loaded,
                "on_loaded",
                "load-finished",
                G_CALLBACK(Sprite_Sheet_on_loaded),
                L);
        ]];
}

[[
void Sprite_Sheet_on_loaded(SpriteSheet * self , gpointer error , lua_State * L )
{
    if ( ImageExtra::get( self )->async )
    {
        lua_pushboolean(L,error?1:0);
        UserData::invoke_callback(G_OBJECT(self),"on_loaded",1,0,L);
    }
}
]]

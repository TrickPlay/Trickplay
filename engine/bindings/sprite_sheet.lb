module sprite_sheet;

[[
#include "spritesheet.h"
#include <glib.h>
#include <string.h>
#include "bitmap.h"
#include "bitmap.lb.h"
#include "json.h"
#include "app_resource.h"
#include "util.h"
]]

[[

//------------------------------------------------------------------------
// Emit signal "later"

class EmitLoadedSignalLater : public Action
{

public:
    EmitLoadedSignalLater( SpriteSheet * self, const char * error_message )
    {
        this->self = self;
        this->error_message = error_message;
    }

protected:
    bool run()
    {
        g_signal_emit_by_name( self->extra, "on-loaded", error_message );
        return false;
    }

private:
    SpriteSheet * self;
    const char  * error_message;
};

//------------------------------------------------------------------------
// Helper functions

#define LUA_CALLBACK( self, status ) g_signal_emit_by_name( ( self )->extra, "on-loaded", status )

typedef void (* LFunc) ( lua_State * L, int index, gpointer user_data );

void lua_foreach ( lua_State * L, int index, LFunc func, gpointer user_data )
{
    index = index > 0 ? index : lua_gettop( L ) + index + 1;
    
    lua_pushnil( L );
    while ( lua_next( L, index ) )
    {
        func( L, lua_gettop( L ), user_data );
        lua_pop( L, 1 );
    }
}

class SpriteDef {
    public:
        SpriteDef( int x, int y, int w, int h, char * id )
            : x( x ), y( y ), w( w ), h( h ), id( id )
        {}
        
        int x, y, w, h;
        char * id;
};

void spritedef_delete ( SpriteDef * sprite )
{
    delete sprite;
}

void spritedef_map ( SpriteDef * sprite, SpriteSheet * self )
{
    self->map_subtexture( sprite->id, -1, sprite->x, sprite->y, sprite->w, sprite->h );
}

class SSDef {
    public:
        SSDef( SpriteSheet * ss )
            : sheet( ss ),
              sprites( g_ptr_array_new_with_free_func( (GDestroyNotify) spritedef_delete ) )
        {}
        
        ~SSDef() { g_ptr_array_free( sprites, true ); }
        
        void load ( Image * image )
        {
            if ( image )
            {
                ClutterActor * texture = clutter_texture_new();
                Images::load_texture( CLUTTER_TEXTURE( texture ), image );
                CoglHandle source = clutter_texture_get_cogl_texture( CLUTTER_TEXTURE( texture ) );
                
                cogl_handle_ref( source );
                sheet->add_texture( source );
                g_ptr_array_foreach( sprites, (GFunc) spritedef_map, sheet );
                
                clutter_actor_destroy( texture );
            }
        }
        
        int tex;
        SpriteSheet * sheet;
        GPtrArray   * sprites;
};

void async_img_callback ( Image * image, SSDef * ssdef )
{
    ssdef->load( image );
    delete ssdef;
    
    LUA_CALLBACK( ssdef->sheet, image ? NULL : "FAILED_IMG_LOAD" );
}

void ssdef_add_sprite ( lua_State * L, int index, SSDef * ssdef )
{
    LSG;
    
    if ( !lua_istable( L, index ) )
    {
        g_warning( "Couldn't understand that sprite definition." );
        return;
    }
    
    lua_getfield( L, index, "x" );
    lua_getfield( L, index, "y" );
    lua_getfield( L, index, "w" );
    lua_getfield( L, index, "h" );
    lua_getfield( L, index, "id" );
    
    SpriteDef * sprite = new SpriteDef(
        (int) lua_tointeger( L, -5 ),
        (int) lua_tointeger( L, -4 ),
        (int) lua_tointeger( L, -3 ),
        (int) lua_tointeger( L, -2 ),
        strdup( (char *) lua_tostring( L, -1 ) )
    );
    
    g_ptr_array_add( ssdef->sprites, sprite );
    
    lua_pop( L, 5 );
    
    LSG_END( 0 );
}

void add_spritesheet_map ( lua_State * L, int index, SpriteSheet * self )
{
    LSG;
    
    if ( !lua_istable( L, index ) )
    {
        g_warning( "Couldn't understand that map definition." );
        return;
    }
    
    Bitmap * bitmap;
    SSDef  * ssdef = new SSDef( self );
    
    lua_getfield( L, index, "sprites" );
    lua_getfield( L, index, "img" );
    
    if ( lua_istable( L, -2 ) )
    {
        lua_foreach( L, -2, (LFunc) ssdef_add_sprite, ssdef );
        
        g_message( "[img] type is %s", lua_typename( L, lua_type( L, -1 ) ) );
        if ( lua_isstring( L, -1 ) )
        {
            const char * img = lua_tostring( L, -1 );
            App  * app = App::get( L );
            
            if ( g_object_get_data( self->extra, "tp-async" ) )
            {
                app->load_image_async( img, false, (Image::DecodeAsyncCallback) async_img_callback, ssdef, 0 );
            }
            else
            {
                ssdef->load( app->load_image( img, false ) );
                delete ssdef;
            }
        }
        else if (( bitmap = LB_GET_BITMAP( L, -1 ) ))
        {
            ssdef->load( bitmap->get_image() );
            delete ssdef;
        }
        else
        {
            g_warning( "Couldn't understand that source image." );
        }
    }
    else
    {
        g_warning( "Couldn't understand that list of sprites." );
    }
    
    lua_pop( L, 2 );
    
    LSG_END( 0 );
}

void async_map_callback ( const Network::Response & response, SpriteSheet * self )
{
    if ( !response.failed && response.body->len )
    {
        guint8 null = '\0';
        char * map = g_strdup( (char*) g_byte_array_append( response.body, &null, 1 )->data );
        
        lua_State * L = luaL_newstate();
        
        JSON::parse( L, map );
        
        if ( lua_istable( L, -1 ) )
        {
            lua_foreach( L, -1, (LFunc) add_spritesheet_map, self );
        }
        else
        {
            LUA_CALLBACK( self, "FAILED_MAP_PARSE" );
        }
        
        lua_close( L );
    }
    else
    {
        LUA_CALLBACK( self, "FAILED_MAP_LOAD" );
    }
}

void lua_load_map_uri( lua_State * L, int index, SpriteSheet * self )
{
    index = index > 0 ? index : lua_gettop( L ) + index + 1;
    
    char * map;
    App  * app = App::get( L );
    AppResource resource( app, lua_tostring( L, -1 ) );
    
    if ( resource.is_native() )
    {
        const char * path = resource.get_native_path().c_str();
        if ( ! g_file_get_contents( path, &map, NULL, NULL ) )
        {
            luaL_error( L, "SpriteSheet: could not open map %s.", path );
        }
    }
    else if ( resource.is_http() )
    {
        Network::Request request( app->get_user_agent(), resource.get_uri() );
        
        if ( g_object_get_data( self->extra, "tp-async" ) )
        {
            app->get_network()->perform_request_async( request, app->get_cookie_jar(),
                (Network::ResponseCallback) async_map_callback, self, 0 );
        }
        else
        {
            Network::Response response = app->get_network()->perform_request( request, app->get_cookie_jar() );
            
            if ( response.failed || response.body->len == 0 )
            {
                luaL_error( L, "SpriteSheet: could not download map %s.", resource.get_uri().c_str() );
            }
            
            guint8 null = '\0';
            map = g_strdup( (char*) g_byte_array_append( response.body, &null, 1 )->data );
        }
    }
    else
    {
        luaL_error( L, "SpriteSheet: could not understand map URI %s.", lua_tostring( L, -1 ) );
    }
    
    if ( map )
    {
        JSON::parse( L, map );
    }
    else
    {
        lua_pushnil( L );
    }
}

void Sprite_Sheet_on_loaded( GObject * extra, char * error, lua_State * L );

]]

/*
    Class: SpriteSheet
    
    The SpriteSheet class will load a single image containing many sprites. An app may want to do this to avoid loading possibly hundreds of small icons or sprites, or to simplify the management of many similar images onscreen at once. A SpriteSheet, once created, is a static userdata that can be referenced by <Sprite> or <NineSlice>. These objects can then draw sections from the SpriteSheet directly without creating copies or clones.
    
    In order to know what to draw, the SpriteSheet needs a map of where individual sprites appear in the texture. This map is specified in the SpriteSheet constructor with either a Lua table, or a .json file with the following structure.
    
    (code)
    // assets.json
    {
        "sprites": [
            { "x": 0, "y": 0, "w": 16, "h": 16, "id": "sprite-1.png" },
            { "x": 16, "y": 0, "w": 16, "h": 16, "id": "subfolder/sprite-2.png },
            ...
        ],
        "img": "assets.png"
    }
    
    -- main.lua
    sheet1 = SpriteSheet { map = "assets.json" }
    sheet2 = SpriteSheet { map = {
        sprites = {
            { x = 0, y = 0, w = 16, h = 16, id = "sprite-1.png" },
            { x = 16, y = 0, w = 16, h = 16, id = "subfolder/sprite-2.png" },
            ...
        }
    }, img = Bitmap{ src = "assets.png" } }
    (end)
    
    Notice that the id strings look like path names; this is not stricly necessary, since ids can be any string at all, but since SpriteSheet textures are usually generated from seperate source images, using a path name as if the SpriteSheet is actually a folder of images is often clearer. By default, the SpriteSheet will load the image named by the "img" property in the .json file. This can be overridden by passing a different image along with the map to the SpriteSheet constructor, as below. If map is a Lua table, passing a <Bitmap> to img is required.
    
    (code)
    sheet = SpriteSheet { map = "assets.json", img = Bitmap{ src = "assets.png" } }
    (end)
    
    What if the app needs to download its assets from a URL? The SpriteSheet can take URI paths as well as local paths, and load its map and texture asynchronously.
    
    (code)
    sheet = SpriteSheet { map = "http://www.trickplay.com/resources/assets.json", async = true }
    (end)
    
    *See Also:* the <Sprite> class
    
*/

class SpriteSheet [[SpriteSheet*]]
{
    /*
        Constructor: SpriteSheet
        
        The SpriteSheet() constructor creates a new SpriteSheet object.
        
        *Arguments:*
        
        props - table defining the object's construction
        
        *Properties:*
        
        map - Lua table or path to a .json file of sprite definitions
        [img] - Bitmap to load from. This is required if map is a Lua table, or a .json file with no "img" property
        [async] - load remote URIs asynchronously
        
        *Return Value:* new NineSlice object
    */
    
    SpriteSheet(table props = 0 )
        [[
            LSG;
            self = lb_construct( SpriteSheet, new SpriteSheet() );
            g_object_set_data( self->extra, "tp-app", App::get( L ) );

            g_signal_connect_data( self->extra, "on-loaded", (GCallback) Sprite_Sheet_on_loaded,
                L, 0, GConnectFlags( 0 ) );

            if ( props )
            {
                lua_getfield( L, 1, "async" );
                lua_getfield( L, 1, "map" );
                
                g_object_set_data( self->extra, "tp-async", GINT_TO_POINTER( lua_toboolean( L, -2 ) ) );

                if ( lua_isstring( L, -1 ) )
                {
                    lua_load_map_uri( L, -1, self );
                    lua_remove( L, -2 );
                }
                
                if ( lua_istable( L, -1 ) )
                {
                    lua_foreach( L, -1, (LFunc) add_spritesheet_map, self );
                }
                else if ( ! lua_isnil( L, -1 ) )
                {
                    luaL_error( L, "SpriteSheet initialization error: key 'map' was not a table or URI string." );
                }
                
                lua_pop( L, 2 );
            }
            else
            {
                luaL_error( L, "SpriteSheet initialization error: Must pass a table to SpriteSheet constructor." );
            }

            LSG_END(0);
        ]];

    /*
        Function: get_ids()
        
        Returns a table of all the sprite ids in this SpriteSheet
    */

    table get_ids()
        [[
            GList * iter = self->get_ids();

            int index = 1;

            lua_newtable( L );

            for ( ; iter ; iter = iter->next )
            {
                lua_pushstring( L, (char*) iter->data );
                lua_rawseti( L, -2, index );
                ++index;
            }
        ]];

    ~SpriteSheet()
        [[
        ]];

    dump()
        [[
            self->dump();
        ]];

    /*
        Callback: on_loaded
        
        The on_loaded() event handler is fired when an asynchronously-loaded SpriteSheet has finished loading. 
        
        *Prototype:*
        (code)
        void on_loaded( SpriteSheet *sheet )
        (end)
        
        *Return Value:* None
    */

    callback on_loaded
        [[
        ]];
}

[[
void Sprite_Sheet_on_loaded( GObject * extra, char * error, lua_State * L )
{
    lua_pushboolean( L, error ? 1 : 0 );

    if ( error )
    {
        lua_pushstring( L, error );
    }
    else
    {
        lua_pushnil( L );
    }

    SpriteSheet * self = (SpriteSheet *) g_object_get_data( extra, "tp-sheet" );

    UserData::invoke_callback( self, "on_loaded", 2, 0, L);
}

#undef LUA_CALLBACK
]]

module sprite_sheet;

[[
#include "spritesheet.h"
#include <glib.h>
#include <string.h>
#include "bitmap.h"
#include "bitmap.lb.h"
#include "json.h"
#include "app_resource.h"
#include "util.h"
]]

[[
/*

int get_sprites_from_lua_table( lua_State * L, JSON::Array ** sprites )
{
    JSON::Value map_value = JSON::to_json( L, -1 );

    if ( map_value.get_type() == JSON::Value::T_NULL )
    {
        return 0;
    }

    if ( ! map_value.is<JSON::Object>() )
    {
        return 0;
    }

    JSON::Object map_obj = map_value.as<JSON::Object>();

    if ( ! map_obj.has( "sprites" ) )
    {
        return 0;
    }

    if ( ! map_obj["sprites"].is<JSON::Array>() )
    {
        // An empty table is converted to JSON::Object so this handles an empty array

        if ( map_obj["sprites"].is<JSON::Object>() )
        {
            JSON::Object sprites_obj = map_obj["sprites"].as<JSON::Object>();
            if ( sprites_obj.begin() != sprites_obj.end() )
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }

    *sprites = new JSON::Array( map_obj["sprites"].as<JSON::Array>() );

    return 1;
}

int get_image_src_from_lua_table( lua_State * L, const char ** image_src )
{
    JSON::Value map_value = JSON::to_json( L, -1 );

    if ( map_value.get_type() == JSON::Value::T_NULL )
    {
        return 0;
    }

    if ( ! map_value.is<JSON::Object>() )
    {
        return 0;
    }

    JSON::Object map_obj = map_value.as<JSON::Object>();

    if ( ! map_obj.has( "img" ) )
    {
        return 0;
    }

    if ( ! map_obj["img"].is<String>() )
    {
        return 0;
    }

    *image_src = strdup( map_obj["img"].as<String>().c_str() );

    return 1;
}

int get_bitmap_image_from_lua_table( lua_State * L, Image ** image, gchar ** error_message )
{
    lua_getfield( L, 1, "img" );

    if ( lua_isnil( L, -1 ) )
    {
        *error_message = (char*) "Key 'img' not found.";
        lua_pop( L, 1 );
        return 0;
    }

    if ( ! lua_isuserdata( L, -1 ) )
    {
        *error_message = (char*) "Property 'img' must be a Bitmap.";
        lua_pop( L, 1 );
        return 0;
    }

    if ( ! luaL_getmetafield( L, -1, "type" ) )
    {
        *error_message = (char*) "Property 'img' must be a Bitmap.";
        lua_pop( L, 1 );
        return 0;
    }

    if ( strcmp( lua_tostring( L, -1 ), "Bitmap" ) != 0 )
    {
        *error_message = (char*) "Property 'img' must be a Bitmap.";
        lua_pop( L, 2 );
        return 0;
    }

    lua_pop( L, 1 );

    Bitmap * bitmap_image = (Bitmap*) UserData::get_client( L, -1 );

    Image * image_tmp = bitmap_image->get_image();

    if ( ! image_tmp )
    {
        *error_message = (char*) "Bitmap must have an associated Image.";
        return 0;
    }

    *image = image_tmp;

    lua_pop( L, 1 );

    return 1;
}

int parse_map( char * map_str, JSON::Array ** sprites, const char ** image_src, char ** error_message )
{
    lua_State * L = luaL_newstate();

    JSON::parse( L, map_str );

    if ( lua_isnil( L, -1 ) || ! lua_istable( L, -1 ) )
    {
        *error_message = (char*) "Unable to parse JSON file";
        return 0;
    }

    if ( ! get_sprites_from_lua_table( L, sprites ) )
    {
        *error_message = (char*) "Unable to parse JSON file";
        return 0;
    }

    if ( ! get_image_src_from_lua_table( L, image_src ) )
    {
        *error_message = (char*) "Unable to parse JSON file";
        return 0;
    }

    lua_close( L );

    return 1;
}

//------------------------------------------------------------------------
// Synchronous downloader

int download_map( App * app, AppResource resource, char ** contents )
{
    if ( resource.is_http() )
    {
        Network::Request request( app->get_user_agent(), resource.get_uri() );
        Network::Response response = app->get_network()->perform_request( request, app->get_cookie_jar() );

        if ( response.failed || response.body->len == 0 )
        {
            return 0;
        }

        guint8 null = '\0';
        *contents = g_strdup( (char*) g_byte_array_append( response.body, &null, 1 )->data );
    }
    else if ( resource.is_native() )
    {
        const char * path = resource.get_native_path().c_str();
        if ( ! g_file_test( path, G_FILE_TEST_IS_REGULAR ) )
        {
            return 0;
        }

        GError * error;
        if ( ! g_file_get_contents( path, contents, NULL, &error ) )
        {
            return 0;
        }
    }

    return 1;
}

//------------------------------------------------------------------------
// Initializer
void map_sprites( SpriteSheet * sheet, int tex, JSON::Array sprites )
{
    for ( unsigned int i = 0; i < sprites.size(); i++ )
    {
        JSON::Object sprite = sprites[i].as<JSON::Object>();

        if (
            sprite.has( "id" )
            && sprite.has( "x" )
            && sprite.has( "y" )
            && sprite.has( "w" )
            && sprite.has( "h" )
            )
        {
            const char * id = sprite["id"].as<String>().c_str();
            sheet->map_subtexture(
                strdup( id ), tex,
                sprite["x"].as<long long>(),
                sprite["y"].as<long long>(),
                sprite["w"].as<long long>(),
                sprite["h"].as<long long>() );
        }
    }
}

void initialize( SpriteSheet * sheet, JSON::Array sprites, Image * image )
{
    ClutterTexture * image_texture = CLUTTER_TEXTURE(clutter_texture_new());
    Images::load_texture( image_texture, image );
    int tex = sheet->add_texture( clutter_texture_get_cogl_texture( image_texture ) );

    char * img_src = (char *) g_object_get_data( sheet->extra, "tp-src" );
    g_object_set_data_full( G_OBJECT( image_texture ), "tp-src", (gpointer*) strdup( img_src ), g_free );

    map_sprites( sheet, tex, sprites );
}

//------------------------------------------------------------------------
// Async constructor helpers

void load_image_callback( Image * image, gpointer me )
{
    SpriteSheet * self = (SpriteSheet *) me;
    if ( ! image )
    {
        g_signal_emit_by_name( self->extra, "load-finished", "Could not load image." );
        return;
    }

    JSON::Array * sprites = (JSON::Array*) g_object_get_data( self->extra, "tp-sprite-data" );

    initialize( self, * sprites, image );

    g_signal_emit_by_name( self->extra, "load-finished", 0 );
}

void download_map_callback( const Network::Response & response, gpointer me )
{
    SpriteSheet * self = (SpriteSheet*) me;
    App * app = (App *) g_object_get_data( self->extra, "tp-app" );

    if ( response.failed || response.body->len == 0 )
    {
        g_signal_emit_by_name( self->extra, "load-finished", "Could not load SpriteSheet map" );
        return;
    }

    char * contents;
    const unsigned char null = '\0';
    contents = strdup( (char *) g_byte_array_append( response.body, &null, 1 )->data );

    JSON::Array * sprites;
    const char * image_src;
    char * error_message;

    if ( ! parse_map( contents, &sprites, &image_src, &error_message ) )
    {
        Action::post( new EmitLoadedSignalLater( self, error_message ) );
        return;
    }

    g_object_set_data_full( self->extra, "tp-sprite-data", sprites, g_free );
    g_object_set_data_full( self->extra, "tp-src", (gpointer *) image_src, g_free );

    app->load_image_async( image_src, false, load_image_callback, self, 0 );
}

//------------------------------------------------------------------------
// Async Constructor

void construct_async( SpriteSheet * self, AppResource resource )
{
    App * app = (App*) g_object_get_data( self->extra, "tp-app" );

    if ( resource.is_http() )
    {
        Network::Request request( app->get_user_agent(), resource.get_uri() );
        app->get_network()->perform_request_async(
            request,
            app->get_cookie_jar(),
            download_map_callback,
            self,
            0 );
    }
    else if ( resource.is_native() )
    {
        char * contents;
        const char * path = resource.get_native_path().c_str();

        if ( ! g_file_test( path, G_FILE_TEST_IS_REGULAR ) )
        {
            Action::post( new EmitLoadedSignalLater( self, "Could not open map file" ) );
            return;
        }

        if ( ! g_file_get_contents( path, &contents, NULL, 0 ) )
        {
            Action::post( new EmitLoadedSignalLater( self, "Could not open map file" ) );
            return;
        }

        JSON::Array * sprites;
        const char * image_src;
        char * error_message;

        if ( ! parse_map( contents, &sprites, &image_src, &error_message ) )
        {
            Action::post( new EmitLoadedSignalLater( self, "Could not parse map file" ) );
            return;
        }

        g_object_set_data_full( self->extra, "tp-sprite-data", sprites, g_free );
        g_object_set_data_full( self->extra, "tp-src", (gpointer*) image_src, g_free );

        app->load_image_async( image_src, false, load_image_callback, self, 0 );
    }
}
 */

//------------------------------------------------------------------------
// Emit signal "later"

class EmitLoadedSignalLater : public Action
{

public:
    EmitLoadedSignalLater( SpriteSheet * self, const char * error_message )
    {
        this->self = self;
        this->error_message = error_message;
    }

protected:
    bool run()
    {
        g_signal_emit_by_name( self->extra, "load-finished", error_message );
        return false;
    }

private:
    SpriteSheet * self;
    const char * error_message;
};

//------------------------------------------------------------------------
// Helper functions

typedef void (* LFunc) ( lua_State * L, int index, gpointer user_data );

void lua_foreach ( lua_State * L, int index, LFunc func, gpointer user_data )
{
    index = index > 0 ? index : lua_gettop( L ) + index + 1;
    
    lua_pushnil( L );
    while ( lua_next( L, index ) )
    {
        func( L, lua_gettop( L ), user_data );
        lua_pop( L, 1 );
    }
}

class SpriteDef {
    public:
        SpriteDef( int x, int y, int w, int h, char * id )
            : x( x ), y( y ), w( w ), h( h ), id( id )
        {}
        
        int x, y, w, h;
        char * id;
};

void spritedef_delete ( SpriteDef * sprite )
{
    delete sprite;
}

void spritedef_map ( SpriteDef * sprite, SpriteSheet * self )
{
    self->map_subtexture( sprite->id, -1, sprite->x, sprite->y, sprite->w, sprite->h );
}

class SSDef {
    public:
        SSDef( SpriteSheet * ss )
            : sheet( ss ),
              sprites( g_ptr_array_new_with_free_func( (GDestroyNotify) spritedef_delete ) )
        {}
        
        ~SSDef() { g_ptr_array_free( sprites, true ); }
        
        void load ( Image * image )
        {
            ClutterActor * texture = clutter_texture_new();
            Images::load_texture( CLUTTER_TEXTURE( texture ), image );
            CoglHandle source = clutter_texture_get_cogl_texture( CLUTTER_TEXTURE( texture ) );
            
            cogl_handle_ref( source );
            sheet->add_texture( source );
            g_ptr_array_foreach( sprites, (GFunc) spritedef_map, sheet );
            
            clutter_actor_destroy( texture );
        }
        
        int tex;
        SpriteSheet * sheet;
        GPtrArray   * sprites;
};

void load_image_callback ( Image * image, SSDef * ssdef )
{
    if ( !image )
    {
        g_signal_emit_by_name( ssdef->sheet->extra, "load-finished", "Could not load image." );
        return;
    }
    
    ssdef->load( image );
    delete ssdef;
    
    g_signal_emit_by_name( ssdef->sheet->extra, "load-finished", 0 );
}

void ssdef_add_sprite ( lua_State * L, int index, SSDef * ssdef )
{
    LSG;
    
    if ( !lua_istable( L, index ) )
    {
        g_warning( "Couldn't understand that sprite definition." );
        return;
    }
    
    lua_getfield( L, index, "x" );
    lua_getfield( L, index, "y" );
    lua_getfield( L, index, "w" );
    lua_getfield( L, index, "h" );
    lua_getfield( L, index, "id" );
    
    SpriteDef * sprite = new SpriteDef(
        (int) lua_tointeger( L, -5 ),
        (int) lua_tointeger( L, -4 ),
        (int) lua_tointeger( L, -3 ),
        (int) lua_tointeger( L, -2 ),
        strdup( (char *) lua_tostring( L, -1 ) )
    );
    
    g_ptr_array_add( ssdef->sprites, sprite );
    
    lua_pop( L, 5 );
    
    LSG_END( 0 );
}

void add_spritesheet_map ( lua_State * L, int index, SpriteSheet * self )
{
    LSG;
    
    if ( !lua_istable( L, index ) )
    {
        g_warning( "Couldn't understand that map definition." );
        return;
    }
    
    Bitmap * bitmap;
    SSDef  * ssdef = new SSDef( self );
    
    lua_getfield( L, index, "sprites" );
    lua_getfield( L, index, "img" );
    
    if ( lua_istable( L, -2 ) )
    {
        lua_foreach( L, -2, (LFunc) ssdef_add_sprite, ssdef );
        
        g_message( "[img] type is %s", lua_typename( L, lua_type( L, -1 ) ) );
        if ( lua_isstring( L, -1 ) )
        {
            const char * img = lua_tostring( L, -1 );
            App  * app = App::get( L );
            
            if ( g_object_get_data( self->extra, "tp-async" ) )
            {
                app->load_image_async( img, false, (Image::DecodeAsyncCallback) load_image_callback, ssdef, 0 );
            }
            else
            {
                ssdef->load( app->load_image( img, false ) );
                delete ssdef;
            }
        }
        else if (( bitmap = LB_GET_BITMAP( L, -1 ) ))
        {
            ssdef->load( bitmap->get_image() );
            delete ssdef;
        }
        else
        {
            g_warning( "Couldn't understand that source image." );
        }
    }
    else
    {
        g_warning( "Couldn't understand that list of sprites." );
    }
    
    lua_pop( L, 2 );
    
    LSG_END( 0 );
}

void lua_load_map_uri( lua_State * L, int index, SpriteSheet * self )
{
    index = index > 0 ? index : lua_gettop( L ) + index + 1;
    
    App * app = App::get( L );
    AppResource resource( app, lua_tostring( L, -1 ) );
    
    if ( g_object_get_data( self->extra, "tp-async" ) )
    {
        // do something asyncy
        lua_pushnil( L );
    }
    else
    {
        char * map;
        if ( resource.is_native() )
        {
            const char * path = resource.get_native_path().c_str();
            if ( ! g_file_get_contents( path, &map, NULL, NULL ) )
            {
                luaL_error( L, "SpriteSheet: could not open map" );
            }
        }
        else if ( resource.is_http() )
        {
            Network::Request request( app->get_user_agent(), resource.get_uri() );
            Network::Response response = app->get_network()->perform_request( request, app->get_cookie_jar() );
            
            if ( response.failed || response.body->len == 0 )
            {
                luaL_error( L, "SpriteSheet: could not download map" );
            }
            
            guint8 null = '\0';
            map = g_strdup( (char*) g_byte_array_append( response.body, &null, 1 )->data );
        }
        else
        {
            luaL_error( L, "SpriteSheet: could not understand map URI" );
        }
        
        if ( map )
        {
            JSON::parse( L, map );
        }
        else
        {
            lua_pushnil( L );
        }
    }
}

void Sprite_Sheet_on_loaded(GObject * extra, gpointer error, lua_State * L );
]]

class SpriteSheet [[SpriteSheet*]]
{
    SpriteSheet(table props = 0 )
        [[
            LSG;
            self = lb_construct( SpriteSheet, new SpriteSheet() );
            g_object_set_data( self->extra, "tp-app", App::get( L ) );

            g_signal_connect_data( self->extra, "load-finished", G_CALLBACK( Sprite_Sheet_on_loaded ),
                L, 0, GConnectFlags( 0 ) );

            if ( props )
            {
                lua_getfield( L, 1, "async" );
                lua_getfield( L, 1, "map" );
                
                g_object_set_data( self->extra, "tp-async", GINT_TO_POINTER( lua_toboolean( L, -2 ) ) );

                if ( lua_isstring( L, -1 ) )
                {
                    lua_load_map_uri( L, -1, self );
                    lua_remove( L, -2 );
                }
                
                if ( lua_istable( L, -1 ) )
                {
                    lua_foreach( L, -1, (LFunc) add_spritesheet_map, self );
                }
                else
                {
                    luaL_error( L, "SpriteSheet initialization error: key 'map' was not a table or string." );
                }
                
                lua_pop( L, 2 );
            }
            else
            {
                luaL_error( L, "SpriteSheet initialization error: Must pass a table to SpriteSheet constructor." );
            }

            LSG_END(0);
        ]];

    table get_ids()
        [[
            GList * iter = self->get_ids();

            int index = 1;

            lua_newtable( L );

            for ( ; iter ; iter = iter->next )
            {
                lua_pushstring( L, (char*) iter->data );
                lua_rawseti( L, -2, index );
                ++index;
            }
        ]];

    ~SpriteSheet()
        [[
        ]];

    dump()
        [[
            self->dump();
        ]];

    callback on_loaded
        [[
        ]];
}

[[
void Sprite_Sheet_on_loaded(GObject * extra, gpointer error, lua_State * L )
{
    lua_pushboolean(L,error?1:0);

    if ( error )
    {
        lua_pushstring( L, (char*) error );
    }
    else
    {
        lua_pushnil( L );
    }

    SpriteSheet * self = (SpriteSheet*) g_object_get_data( extra, "tp-sheet" );

    UserData::invoke_callback(self,"on_loaded",2,0,L);
}
]]

module sprite_sheet;

[[
#include <glib.h>
#include "spritesheet.h"
#include "clutter_util.h"
#include <string.h>
#include "bitmap.h"
#include "bitmap.lb.h"
#include "json.h"
#include "app_resource.h"
#include "util.h"
]]

[[

//------------------------------------------------------------------------
// Emit signal "later"

class EmitLoadedSignalLater : public Action
{

public:
    EmitLoadedSignalLater( SpriteSheet * self, const char * error_message )
    {
        this->self = self;
        this->error_message = error_message;
    }

protected:
    bool run()
    {
        g_signal_emit_by_name( self->extra, "load-finished", error_message );
        return false;
    }

private:
    SpriteSheet * self;
    const char  * error_message;
};

//------------------------------------------------------------------------
// Helper functions

typedef void (* LFunc) ( lua_State * L, int index, gpointer user_data );
typedef SpriteSheet::Source Source;

void lua_foreach ( lua_State * L, int index, LFunc func, gpointer user_data )
{
    index = index > 0 ? index : lua_gettop( L ) + index + 1;

    lua_pushnil( L );
    while ( lua_next( L, index ) )
    {
        func( L, lua_gettop( L ), user_data );
        lua_pop( L, 1 );
    }
}

void async_img_callback( Image * image, Source * source )
{
    if ( image )
    {
        source->load( image );
        source->sheet->emit_signal( image ? NULL : "FAILED_IMG_LOAD" );
    }
}

void spritesheet_source_path( SpriteSheet * self, const char * path )
{
    App * app = (App *) g_object_get_data( G_OBJECT( self->extra ), "tp-app" );
    const char * json = (const char *) g_object_get_data( self->extra, "tp-json-path" );

    if ( json )
    {
        json = g_path_get_dirname( json );
        path = g_build_filename( json, path, NULL );
    }

    if ( self->async )
    {
        app->load_image_async( path, false, (Image::DecodeAsyncCallback) async_img_callback,
            self->add_source(), NULL );
    }
    else
    {
        self->add_source()->load( app->load_image( path, false ) );
    }

    if( json )
    {
        free( (void *) path );
        free( (void *) json );
    }
}

void spritesheet_add_lua_sprite ( lua_State * L, int index, SpriteSheet * self )
{
    LSG;

    if ( !lua_istable( L, index ) )
    {
        g_warning( "Couldn't understand that sprite definition." );
        return;
    }

    lua_getfield( L, index, "x" );
    lua_getfield( L, index, "y" );
    lua_getfield( L, index, "w" );
    lua_getfield( L, index, "h" );
    lua_getfield( L, index, "id" );

    self->map_subtexture(
        strdup( (char *) lua_tostring( L, -1 ) ),
        (int) lua_tointeger( L, -5 ),
        (int) lua_tointeger( L, -4 ),
        (int) lua_tointeger( L, -3 ),
        (int) lua_tointeger( L, -2 )
    );

    lua_pop( L, 5 );

    LSG_END( 0 );
}

void spritesheet_add_lua_map ( lua_State * L, int index, SpriteSheet * self )
{
    LSG;

    if ( !lua_istable( L, index ) )
    {
        g_warning( "Couldn't understand that map definition." );
        return;
    }

    Bitmap * bitmap;

    lua_getfield( L, index, "sprites" );
    lua_getfield( L, index, "img" );

    if ( lua_istable( L, -2 ) )
    {
        if ( lua_isstring( L, -1 ) )
        {
            spritesheet_source_path( self, lua_tostring( L, -1 ) );
        }
        else if (( bitmap = LB_GET_BITMAP( L, -1 ) ))
        {
            self->add_source()->load( bitmap->get_image() );
        }
        else
        {
            g_warning( "Couldn't understand that source image." );
        }

        lua_foreach( L, -2, (LFunc) spritesheet_add_lua_sprite, self );
    }
    else
    {
        g_warning( "Couldn't understand that list of sprites." );
    }

    lua_pop( L, 2 );

    LSG_END( 0 );
}

void spritesheet_add_json_maps ( SpriteSheet * self, JSON::Array & array )
{
    for ( unsigned i = 0; i < array.size(); i++ )
    {
        JSON::Object map = array[i].as<JSON::Object>();

        spritesheet_source_path( self, map.at( "img" ).as<std::string>().c_str() );
        JSON::Array sprites = map.at( "sprites" ).as<JSON::Array>();

        for( unsigned i = 0; i < sprites.size(); i++ )
        {
            JSON::Object sprite = sprites[i].as<JSON::Object>();
            self->map_subtexture(
                strdup( sprite.at( "id" ).as<std::string>().c_str() ),
                (int) sprite.at( "x" ).as<long long>(),
                (int) sprite.at( "y" ).as<long long>(),
                (int) sprite.at( "w" ).as<long long>(),
                (int) sprite.at( "h" ).as<long long>()
            );
        }
    }
}

void async_map_callback ( const Network::Response & response, SpriteSheet * self )
{
    if ( !response.failed && response.body->len )
    {
        JSON::Value root = JSON::Parser::parse( (char *) response.body->data, response.body->len );

        if ( root.is<JSON::Array>() )
        {
            spritesheet_add_json_maps( self, root.as<JSON::Array>() );
        }
        else
        {
            self->emit_signal( "FAILED_MAP_PARSE" );
        }
    }
    else
    {
        self->emit_signal( "FAILED_MAP_LOAD" );
    }
}

void spritesheet_load_json( SpriteSheet * self, const char * path )
{
    App  * app = (App *) g_object_get_data( G_OBJECT( self->extra ), "tp-app" );
    g_object_set_data_full( self->extra, "tp-json-path", strdup( path ), g_free );

    char * map = NULL;
    gsize length;
    AppResource resource( app, path );

    if ( resource.is_native() )
    {
        if ( ! g_file_get_contents( resource.get_native_path().c_str(), &map, &length, NULL ) )
        {
            g_warning( "SpriteSheet: could not open map %s.", path );
        }
    }
    else if ( resource.is_http() )
    {
        Network::Request request( app->get_user_agent(), resource.get_uri() );

        if ( self->async )
        {
            app->get_network()->perform_request_async( request, app->get_cookie_jar(),
                (Network::ResponseCallback) async_map_callback, self, 0 );
        }
        else
        {
            Network::Response response = app->get_network()->perform_request( request, app->get_cookie_jar() );

            if ( response.failed || response.body->len == 0 )
            {
                g_warning( "SpriteSheet: could not download map %s.", path );
            }

            map = (char *) response.body->data;
            length = response.body->len;
        }
    }
    else
    {
        g_warning( "SpriteSheet: could not understand map URI %s.", path );
    }

    if ( map )
    {
        JSON::Value root = JSON::Parser::parse( map, length );

        if ( root.is<JSON::Array>() )
        {
            spritesheet_add_json_maps( self, root.as<JSON::Array>() );
        }
        else
        {
            g_warning( "SpriteSheet: could not parse map %s.", path );
        }
    }
}

void Sprite_Sheet_on_loaded( GObject * extra, char * error, lua_State * L );

]]

/*
    Class: SpriteSheet

    The SpriteSheet class will load a set of large images containing many small sprites. An app may want to do this to avoid loading possibly hundreds of small icons or sprites, or to simplify the management of many similar images onscreen at once. A SpriteSheet, once created, is a static userdata that can be referenced by <Sprite> or <NineSlice>. These objects can then draw sprites from the SpriteSheet directly without creating copies or clones.

    In order to know what to draw, the SpriteSheet needs a map of where individual sprites appear in each source texture. This map is specified in the SpriteSheet constructor with either a Lua table, or a .json file with the following structure.

    (code)
    // assets.json
    [
        {
            "sprites": [
                { "x": 0, "y": 0, "w": 16, "h": 16, "id": "sprite-1.png" },
                { "x": 16, "y": 0, "w": 16, "h": 16, "id": "subfolder/sprite-2.png },
                ...
            ],
            "img": "assets.png"
        },
        ...
    ]

    -- main.lua
    sheet1 = SpriteSheet { map = "assets.json" }
    sheet2 = SpriteSheet { map = {
        {
            sprites = {
                { x = 0, y = 0, w = 16, h = 16, id = "sprite-1.png" },
                { x = 16, y = 0, w = 16, h = 16, id = "subfolder/sprite-2.png" },
                ...
            },
            img = Bitmap{ src = "assets.png" }
        },
        ...
    }
    (end)

    Notice that the id strings look like path names; this is not stricly necessary, since ids can be any string at all, but since SpriteSheets are usually generated from seperate source files, using a path name as if the SpriteSheet is actually a folder of images is often clearer.

    What if the app needs to download its assets from a URL? The SpriteSheet can take URI paths as well as local paths, and load its map and texture asynchronously.

    (code)
    sheet = SpriteSheet { map = "http://www.trickplay.com/resources/assets.json", async = true }
    (end)

    *See Also:* the <Sprite> class

*/

class SpriteSheet [[SpriteSheet*]]
{
    /*
        Constructor: SpriteSheet

        The SpriteSheet() constructor creates a new SpriteSheet object.

        *Arguments:*

        props - table defining the object's construction

        *Properties:*

        map - Lua table or path to a .json file of source-and-sprite definitions
        [async] - load remote URIs asynchronously

        *Return Value:* new NineSlice object
    */

    SpriteSheet(table props = 0 )
        [[
            LSG;
            self = lb_construct( SpriteSheet, new SpriteSheet() );

            g_signal_connect_data( self->extra, "load-finished",
                (GCallback) Sprite_Sheet_on_loaded,
                L, 0, GConnectFlags( 0 ) );

            g_object_set_data( G_OBJECT( self->extra ), "tp-app", App::get( L ) );

            if ( props )
            {
                ClutterUtil::set_props_from_table( L, props );

                lua_getfield( L, 1, "async" );
                lua_getfield( L, 1, "map" );

                self->async = lua_toboolean( L, -2 );

                if ( lua_isstring( L, -1 ) )
                {
                    spritesheet_load_json( self, lua_tostring( L, -1 ) );
                }
                else if ( lua_istable( L, -1 ) )
                {
                    lua_foreach( L, -1, (LFunc) spritesheet_add_lua_map, self );
                }
                else
                {
                    luaL_error( L, "SpriteSheet initialization error: key 'map' was not a table or URI string." );
                }

                lua_pop( L, 2 );
            }
            else
            {
                luaL_error( L, "SpriteSheet initialization error: Must pass a table to SpriteSheet constructor." );
            }

            LSG_END( 0 );
        ]];

    ~SpriteSheet()
        [[
        ]];

    /*
        Function: get_ids()

        Returns a table of all the sprite ids in this SpriteSheet
    */

    table get_ids()
        [[
            std::list< std::string > * ids = self->get_ids();

            lua_newtable( L );
            int index = 1;

            for ( std::list< std::string >::iterator id = ids->begin(); id != ids->end(); ++id )
            {
                lua_pushstring( L, id->c_str() );
                lua_rawseti( L, -2, index++ );
            }

            delete ids;
        ]];

    /*
        Callback: on_loaded

        The on_loaded() event handler is fired whenever SpriteSheet gets a result from an asynchronous load. A single SpriteSheet may load a map and/or one or more image files asynchronously.

        *Prototype:*
        (code)
        void on_loaded( SpriteSheet self, boolean success, string status )
        (end)

        *Status Strings:*

        FAILED_MAP_LOAD - Couldn't load the JSON map from a remote URI
        FAILED_MAP_PARSE - Couldn't parse the JSON map correctly
        FAILED_IMG_LOAD - Couldn't load one of the source images (remote or local)
        nil - Successfully loaded a source image (remote or local)
    */

    callback on_loaded
        [[
        ]];
}

[[
void Sprite_Sheet_on_loaded( GObject * extra, char * error, lua_State * L )
{
    lua_pushboolean( L, !error );

    if ( error )
    {
        lua_pushstring( L, error );
    }
    else
    {
        lua_pushnil( L );
    }

    SpriteSheet * self = (SpriteSheet *) g_object_get_data( extra, "tp-sheet" );

    UserData::invoke_callback( self, "on_loaded", 2, 0, L);
}

#undef LUA_CALLBACK
]]

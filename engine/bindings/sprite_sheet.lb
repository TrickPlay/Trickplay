module sprite_sheet;

[[
#include <glib.h>
#include "spritesheet.h"
#include "clutter_util.h"
#include <string.h>
#include "bitmap.h"
#include "bitmap.lb.h"
#include "json.h"
#include "app_resource.h"
#include "util.h"
]]

[[

//------------------------------------------------------------------------
// Emit signal "later"
/*
class EmitLoadedSignalLater : public Action
{

public:
    EmitLoadedSignalLater( SpriteSheet * self, const char * error_message )
    {
        this->self = self;
        this->error_message = error_message;
    }

protected:
    bool run()
    {
        g_signal_emit_by_name( self->extra, "load-finished", error_message );
        return false;
    }

private:
    SpriteSheet * self;
    const char  * error_message;
};
*/
//------------------------------------------------------------------------
// Helper functions

typedef void (* LFunc) ( lua_State * L, int index, gpointer user_data );
typedef SpriteSheet::Source Source;

void foreach_in_table ( lua_State * L, int index, LFunc func, gpointer user_data )
{
    index = index > 0 ? index : lua_gettop( L ) + index + 1;

    lua_pushnil( L );
    while ( lua_next( L, index ) )
    {
        func( L, lua_gettop( L ), user_data );
        lua_pop( L, 1 );
    }
}

void spritesheet_add_lua_sprite ( lua_State * L, int index, Source * source )
{
    LSG;

    if ( !lua_istable( L, index ) )
    {
        g_warning( "Couldn't understand that sprite definition." );
        return;
    }

    lua_getfield( L, index, "x" );
    lua_getfield( L, index, "y" );
    lua_getfield( L, index, "w" );
    lua_getfield( L, index, "h" );
    lua_getfield( L, index, "id" );

    source->sheet->add_sprite( source,
        strdup( (char *) lua_tostring( L, -1 ) ),
        (int) lua_tointeger( L, -5 ),
        (int) lua_tointeger( L, -4 ),
        (int) lua_tointeger( L, -3 ),
        (int) lua_tointeger( L, -2 )
    );

    lua_pop( L, 5 );

    LSG_END( 0 );
}

void spritesheet_add_lua_map ( lua_State * L, int index, SpriteSheet * self )
{
    if ( !lua_istable( L, index ) )
    {
        g_warning( "Map subsheet is not a table" );
        return;
    }
    
    Bitmap * bitmap;
    Source * source = self->add_source();
    
    
    lua_getfield( L, index, "img" );
    int img = lua_gettop( L );
    
    if ( lua_isstring( L, img ) )
    {
        source->set_source( lua_tostring( L, img ) );
    }
    else if (( bitmap = LB_GET_BITMAP( L, img ) ))
    {
        source->set_source( bitmap->get_image() );
    }
    else
    {
        g_warning( "Source image is not a URI or Bitmap" );
    }
    
    lua_pop( L, 1 );
    
    
    lua_getfield( L, index, "sprites" );
    int sprites = lua_gettop( L );

    if ( lua_istable( L, sprites ) )
    {
        foreach_in_table( L, sprites, (LFunc) spritesheet_add_lua_sprite, source );
    }
    else
    {
        g_warning( "List of sprites is not a table" );
    }
    
    lua_pop( L, 1 );
}
void SpriteSheet_on_loaded( GObject * extra, gpointer error, lua_State * L );

]]

/*
    Class: SpriteSheet

    The SpriteSheet class will load a set of large images containing many small sprites. An app may want to do this to avoid loading possibly hundreds of small icons or sprites, or to simplify the management of many similar images onscreen at once. A SpriteSheet, once created, is a static userdata that can be referenced by <Sprite> or <NineSlice>. These objects can then draw sprites from the SpriteSheet directly without creating copies or clones.

    In order to know what to draw, the SpriteSheet needs a map of where individual sprites appear in each source texture. This map is specified in the SpriteSheet constructor with either a Lua table, or a .json file with the following structure.

    (code)
    // assets.json
    [
        {
            "sprites": [
                { "x": 0, "y": 0, "w": 16, "h": 16, "id": "sprite-1.png" },
                { "x": 16, "y": 0, "w": 16, "h": 16, "id": "subfolder/sprite-2.png },
                ...
            ],
            "img": "assets.png"
        },
        ...
    ]

    -- main.lua
    sheet1 = SpriteSheet { map = "assets.json" }
    sheet2 = SpriteSheet { map = {
        {
            sprites = {
                { x = 0, y = 0, w = 16, h = 16, id = "sprite-1.png" },
                { x = 16, y = 0, w = 16, h = 16, id = "subfolder/sprite-2.png" },
                ...
            },
            img = Bitmap{ src = "assets.png" }
        },
        ...
    }
    (end)

    Notice that the id strings look like path names; this is not stricly necessary, since ids can be any string at all, but since SpriteSheets are usually generated from seperate source files, using a path name as if the SpriteSheet is actually a folder of images is often clearer.

    What if the app needs to download its assets from a URL? The SpriteSheet can take URI paths as well as local paths, and load its map and texture asynchronously.

    (code)
    sheet = SpriteSheet { map = "http://www.trickplay.com/resources/assets.json", async = true }
    (end)

    *See Also:* the <Sprite> class

*/

class SpriteSheet [[SpriteSheet*]]
{
    /*
        Constructor: SpriteSheet

        The SpriteSheet() constructor creates a new SpriteSheet object.

        *Arguments:*

        props - table defining the object's construction

        *Properties:*

        map - Lua table or path to a .json file of source-and-sprite definitions
        [async] - load the map URI asynchronously, and fire an <on_loaded> event

        *Return Value:* new NineSlice object
    */

    SpriteSheet( table props = 0 )
        [[
            LSG;
            self = lb_construct( SpriteSheet, new SpriteSheet() );
            
            g_signal_connect_data( self->extra, "load-finished",
                (GCallback) SpriteSheet_on_loaded,
                L, 0, GConnectFlags( 0 ) );
            
            self->app = App::get( L );
            
            if ( props )
            {
                ClutterUtil::set_props_from_table( L, props );
                
                lua_getfield( L, 1, "async" );
                lua_getfield( L, 1, "map" );
                
                self->async = lua_toboolean( L, -2 );
                
                if ( lua_isstring( L, -1 ) )
                {
                    self->load_json( lua_tostring( L, -1 ) );
                }
                else if ( lua_istable( L, -1 ) )
                {
                    foreach_in_table( L, -1, (LFunc) spritesheet_add_lua_map, self );
                    self->loaded = true;
                    self->emit_signal( NULL );
                }
                else
                {
                    luaL_error( L, "Key 'map' was not a table or URI string." );
                }
                
                lua_pop( L, 2 );
            }
            else
            {
                luaL_error( L, "Must pass a table to SpriteSheet constructor." );
            }
            
            LSG_END( 0 );
        ]];

    ~SpriteSheet()
        [[
        ]];

    /*
        Function: get_ids()

        Returns a table of all the sprite ids in this SpriteSheet
    */

    table get_ids()
        [[
            std::list< std::string > * ids = self->get_ids();

            lua_createtable( L, 0, ids->size() );
            int table = lua_gettop( L );

            for ( std::list< std::string >::iterator id = ids->begin(); id != ids->end(); ++id )
            {
                lua_pushboolean( L, true );
                lua_setfield( L, table, id->c_str() );
            }

            delete ids;
        ]];

    /*
        Property: map_uri

        Returns the URI of the JSON map of this SpriteSheet, if applicable, or an empty string otherwise
    */
    
    readonly string map_uri
        [[
            map_uri = self->get_json_path();
        ]];
        
    /*
        Property: loaded
        
        The loaded property is a boolean value indicating if the JSON map of the SpriteSheet was loaded successfully.
        
        *Default Setting:* false
        
        *See Also:* the <map_uri> property
    */
    
    readonly bool loaded
        [[
            loaded = self->loaded;
        ]];
        
    /*
        Function: add_onloaded_listener
        
        The add_onloaded_listener() function registers a handler function for <on_loaded> events.
        
        *Arguments*
        
            fn - reference to handler function. The function prototype is described below.

        *Return Value:* Handle to the registered handler. Pass this handle to the <remove_onloaded_listener> function to unregister the handler.

        *Handler Prototype:*

        (code)
        fn( SpriteSheet self, boolean failed )
        (end)

        *Handler Arguments:*

            self - the SpriteSheet object that has finished loading
            failed - boolean value indicating failure or success of the load operation (true=failure)
        
        *Handler Return Value:* None
        
        *See Also:* the <on_loaded> event and the <remove_onloaded_listener> function
    */
    
    int add_onloaded_listener( function fn )
        [[
            result = UserData::get( L )->add_callback( (char *) "on_loaded" , L );
        ]];
        
    /*
        Function: remove_onloaded_listener

        The remove_onloaded_listener() function unregisters the specified event handler.

        *Arguments:*

            ref - handle for event handler to unregister. This handle is returned by the <add_onloaded_listener> function.

        *Return Value:* None

        *See Also:* the <add_onloaded_listener> function
    */

    remove_onloaded_listener( int ref )
        [[
            UserData::get( L )->remove_callback( (char *) "on_loaded" , L );
        ]];

    /*
        Event: on_loaded

        The on_loaded event occurs when an asynchronously-loaded spritesheet map has finished loading. This only relates to the JSON map, not its source images, which will be lazy-loaded as sprites are used.

        *Prototype:*
        (code)
        void on_loaded( SpriteSheet self, boolean failed )
        (end)

        *See Also:* the <add_onloaded_listener> function
    */

    function on_loaded
        [[
            return UserData::get( L )->get_last_callback( (char *) "on_loaded" , L );
        ]]
        [[
            UserData::get( L )->set_last_callback( (char *) "on_loaded" , L );
        ]];
}

[[

void SpriteSheet_on_loaded( GObject * extra, gpointer error, lua_State * L )
{
    SpriteSheet * self = (SpriteSheet *) g_object_get_data( extra, "tp-sheet" );
    
    if ( self->async )
    {
        lua_pushboolean( L, error ? 1 : 0 );
        UserData::invoke_callbacks( self, "on_loaded", 1, 0, L);
    }
}

]]

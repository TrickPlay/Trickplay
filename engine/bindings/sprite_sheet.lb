module sprite_sheet;

[[
#include "spritesheet.h"
#include <glib.h>
#include <string.h>
#include "bitmap.h"
#include "bitmap.lb.h"
#include "json.h"
#include "app_resource.h"
#include "util.h"
]]

[[

//------------------------------------------------------------------------
// Emit signal "later"

class EmitLoadedSignalLater : public Action
{

public:
    EmitLoadedSignalLater( SpriteSheet * self, const char * error_message )
    {
        this->self = self;
        this->error_message = error_message;
    }

protected:
    bool run()
    {
        g_signal_emit_by_name( self->extra, "on-loaded", error_message );
        return false;
    }

private:
    SpriteSheet * self;
    const char  * error_message;
};

//------------------------------------------------------------------------
// Helper functions

#define LUA_CALLBACK( self, status ) g_signal_emit_by_name( ( self )->extra, "on-loaded", status )

typedef void (* LFunc) ( lua_State * L, int index, gpointer user_data );

void lua_foreach ( lua_State * L, int index, LFunc func, gpointer user_data )
{
    index = index > 0 ? index : lua_gettop( L ) + index + 1;
    
    lua_pushnil( L );
    while ( lua_next( L, index ) )
    {
        func( L, lua_gettop( L ), user_data );
        lua_pop( L, 1 );
    }
}

class SpriteDef {
    public:
        SpriteDef( int x, int y, int w, int h, char * id )
            : x( x ), y( y ), w( w ), h( h ), id( id )
        {}
        
        int x, y, w, h;
        char * id;
};

void spritedef_delete ( SpriteDef * sprite )
{
    delete sprite;
}

void spritedef_map ( SpriteDef * sprite, SpriteSheet * self )
{
    self->map_subtexture( sprite->id, -1, sprite->x, sprite->y, sprite->w, sprite->h );
}

class SSDef {
    public:
        SSDef( SpriteSheet * ss )
            : sheet( ss ),
              sprites( g_ptr_array_new_with_free_func( (GDestroyNotify) spritedef_delete ) )
        {}
        
        ~SSDef() { g_ptr_array_free( sprites, true ); }
        
        void load ( Image * image )
        {
            if ( image )
            {
                ClutterActor * texture = clutter_texture_new();
                Images::load_texture( CLUTTER_TEXTURE( texture ), image );
                CoglHandle source = clutter_texture_get_cogl_texture( CLUTTER_TEXTURE( texture ) );
                
                cogl_handle_ref( source );
                sheet->add_texture( source );
                g_ptr_array_foreach( sprites, (GFunc) spritedef_map, sheet );
                
                clutter_actor_destroy( texture );
            }
        }
        
        int tex;
        SpriteSheet * sheet;
        GPtrArray   * sprites;
};

void async_img_callback ( Image * image, SSDef * ssdef )
{
    ssdef->load( image );
    delete ssdef;
    
    LUA_CALLBACK( ssdef->sheet, image ? NULL : "FAILED_IMG_LOAD" );
}

void ssdef_add_sprite ( lua_State * L, int index, SSDef * ssdef )
{
    LSG;
    
    if ( !lua_istable( L, index ) )
    {
        g_warning( "Couldn't understand that sprite definition." );
        return;
    }
    
    lua_getfield( L, index, "x" );
    lua_getfield( L, index, "y" );
    lua_getfield( L, index, "w" );
    lua_getfield( L, index, "h" );
    lua_getfield( L, index, "id" );
    
    SpriteDef * sprite = new SpriteDef(
        (int) lua_tointeger( L, -5 ),
        (int) lua_tointeger( L, -4 ),
        (int) lua_tointeger( L, -3 ),
        (int) lua_tointeger( L, -2 ),
        strdup( (char *) lua_tostring( L, -1 ) )
    );
    
    g_ptr_array_add( ssdef->sprites, sprite );
    
    lua_pop( L, 5 );
    
    LSG_END( 0 );
}

void add_spritesheet_map ( lua_State * L, int index, SpriteSheet * self )
{
    LSG;
    
    if ( !lua_istable( L, index ) )
    {
        g_warning( "Couldn't understand that map definition." );
        return;
    }
    
    Bitmap * bitmap;
    SSDef  * ssdef = new SSDef( self );
    
    lua_getfield( L, index, "sprites" );
    lua_getfield( L, index, "img" );
    
    if ( lua_istable( L, -2 ) )
    {
        lua_foreach( L, -2, (LFunc) ssdef_add_sprite, ssdef );
        
        g_message( "[img] type is %s", lua_typename( L, lua_type( L, -1 ) ) );
        if ( lua_isstring( L, -1 ) )
        {
            const char * img = lua_tostring( L, -1 );
            App  * app = App::get( L );
            
            if ( g_object_get_data( self->extra, "tp-async" ) )
            {
                app->load_image_async( img, false, (Image::DecodeAsyncCallback) async_img_callback, ssdef, 0 );
            }
            else
            {
                ssdef->load( app->load_image( img, false ) );
                delete ssdef;
            }
        }
        else if (( bitmap = LB_GET_BITMAP( L, -1 ) ))
        {
            ssdef->load( bitmap->get_image() );
            delete ssdef;
        }
        else
        {
            g_warning( "Couldn't understand that source image." );
        }
    }
    else
    {
        g_warning( "Couldn't understand that list of sprites." );
    }
    
    lua_pop( L, 2 );
    
    LSG_END( 0 );
}

void async_map_callback ( const Network::Response & response, SpriteSheet * self )
{
    if ( !response.failed && response.body->len )
    {
        guint8 null = '\0';
        char * map = g_strdup( (char*) g_byte_array_append( response.body, &null, 1 )->data );
        
        lua_State * L = luaL_newstate();
        
        JSON::parse( L, map );
        
        if ( lua_istable( L, -1 ) )
        {
            lua_foreach( L, -1, (LFunc) add_spritesheet_map, self );
        }
        else
        {
            LUA_CALLBACK( self, "FAILED_MAP_PARSE" );
        }
        
        lua_close( L );
    }
    else
    {
        LUA_CALLBACK( self, "FAILED_MAP_LOAD" );
    }
}

void lua_load_map_uri( lua_State * L, int index, SpriteSheet * self )
{
    index = index > 0 ? index : lua_gettop( L ) + index + 1;
    
    char * map;
    App  * app = App::get( L );
    AppResource resource( app, lua_tostring( L, -1 ) );
    
    if ( resource.is_native() )
    {
        const char * path = resource.get_native_path().c_str();
        if ( ! g_file_get_contents( path, &map, NULL, NULL ) )
        {
            luaL_error( L, "SpriteSheet: could not open map %s.", path );
        }
    }
    else if ( resource.is_http() )
    {
        Network::Request request( app->get_user_agent(), resource.get_uri() );
        
        if ( g_object_get_data( self->extra, "tp-async" ) )
        {
            app->get_network()->perform_request_async( request, app->get_cookie_jar(),
                (Network::ResponseCallback) async_map_callback, self, 0 );
        }
        else
        {
            Network::Response response = app->get_network()->perform_request( request, app->get_cookie_jar() );
            
            if ( response.failed || response.body->len == 0 )
            {
                luaL_error( L, "SpriteSheet: could not download map %s.", resource.get_uri().c_str() );
            }
            
            guint8 null = '\0';
            map = g_strdup( (char*) g_byte_array_append( response.body, &null, 1 )->data );
        }
    }
    else
    {
        luaL_error( L, "SpriteSheet: could not understand map URI %s.", lua_tostring( L, -1 ) );
    }
    
    if ( map )
    {
        JSON::parse( L, map );
    }
    else
    {
        lua_pushnil( L );
    }
}

void Sprite_Sheet_on_loaded( GObject * extra, char * error, lua_State * L );

]]

class SpriteSheet [[SpriteSheet*]]
{
    SpriteSheet(table props = 0 )
        [[
            LSG;
            self = lb_construct( SpriteSheet, new SpriteSheet() );
            g_object_set_data( self->extra, "tp-app", App::get( L ) );

            g_signal_connect_data( self->extra, "on-loaded", (GCallback) Sprite_Sheet_on_loaded,
                L, 0, GConnectFlags( 0 ) );

            if ( props )
            {
                lua_getfield( L, 1, "async" );
                lua_getfield( L, 1, "map" );
                
                g_object_set_data( self->extra, "tp-async", GINT_TO_POINTER( lua_toboolean( L, -2 ) ) );

                if ( lua_isstring( L, -1 ) )
                {
                    lua_load_map_uri( L, -1, self );
                    lua_remove( L, -2 );
                }
                
                if ( lua_istable( L, -1 ) )
                {
                    lua_foreach( L, -1, (LFunc) add_spritesheet_map, self );
                }
                else if ( ! lua_isnil( L, -1 ) )
                {
                    luaL_error( L, "SpriteSheet initialization error: key 'map' was not a table or URI string." );
                }
                
                lua_pop( L, 2 );
            }
            else
            {
                luaL_error( L, "SpriteSheet initialization error: Must pass a table to SpriteSheet constructor." );
            }

            LSG_END(0);
        ]];

    table get_ids()
        [[
            GList * iter = self->get_ids();

            int index = 1;

            lua_newtable( L );

            for ( ; iter ; iter = iter->next )
            {
                lua_pushstring( L, (char*) iter->data );
                lua_rawseti( L, -2, index );
                ++index;
            }
        ]];

    ~SpriteSheet()
        [[
        ]];

    dump()
        [[
            self->dump();
        ]];

    callback on_loaded
        [[
        ]];
}

[[
void Sprite_Sheet_on_loaded( GObject * extra, char * error, lua_State * L )
{
    lua_pushboolean( L, error ? 1 : 0 );

    if ( error )
    {
        lua_pushstring( L, error );
    }
    else
    {
        lua_pushnil( L );
    }

    SpriteSheet * self = (SpriteSheet *) g_object_get_data( extra, "tp-sheet" );

    UserData::invoke_callback( self, "on_loaded", 2, 0, L);
}

#undef LUA_CALLBACK
]]


module clutter;

[[
//-----------------------------------------------------------------------------
// Use either GDK_PIXBUF or ImageMagick++ for loading images

#define TP_USE_GDK_PIXBUF 0  
  
#if TP_USE_GDK_PIXBUF
    #include <gdk-pixbuf/gdk-pixbuf.h>
#else
    #include <Magick++.h>
#endif

//-----------------------------------------------------------------------------

#include "clutter/clutter.h"

#include <cstring>
#include <string>

#include "network.h"
#include "util.h"
#include "app.h"
#include "context.h"
]]

[[

#if !TP_USE_GDK_PIXBUF

bool load_texture_from_data(ClutterTexture * texture,const void * data,size_t length)
{
    try
    {
	//g_debug("DECODING IMAGE %lu",length);
	
	Magick::Image image(Magick::Blob(data,length));
	
	Magick::Blob blob;
	
	image.write(&blob,"RGBA",8);
	
	//g_debug("  DECODED");
	
	clutter_texture_set_from_rgb_data(
	    texture,
	    (const guchar *)blob.data(),
	    TRUE,
	    image.columns(),
	    image.rows(),
	    image.columns()*4,
	    4,
	    CLUTTER_TEXTURE_NONE,NULL);
	
	return true;
    }
    catch(...)
    {
	return false;
    }
}

bool load_texture_from_file(ClutterTexture * texture,const char * file_name)
{
    gchar * data=NULL;
    gsize length=0;

    //g_debug("LOADING FILE CONTENTS %s",file_name);
    
    if (!g_file_get_contents(file_name,&data,&length,NULL))
	return false;
    
    //g_debug("LOADED");
    
    bool result=load_texture_from_data(texture,data,length);
    
    g_free(data);
    
    return result;
}
#endif

]]

[[
// Forward declaration for generated constructor

int new_signal_collector(lua_State *);    
    
class SignalCollector
{
public:
    
    static SignalCollector * get(lua_State * L)
    {
	LSG;
	
	SignalCollector * result=NULL;
	
	g_assert(L);
	lua_pushstring(L,"tp_signalcollector");
	lua_rawget(L,LUA_REGISTRYINDEX);
	if (lua_isnil(L,-1))
	{
	    lua_pop(L,1);
	    result=new SignalCollector(L);
	    
	    lua_pushlightuserdata(L,result);
	    new_signal_collector(L);
	    lua_setfield(L,LUA_REGISTRYINDEX,"tp_signalcollector");
	    lua_pop(L,1);
	}
	else
	{
	    result = *(SignalCollector**)lua_touserdata(L,-1);
	    lua_pop(L,1);
	}
	g_assert(result);
	
	LSG_END(0);
	
	return result;    
    }

    ~SignalCollector()
    {
	g_debug("DESTROYING SIGNAL COLLECTOR %p",this);
	
	// We need to disconnect all signals, because Lua is going away
	
	for (InstanceMap::const_iterator it=instances.begin();it!=instances.end();++it)
	{
	    for (NameToHandlerMap::const_iterator nt=it->second.begin();nt!=it->second.end();++nt)
	    {
		g_debug("  DISCONNECTING %p %s %lu",it->first,nt->first.c_str(),nt->second);

		g_signal_handler_disconnect(it->first,nt->second);
	    }
	    
	    // And we also detach our weak ref
	    
	    g_object_weak_unref(G_OBJECT(it->first),instance_destroyed_notify,this);
	}
    }

    static void instance_destroyed_notify(gpointer data,GObject * instance)
    {
	((SignalCollector*)data)->instance_destroyed(instance);
    }
    
    void instance_destroyed(gpointer instance)
    {
	g_debug("INSTANCE DESTROYED %p",instance);
	
	instances.erase(instance);	
    }
    
    void connect(const gchar * name,gpointer instance,const gchar * detailed_signal,GCallback handler,gpointer data)
    {
	// See if we have any entries for this instance
	
	InstanceMap::iterator it=instances.find(instance);
	
	// If we don't..
	
	if (it==instances.end())
	{
	    // We add a weak ref to it so we can be told when it goes away
	    
	    g_object_weak_ref(G_OBJECT(instance),instance_destroyed_notify,this);
	    
	    // Inserts a new element in the instaces map and sets the iterator
	    // to point to it
	    
	    it=instances.insert(std::make_pair(instance,NameToHandlerMap())).first;
	}
	
	// The instance was found
	
	else
	{
	    // Disconnect the old one
	    
	    disconnect(name,it);    
	}
	
	// Connect the new signal
	
	gulong id=g_signal_connect(instance,detailed_signal,handler,data);
	
	g_debug("CONNECTING %p %s %lu",instance,name,id);
	
	// Store it
	
	it->second[String(name)]=id;
    }
    
    void disconnect(const gchar * name,gpointer instance)
    {
	InstanceMap::iterator it=instances.find(instance);
	
	if (it!=instances.end())
	{
	    disconnect(name,it);    
	}
    }

    void connect_if(int condition,const gchar * name,gpointer instance,const gchar * detailed_signal,GCallback handler,gpointer data)
    {
	if (condition)
	{
	    connect(name,instance,detailed_signal,handler,data);
	}
	else
	{
	    disconnect(name,instance);
	}
    }
    
private:
    
    SignalCollector(lua_State * l)
    :
	L(l)
    {
	g_debug("CREATING SIGNAL COLLECTOR %p",this);
    }
    
    typedef std::map<String,gulong> 		NameToHandlerMap;
    typedef std::map<gpointer,NameToHandlerMap>	InstanceMap;

    void disconnect(const gchar * name,const InstanceMap::iterator & it)
    {
	NameToHandlerMap::iterator nt=it->second.find(String(name));
	
	if (nt!=it->second.end())
	{
	    g_debug("DISCONNECTING %p %s %lu",it->first,name,nt->second);
	    
	    g_signal_handler_disconnect(it->first,nt->second);
	    
	    it->second.erase(nt);
	}
    }

    lua_State * L;
    InstanceMap	instances;
};
]]

interface signal_collector [[SignalCollector*]]
{
    signal_collector()
	[[
	    *self=(SignalCollector*)lua_touserdata(L,-2);        
	]];
	
    ~signal_collector()
	[[
	    delete self;    
	]];
}

[[
void push_clutter_color(lua_State*L,ClutterColor*color)
{
    LSG;
    
    lua_newtable(L);
    lua_pushnumber(L,color->red);
    lua_rawseti(L,-2,1);
    lua_pushnumber(L,color->green);
    lua_rawseti(L,-2,2);
    lua_pushnumber(L,color->blue);
    lua_rawseti(L,-2,3);
    lua_pushnumber(L,color->alpha);
    lua_rawseti(L,-2,4);
    
    LSG_END(1);
}

void to_clutter_color(lua_State*L,int index,ClutterColor*color)
{
    LSG;
    
    if(lua_istable(L,index))
    {
        lua_rawgeti(L,2,1);
        lua_rawgeti(L,2,2);
        lua_rawgeti(L,2,3);
        lua_rawgeti(L,2,4);
        color->red = luaL_optint(L,-4,0);
        color->green = luaL_optint(L,-3,0);
        color->blue = luaL_optint(L,-2,0);
        color->alpha = luaL_optint(L,-1,255);
        lua_pop(L,4);
    }
    else if (lua_isstring(L,index))
    {
        int colors[4]={0,0,0,255};
	char buffer[3]={0,0,0};
	
	const char * s=lua_tostring(L,index);
	
	if (*s=='#')
	    ++s;
	    
	int len=strlen(s);
	int i=0;
	
	while(len>=2)
	{
	    buffer[0]=*(s++);
	    buffer[1]=*(s++);
	    
	    sscanf(buffer,"%x",&colors[i]);	    
	    
	    if (colors[i]<0)
	    {
		colors[i]=0;
	    }
	    else if(colors[i]>255)
	    {
		colors[i]=255;
	    }
	    
	    len-=2;
	    i++;		
	}
				
        color->red   = colors[0];
        color->green = colors[1];
        color->blue  = colors[2];
        color->alpha = colors[3];
    }
    else
    {
        luaL_error(L,"Expecting a color as a table or a string");
    }
    
    LSG_END(0);
}

gulong to_clutter_animation_mode(const char * mode)
{
    if (!mode)
	return CLUTTER_LINEAR;
    
    gulong result=CLUTTER_LINEAR;
    
    GEnumClass * ec=G_ENUM_CLASS(g_type_class_ref(CLUTTER_TYPE_ANIMATION_MODE));
    gchar * cm=g_strdup_printf("CLUTTER_%s",mode);    
    GEnumValue * v=g_enum_get_value_by_name(ec,cm);
    g_free(cm);
    
    if(v)
    {
	result=v->value;
    }
    
    g_type_class_unref(ec);
    
    return result;
}

ClutterActor * user_data_to_actor(lua_State*L,int n)
{
    void * udata=lua_touserdata(L,n);
    
    if (!udata)
	return NULL;
    
    GObject * obj= *((GObject**)udata);
    
    if (!obj)
	return NULL;
    
    return CLUTTER_IS_ACTOR(obj)?CLUTTER_ACTOR(obj):NULL;
}

void set_props_from_table(lua_State*L,int table)
{
    LSG;
    
    if (table)
    {
	if(table==lua_gettop(L))
	{
	    lb_set_props_from_table(L);	    
	}
	else
	{
	    lua_pushvalue(L,table);
	    lb_set_props_from_table(L);
	    lua_pop(L,1);
	}
    }
    
    LSG_END(0);
}

void wrap_concrete_actor(lua_State*L,ClutterActor*actor);
const char * get_actor_metatable(ClutterActor*actor);

// This lets us bolt on a table of user data 

class actor_extra
{
public:

    // Creates a new table, takes a ref on it and leaves it
    // on the stack
    
    actor_extra(lua_State * L)
    :
	lsp(App::get(L)->ref_lua_state_proxy())
    {
	lua_newtable(L);
	lua_pushvalue(L,-1);
	table_ref = luaL_ref(L,LUA_REGISTRYINDEX);
    }
    
    // Takes a ref on a table that is already on the stack
    // and leaves it on the stack
    
    actor_extra(lua_State * L,int t)
    :
	lsp(App::get(L)->ref_lua_state_proxy())
    {
	lua_pushvalue(L,t);
	table_ref = luaL_ref(L,LUA_REGISTRYINDEX);
    }
    
    // Releases the ref
    // This may happen after the lua state is closed, because extra is bolted
    // on to a GObject...so we protect against that by using a lua state
    // proxy and checking that it is still good.
    
    ~actor_extra()
    {
	if (lsp->is_valid())
	{
	    luaL_unref(lsp->get_lua_state(),LUA_REGISTRYINDEX,table_ref);
	}
	
	lsp->unref();
    }
    
    // Pushes the referenced table onto the stack
    
    void push_table()
    {
	lua_rawgeti(lsp->get_lua_state(),LUA_REGISTRYINDEX,table_ref);
    }
    
    // GDestroyNotify for it
    
    static void destroy(gpointer a)
    {
	if (a)
	{
	    delete (actor_extra*)a;
	}
    }
    
private:
    actor_extra()
    {}
    
    actor_extra(const actor_extra &)
    {}
    
    LuaStateProxy *	lsp;
    int			table_ref;
};

]]

[[

#if 0

// An attempt at aligning actors inside their parent, feeble at best

void actor_allocation_changed(ClutterActor * actor,ClutterActorBox * box,ClutterAllocationFlags flags,lua_State * L)
{
    g_debug("ALLOCATION CHANGED %p : %d : %f,%f %fx%f : %p",actor,flags,box->x1,box->y1,box->x2,box->y2,clutter_actor_get_parent(actor));
    
    ClutterActor * parent=clutter_actor_get_parent(actor);
    
    if (!parent)
	return;
    
    const gchar * valign=(const gchar *)g_object_get_data(G_OBJECT(actor),"tp-valign");
    const gchar * halign=(const gchar *)g_object_get_data(G_OBJECT(actor),"tp-halign");
    
    ClutterActorBox * new_box=clutter_actor_box_copy(box);
    
    if (valign)
    {
	gfloat parent_height=clutter_actor_get_height(parent);
	gfloat height=clutter_actor_box_get_height(box);
	
	switch(*valign)
	{
	    case 'T':
	    case 't':
	    {
		new_box->y1=0;
		new_box->y2=new_box->y1+height;
		break;
	    }
	    
	    case 'C':
	    case 'c':
	    {
		new_box->y1=(parent_height-height)/2;
		new_box->y2=new_box->y1+height;
		break;
	    }
	    
	    case 'B':
	    case 'b':
	    {
		new_box->y1=parent_height-height;
		new_box->y2=new_box->y1+height;
		break;
	    }
	}
    }
    
    if (halign)
    {
	gfloat parent_width=clutter_actor_get_width(parent);
	gfloat width=clutter_actor_box_get_width(box);
	
	switch(*halign)
	{
	    case 'L':
	    case 'l':
	    {
		new_box->x1=0;
		new_box->x2=new_box->x1+width;
		break;
	    }
	    
	    case 'C':
	    case 'c':
	    {
		new_box->x1=(parent_width-width)/2;
		new_box->x2=new_box->x1+width;
		break;
	    }
	    
	    case 'R':
	    case 'r':
	    {
		new_box->x1=parent_width-width;
		new_box->x2=new_box->x1+width;
		break;
	    }
	}	
    }
    
    if (!clutter_actor_box_equal(box,new_box))
    {
	ClutterGeometry g;
	g.x=new_box->x1;
	g.y=new_box->y1;
	g.width=clutter_actor_box_get_width(new_box);
	g.height=clutter_actor_box_get_height(new_box);
	// This is wrong, we should not set the width and height - they should
	// remain as they were.
	clutter_actor_set_geometry(actor,&g);
    }
    
    clutter_actor_box_free(new_box);
}

#endif

void initialize_actor(lua_State * L,ClutterActor*actor,const char * metatable)
{
    // Metatables are static, so we don't need to free it 
    g_object_set_data(G_OBJECT(actor),"tp-metatable",(gpointer)metatable);
#if 0
    g_signal_connect(actor,"allocation-changed",G_CALLBACK(actor_allocation_changed),L);
#endif
}
    
    
void actor_on_show(ClutterActor*actor,lua_State*L)
{
    lb_invoke_callback(L,actor,get_actor_metatable(actor),"on_show",0,0);        
}

void actor_on_hide(ClutterActor*actor,lua_State*L)
{
    lb_invoke_callback(L,actor,get_actor_metatable(actor),"on_hide",0,0);        
}
    
void actor_on_key_focus_in(ClutterActor*actor,lua_State*L)
{
    lb_invoke_callback(L,actor,get_actor_metatable(actor),"on_key_focus_in",0,0);        
}

void actor_on_key_focus_out(ClutterActor*actor,lua_State*L)
{
    lb_invoke_callback(L,actor,get_actor_metatable(actor),"on_key_focus_out",0,0);        
}

gboolean actor_on_key_down(ClutterActor*actor,ClutterKeyEvent*event,lua_State*L)
{
    int result = FALSE;
    
    lua_pushinteger(L,event->keyval);
    lua_pushinteger(L,event->unicode_value);
    lua_pushinteger(L,event->time);
    
    if(lb_invoke_callback(L,actor,get_actor_metatable(actor),"on_key_down",3,1))
    {
	if (lua_toboolean(L,-1))
	    result = TRUE;
	lua_pop(L,1);
    }

    return result;
}

gboolean actor_on_key_up(ClutterActor*actor,ClutterKeyEvent*event,lua_State*L)
{
    int result = FALSE;
    
    lua_pushinteger(L,event->keyval);
    lua_pushinteger(L,event->unicode_value);
    lua_pushinteger(L,event->time);
    
    if(lb_invoke_callback(L,actor,get_actor_metatable(actor),"on_key_up",3,1))
    {
	if (lua_toboolean(L,-1))
	    result = TRUE;
	lua_pop(L,1);
    }

    return result;
}

gboolean actor_on_button_down(ClutterActor*actor,ClutterButtonEvent*event,lua_State*L)
{
    int result = FALSE;
    
    lua_pushnumber(L,event->x);
    lua_pushnumber(L,event->y);
    lua_pushinteger(L,event->button);
    lua_pushinteger(L,event->click_count);
    
    if(lb_invoke_callback(L,actor,get_actor_metatable(actor),"on_button_down",4,1))
    {
	if (lua_toboolean(L,-1))
	    result = TRUE;
	lua_pop(L,1);
    }

    return result;
}

gboolean actor_on_button_up(ClutterActor*actor,ClutterButtonEvent*event,lua_State*L)
{
    int result = FALSE;
    
    lua_pushnumber(L,event->x);
    lua_pushnumber(L,event->y);
    lua_pushinteger(L,event->button);
    lua_pushinteger(L,event->click_count);
    
    if(lb_invoke_callback(L,actor,get_actor_metatable(actor),"on_button_up",4,1))
    {
	if (lua_toboolean(L,-1))
	    result = TRUE;
	lua_pop(L,1);
    }

    return result;
}

gboolean actor_on_scroll(ClutterActor*actor,ClutterScrollEvent*event,lua_State*L)
{
    int result = FALSE;
    
    lua_pushnumber(L,event->x);
    lua_pushnumber(L,event->y);
    lua_pushinteger(L,event->direction);
    
    if(lb_invoke_callback(L,actor,get_actor_metatable(actor),"on_scroll",3,1))
    {
	if (lua_toboolean(L,-1))
	    result = TRUE;
	lua_pop(L,1);
    }

    return result;
}

static void actor_animation_completed(ClutterAnimation * animation,lua_State * L)
{
    // Get the ref to the callback, which we stored in the animation
    
    int function_ref=GPOINTER_TO_INT(g_object_get_data(G_OBJECT(animation),"tp-completed"));
    
    if (function_ref)
    {
	// Get the function from the registry
	lua_rawgeti(L,LUA_REGISTRYINDEX,function_ref);
	
	// Wrap the actor
	wrap_concrete_actor(L,CLUTTER_ACTOR(clutter_animation_get_object(animation)));

	// Call the function	
	lua_call(L,1,0);
	
	// Unref it
	luaL_unref(L,LUA_REGISTRYINDEX,function_ref);
    }
}

]]

interface actor [[ClutterActor*]]
{
    string name
        [[name=clutter_actor_get_name(self);]]
        [[clutter_actor_set_name(self,name);]];
        
    readonly long gid
        [[gid=clutter_actor_get_gid(self);]];
    
    double x
        [[ x = clutter_actor_get_x( self ); ]]
        [[ clutter_actor_set_x( self , x ); ]];
    
    double y
        [[ y = clutter_actor_get_y( self ); ]]
        [[ clutter_actor_set_y( self , y ); ]];
    
    double z
        [[ z = clutter_actor_get_depth( self ); ]]
        [[ clutter_actor_set_depth( self , z ); ]];

    double w
        [[ w = clutter_actor_get_width( self ); ]]
        [[ clutter_actor_set_width( self , w ); ]];
    
    double h
        [[ h = clutter_actor_get_height( self ); ]]
        [[ clutter_actor_set_height( self , h ); ]];

    double width
        [[ width = clutter_actor_get_width( self ); ]]
        [[ clutter_actor_set_width( self , width ); ]];
    
    double height
        [[ height = clutter_actor_get_height( self ); ]]
        [[ clutter_actor_set_height( self , height ); ]];

    table position
        [[
            lua_newtable(L);
            lua_pushnumber(L,clutter_actor_get_x(self));
            lua_rawseti(L,-2,1);
            lua_pushnumber(L,clutter_actor_get_y(self));
            lua_rawseti(L,-2,2);
            lua_pushnumber(L,clutter_actor_get_depth(self));
	    lua_rawseti(L,-2,3);
        ]]
        [[
            luaL_checktype(L,2,LUA_TTABLE);
            lua_rawgeti(L,2,1);
            lua_rawgeti(L,2,2);
	    lua_rawgeti(L,2,3);
            clutter_actor_set_position(self,lua_tonumber(L,-3),lua_tonumber(L,-2));
	    clutter_actor_set_depth(self,lua_tonumber(L,-1));
            lua_pop(L,3);
        ]];
        
    table anchor_point
        [[
	    gfloat x;
	    gfloat y;
	    clutter_actor_get_anchor_point(self,&x,&y);
            lua_newtable(L);
            lua_pushnumber(L,x);
            lua_rawseti(L,-2,1);
            lua_pushnumber(L,y);
            lua_rawseti(L,-2,2);
        ]]
        [[
            luaL_checktype(L,2,LUA_TTABLE);
            lua_rawgeti(L,2,1);
            lua_rawgeti(L,2,2);	    
            clutter_actor_set_anchor_point(self,lua_tonumber(L,-2),lua_tonumber(L,-2));
            lua_pop(L,2);
        ]];
	
    table size
        [[
            lua_newtable(L);
            lua_pushnumber(L,clutter_actor_get_width(self));
            lua_rawseti(L,-2,1);
            lua_pushnumber(L,clutter_actor_get_height(self));
            lua_rawseti(L,-2,2);
        ]]
        [[
            luaL_checktype(L,2,LUA_TTABLE);
            lua_rawgeti(L,2,1);
            lua_rawgeti(L,2,2);
            clutter_actor_set_size(self,lua_tonumber(L,-2),lua_tonumber(L,-1));
            lua_pop(L,2);
        ]];
        
    table scale
        [[
            gdouble scalex;
            gdouble scaley;
            clutter_actor_get_scale(self,&scalex,&scaley);
            lua_newtable(L);
            lua_pushnumber(L,scalex);
            lua_rawseti(L,-2,1);
            lua_pushnumber(L,scaley);
            lua_rawseti(L,-2,2);
            
            gfloat x;
            gfloat y;
            clutter_actor_get_scale_center(self,&x,&y);
            lua_pushnumber(L,x);
            lua_rawseti(L,-2,3);
            lua_pushnumber(L,y);
            lua_rawseti(L,-2,4);
        ]]
        [[
            luaL_checktype(L,2,LUA_TTABLE);
            lua_rawgeti(L,2,1);
            lua_rawgeti(L,2,2);            
            lua_rawgeti(L,2,3);
            lua_rawgeti(L,2,4);
            if (!lua_isnil(L,-2)&&!lua_isnil(L,-1))
                clutter_actor_set_scale_full(self,lua_tonumber(L,-4),lua_tonumber(L,-3),lua_tonumber(L,-2),lua_tonumber(L,-1));
            else
                clutter_actor_set_scale(self,lua_tonumber(L,-4),lua_tonumber(L,-3));
            lua_pop(L,4);
        ]];
        
    table x_rotation
        [[
            gfloat x;
            gfloat y;
            gfloat z;
            gdouble angle = clutter_actor_get_rotation(self,CLUTTER_X_AXIS,&x,&y,&z);
            lua_newtable(L);
            lua_pushnumber(L,angle);
            lua_rawseti(L,-2,1);
            lua_pushnumber(L,y);
            lua_rawseti(L,-2,2);
            lua_pushnumber(L,z);
            lua_rawseti(L,-2,3);
        ]]
        [[
            luaL_checktype(L,2,LUA_TTABLE);
            lua_rawgeti(L,2,1);
            lua_rawgeti(L,2,2);
            lua_rawgeti(L,2,3);
            clutter_actor_set_rotation(self,CLUTTER_X_AXIS,lua_tonumber(L,-3),0,lua_tonumber(L,-2),lua_tonumber(L,-1));
            lua_pop(L,3);
        ]];

    table y_rotation
        [[
            gfloat x;
            gfloat y;
            gfloat z;
            gdouble angle = clutter_actor_get_rotation(self,CLUTTER_Y_AXIS,&x,&y,&z);
            lua_newtable(L);
            lua_pushnumber(L,angle);
            lua_rawseti(L,-2,1);
            lua_pushnumber(L,x);
            lua_rawseti(L,-2,2);
            lua_pushnumber(L,z);
            lua_rawseti(L,-2,3);
        ]]
        [[
            luaL_checktype(L,2,LUA_TTABLE);
            lua_rawgeti(L,2,1);
            lua_rawgeti(L,2,2);
            lua_rawgeti(L,2,3);
            clutter_actor_set_rotation(self,CLUTTER_Y_AXIS,lua_tonumber(L,-3),lua_tonumber(L,-2),0,lua_tonumber(L,-1));
            lua_pop(L,3);
        ]];
        
    table z_rotation
        [[
            gfloat x;
            gfloat y;
            gfloat z;
            gdouble angle = clutter_actor_get_rotation(self,CLUTTER_Z_AXIS,&x,&y,&z);
            lua_newtable(L);
            lua_pushnumber(L,angle);
            lua_rawseti(L,-2,1);
            lua_pushnumber(L,x);
            lua_rawseti(L,-2,2);
            lua_pushnumber(L,y);
            lua_rawseti(L,-2,3);
        ]]
        [[
            luaL_checktype(L,2,LUA_TTABLE);
            lua_rawgeti(L,2,1);
            lua_rawgeti(L,2,2);
            lua_rawgeti(L,2,3);
            clutter_actor_set_rotation(self,CLUTTER_Z_AXIS,lua_tonumber(L,-3),lua_tonumber(L,-2),lua_tonumber(L,-1),0);
            lua_pop(L,3);
        ]];
        
        
    readonly bool is_scaled
        [[is_scaled=clutter_actor_is_scaled(self);]];
        
    readonly bool is_rotated
        [[is_rotated=clutter_actor_is_rotated(self);]];
        
    int opacity
        [[opacity=clutter_actor_get_opacity(self);]]
        [[clutter_actor_set_opacity(self,opacity);]];
        
    table clip
        [[
            if (!clutter_actor_has_clip(self))
            {
                lua_pushnil(L);
            }
            else
            {
                gfloat x;
                gfloat y;
                gfloat w;
                gfloat h;
                clutter_actor_get_clip(self,&x,&y,&w,&h);
                lua_newtable(L);
                lua_pushnumber(L,x);
                lua_rawseti(L,-2,1);
                lua_pushnumber(L,y);
                lua_rawseti(L,-2,2);
                lua_pushnumber(L,w);
                lua_rawseti(L,-2,3);
                lua_pushnumber(L,h);
                lua_rawseti(L,-2,4);
            }
        ]]
        [[
            if (lua_isnil(L,2))
            {
                clutter_actor_remove_clip(self);
            }
            else
            {
                luaL_checktype(L,2,LUA_TTABLE);
                lua_rawgeti(L,2,1);
                lua_rawgeti(L,2,2);
                lua_rawgeti(L,2,3);
                lua_rawgeti(L,2,4);
                clutter_actor_set_clip(self,lua_tonumber(L,-4),lua_tonumber(L,-3),lua_tonumber(L,-2),lua_tonumber(L,-1));
                lua_pop(L,4);
            }
        ]];
        
    readonly bool has_clip
        [[has_clip=clutter_actor_has_clip(self);]];
        
    double depth
        [[depth=clutter_actor_get_depth(self);]]
        [[clutter_actor_set_depth(self,depth);]];
	
    udata set(table props)
	[[
	    set_props_from_table(L,props);
	    lua_pushvalue(L,1);
	]];
#if 0	
    string valign
	[[
	    valign=(const char *)g_object_get_data(G_OBJECT(self),"tp-valign");    
	]]
	[[
	    g_object_set_data_full(G_OBJECT(self),"tp-valign",g_strdup(valign),g_free);
	]];

    string halign
	[[
	    halign=(const char *)g_object_get_data(G_OBJECT(self),"tp-halign");    
	]]
	[[
	    g_object_set_data_full(G_OBJECT(self),"tp-halign",g_strdup(halign),g_free);
	]];
#endif
    show()
        [[clutter_actor_show(self);]];
        
    show_all()
        [[clutter_actor_show_all(self);]];
        
    hide()
        [[clutter_actor_hide(self);]];
        
    hide_all()
        [[clutter_actor_hide_all(self);]];
	
    move_by( double dx , double dy )
	[[clutter_actor_move_by(self,dx,dy);]];
	
    readonly udata parent
	[[wrap_concrete_actor(L,clutter_actor_get_parent(self));]];
	
    unparent()
	[[
	    if(ClutterActor * parent=clutter_actor_get_parent(self))
	    {
		clutter_container_remove_actor(CLUTTER_CONTAINER(parent),self);
	    }
	]];
	
    raise( udata above )
	[[
	    ClutterActor* source =user_data_to_actor(L,above);
	    if(source)
	    {
		clutter_actor_raise(self,source);
	    }
	]];
	
    lower( udata below )
	[[
	    ClutterActor* source=user_data_to_actor(L,below);
	    if (source)
	    {
		clutter_actor_lower(self,source);
	    }
	]];
	
    raise_to_top()
	[[
	    clutter_actor_raise_top(self);    
	]];
	
    lower_to_bottom()
	[[
	    clutter_actor_lower_bottom(self);    
	]];
	
    move_anchor_point( double x , double y )
	[[clutter_actor_move_anchor_point(self,x,y);]];
	
    grab_key_focus()
	[[clutter_actor_grab_key_focus(self);]];
	
    bool reactive
	[[reactive=clutter_actor_get_reactive(self);]]
	[[clutter_actor_set_reactive(self,reactive);]];
	
    readonly table transformed_size
	[[
	    gfloat w;
	    gfloat h;
	    clutter_actor_get_transformed_size(self,&w,&h);
	    lua_newtable(L);
	    lua_pushnumber(L,w);
	    lua_rawseti(L,-2,1);
	    lua_pushnumber(L,h);
	    lua_rawseti(L,-2,2);
	]];
	
    readonly table transformed_position
	[[
	    gfloat x;
	    gfloat y;
	    clutter_actor_get_transformed_position(self,&x,&y);
	    lua_newtable(L);
	    lua_pushnumber(L,x);
	    lua_rawseti(L,-2,1);
	    lua_pushnumber(L,y);
	    lua_rawseti(L,-2,2);
	]];
	
    readonly table min_size
	[[
	    gfloat mw;
	    gfloat mh;
	    gfloat nw;
	    gfloat nh;
	    
	    clutter_actor_get_preferred_size(self,&mw,&mh,&nw,&nh);
	    lua_newtable(L);
	    lua_pushnumber(L,mw);
	    lua_rawseti(L,-2,1);
	    lua_pushnumber(L,mh);
	    lua_rawseti(L,-2,2);
	]];

    readonly table natural_size
	[[
	    gfloat mw;
	    gfloat mh;
	    gfloat nw;
	    gfloat nh;
	    
	    clutter_actor_get_preferred_size(self,&mw,&mh,&nw,&nh);
	    lua_newtable(L);
	    lua_pushnumber(L,nw);
	    lua_rawseti(L,-2,1);
	    lua_pushnumber(L,nh);
	    lua_rawseti(L,-2,2);
	]];
	
    table extra
	[[
	    actor_extra * e = (actor_extra*)g_object_get_data(G_OBJECT(self),"tp-extra");
	    
	    if (!e)
	    {
		g_object_set_data_full(G_OBJECT(self),"tp-extra",new actor_extra(L),actor_extra::destroy);
	    }
	    else
	    {
		e->push_table();
	    }
	]]
	[[
	    if (lua_isnil(L,2))
	    {
		g_object_set_data_full(G_OBJECT(self),"tp-extra",NULL,actor_extra::destroy);
	    }
	    else
	    {
		lb_checktable(L,2);
		g_object_set_data_full(G_OBJECT(self),"tp-extra",new actor_extra(L,2),actor_extra::destroy);
	    }
	]];
	
    string request_mode
	[[
	    ClutterRequestMode mode;
	    g_object_get(G_OBJECT(self),"request-mode",&mode,NULL);
	    switch(mode)
	    {
		case CLUTTER_REQUEST_HEIGHT_FOR_WIDTH:
		    request_mode = "HEIGHT_FOR_WIDTH";
		    break;
		case CLUTTER_REQUEST_WIDTH_FOR_HEIGHT:
		    request_mode = "WIDTH_FOR_HEIGHT";
		    break;
		default:
		    request_mode = "";
	    }
	]]
	[[
	    ClutterRequestMode mode = CLUTTER_REQUEST_HEIGHT_FOR_WIDTH;
	    if (!strcmp(request_mode,"HEIGHT_FOR_WIDTH"))
		mode = CLUTTER_REQUEST_HEIGHT_FOR_WIDTH;
	    else if (!strcmp(request_mode,"WIDTH_FOR_HEIGHT"))
		mode = CLUTTER_REQUEST_WIDTH_FOR_HEIGHT;
	    else
		luaL_error(L,"Invalid request mode '%s'",request_mode);
	    g_object_set(G_OBJECT(self),"request-mode",mode,NULL);
	]];

    animate(table props)
	[[
	    lua_getfield(L,props,"duration");
	    guint duration=lua_tonumber(L,-1);
	    lua_pop(L,1);
	    
	    lua_getfield(L,props,"mode");
	    gulong mode=to_clutter_animation_mode(lua_tostring(L,-1));
	    lua_pop(L,1);
	    
	    GPtrArray * names=g_ptr_array_new_with_free_func(g_free);
	    GValueArray * values=g_value_array_new(6);
	    
	    lua_pushnil(L);
	    
	    while(lua_next(L,props))
	    {
		GValue value={0};
		
		if (lua_isstring(L,-2)&&!lua_isnil(L,-2))
		{
		    const char * k=lua_tostring(L,-2);
		
		    if (!strcmp("x",k)||!strcmp("y",k))
		    {
			g_value_init(&value,G_TYPE_FLOAT);
			g_value_set_float(&value,lua_tonumber(L,-1));
			g_ptr_array_add(names,g_strdup(k));
			g_value_array_append(values,&value);
		    }
		    else if (!strcmp("w",k)||!strcmp("width",k))
		    {
			g_value_init(&value,G_TYPE_FLOAT);
			g_value_set_float(&value,lua_tonumber(L,-1));
			g_ptr_array_add(names,g_strdup("width"));
			g_value_array_append(values,&value);
		    }
		    else if (!strcmp("h",k)||!strcmp("height",k))
		    {
			g_value_init(&value,G_TYPE_FLOAT);
			g_value_set_float(&value,lua_tonumber(L,-1));
			g_ptr_array_add(names,g_strdup("height"));
			g_value_array_append(values,&value);
		    }
		    else if (!strcmp("z",k)||!strcmp("depth",k))
		    {
			g_value_init(&value,G_TYPE_FLOAT);
			g_value_set_float(&value,lua_tonumber(L,-1));			
			g_ptr_array_add(names,g_strdup("depth"));
			g_value_array_append(values,&value);			
		    }
		    else if (!strcmp("opacity",k))
		    {
			g_value_init(&value,G_TYPE_UCHAR);
			g_value_set_uchar(&value,lua_tointeger(L,-1));
			g_ptr_array_add(names,g_strdup(k));
			g_value_array_append(values,&value);
		    }
		    else if (!strcmp("position",k))
		    {
			if (lua_type(L,-1)==LUA_TTABLE)
			{
			    g_ptr_array_add(names,g_strdup("x"));
			    g_ptr_array_add(names,g_strdup("y"));
			    
			    lua_rawgeti(L,-1,1);
			    g_value_init(&value,G_TYPE_FLOAT);
			    g_value_set_float(&value,lua_tonumber(L,-1));
			    g_value_array_append(values,&value);			    
			    lua_pop(L,1);
			    
			    lua_rawgeti(L,-1,2);
			    g_value_unset(&value);
			    g_value_init(&value,G_TYPE_FLOAT);
			    g_value_set_float(&value,lua_tonumber(L,-1));
			    g_value_array_append(values,&value);
			    lua_pop(L,1);
			}
		    }
		    else if (!strcmp("size",k))
		    {
			if (lua_type(L,-1)==LUA_TTABLE)
			{
			    g_ptr_array_add(names,g_strdup("width"));
			    g_ptr_array_add(names,g_strdup("height"));
			    
			    lua_rawgeti(L,-1,1);
			    g_value_init(&value,G_TYPE_FLOAT);
			    g_value_set_float(&value,lua_tonumber(L,-1));
			    g_value_array_append(values,&value);			    
			    lua_pop(L,1);
			    
			    lua_rawgeti(L,-1,2);
			    g_value_unset(&value);
			    g_value_init(&value,G_TYPE_FLOAT);
			    g_value_set_float(&value,lua_tonumber(L,-1));
			    g_value_array_append(values,&value);
			    lua_pop(L,1);
			}			
		    }
		    else if (!strcmp("scale",k))
		    {
			if (lua_type(L,-1)==LUA_TTABLE)
			{
			    g_ptr_array_add(names,g_strdup("scale-x"));
			    g_ptr_array_add(names,g_strdup("scale-y"));
			    
			    lua_rawgeti(L,-1,1);
			    g_value_init(&value,G_TYPE_DOUBLE);
			    g_value_set_double(&value,lua_tonumber(L,-1));
			    g_value_array_append(values,&value);			    
			    lua_pop(L,1);
			    
			    lua_rawgeti(L,-1,2);
			    g_value_unset(&value);
			    g_value_init(&value,G_TYPE_DOUBLE);
			    g_value_set_double(&value,lua_tonumber(L,-1));
			    g_value_array_append(values,&value);
			    lua_pop(L,1);
			}			
		    }
		    else if (!strcmp("x_rotation",k))
		    {
			if (lua_type(L,-1)==LUA_TTABLE)
			{
			    
			}
			else
			{
			    g_ptr_array_add(names,g_strdup("rotation-angle-x"));
			    g_value_init(&value,G_TYPE_DOUBLE);
			    g_value_set_double(&value,lua_tonumber(L,-1));
			    g_value_array_append(values,&value);
			}
		    }
		    else if (!strcmp("y_rotation",k))
		    {
			if (lua_type(L,-1)==LUA_TTABLE)
			{
			    
			}
			else
			{
			    g_ptr_array_add(names,g_strdup("rotation-angle-y"));
			    g_value_init(&value,G_TYPE_DOUBLE);
			    g_value_set_double(&value,lua_tonumber(L,-1));
			    g_value_array_append(values,&value);
			}
		    }
		    else if (!strcmp("z_rotation",k))
		    {
			if (lua_type(L,-1)==LUA_TTABLE)
			{
			    
			}
			else
			{
			    g_ptr_array_add(names,g_strdup("rotation-angle-z"));
			    g_value_init(&value,G_TYPE_DOUBLE);
			    g_value_set_double(&value,lua_tonumber(L,-1));
			    g_value_array_append(values,&value);
			}
		    }
		}
		
		lua_pop(L,1);
	    }
	    
	    ClutterAnimation * a=clutter_actor_animatev(self,mode,duration,
							values->n_values,
							(gchar**)names->pdata,
							values->values);
	    
	    lua_getfield(L,props,"loop");
	    if (!lua_isnil(L,-1))
	    {
		clutter_animation_set_loop(a,lua_toboolean(L,-1));
	    }
	    lua_pop(L,1);
	    
	    // If you call animate several times, clutter reuses the same
	    // ClutterAnimation object. So, if we are not set to loop,
	    // and the user passed an "on_completed" function, we may have
	    // to unref the old function and disconnect the old handler.
	    
	    if (!clutter_animation_get_loop(a))
	    {
		lua_getfield(L,props,"on_completed");
		
		if (lua_type(L,-1)==LUA_TFUNCTION)
		{
		    int function_ref=luaL_ref(L,LUA_REGISTRYINDEX);
		    
		    // Remove the old one, if any
		    
		    int old_function_ref=GPOINTER_TO_INT(g_object_get_data(G_OBJECT(a),"tp-completed"));
		    
		    if (old_function_ref)
		    {
			luaL_unref(L,LUA_REGISTRYINDEX,old_function_ref);
		    }
		    
		    g_signal_handlers_disconnect_by_func(a,gpointer(actor_animation_completed),L);
		    
		    // Attach the new one
		    
		    g_object_set_data(G_OBJECT(a),"tp-completed",GINT_TO_POINTER(function_ref));
		    
		    g_signal_connect_after(a,"completed",G_CALLBACK(actor_animation_completed),L);
		}
		else
		{
		    lua_pop(L,1);
		}
	    }
	    
	    g_value_array_free(values);
	    g_ptr_array_free(names,TRUE);
	]];
	
    bool complete_animation()
	[[
	    ClutterAnimation * animation=clutter_actor_get_animation(self);
	    g_debug("ANIMATION=%p",animation);
	    if (animation)
	    {
		clutter_animation_completed(animation);
		result=true;
	    }
	    else
	    {
		result=false;
	    }
	]];
	
    readonly bool is_animating
	[[
	    is_animating=clutter_actor_get_animation(self)!=NULL;    
	]];

    callback on_key_focus_in
	[[
	    SignalCollector::get(L)->connect_if(
		on_key_focus_in,"on_key_focus_in",
		self,"key-focus-in",G_CALLBACK(actor_on_key_focus_in),L);
	]];

    callback on_key_focus_out
	[[
	    SignalCollector::get(L)->connect_if(
		on_key_focus_out,"on_key_focus_out",
		self,"key-focus-out",G_CALLBACK(actor_on_key_focus_out),L);
	]];
	
    callback on_key_down
	[[
	    SignalCollector::get(L)->connect_if(
		on_key_down,"on_key_down",
		self,"key-press-event",G_CALLBACK(actor_on_key_down),L);	    
	]];
	
    callback on_key_up
	[[
	    SignalCollector::get(L)->connect_if(
		on_key_up,"on_key_up",
		self,"key-release-event",G_CALLBACK(actor_on_key_up),L);	    
	]];
	
    callback on_scroll
	[[
	    SignalCollector::get(L)->connect_if(
		on_scroll,"on_scroll",
		self,"scroll-event",G_CALLBACK(actor_on_scroll),L);	    
	]];
	
    callback on_button_down
	[[
	    SignalCollector::get(L)->connect_if(
		on_button_down,"on_button_down",
		self,"button-press-event",G_CALLBACK(actor_on_button_down),L);	    
	]];
	
    callback on_button_up
	[[
	    SignalCollector::get(L)->connect_if(
		on_button_up,"on_button_up",
		self,"button-release-event",G_CALLBACK(actor_on_button_up),L);	    
	]];
	
    callback on_show
	[[
	    SignalCollector::get(L)->connect_if(
		on_show,"on_show",
		self,"show",G_CALLBACK(actor_on_show),L);	    	    
	]];
	
    callback on_hide
	[[
	    SignalCollector::get(L)->connect_if(
		on_hide,"on_hide",
		self,"hide",G_CALLBACK(actor_on_hide),L);	    	    
	]];
}

[[
void container_foreach_callback(ClutterActor*actor,lua_State*L)
{
    // The callback is always at 2
    lua_pushvalue(L,2);
    wrap_concrete_actor(L,actor);
    lua_call(L,1,0);
}

]]

interface container [[ClutterActor*]]
{
    add( )
        [[
            for(int i=2;i<=lua_gettop(L);++i)
            {
		if (ClutterActor * actor=user_data_to_actor(L,i))
		        clutter_container_add_actor(CLUTTER_CONTAINER(self),actor);
            }
        ]];
	
    remove()
	[[
            for(int i=2;i<=lua_gettop(L);++i)
            {
		if (ClutterActor * actor=user_data_to_actor(L,i))
		        clutter_container_remove_actor(CLUTTER_CONTAINER(self),actor);
            }	    
	]];
	
    clear()
	[[
            clutter_group_remove_all(CLUTTER_GROUP(self));	    
	]];
	
    foreach_child( function f )
	[[
	    clutter_container_foreach(CLUTTER_CONTAINER(self),(ClutterCallback)container_foreach_callback,L);    
	]];
	
    table find_child( string name )
	[[
	    wrap_concrete_actor(L,clutter_container_find_child_by_name(CLUTTER_CONTAINER(self),name));    
	]];
	
    raise_child( udata child , udata sibling = 0 )
	[[
	    ClutterActor * c = user_data_to_actor(L,child);
	    ClutterActor * s = sibling?user_data_to_actor(L,sibling):NULL;
	    
	    if (c)
	    {
		clutter_container_raise_child(CLUTTER_CONTAINER(self),c,s);
	    }
	]];
	
    lower_child( udata child , udata sibling = 0 )
	[[
	    ClutterActor * c = user_data_to_actor(L,child);
	    ClutterActor * s = sibling?user_data_to_actor(L,sibling):NULL;

	    if (c)
	    {
		clutter_container_lower_child(CLUTTER_CONTAINER(self),c,s);
	    }
	]];

    # This one is very wasteful - it has to create and free the list as well as
    # traverse it to determine the number of children. Should consider removing
    # it altogether
    
    readonly int count
	[[
            GList * list=clutter_container_get_children(CLUTTER_CONTAINER(self));
	    count = g_list_length(list);
	    g_list_free(list);
	]];
	
    table children
        [[
            GList * list=clutter_container_get_children(CLUTTER_CONTAINER(self));
	    
	    lua_newtable(L);
	    int n = 1;
	    for(GList*item=g_list_first(list);item;item=g_list_next(item),++n)
	    {
		wrap_concrete_actor(L,CLUTTER_ACTOR(item->data));
		lua_rawseti(L,-2,n);
	    }
	    g_list_free(list);
        ]]
        [[
            luaL_checktype(L,2,LUA_TTABLE);
            clutter_group_remove_all(CLUTTER_GROUP(self));
            lua_pushnil(L);
            while(lua_next(L,2))
            {
                ClutterActor* source=user_data_to_actor(L,-1);
                if(source)
		{
                    clutter_container_add_actor(CLUTTER_CONTAINER(self),source);
		}
                lua_pop(L,1);
            }
        ]];
	
}

[[
#ifndef TP_PRODUCTION

gboolean Stage_quit(ClutterActor*actor,ClutterEvent*event,lua_State*L)
{
    ClutterKeyEvent * k=(ClutterKeyEvent*)event;
    
    if (k->keyval==CLUTTER_Escape)
    {
	App::get(L)->get_context()->close_app();
	return TRUE;
    }
    return FALSE;    
}

#endif


]]

global screen [[ClutterActor*]] actor , container
{
    screen()
	[[
	    *self=clutter_get_actor_by_gid(App::get(L)->get_screen_gid());
	    
	    g_object_ref(G_OBJECT(*self));
	    
	    initialize_actor(L,*self,SCREEN_METATABLE);
	    	    	    
#ifndef TP_PRODUCTION
	    SignalCollector::get(L)->connect(
		"screen-quit",*self,"key-press-event",G_CALLBACK(Stage_quit),L);
#endif
	]];
    
    ~screen()
	[[
	    g_object_unref(G_OBJECT(self));
	]];

    #..........................................................................
    # We have to override these from regular actors, so that app developers
    # cannot reach outside their screen
    
    show()
        [[
	    clutter_actor_show(self);
	    // Show the stage as well
	    clutter_actor_show(clutter_stage_get_default());
	]];
        
    show_all()
        [[
	    clutter_actor_show_all(self);
	    // Show the stage as well
	    clutter_actor_show(clutter_stage_get_default());
	]];
	
    readonly udata parent
	[[
	    lua_pushnil(L);
	]];
	
    unparent()
	[[
	    // Cannot let the app developer remove his screen from the stage,
	    // because he would not have a way to put it back
	]];
	
    #..........................................................................	
    # These are stage properties
    
    # TODO
    # This can potentionally let an app get an actor outside its group, so I'll
    # have to rework it.
    
    /*
    udata key_focus
	[[
	    wrap_concrete_actor(L,clutter_stage_get_key_focus(CLUTTER_STAGE(clutter_stage_get_default())));
	]]
	[[
	    ClutterActor *k=user_data_to_actor(L,2);
	    if (k)
	    {
		clutter_stage_set_key_focus(CLUTTER_STAGE(clutter_stage_get_default()),k);
	    }
	]];
    
    
    # This doesn't seem to work
    
    udata get_object_at( double x , double y )
	[[
	    wrap_concrete_actor(L,clutter_stage_get_actor_at_pos(CLUTTER_STAGE(clutter_stage_get_default()),CLUTTER_PICK_ALL,x,y));
	]];
    */		    
    
	
/*
    // App developers cannot control the color of the stage - and their new 'screen'
    // doesn't have a color, since it is a group.
    
    table color
        [[
            ClutterColor color;
            clutter_stage_get_color(CLUTTER_STAGE(self),&color);
            push_clutter_color(L,&color);
        ]]
        [[
            ClutterColor color;
            to_clutter_color(L,2,&color);
            clutter_stage_set_color(CLUTTER_STAGE(self),&color);            
        ]];
	
    table perspective
	[[
	    ClutterPerspective p;
	    clutter_stage_get_perspective(CLUTTER_STAGE(self),&p);
	    lua_newtable(L);
	    lua_pushnumber(L,p.fovy);
	    lua_rawseti(L,-2,1);
	    lua_pushnumber(L,p.aspect);
	    lua_rawseti(L,-2,2);
	    lua_pushnumber(L,p.z_near);
	    lua_rawseti(L,-2,3);
	    lua_pushnumber(L,p.z_far);
	    lua_rawseti(L,-2,4);
	]]
	[[
	    luaL_checktype(L,2,LUA_TTABLE);
            lua_rawgeti(L,2,1);
            lua_rawgeti(L,2,2);
            lua_rawgeti(L,2,3);
            lua_rawgeti(L,2,4);
	    ClutterPerspective p = {lua_tonumber(L,-4),lua_tonumber(L,-3),
		lua_tonumber(L,-2),lua_tonumber(L,-1)};
            clutter_stage_set_perspective(CLUTTER_STAGE(self),&p);
            lua_pop(L,4);
	]];	
 */	
}

[[
void Text_on_text_changed(ClutterText*text,lua_State*L);
]]

class Text [[ClutterActor*]] actor
{
    Text(table props =0)
        [[
            *self = clutter_text_new();
	    initialize_actor(L,*self,TEXT_METATABLE);
	    set_props_from_table(L,props);
	    g_object_ref_sink(G_OBJECT(*self));
        ]];
	
    ~Text()
	[[g_object_unref(G_OBJECT(self));]];
    
    table color
        [[
            ClutterColor color;
            clutter_text_get_color(CLUTTER_TEXT(self),&color);
            push_clutter_color(L,&color);
        ]]
        [[
            ClutterColor color;
            to_clutter_color(L,2,&color);
            clutter_text_set_color(CLUTTER_TEXT(self),&color);
        ]];
        
    string text
        [[text=clutter_text_get_text(CLUTTER_TEXT(self));]]
        [[clutter_text_set_text(CLUTTER_TEXT(self),text);]];
        
    string markup
        [[
            // markup doesn't have a getter
            markup=clutter_text_get_text(CLUTTER_TEXT(self));
        ]]
        [[clutter_text_set_markup(CLUTTER_TEXT(self),markup);]];
        
    string font
        [[font=clutter_text_get_font_name(CLUTTER_TEXT(self));]]
        [[clutter_text_set_font_name(CLUTTER_TEXT(self),font);]];
        
    bool justify
        [[justify=clutter_text_get_justify(CLUTTER_TEXT(self));]]
        [[clutter_text_set_justify(CLUTTER_TEXT(self),justify);]];
        
    bool wrap
        [[wrap=clutter_text_get_line_wrap(CLUTTER_TEXT(self));]]
        [[clutter_text_set_line_wrap(CLUTTER_TEXT(self),wrap);]];
        
    bool use_markup
        [[use_markup=clutter_text_get_use_markup(CLUTTER_TEXT(self));]]
        [[clutter_text_set_use_markup(CLUTTER_TEXT(self),use_markup);]];
	
    string ellipsize
	[[
	    switch(clutter_text_get_ellipsize(CLUTTER_TEXT(self)))
	    {
		case PANGO_ELLIPSIZE_START:
		    ellipsize="START";
		    break;
		case PANGO_ELLIPSIZE_MIDDLE:
		    ellipsize="MIDDLE";
		    break;
		case PANGO_ELLIPSIZE_END:
		    ellipsize="END";
		    break;
		default:
		    ellipsize="NONE";
	    }
	]]
	[[
	    PangoEllipsizeMode mode = PANGO_ELLIPSIZE_NONE;
	    if(!strcmp(ellipsize,"START"))
		mode = PANGO_ELLIPSIZE_START;
	    else if(!strcmp(ellipsize,"MIDDLE"))
		mode = PANGO_ELLIPSIZE_MIDDLE;
	    else if(!strcmp(ellipsize,"END"))
		mode = PANGO_ELLIPSIZE_END;
	    else if(!strcmp(ellipsize,"NONE"))
		mode = PANGO_ELLIPSIZE_NONE;
	    else
		luaL_error(L,"Invalid ellipsize '%s'",ellipsize);
	    clutter_text_set_ellipsize(CLUTTER_TEXT(self),mode);	
	]];
	
    string alignment
	[[
	    switch(clutter_text_get_line_alignment(CLUTTER_TEXT(self)))
	    {
		case PANGO_ALIGN_CENTER:
		    alignment="CENTER";
		    break;
		case PANGO_ALIGN_RIGHT:
		    alignment="RIGHT";
		    break;
		default:
		    alignment="LEFT";
	    }	    
	]]
	[[
	    PangoAlignment a=PANGO_ALIGN_LEFT;
	    if(!strcmp(alignment,"LEFT"))
		a=PANGO_ALIGN_LEFT;
	    else if(!strcmp(alignment,"CENTER"))
		a=PANGO_ALIGN_CENTER;
	    else if(!strcmp(alignment,"RIGHT"))
		a=PANGO_ALIGN_RIGHT;
	    else
		luaL_error(L,"Invalid alignment '%s'",alignment);
	    clutter_text_set_line_alignment(CLUTTER_TEXT(self),a);
	]];
	
    int max_length
	[[max_length=clutter_text_get_max_length(CLUTTER_TEXT(self));]]
	[[clutter_text_set_max_length(CLUTTER_TEXT(self),max_length);]];
	
    set_selection( int start_pos , int end_pos )
	[[clutter_text_set_selection(CLUTTER_TEXT(self),start_pos,end_pos);]];
	    
    readonly string selected_text
	[[
	    gchar * s = clutter_text_get_selection(CLUTTER_TEXT(self));
	    selected_text = s;	    
	    Util::GFreeLater later(s);	    
	]];
	
    int selection_end
	[[selection_end=clutter_text_get_selection_bound(CLUTTER_TEXT(self));]]
	[[clutter_text_set_selection_bound(CLUTTER_TEXT(self),selection_end);]];
	
    bool single_line
	[[single_line=clutter_text_get_single_line_mode(CLUTTER_TEXT(self));]]
	[[clutter_text_set_single_line_mode(CLUTTER_TEXT(self),single_line);]];
	
    bool editable
	[[editable=clutter_text_get_editable(CLUTTER_TEXT(self));]]
	[[clutter_text_set_editable(CLUTTER_TEXT(self),editable);]];
	
    insert_text( int pos , string text )
	[[clutter_text_insert_text(CLUTTER_TEXT(self),text,pos);]];
	
    delete_chars( int count )
	[[clutter_text_delete_chars(CLUTTER_TEXT(self),count);]];
	
    delete_text( int start_pos , int end_pos )
	[[clutter_text_delete_text(CLUTTER_TEXT(self),start_pos,end_pos);]];
	
    bool delete_selection()
	[[result=clutter_text_delete_selection(CLUTTER_TEXT(self));]];
	
    string get_chars( int start_pos , int end_pos )
	[[
	    gchar * c=clutter_text_get_chars(CLUTTER_TEXT(self),start_pos,end_pos);
	    result = c;
	    Util::GFreeLater later(c);
	]];
	
    table cursor_color
	[[
	    ClutterColor color;
	    clutter_text_get_cursor_color(CLUTTER_TEXT(self),&color);
	    push_clutter_color(L,&color);
	]]
	[[
	    ClutterColor color;
	    to_clutter_color(L,2,&color);
	    clutter_text_set_cursor_color(CLUTTER_TEXT(self),&color);
	]];
	
    table selection_color
	[[
	    ClutterColor color;
	    clutter_text_get_selection_color(CLUTTER_TEXT(self),&color);
	    push_clutter_color(L,&color);
	]]
	[[
	    ClutterColor color;
	    to_clutter_color(L,2,&color);
	    clutter_text_set_selection_color(CLUTTER_TEXT(self),&color);
	]];
	
    int cursor_position
	[[cursor_position=clutter_text_get_cursor_position(CLUTTER_TEXT(self));]]
	[[clutter_text_set_cursor_position(CLUTTER_TEXT(self),cursor_position);]];
	
    bool cursor_visible
	[[cursor_visible=clutter_text_get_cursor_visible(CLUTTER_TEXT(self));]]
	[[clutter_text_set_cursor_visible(CLUTTER_TEXT(self),cursor_visible);]];
    
    int cursor_size
	[[cursor_size=clutter_text_get_cursor_size(CLUTTER_TEXT(self));]]
	[[clutter_text_set_cursor_size(CLUTTER_TEXT(self),cursor_size);]];
	
    bool wants_enter
	[[wants_enter=!clutter_text_get_activatable(CLUTTER_TEXT(self));]]
	[[clutter_text_set_activatable(CLUTTER_TEXT(self),!wants_enter);]];
	
    int password_char
	[[password_char=clutter_text_get_password_char(CLUTTER_TEXT(self));]]
	[[clutter_text_set_password_char(CLUTTER_TEXT(self),password_char);]];
	
    callback on_text_changed
	[[
	    SignalCollector::get(L)->connect_if(
		on_text_changed,"on_text_changed",
		self,"text-changed",G_CALLBACK(Text_on_text_changed),L);	    
	]];
}
[[
void Text_on_text_changed(ClutterText*text,lua_State*L)
{
    invoke_Text_on_text_changed(L,CLUTTER_ACTOR(text),0,0);
}
]]

class Rectangle [[ClutterActor*]] actor
{
    Rectangle(table props = 0)
        [[
            *self = clutter_rectangle_new();
	    initialize_actor(L,*self,RECTANGLE_METATABLE);
	    set_props_from_table(L,props);
	    g_object_ref_sink(G_OBJECT(*self));
        ]];
	
    ~Rectangle()
	[[g_object_unref(G_OBJECT(self));]];
        
    table color
        [[
            ClutterColor color;
            clutter_rectangle_get_color(CLUTTER_RECTANGLE(self),&color);
            push_clutter_color(L,&color);
        ]]
        [[
            ClutterColor color;
            to_clutter_color(L,2,&color);
            clutter_rectangle_set_color(CLUTTER_RECTANGLE(self),&color);            
        ]];
        
    int border_width
        [[border_width=clutter_rectangle_get_border_width(CLUTTER_RECTANGLE(self));]]
        [[clutter_rectangle_set_border_width(CLUTTER_RECTANGLE(self),border_width);]];
        
    table border_color
        [[
            ClutterColor color;
            clutter_rectangle_get_border_color(CLUTTER_RECTANGLE(self),&color);
            push_clutter_color(L,&color);
        ]]
        [[
            ClutterColor color;
            to_clutter_color(L,2,&color);
            clutter_rectangle_set_border_color(CLUTTER_RECTANGLE(self),&color);
        ]];
}

class Clone [[ClutterActor*]] actor
{
    Clone(table props = 0)
        [[
            *self = clutter_clone_new(NULL);
	    initialize_actor(L,*self,CLONE_METATABLE);
	    set_props_from_table(L,props);
	    g_object_ref_sink(G_OBJECT(*self));
        ]];
	
    ~Clone()
	[[g_object_unref(G_OBJECT(self));]];
        
    udata source
        [[
	    wrap_concrete_actor(L,clutter_clone_get_source(CLUTTER_CLONE(self)));
        ]]
        [[
            ClutterActor* source=user_data_to_actor(L,2);
            if(source)
	    {
                clutter_clone_set_source(CLUTTER_CLONE(self),source);
	    }
        ]];
}

class Group [[ClutterActor*]] actor , container
{
    Group(table props = 0 )
        [[
            *self = clutter_group_new();
	    initialize_actor(L,*self,GROUP_METATABLE);
	    set_props_from_table(L,props);
	    g_object_ref_sink(G_OBJECT(*self));
        ]];
	
    ~Group()
	[[g_object_unref(G_OBJECT(self));]];        
}

[[

#if TP_USE_GDK_PIXBUF

struct ImageClosure
{
    ImageClosure(ClutterTexture*i)
    :
	image(i),
	loader(gdk_pixbuf_loader_new()),
	error(NULL)
    {
	g_assert(image);
	g_assert(loader);
	g_object_ref(G_OBJECT(image));
    }
    
    ~ImageClosure()
    {
	g_object_unref(G_OBJECT(image));
	gdk_pixbuf_loader_close(loader,NULL);
	g_object_unref(G_OBJECT(loader));
	g_clear_error(&error);
    }
    
    ClutterTexture * 	image;
    GdkPixbufLoader * 	loader;
    GError * 		error;
};

static void Image_destroy_image_closure(gpointer ic)
{
    delete (ImageClosure*)ic;
}

// This one gets called directly by the network thread every time
// we get a piece of the body - we take advantage of the thread to
// decode the image one chunk at a time.

bool Image_incremental_response_callback(const Network::Response & response,gpointer body,guint len,bool finished,gpointer user)
{
    ImageClosure * closure=(ImageClosure*)user;
    
    // If it is finished, we are running in the main thread, otherwise, we are
    // running in the network thread.
    
    if (finished)
    {
	if (response.failed && !closure->error)
	{
	    g_set_error(&closure->error,
		CLUTTER_TEXTURE_ERROR,
		CLUTTER_TEXTURE_ERROR_BAD_FORMAT,
		"Request failed : %s" , response.status.c_str() );
	}
	
	// Close the loader. If there is an error already, we pass NULL
	// so that we retain the old error - the loader has to be closed
	// either way. Otherwise, we pass the error address so that close
	// has a chance to fail.
	
	gdk_pixbuf_loader_close(closure->loader,closure->error?NULL:&closure->error);

	if (!closure->error)
	{
	    GdkPixbuf * p = gdk_pixbuf_loader_get_pixbuf(closure->loader);
	    
	    if (p)
	    {
		if ( ! clutter_texture_set_from_rgb_data(closure->image,
		    gdk_pixbuf_get_pixels(p),
		    gdk_pixbuf_get_has_alpha(p),
		    gdk_pixbuf_get_width(p),
		    gdk_pixbuf_get_height(p),
		    gdk_pixbuf_get_rowstride(p),
		    gdk_pixbuf_get_has_alpha(p)?4:3,
		    CLUTTER_TEXTURE_NONE,NULL))
		{
		    g_set_error(&closure->error,
			CLUTTER_TEXTURE_ERROR,
			CLUTTER_TEXTURE_ERROR_BAD_FORMAT,
			"Failed to set texture data");
		}
	    }
	    else
	    {
		g_set_error(&closure->error,
		    CLUTTER_TEXTURE_ERROR,
		    CLUTTER_TEXTURE_ERROR_BAD_FORMAT,
		    "Failed to get pixbuf from loader");
	    }
	}
	
	if (closure->error)
	{
	    g_warning("Failed to load image : %s",closure->error->message);
	    g_signal_emit_by_name(G_OBJECT(closure->image),"load-finished",closure->error);	
	}
    }
    else
    {
	// If there was an error already, we do nothing
	
	if (!closure->error)
	{
	    gdk_pixbuf_loader_write(closure->loader,(const guchar*)body,len,&closure->error);    
	}
    }
    
    // If there is no error, we return true to carry on
    
    return !closure->error;
}
#else

static void Image_destroy_image_closure(gpointer texture)
{
    g_object_unref(G_OBJECT(texture));
}

void Image_response_callback(const Network::Response & response,gpointer texture)
{
    GError * error=NULL;
    
    if (response.failed)
    {
	g_set_error(&error,
	    CLUTTER_TEXTURE_ERROR,
	    CLUTTER_TEXTURE_ERROR_BAD_FORMAT,
	    "Request failed : %s" , response.status.c_str() );	
    }
    else
    {
	if (!load_texture_from_data(CLUTTER_TEXTURE(texture),response.body->data,response.body->len))
	{
	    g_set_error(&error,
		CLUTTER_TEXTURE_ERROR,
		CLUTTER_TEXTURE_ERROR_BAD_FORMAT,
		"Failed to load texture data");
	}
    }
    
    if (error)
    {
	g_warning("Failed to load image : %s",error->message);
	g_signal_emit_by_name(G_OBJECT(texture),"load-finished",error);
	
	g_clear_error(&error);
    }
}

#endif


]]

[[
void Image_on_loaded(ClutterTexture*self,gpointer error,lua_State*L);
void Image_on_size_changed(ClutterTexture*self,gint width,gint height,lua_State*L);
]]

class Image [[ClutterActor*]] actor
{
    Image(table props = 0 )
        [[
            *self = clutter_texture_new();
	    initialize_actor(L,*self,IMAGE_METATABLE);
	    set_props_from_table(L,props);
	    g_object_ref_sink(G_OBJECT(*self));
        ]];
	
    ~Image()
	[[
	    g_object_unref(G_OBJECT(self));
	]];
    
    string src
	[[
	    src=(char*)g_object_get_data(G_OBJECT(self),"tp-src");
	]]
	[[
	    bool is_uri;
	    
	    App * app=App::get(L);
	    
	    char * path=app->normalize_path(src,&is_uri);
	    
	    if (path)
	    {
		Util::GFreeLater free_path(path);
    
		if (is_uri)
		{
		    Network::Request request(app->get_user_agent());
		    request.url = path;
		    
#if TP_USE_GDK_PIXBUF

		    app->get_network()->perform_request_async_incremental(
			request,
			app->get_cookie_jar(),
			Image_incremental_response_callback,
			new ImageClosure(CLUTTER_TEXTURE(self)),
			Image_destroy_image_closure);
#else

		    g_object_ref(G_OBJECT(self));
		    
		    app->get_network()->perform_request_async(
			request,
			app->get_cookie_jar(),
			Image_response_callback,
			self,
			Image_destroy_image_closure);
		    
#endif		    
		}
		else
		{
#if TP_USE_GDK_PIXBUF
		    clutter_texture_set_from_file(CLUTTER_TEXTURE(self),path,NULL);
#else
		    if (!load_texture_from_file(CLUTTER_TEXTURE(self),path))
		    {
			GError * error=NULL;

			g_set_error(&error,
			    CLUTTER_TEXTURE_ERROR,
			    CLUTTER_TEXTURE_ERROR_BAD_FORMAT,
			    "Failed to load texture data");
			
			g_signal_emit_by_name(G_OBJECT(self),"load-finished",error);
			
			g_clear_error(&error);
		    }
#endif
		}
		g_object_set_data_full(G_OBJECT(self),"tp-src",g_strdup(src),g_free);
	    }
	]];
	
    readonly table base_size
	[[
	    gint w;
	    gint h;
	    clutter_texture_get_base_size(CLUTTER_TEXTURE(self),&w,&h);
	    lua_newtable(L);
	    lua_pushnumber(L,w);
	    lua_rawseti(L,-2,1);
	    lua_pushnumber(L,h);
	    lua_rawseti(L,-2,2);
	]];
	
    bool sync_size
	[[sync_size=clutter_texture_get_sync_size(CLUTTER_TEXTURE(self));]]
	[[clutter_texture_set_sync_size(CLUTTER_TEXTURE(self),sync_size);]];
	
    table tile
	[[
	    gboolean rx;
	    gboolean ry;
	    clutter_texture_get_repeat(CLUTTER_TEXTURE(self),&rx,&ry);
	    lua_newtable(L);
	    lua_pushboolean(L,rx);
	    lua_rawseti(L,-2,1);
	    lua_pushboolean(L,ry);
	    lua_rawseti(L,-2,2);
	]]
	[[
	    lb_checktable(L,2);
	    lua_rawgeti(L,2,1);
	    lua_rawgeti(L,2,2);
	    clutter_texture_set_repeat(CLUTTER_TEXTURE(self),lua_toboolean(L,-2),lua_toboolean(L,-1));
	    lua_pop(L,2);
	]];
	
    bool keep_aspect_ratio
	[[keep_aspect_ratio=clutter_texture_get_keep_aspect_ratio(CLUTTER_TEXTURE(self));]]
	[[clutter_texture_set_keep_aspect_ratio(CLUTTER_TEXTURE(self),keep_aspect_ratio);]];
	
    bool load_async
	[[load_async=clutter_texture_get_load_async(CLUTTER_TEXTURE(self));]]
	[[clutter_texture_set_load_async(CLUTTER_TEXTURE(self),load_async);]];
	
    bool load_from_data(lstring data)
	[[
#if TP_USE_GDK_PIXBUF
	    result = false;
	    
	    GdkPixbufLoader * loader = gdk_pixbuf_loader_new();
	    
	    if (loader)
	    {
		if (gdk_pixbuf_loader_write(loader,(const guchar *)data,data_len,NULL))
		{
		    if (gdk_pixbuf_loader_close(loader,NULL))
		    {	    
			GdkPixbuf * p = gdk_pixbuf_loader_get_pixbuf(loader);
			
			if (p)
			{
			    if ( clutter_texture_set_from_rgb_data(CLUTTER_TEXTURE(self),
				gdk_pixbuf_get_pixels(p),
				gdk_pixbuf_get_has_alpha(p),
				gdk_pixbuf_get_width(p),
				gdk_pixbuf_get_height(p),
				gdk_pixbuf_get_rowstride(p),
				gdk_pixbuf_get_has_alpha(p)?4:3,
				CLUTTER_TEXTURE_NONE,NULL))
			    {
				result=true;
			    }
			}
		    }
		}	
		else
		{
		    gdk_pixbuf_loader_close(loader,NULL);
		}
		
		g_object_unref(G_OBJECT(loader));
	    }
#else
	    result=load_texture_from_data(CLUTTER_TEXTURE(self),data,data_len);
#endif	    
	]];
	
    callback on_loaded
	[[
	    SignalCollector::get(L)->connect_if(
		on_loaded,"on_loaded",
		self,"load-finished",G_CALLBACK(Image_on_loaded),L);
	]];
	
    callback on_size_changed
	[[
	    SignalCollector::get(L)->connect_if(
		on_size_changed,"on_size_changed",
		self,"size-change",G_CALLBACK(Image_on_size_changed),L);	    
	]];	
}

[[
void Image_on_loaded(ClutterTexture*self,gpointer error,lua_State*L)
{
    lua_pushboolean(L,error?1:0);
    invoke_Image_on_loaded(L,CLUTTER_ACTOR(self),1,0);
}

void Image_on_size_changed(ClutterTexture*self,gint width,gint height,lua_State*L)
{
    lua_pushinteger(L,width);
    lua_pushinteger(L,height);
    invoke_Image_on_size_changed(L,CLUTTER_ACTOR(self),2,0);
}
]]



[[
void Timeline_on_new_frame(ClutterTimeline*timeline,gint msecs,lua_State*L);
void Timeline_on_started(ClutterTimeline*timeline,lua_State*L);
void Timeline_on_completed(ClutterTimeline*timeline,lua_State*L);
void Timeline_on_paused(ClutterTimeline*timeline,lua_State*L);
void Timeline_on_marker_reached(ClutterTimeline *timeline,gchar*marker_name,gint msecs,lua_State*L);
]]

class Timeline [[ClutterTimeline*]]
{
    Timeline(table props = 0)
	[[
	    *self=clutter_timeline_new(1000);
    	    set_props_from_table(L,props);
	]];
	
    ~Timeline()
	[[
	    g_object_unref(G_OBJECT(self));
	]];
	
    int duration
	[[duration=clutter_timeline_get_duration(self);]]
	[[clutter_timeline_set_duration(self,duration);]];
	
    bool loop
	[[loop=clutter_timeline_get_loop(self);]]
	[[clutter_timeline_set_loop(self,loop);]];
	
    int delay
	[[delay=clutter_timeline_get_delay(self);]]
	[[clutter_timeline_set_delay(self,delay);]];
	
    string direction
	[[direction=(clutter_timeline_get_direction(self)==CLUTTER_TIMELINE_FORWARD?"FORWARD":"BACKWARD");]]
	[[
	    static const char * directions[3] = { "FORWARD" , "BACKWARD" , NULL };
	    clutter_timeline_set_direction(self,luaL_checkoption(L,-1,directions[0],directions)==0?CLUTTER_TIMELINE_FORWARD:CLUTTER_TIMELINE_BACKWARD);
	]];

	reverse()
	[[clutter_timeline_set_direction(self,
			clutter_timeline_get_direction(self)==CLUTTER_TIMELINE_FORWARD
			?CLUTTER_TIMELINE_BACKWARD
			:CLUTTER_TIMELINE_FORWARD);]];
	
    start()
	[[clutter_timeline_start(self);]];
	
    pause()
	[[clutter_timeline_pause(self);]];
	
    stop()
	[[clutter_timeline_stop(self);]];
	
    rewind()
	[[clutter_timeline_rewind(self);]];
	
    skip(int msecs)
	[[clutter_timeline_skip(self,msecs);]];
	
    advance(int msecs)
	[[clutter_timeline_advance(self,msecs);]];
	
    readonly int elapsed
	[[elapsed=clutter_timeline_get_elapsed_time(self);]];
	
    readonly int delta
	[[delta=clutter_timeline_get_delta(self);]];
	
    readonly double progress
	[[progress=clutter_timeline_get_progress(self);]];
	
    readonly bool is_playing
	[[is_playing=clutter_timeline_is_playing(self);]];
	
    add_marker(string name,int msecs)
	[[clutter_timeline_add_marker_at_time(self,name,msecs);]];
	
    remove_marker(string name)
	[[clutter_timeline_remove_marker(self,name);]];
	
    bool has_marker(string name)
	[[result=clutter_timeline_has_marker(self,name);]];
	
    advance_to_marker(string name)
	[[clutter_timeline_advance_to_marker(self,name);]];
    
    table list_markers(int msecs = -1)
	[[
	    gsize len;
	    gchar** markers=clutter_timeline_list_markers(self,msecs,&len);
	    gchar** m = markers;
	    lua_newtable(L);
	    for(int i=1;len;--len,++m,++i)
	    {
		lua_pushstring(L,*m);
		lua_rawseti(L,-2,i);
	    }
	    g_strfreev(markers);
	]];
	
    readonly table markers
	[[Timeline_list_markers(L);]];
	
    table extra
	[[
	    actor_extra * e = (actor_extra*)g_object_get_data(G_OBJECT(self),"tp-extra");
	    
	    if (!e)
	    {
		g_object_set_data_full(G_OBJECT(self),"tp-extra",new actor_extra(L),actor_extra::destroy);
	    }
	    else
	    {
		e->push_table();
	    }
	]]
	[[
	    if (lua_isnil(L,2))
	    {
		g_object_set_data_full(G_OBJECT(self),"tp-extra",NULL,actor_extra::destroy);
	    }
	    else
	    {
		lb_checktable(L,2);
		g_object_set_data_full(G_OBJECT(self),"tp-extra",new actor_extra(L,2),actor_extra::destroy);
	    }
	]];
	
    callback on_new_frame
	[[
	    SignalCollector::get(L)->connect_if(
		on_new_frame,"on_new_frame",
		self,"new-frame",G_CALLBACK(Timeline_on_new_frame),L);
	]];
	
    callback on_started
	[[
	    SignalCollector::get(L)->connect_if(
		on_started,"on_started",
		self,"started",G_CALLBACK(Timeline_on_started),L);	    
	]];
    
    callback on_completed
	[[
	    SignalCollector::get(L)->connect_if(
		on_completed,"on_completed",
		self,"completed",G_CALLBACK(Timeline_on_completed),L);	    	    
	]];
	
    callback on_paused
	[[
	    SignalCollector::get(L)->connect_if(
		on_paused,"on_paused",
		self,"paused",G_CALLBACK(Timeline_on_paused),L);	    	    
	]];
	
    callback on_marker_reached
	[[
	    SignalCollector::get(L)->connect_if(
		on_marker_reached,"on_marker_reached",
		self,"marker-reached",G_CALLBACK(Timeline_on_marker_reached),L);	    	    	    
	]];
}

[[
void Timeline_on_new_frame(ClutterTimeline*timeline,gint msecs,lua_State*L)
{
    lua_pushinteger(L,msecs);
    lua_pushnumber(L,clutter_timeline_get_progress(timeline));
    invoke_Timeline_on_new_frame(L,timeline,2,0);
}

void Timeline_on_started(ClutterTimeline*timeline,lua_State*L)
{
    invoke_Timeline_on_started(L,timeline,0,0);    
}

void Timeline_on_completed(ClutterTimeline*timeline,lua_State*L)
{
    invoke_Timeline_on_completed(L,timeline,0,0);    
}

void Timeline_on_paused(ClutterTimeline*timeline,lua_State*L)
{
    invoke_Timeline_on_paused(L,timeline,0,0);    
}

void Timeline_on_marker_reached(ClutterTimeline *timeline,gchar*marker_name,gint msecs,lua_State*L)
{
    lua_pushstring(L,marker_name);
    lua_pushinteger(L,msecs);
    invoke_Timeline_on_marker_reached(L,timeline,2,0);
}

]]

[[
gdouble Alpha_on_alpha(ClutterAlpha*self,gpointer lsp);
void Alpha_on_alpha_destroy(gpointer lsp);
]]

class Alpha [[ClutterAlpha*]]
{
    Alpha(table props = 0)
	[[
	    *self=clutter_alpha_new();
	    g_object_ref_sink(G_OBJECT(*self));
    	    set_props_from_table(L,props);
	]];

    
    ~Alpha()
	[[
	    g_object_unref(G_OBJECT(self));
	]];
	
    udata timeline
	[[
	    ClutterTimeline * timeline=clutter_alpha_get_timeline(self);
	    if(wrap_Timeline(L,timeline))
		g_object_ref(G_OBJECT(timeline));
	]]
	[[
	    luaL_checkudata(L,-1,TIMELINE_METATABLE);
	    void * udata=lua_touserdata(L,-1);
	    if (udata)
	    {
		GObject * timeline=*((GObject**)udata);
		
		if (timeline && CLUTTER_IS_TIMELINE(timeline))
		    clutter_alpha_set_timeline(self,CLUTTER_TIMELINE(timeline));
	    }
	]];
	
    string mode
	[[
	    GEnumClass * ec = G_ENUM_CLASS(g_type_class_ref(CLUTTER_TYPE_ANIMATION_MODE));
	    GEnumValue * v  = g_enum_get_value(ec,clutter_alpha_get_mode(self));
	    mode = (v?&(v->value_name[8]):"");
	    g_type_class_unref(ec);	    
	]]
	[[
	    GEnumClass * ec = G_ENUM_CLASS(g_type_class_ref(CLUTTER_TYPE_ANIMATION_MODE));
	    std::string cm("CLUTTER_");
	    cm+= mode;
	    
	    GEnumValue * v = g_enum_get_value_by_name(ec,cm.c_str());
	    
	    if(!v)
		luaL_error(L,"Invalid alpha mode '%s'",mode);
		
		
	    clutter_alpha_set_mode(self,v->value);
	    g_type_class_unref(ec);
	]];
	
    readonly double alpha
	[[alpha=clutter_alpha_get_alpha(self);]];
	
    callback on_alpha
	[[
	    clutter_alpha_set_func(self,NULL,NULL,NULL);
	    if (on_alpha)
	    {
		clutter_alpha_set_func(
		    self,
		    Alpha_on_alpha,
		    App::get(L)->ref_lua_state_proxy(),
		    Alpha_on_alpha_destroy);
	    }
	]];	    
}

[[

void Alpha_on_alpha_destroy(gpointer lsp)
{
    ((LuaStateProxy*)lsp)->unref();
}

gdouble Alpha_on_alpha(ClutterAlpha*self,gpointer lsp)
{
    lua_State * L=((LuaStateProxy*)lsp)->get_lua_state();
    
    if (!L)
    {
	return 0;
    }
    
    lua_pushnumber(L,clutter_timeline_get_progress(clutter_alpha_get_timeline(self)));
    
    invoke_Alpha_on_alpha(L,self,1,1);
    
    gdouble result(lua_tonumber(L,-1));
    lua_pop(L,1);
    
    return result;    
}
]]

[[
struct interval
{
    interval(double aa , double bb) : a(aa),b(bb) {}
    double a;
    double b;
};
]]

class Interval [[interval*]]
{
    Interval( double from , double to )
	[[
	    *self = new interval(from,to);
	]];
    
    ~Interval()
	[[
	    delete self;
	]];
	
    double get_value(double factor)
	[[
	    result=(factor*(self->b-self->a))+self->a;
	]];
	
    double from
	[[from=self->a;]]
	[[self->a=from;]];
	
    double to
	[[to=self->b;]]
	[[self->b=to;]];
    
}

[[
cairo_t * get_canvas_cairo_t(ClutterActor * canvas)
{
    return (cairo_t*) g_object_get_data(G_OBJECT(canvas),"tp-cairot");
}

cairo_t * check_canvas_cairo_t(lua_State * L,ClutterActor * canvas)
{
    cairo_t * result=(cairo_t*) g_object_get_data(G_OBJECT(canvas),"tp-cairot");
    if(!result)
	luaL_error(L,"You must call begin_painting first");
    return result;
}

void destroy_cairo_t(gpointer t)
{
    cairo_destroy((cairo_t*)t);    
}

]]

class Canvas [[ClutterActor*]] actor
{
    Canvas(table props=0)
	[[
            *self = clutter_cairo_texture_new(0,0);
	    initialize_actor(L,*self,CANVAS_METATABLE);
	    set_props_from_table(L,props);
	    g_object_ref_sink(G_OBJECT(*self));
	]];
	
    ~Canvas()
	[[
	    g_object_unref(G_OBJECT(self));    
	]];
	
    double w
        [[ w = clutter_actor_get_width( self ); ]]
        [[
	    clutter_actor_set_width( self , w );
	    guint sw;
	    guint sh;
	    clutter_cairo_texture_get_surface_size(CLUTTER_CAIRO_TEXTURE(self),&sw,&sh);
	    sw=w;
	    clutter_cairo_texture_set_surface_size(CLUTTER_CAIRO_TEXTURE(self),sw,sh);
	]];
    
    double h
        [[ h = clutter_actor_get_height( self ); ]]
        [[
	    clutter_actor_set_height( self , h );
	    guint sw;
	    guint sh;
	    clutter_cairo_texture_get_surface_size(CLUTTER_CAIRO_TEXTURE(self),&sw,&sh);
	    sh=h;
	    clutter_cairo_texture_set_surface_size(CLUTTER_CAIRO_TEXTURE(self),sw,sh);
	]];

    double width
        [[ width = clutter_actor_get_width( self ); ]]
        [[ set_Canvas_w(L);]];
    
    double height
        [[ height = clutter_actor_get_height( self ); ]]
        [[ set_Canvas_h(L);]];
	
    table size
        [[
            lua_newtable(L);
            lua_pushnumber(L,clutter_actor_get_width(self));
            lua_rawseti(L,-2,1);
            lua_pushnumber(L,clutter_actor_get_height(self));
            lua_rawseti(L,-2,2);
        ]]
        [[
            luaL_checktype(L,2,LUA_TTABLE);
            lua_rawgeti(L,2,1);
            lua_rawgeti(L,2,2);
            clutter_actor_set_size(self,lua_tonumber(L,-2),lua_tonumber(L,-1));
	    clutter_cairo_texture_set_surface_size(CLUTTER_CAIRO_TEXTURE(self),lua_tonumber(L,-2),lua_tonumber(L,-1));
            lua_pop(L,2);
        ]];
	
    bool begin_painting(table region=0)
	[[
	    if (get_canvas_cairo_t(self))
	    {
		result=false;
	    }
	    else
	    {
		cairo_t * t=NULL;
		
		if (region)
		{
		    lua_rawgeti(L,region,1);
		    lua_rawgeti(L,region,2);
		    lua_rawgeti(L,region,3);
		    lua_rawgeti(L,region,4);
		    
		    t=clutter_cairo_texture_create_region(CLUTTER_CAIRO_TEXTURE(self),
			lua_tonumber(L,-4),lua_tonumber(L,-3),lua_tonumber(L,-2),lua_tonumber(L,-1));
		    lua_pop(L,4);
		}
		else
		{
		    t=clutter_cairo_texture_create(CLUTTER_CAIRO_TEXTURE(self));
		}
		
		if (!t)
		{
		    result=false;
		}
		else
		{
		    g_object_set_data_full(G_OBJECT(self),"tp-cairot",t,destroy_cairo_t);
		    result=true;
		}
	    }
	]];
	
    bool finish_painting()
	[[
	    result=get_canvas_cairo_t(self)?true:false;
	    
	    if(result)
	    {
		// This should NULL it and call cairo_destroy on it
		
		g_object_set_data(G_OBJECT(self),"tp-cairot",NULL);
	    }	    
	]];
	
    clear_surface()
	[[
	    clutter_cairo_texture_clear(CLUTTER_CAIRO_TEXTURE(self));
	]];
	
    save()
	[[
	    cairo_t * cr=check_canvas_cairo_t(L,self);
	    cairo_save(cr);    
	]];
	
    restore()
	[[
	    cairo_t * cr=check_canvas_cairo_t(L,self);
	    cairo_restore(cr);    	    
	]];
	
    # TODO: Really a color argument
    set_source_color()
	[[
	    cairo_t * cr=check_canvas_cairo_t(L,self);
		
	    ClutterColor c;
	    to_clutter_color(L,2,&c);
	    cairo_set_source_rgba(cr,c.red/255.0,c.green/255.0,c.blue/255.0,c.alpha/255.0);
	]];
	
    fill(bool preserve=false)
	[[
	    cairo_t * cr=check_canvas_cairo_t(L,self);
	    if(preserve)
		cairo_fill_preserve(cr);
	    else
		cairo_fill(cr);
	]];
	
    paint(int alpha=255)
	[[
	    cairo_t * cr=check_canvas_cairo_t(L,self);
	    if (alpha==255)
		cairo_paint(cr);
	    else
		cairo_paint_with_alpha(cr,alpha/255.0);
	]];
	
    stroke(bool preserve=false)
	[[
	    cairo_t * cr=check_canvas_cairo_t(L,self);
	    if(preserve)
		cairo_stroke_preserve(cr);	    
	    else
		cairo_stroke(cr);
	]];
	
    new_path()
	[[
	    cairo_t * cr=check_canvas_cairo_t(L,self);
	    cairo_new_path(cr); 
	]];

    close_path()
	[[
	    cairo_t * cr=check_canvas_cairo_t(L,self);
	    cairo_close_path(cr); 
	]];
	
    arc(double xc,double yc,double radius,double angle1,double angle2)
	[[
	    cairo_t * cr=check_canvas_cairo_t(L,self);
	    cairo_arc(cr,xc,yc,radius,angle1,angle2);
	]];
	
    arc_negative(double xc,double yc,double radius,double angle1,double angle2)
	[[
	    cairo_t * cr=check_canvas_cairo_t(L,self);
	    cairo_arc_negative(cr,xc,yc,radius,angle1,angle2);
	]];
    
    curve_to(double x1,double y1,double x2,double y2,double x3,double y3,bool relative=false)
	[[
	    cairo_t * cr=check_canvas_cairo_t(L,self);
	    if (relative)
		cairo_rel_curve_to(cr,x1,y1,x2,y2,x3,y3); 
	    else
		cairo_curve_to(cr,x1,y1,x2,y2,x3,y3); 
	]];
	
    line_to(double x,double y,bool relative=false)
	[[
	    cairo_t * cr=check_canvas_cairo_t(L,self);
	    if (relative)
		cairo_rel_line_to(cr,x,y);
	    else
		cairo_line_to(cr,x,y);
	]];
	
    move_to(double x,double y,bool relative=false)
	[[
	    cairo_t * cr=check_canvas_cairo_t(L,self);
	    if (relative)
		cairo_rel_move_to(cr,x,y);
	    else
		cairo_move_to(cr,x,y);
	]];
    
    rectangle(double x,double y,double width,double height)
	[[
	    cairo_t * cr=check_canvas_cairo_t(L,self);
	    cairo_rectangle(cr,x,y,width,height);
	]];
	
    round_rectangle(double x,double y,double w,double h,double r)
	[[
	    cairo_t * cr=check_canvas_cairo_t(L,self);
	
	    cairo_move_to(cr,x+r,y);
	    cairo_line_to(cr,x+w-r,y);
	    cairo_curve_to(cr,x+w,y,x+w,y,x+w,y+r);
	    cairo_line_to(cr,x+w,y+h-r);
	    cairo_curve_to(cr,x+w,y+h,x+w,y+h,x+w-r,y+h);
	    cairo_line_to(cr,x+r,y+h);
	    cairo_curve_to(cr,x,y+h,x,y+h,x,y+h-r);
	    cairo_line_to(cr,x,y+r);     
	    cairo_curve_to(cr,x,y,x,y,x+r,y);
	]];	
	
    set_source_linear_pattern(double x1,double y1,double x2,double y2)
	[[
	    cairo_t * cr=check_canvas_cairo_t(L,self);
	    cairo_pattern_t *p=cairo_pattern_create_linear(x1,y1,x2,y2);
	    cairo_set_source(cr,p);
	    cairo_pattern_destroy(p);
	]];
	
    set_source_radial_pattern(double cx0,double cy0,double radius0,double cx1,double cy1,double radius1)
	[[
	    cairo_t * cr=check_canvas_cairo_t(L,self);
	    cairo_pattern_t *p=cairo_pattern_create_radial(cx0,cy0,radius0,cx1,cy1,radius1);
	    cairo_set_source(cr,p);
	    cairo_pattern_destroy(p);
	]];
	
    # TODO: second parameter is a color
    
    add_source_pattern_color_stop(double offset)
	[[
	    cairo_t * cr=check_canvas_cairo_t(L,self);
	    cairo_pattern_t *p=cairo_get_source(cr);
	    if (p)
	    {
		ClutterColor c;
		to_clutter_color(L,3,&c);
		cairo_pattern_add_color_stop_rgba(p,offset,c.red/255.0,c.green/255.0,c.blue/255.0,c.alpha/255.0);
	    }
	]];
	
    set_line_width(double width)
	[[
	    cairo_t * cr=check_canvas_cairo_t(L,self);
	    cairo_set_line_width(cr,width);	    
	]];
}


[[

const char * get_actor_metatable(ClutterActor*actor)
{
    if (!actor)
	return NULL;
    
    return (const char *)g_object_get_data(G_OBJECT(actor),"tp-metatable");
}

void wrap_concrete_actor(lua_State*L,ClutterActor*actor)
{
    const char * metatable=get_actor_metatable(actor);
    
    if (!metatable)
    {
	lua_pushnil(L);
	return;
    }
    
    int is_new=lb_wrap(L,actor,metatable);
    	
    if (is_new)
	g_object_ref(G_OBJECT(actor));
}

]]

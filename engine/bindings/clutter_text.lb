module clutter_text;

[[
#include "clutter/clutter.h"

#include "util.h"
#include "clutter_util.h"
]]

[[
void Text_on_text_changed(ClutterText*text,lua_State*L);
]]

/*
    Class: Text
    
    Text is a <UIElement> that lets you display text. 
*/

class Text [[ClutterActor*]] actor
{
    Text(table props =0)
        [[
            self = lb_construct_gobject( ClutterActor , ClutterUtil::make_actor( clutter_text_new ) );
		    ClutterUtil::initialize_actor(L,self,TEXT_METATABLE);
		    ClutterUtil::set_props_from_table(L,props);
		    g_object_unref( self );
        ]];
	
    ~Text()
		[[
        ]];
    
    /*
    	Property: color
    	
    	The color of the text. See <Rectangle.color> for details.
    */
    
    table color
        [[
            ClutterColor color;
            clutter_text_get_color(CLUTTER_TEXT(self),&color);
            ClutterUtil::push_clutter_color(L,&color);
        ]]
        [[
            ClutterColor color;
            ClutterUtil::to_clutter_color(L,2,&color);
            clutter_text_set_color(CLUTTER_TEXT(self),&color);
        ]];
    
    /*
    	Property: text
    	
    	The string that the text displays.
    */
        
    string text
        [[text=clutter_text_get_text(CLUTTER_TEXT(self));]]
        [[clutter_text_set_text(CLUTTER_TEXT(self),text);]];
        
    /*
    	Property: markup
    	
    	Text can contain simple HTML-like markup. Setting this
    	property sets <use_markup> to true and then sets <text>.
    	
    	For more details on the markup, see <http://library.gnome.org/devel/pango/stable/PangoMarkupFormat.html>.
    */
    
    string markup
        [[
            // markup doesn't have a getter
            markup=clutter_text_get_text(CLUTTER_TEXT(self));
        ]]
        [[clutter_text_set_markup(CLUTTER_TEXT(self),markup);]];
        
    /*
    	Property: font
    	
    	The font used to render the text. This string can contain a
    	family list, style options and the size of the text.
    	
    	For more details, see <http://library.gnome.org/devel/pango/stable/pango-Fonts.html#pango-font-description-from-string>.
    	
    	(code)
    		local t = Text{ font = "Sans 38px", color = "FFFFFF", text = "Hello World!" }
    	(end)
    */
    
    string font
        [[font=clutter_text_get_font_name(CLUTTER_TEXT(self));]]
        [[clutter_text_set_font_name(CLUTTER_TEXT(self),font);]];
        
    /*
    	Property: justify
    	
    	This is a boolean property that justifies the text on both margins.
    */
    
    bool justify
        [[justify=clutter_text_get_justify(CLUTTER_TEXT(self));]]
        [[clutter_text_set_justify(CLUTTER_TEXT(self),justify);]];
    
    /*
    	Property: wrap
    	
    	Whether text should be wrapped into multiple lines.
    */    
    
    bool wrap
        [[wrap=clutter_text_get_line_wrap(CLUTTER_TEXT(self));]]
        [[clutter_text_set_line_wrap(CLUTTER_TEXT(self),wrap);]];
    
    /*
    	Property: wrap_mode

	How the line wrapping is performed. 
        The default is WORD which means wrap on word boundaries.

	     Possible Values:
		
		WORD	  - wrap lines at word boundaries
		CHAR	  - wrap lines at character boundaries 
		WORD_CHAR - wrap lines at word boundaries, but fall back to character 
			   boundaries if there is not enough space for a full word. 
    */    

    string wrap_mode
	[[
                    switch(clutter_text_get_line_wrap_mode(CLUTTER_TEXT(self)))
                    {
                        case PANGO_WRAP_WORD:
                            wrap_mode="WORD";
                            break;
                        case PANGO_WRAP_CHAR:
                            wrap_mode="CHAR";
                            break;
                        default:
                            wrap_mode="WORD_CHAR";
                    }
        ]]
        [[
                    PangoWrapMode wm=PANGO_WRAP_WORD;
                    if(!strcmp(wrap_mode,"WORD"))
                        wm=PANGO_WRAP_WORD;
                    else if(!strcmp(wrap_mode,"CHAR"))
                        wm=PANGO_WRAP_CHAR;
                    else if(!strcmp(wrap_mode,"WORD_CHAR"))
                        wm=PANGO_WRAP_WORD_CHAR;
                    else
                        luaL_error(L,"Invalid wrap_mode '%s'",wrap_mode);
                    clutter_text_set_line_wrap_mode(CLUTTER_TEXT(self),wm);
        ]];


    /*
    	Property: use_markup
    	
    	Whether to interpret the text's string as markup or not.
    */    
    
    bool use_markup
        [[use_markup=clutter_text_get_use_markup(CLUTTER_TEXT(self));]]
        [[clutter_text_set_use_markup(CLUTTER_TEXT(self),use_markup);]];
	
	/*
		Property: ellipsize
		
		When the text is clipped, you can have TrickPlay automatically
		add ellipsis to it.
		
		Possible Values:
		
			START - The ellipsis will be at the beginning of the string.
			MIDDLE - Ellipsis in the middle of the string.
			END - Ellipsis at the end of the string.
			NONE - No ellipsis (this is the default).
	*/
	
    string ellipsize
		[[
		    switch(clutter_text_get_ellipsize(CLUTTER_TEXT(self)))
		    {
			case PANGO_ELLIPSIZE_START:
			    ellipsize="START";
			    break;
			case PANGO_ELLIPSIZE_MIDDLE:
			    ellipsize="MIDDLE";
			    break;
			case PANGO_ELLIPSIZE_END:
			    ellipsize="END";
			    break;
			default:
			    ellipsize="NONE";
		    }
		]]
		[[
		    PangoEllipsizeMode mode = PANGO_ELLIPSIZE_NONE;
		    if(!strcmp(ellipsize,"START"))
			mode = PANGO_ELLIPSIZE_START;
		    else if(!strcmp(ellipsize,"MIDDLE"))
			mode = PANGO_ELLIPSIZE_MIDDLE;
		    else if(!strcmp(ellipsize,"END"))
			mode = PANGO_ELLIPSIZE_END;
		    else if(!strcmp(ellipsize,"NONE"))
			mode = PANGO_ELLIPSIZE_NONE;
		    else
			luaL_error(L,"Invalid ellipsize '%s'",ellipsize);
		    clutter_text_set_ellipsize(CLUTTER_TEXT(self),mode);	
		]];

	/*
		Property: alignment
		
		How lines of a wrapped text element align respective to each other.
		
		Possible Values:
		
			LEFT - Left aligned.
			CENTER - Center aligned.
			RIGHT - Right aligned.
	*/	
	
    string alignment
		[[
		    switch(clutter_text_get_line_alignment(CLUTTER_TEXT(self)))
		    {
			case PANGO_ALIGN_CENTER:
			    alignment="CENTER";
			    break;
			case PANGO_ALIGN_RIGHT:
			    alignment="RIGHT";
			    break;
			default:
			    alignment="LEFT";
		    }	    
		]]
		[[
		    PangoAlignment a=PANGO_ALIGN_LEFT;
		    if(!strcmp(alignment,"LEFT"))
			a=PANGO_ALIGN_LEFT;
		    else if(!strcmp(alignment,"CENTER"))
			a=PANGO_ALIGN_CENTER;
		    else if(!strcmp(alignment,"RIGHT"))
			a=PANGO_ALIGN_RIGHT;
		    else
			luaL_error(L,"Invalid alignment '%s'",alignment);
		    clutter_text_set_line_alignment(CLUTTER_TEXT(self),a);
		]];

	/*
		Property: max_length
		
		The maximum number of characters allowed in this text element. Set to 
		0 to allow any number of characters.
	*/	
	
    int max_length
		[[max_length=clutter_text_get_max_length(CLUTTER_TEXT(self));]]
		[[clutter_text_set_max_length(CLUTTER_TEXT(self),max_length);]];

	/*
		Property: selected_text
		
		Returns the text that is currently selected.
	*/
		
    readonly string selected_text
		[[
		    gchar * s = clutter_text_get_selection(CLUTTER_TEXT(self));
		    selected_text = s;	    
		    FreeLater free_later(s);	    
		]];

	/*
		Property: selection_end
		
		Get or set the end of the selection in characters.
	*/
	
    int selection_end
		[[selection_end=clutter_text_get_selection_bound(CLUTTER_TEXT(self));]]
		[[clutter_text_set_selection_bound(CLUTTER_TEXT(self),selection_end);]];

	/*
		Property: single_line
		
		Whether the text should remain as a single line and be clipped to its width.
	*/
    bool single_line
		[[single_line=clutter_text_get_single_line_mode(CLUTTER_TEXT(self));]]
		[[clutter_text_set_single_line_mode(CLUTTER_TEXT(self),single_line);]];
	

	/*
		Property: editable
		
		Whether the Text element is editable or not.
	*/
	
    bool editable
		[[editable=clutter_text_get_editable(CLUTTER_TEXT(self));]]
		[[clutter_text_set_editable(CLUTTER_TEXT(self),editable);]];

	/*
		Property: cursor_color
		
		The color of the cursor when text is editable.
	*/

    table cursor_color
		[[
		    ClutterColor color;
		    clutter_text_get_cursor_color(CLUTTER_TEXT(self),&color);
		    ClutterUtil::push_clutter_color(L,&color);
		]]
		[[
		    ClutterColor color;
		    ClutterUtil::to_clutter_color(L,2,&color);
		    clutter_text_set_cursor_color(CLUTTER_TEXT(self),&color);
		]];

	/*
		Property : selection_color
		
		The color of selected text.
	*/	
    
    table selection_color
		[[
		    ClutterColor color;
		    clutter_text_get_selection_color(CLUTTER_TEXT(self),&color);
		    ClutterUtil::push_clutter_color(L,&color);
		]]
		[[
		    ClutterColor color;
		    ClutterUtil::to_clutter_color(L,2,&color);
		    clutter_text_set_selection_color(CLUTTER_TEXT(self),&color);
		]];

	/*
		Property: cursor_position
		
		Get or set the position of the cursor in characters.
	*/	
    
    int cursor_position
		[[cursor_position=clutter_text_get_cursor_position(CLUTTER_TEXT(self));]]
		[[clutter_text_set_cursor_position(CLUTTER_TEXT(self),cursor_position);]];

	/*
		Property: cursor_visible
		
		Whether the cursor is visible.
	*/
		
    bool cursor_visible
		[[cursor_visible=clutter_text_get_cursor_visible(CLUTTER_TEXT(self));]]
		[[clutter_text_set_cursor_visible(CLUTTER_TEXT(self),cursor_visible);]];

	/*
		Property: cursor_size
		
		The size of the cursor in pixels, or -1 to use the default size.
	*/    
    
    int cursor_size
		[[cursor_size=clutter_text_get_cursor_size(CLUTTER_TEXT(self));]]
		[[clutter_text_set_cursor_size(CLUTTER_TEXT(self),cursor_size);]];
	
	/*
		Property: wants_enter
		
                Whether the user needs to first press Enter to activate text box editing.
		See http://docs.clutter-project.org/docs/clutter/stable/ClutterText.html#ClutterText--activatable
	*/
	
    bool wants_enter
		[[wants_enter=!clutter_text_get_activatable(CLUTTER_TEXT(self));]]
		[[clutter_text_set_activatable(CLUTTER_TEXT(self),!wants_enter);]];
	
	/*
		Property: password_char
		
		A replacement character to show instead of the text's string.
	*/

    int password_char
		[[password_char=clutter_text_get_password_char(CLUTTER_TEXT(self));]]
		[[clutter_text_set_password_char(CLUTTER_TEXT(self),password_char);]];
	

    /*
        Property: baseline

        Returns the Y position of the baseline of the first line.
    */

    readonly int baseline
        [[
            if ( PangoLayout * p = clutter_text_get_layout( CLUTTER_TEXT( self ) ) )
            {
                baseline = pango_layout_get_baseline( p ) / PANGO_SCALE;
            }
            else
            {
                baseline = 0;
            }
        ]];

    /*
        Property: line_spacing

        Space (in pixels) between lines.
    */

    int line_spacing
        [[
            if ( PangoLayout * p = clutter_text_get_layout( CLUTTER_TEXT( self ) ) )
            {
                line_spacing = pango_layout_get_spacing( p ) / PANGO_SCALE;
            }
            else
            {
                line_spacing = 0;
            }
        ]]
        [[
            if ( PangoLayout * p = clutter_text_get_layout( CLUTTER_TEXT( self ) ) )
            {
                pango_layout_set_spacing( p , line_spacing * PANGO_SCALE );
                clutter_actor_queue_redraw( self );
            }
        ]];

    set_selection( int start_pos , int end_pos )
	[[clutter_text_set_selection(CLUTTER_TEXT(self),start_pos,end_pos);]];
	    
	
    insert_text( int pos , string text )
	[[clutter_text_insert_text(CLUTTER_TEXT(self),text,pos);]];
	
    delete_chars( int count )
	[[clutter_text_delete_chars(CLUTTER_TEXT(self),count);]];
	
    delete_text( int start_pos , int end_pos )
	[[clutter_text_delete_text(CLUTTER_TEXT(self),start_pos,end_pos);]];
	
    bool delete_selection()
	[[result=clutter_text_delete_selection(CLUTTER_TEXT(self));]];
	
    string get_chars( int start_pos , int end_pos )
	[[
	    gchar * c=clutter_text_get_chars(CLUTTER_TEXT(self),start_pos,end_pos);
	    result = c;
	    FreeLater free_later(c);
	]];

	/*
		Event: on_text_changed
		
		Called every time the text changes.
		
		Arguments:
		
			text - The Text element this event applies to.
	*/	
	
    callback on_text_changed
		[[
		    UserData::get(L)->connect_signal_if(
				on_text_changed,
				"on_text_changed",
				"text-changed",
				G_CALLBACK(Text_on_text_changed),
				L);	    
		]];

}

[[
void Text_on_text_changed(ClutterText*text,lua_State*L)
{
	UserData::invoke_callback( G_OBJECT( text ) , "on_text_changed" , 0 , 0 , L );
}
]]


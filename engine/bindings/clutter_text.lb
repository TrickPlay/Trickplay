module clutter_text;

[[
#include "clutter/clutter.h"

#include "util.h"
#include "signal_collector.h"
#include "clutter_util.h"
]]

[[
void Text_on_text_changed(ClutterText*text,lua_State*L);
]]

/*
    Class: Text
    
    Text is a <UIElement> that lets you display text. 
*/

class Text [[ClutterActor*]] actor
{
    Text(table props =0)
        [[
            *self = clutter_text_new();
		    ClutterUtil::initialize_actor(L,*self,TEXT_METATABLE);
		    ClutterUtil::set_props_from_table(L,props);
		    g_object_ref_sink(G_OBJECT(*self));
        ]];
	
    ~Text()
		[[
            g_object_unref(G_OBJECT(self));
        ]];
    
    /*
    	Property: color
    	
    	The color of the text. See <Rectangle.color> for details.
    */
    
    table color
        [[
            ClutterColor color;
            clutter_text_get_color(CLUTTER_TEXT(self),&color);
            ClutterUtil::push_clutter_color(L,&color);
        ]]
        [[
            ClutterColor color;
            ClutterUtil::to_clutter_color(L,2,&color);
            clutter_text_set_color(CLUTTER_TEXT(self),&color);
        ]];
    
    /*
    	Property: text
    	
    	The string that the text displays.
    */
        
    string text
        [[text=clutter_text_get_text(CLUTTER_TEXT(self));]]
        [[clutter_text_set_text(CLUTTER_TEXT(self),text);]];
        
    /*
    	Property: markup
    	
    	Text can contain simple HTML-like markup. Setting this
    	property sets <use_markup> to true and then sets <text>.
    	
    	For more details on the markup, see <http://library.gnome.org/devel/pango/stable/PangoMarkupFormat.html>.
    */
    
    string markup
        [[
            // markup doesn't have a getter
            markup=clutter_text_get_text(CLUTTER_TEXT(self));
        ]]
        [[clutter_text_set_markup(CLUTTER_TEXT(self),markup);]];
        
    /*
    	Property: font
    	
    	The font used to render the text. This string can contain a
    	family list, style options and the size of the text.
    	
    	For more details, see <http://library.gnome.org/devel/pango/stable/pango-Fonts.html#pango-font-description-from-string>.
    	
    	(code)
    		local t = Text{ font = "Sans 38px", color = "FFFFFF", text = "Hello World!" }
    	(end)
    */
    
    string font
        [[font=clutter_text_get_font_name(CLUTTER_TEXT(self));]]
        [[clutter_text_set_font_name(CLUTTER_TEXT(self),font);]];
        
    /*
    	Property: justify
    	
    	This is a boolean property that justifies the text on both margins.
    */
    
    bool justify
        [[justify=clutter_text_get_justify(CLUTTER_TEXT(self));]]
        [[clutter_text_set_justify(CLUTTER_TEXT(self),justify);]];
    
    /*
    	Property: wrap
    	
    	Whether text should be wrapped into multiple lines.
    */    
    
    bool wrap
        [[wrap=clutter_text_get_line_wrap(CLUTTER_TEXT(self));]]
        [[clutter_text_set_line_wrap(CLUTTER_TEXT(self),wrap);]];
    
    /*
    	Property: use_markup
    	
    	Whether to interpret the text's string as markup or not.
    */    
    
    bool use_markup
        [[use_markup=clutter_text_get_use_markup(CLUTTER_TEXT(self));]]
        [[clutter_text_set_use_markup(CLUTTER_TEXT(self),use_markup);]];
	
	/*
		Property: ellipsize
		
		When the text is clipped, you can have TrickPlay automatically
		add ellipsis to it.
		
		Possible Values:
		
			START - The ellipsis will be at the beginning of the string.
			MIDDLE - Ellipsis in the middle of the string.
			END - Ellipsis at the end of the string.
			NONE - No ellipsis (this is the default).
	*/
	
    string ellipsize
		[[
		    switch(clutter_text_get_ellipsize(CLUTTER_TEXT(self)))
		    {
			case PANGO_ELLIPSIZE_START:
			    ellipsize="START";
			    break;
			case PANGO_ELLIPSIZE_MIDDLE:
			    ellipsize="MIDDLE";
			    break;
			case PANGO_ELLIPSIZE_END:
			    ellipsize="END";
			    break;
			default:
			    ellipsize="NONE";
		    }
		]]
		[[
		    PangoEllipsizeMode mode = PANGO_ELLIPSIZE_NONE;
		    if(!strcmp(ellipsize,"START"))
			mode = PANGO_ELLIPSIZE_START;
		    else if(!strcmp(ellipsize,"MIDDLE"))
			mode = PANGO_ELLIPSIZE_MIDDLE;
		    else if(!strcmp(ellipsize,"END"))
			mode = PANGO_ELLIPSIZE_END;
		    else if(!strcmp(ellipsize,"NONE"))
			mode = PANGO_ELLIPSIZE_NONE;
		    else
			luaL_error(L,"Invalid ellipsize '%s'",ellipsize);
		    clutter_text_set_ellipsize(CLUTTER_TEXT(self),mode);	
		]];

	/*
		Property: alignment
		
		How lines of a wrapped text element align respective to each other.
		
		Possible Values:
		
			LEFT - Left aligned.
			CENTER - Center aligned.
			RIGHT - Right aligned.
	*/	
	
    string alignment
		[[
		    switch(clutter_text_get_line_alignment(CLUTTER_TEXT(self)))
		    {
			case PANGO_ALIGN_CENTER:
			    alignment="CENTER";
			    break;
			case PANGO_ALIGN_RIGHT:
			    alignment="RIGHT";
			    break;
			default:
			    alignment="LEFT";
		    }	    
		]]
		[[
		    PangoAlignment a=PANGO_ALIGN_LEFT;
		    if(!strcmp(alignment,"LEFT"))
			a=PANGO_ALIGN_LEFT;
		    else if(!strcmp(alignment,"CENTER"))
			a=PANGO_ALIGN_CENTER;
		    else if(!strcmp(alignment,"RIGHT"))
			a=PANGO_ALIGN_RIGHT;
		    else
			luaL_error(L,"Invalid alignment '%s'",alignment);
		    clutter_text_set_line_alignment(CLUTTER_TEXT(self),a);
		]];

	/*
		Property: max_length
		
		The maximum number of characters allowed in this text element. Set to 
		0 to allow any number of characters.
	*/	
	
    int max_length
		[[max_length=clutter_text_get_max_length(CLUTTER_TEXT(self));]]
		[[clutter_text_set_max_length(CLUTTER_TEXT(self),max_length);]];

	/*
		Property: selected_text
		
		Returns the text that is currently selected.
	*/
		
    readonly string selected_text
		[[
		    gchar * s = clutter_text_get_selection(CLUTTER_TEXT(self));
		    selected_text = s;	    
		    FreeLater free_later(s);	    
		]];

	/*
		Property: selection_end
		
		Get or set the end of the selection in characters.
	*/
	
    int selection_end
		[[selection_end=clutter_text_get_selection_bound(CLUTTER_TEXT(self));]]
		[[clutter_text_set_selection_bound(CLUTTER_TEXT(self),selection_end);]];

	/*
		Property: single_line
		
		Whether the text should remain as a single line and be clipped to its width.
	*/
    bool single_line
		[[single_line=clutter_text_get_single_line_mode(CLUTTER_TEXT(self));]]
		[[clutter_text_set_single_line_mode(CLUTTER_TEXT(self),single_line);]];
	

	/*
		Property: editable
		
		Whether the Text element is editable or not.
	*/
	
    bool editable
		[[editable=clutter_text_get_editable(CLUTTER_TEXT(self));]]
		[[clutter_text_set_editable(CLUTTER_TEXT(self),editable);]];

	/*
		Property: cursor_color
		
		The color of the cursor when text is editable.
	*/

    table cursor_color
		[[
		    ClutterColor color;
		    clutter_text_get_cursor_color(CLUTTER_TEXT(self),&color);
		    ClutterUtil::push_clutter_color(L,&color);
		]]
		[[
		    ClutterColor color;
		    ClutterUtil::to_clutter_color(L,2,&color);
		    clutter_text_set_cursor_color(CLUTTER_TEXT(self),&color);
		]];

	/*
		Property : selection_color
		
		The color of selected text.
	*/	
    
    table selection_color
		[[
		    ClutterColor color;
		    clutter_text_get_selection_color(CLUTTER_TEXT(self),&color);
		    ClutterUtil::push_clutter_color(L,&color);
		]]
		[[
		    ClutterColor color;
		    ClutterUtil::to_clutter_color(L,2,&color);
		    clutter_text_set_selection_color(CLUTTER_TEXT(self),&color);
		]];

	/*
		Property: cursor_position
		
		Get or set the position of the cursor in characters.
	*/	
    
    int cursor_position
		[[cursor_position=clutter_text_get_cursor_position(CLUTTER_TEXT(self));]]
		[[clutter_text_set_cursor_position(CLUTTER_TEXT(self),cursor_position);]];

	/*
		Property: cursor_visible
		
		Whether the cursor is visible.
	*/
		
    bool cursor_visible
		[[cursor_visible=clutter_text_get_cursor_visible(CLUTTER_TEXT(self));]]
		[[clutter_text_set_cursor_visible(CLUTTER_TEXT(self),cursor_visible);]];

	/*
		Property: cursor_size
		
		The size of the cursor in pixels, or -1 to use the default size.
	*/    
    
    int cursor_size
		[[cursor_size=clutter_text_get_cursor_size(CLUTTER_TEXT(self));]]
		[[clutter_text_set_cursor_size(CLUTTER_TEXT(self),cursor_size);]];
	
	/*
		Property: wants_enter
		
		TODO	
	*/
	
    bool wants_enter
		[[wants_enter=!clutter_text_get_activatable(CLUTTER_TEXT(self));]]
		[[clutter_text_set_activatable(CLUTTER_TEXT(self),!wants_enter);]];
	
	/*
		Property: password_char
		
		A replacement character to show instead of the text's string.
	*/

    int password_char
		[[password_char=clutter_text_get_password_char(CLUTTER_TEXT(self));]]
		[[clutter_text_set_password_char(CLUTTER_TEXT(self),password_char);]];
	

    set_selection( int start_pos , int end_pos )
	[[clutter_text_set_selection(CLUTTER_TEXT(self),start_pos,end_pos);]];
	    
	
    insert_text( int pos , string text )
	[[clutter_text_insert_text(CLUTTER_TEXT(self),text,pos);]];
	
    delete_chars( int count )
	[[clutter_text_delete_chars(CLUTTER_TEXT(self),count);]];
	
    delete_text( int start_pos , int end_pos )
	[[clutter_text_delete_text(CLUTTER_TEXT(self),start_pos,end_pos);]];
	
    bool delete_selection()
	[[result=clutter_text_delete_selection(CLUTTER_TEXT(self));]];
	
    string get_chars( int start_pos , int end_pos )
	[[
	    gchar * c=clutter_text_get_chars(CLUTTER_TEXT(self),start_pos,end_pos);
	    result = c;
	    FreeLater free_later(c);
	]];

	/*
		Event: on_text_changed
		
		Called every time the text changes.
		
		Arguments:
		
			text - The Text element this event applies to.
	*/	
	
    callback on_text_changed
		[[
		    SignalCollector::get(L)->connect_if(
			on_text_changed,"on_text_changed",
			self,"text-changed",G_CALLBACK(Text_on_text_changed),L);	    
		]];
}

[[
void Text_on_text_changed(ClutterText*text,lua_State*L)
{
    invoke_Text_on_text_changed(L,CLUTTER_ACTOR(text),0,0);
}
]]


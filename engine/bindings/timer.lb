module timer;

[[
#include "glib.h"

/*
    You can create a timer in two ways:
    
	Timer( interval , callback )
	Timer{ interval = interval , callback = callback }
	
    If the callback is provided during the constructor, the
    timer will start ticking immediately, otherwise, you
    have to set the callback later and call "start".
    
    If you change the interval to <= 0, remove the callback, call stop
    or return false from the callback, the timer will stop ticking.
*/

class timer
{
public:
    
    timer(lua_State * l );
    ~timer();
    static gboolean timer_fired( gpointer data );
    void start();
    void stop();
    void set_interval(lua_Number new_interval);
    lua_Number get_interval() const;
    void cancel();

private:
    
    lua_State * L;
    GSource *   source;
    lua_Number  interval;
};

]]

# Class: Timer
# Quite simply; a timer. You can create a timer and set a callback that will run
# every time it fires.

class Timer [[timer*]]
{
    # Constructor: Timer
    # Creates a new Timer object. There are several ways to create a timer.
    # You can pass no parameters and have an empty timer. You can also pass
    # an interval and a callback. And, finally you can pass a table that sets
    # properties individually. As long as the interval and the callback are set
    # when the timer is created, it will start right away.
    #
    # Arguments:
    # interval - In seconds, how long until the timer fires. Note that this is
    # a double, so you can specify fractions of seconds: for example, 0.5 is half
    # a second.
    # on_timer - A function that will be called when the timer fires.
    #
    # Examples:
    # This one creates a timer that won't start right away (until we call <start>)
    # > timer=Timer()
    # > timer.interval=5
    # > function timer.on_timer(timer)
    # >   print("TICK")
    # > end
    # > timer:start()
    #
    # This one won't start either, because there is no callback
    # > timer=Timer(5)
    #
    # This one will start right away and will call 'some_function' in about 5
    # seconds
    # > timer=Timer(5,some_function)
    #
    # You can also do it like this
    # > timer=Timer{ interval=5 , on_timer=some_function }
    
    
    Timer( double interval = 0 , function on_timer = 0 )
        [[
            *self = new timer(L);

            if (lua_gettop(L)==2 && lua_istable(L,-2))
            {
                lua_pushvalue(L,-2);
                lb_set_props_from_table(L);
                lua_pop(L,1);
            }
	    else
	    {
		if (interval>0)
		    (*self)->set_interval(interval);
		    
		if (on_timer)
		{
		    lua_pushvalue(L,on_timer);
		    lb_set_callback(L,*self,"on_timer");
		    lua_pop(L,1);
		}
	    }
	    
	    if (lb_callback_attached(L,*self,"on_timer",-1))
		(*self)->start();
        ]];
        
    ~Timer()
        [[
            delete self;
        ]];
	
    # Property: interval
    # The interval, in seconds, after which the timer fires. 
        
    double interval
        [[interval=self->get_interval();]]
        [[self->set_interval(interval);]];
        
    # Function: start
    # Starts the timer if it has not started already
    
    start()
        [[
	    if (lb_callback_attached(L,self,"on_timer",1))
		self->start();
	]];
	
    # Function: stop
    # Stops the timer. It won't tick again unless you start it.
    
    stop()
	[[self->stop();]];

    # Event: on_timer
    # This function gets called every time the timer fires. Timers keep firing
    # until you do one of these things: set the on_timer callback to nil,
    # call <stop> or return false from the on_timer callback.
    #
    # Arguments:
    # timer - The associated Timer
    
    callback on_timer
	[[
	    if(!on_timer)
		self->stop();
	]];        
}

[[

timer::timer(lua_State * l )
:
    L(l) ,
    source( NULL ),
    interval( 0 ) 
{
}

timer::~timer()
{
    cancel();
}

void timer::start( )
{
    if (source)
	return;
    
    if (interval<=0)
	return;
    
    source = g_timeout_source_new( interval * 1000 );
	    
    g_source_set_callback( source , timer_fired , this , NULL );
    g_source_attach( source , g_main_context_default()  );
}

void timer::stop()
{
    if (!source)
	return;
    
    g_source_destroy(source);
    g_source_unref(source);
    source=NULL;
}

void timer::set_interval(lua_Number new_interval)
{
    if (new_interval==interval)
	return;
    
    interval = new_interval;
    
    if(source)
    {
	stop();
	start();
    }
}

lua_Number timer::get_interval() const
{
    return interval;
}
        
void timer::cancel()
{
    stop();
}
      
gboolean timer::timer_fired(gpointer data)
{
    timer * self = (timer*)data;
   
    if (!invoke_Timer_on_timer(self->L,self,0,1))
    {
	self->cancel();
	return FALSE;
    }
    
    if (lua_isboolean(self->L,-1) && !lua_toboolean(self->L,-1))
    {
	self->cancel();
	lua_pop(self->L,1);
	return FALSE;
    }
    lua_pop(self->L,1);
    return TRUE;
}

]]
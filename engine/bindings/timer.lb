module timer;

[[
#include "glib.h"

/*
    You can create a timer in two ways:
    
	Timer( interval , callback )
	Timer{ interval = interval , callback = callback }
	
    If the callback is provided during the constructor, the
    timer will start ticking immediately, otherwise, you
    have to set the callback later and call "start".
    
    If you change the interval to <= 0, remove the callback, call stop
    or return false from the callback, the timer will stop ticking.

    NOTE: This is a "best effort" timer, which will try and call you back every interval.  However,
    the resolution of the timer may vary from platform to platform, and no guarantee is made about the
    precision of the timing of callbacks, particularly for short intervals.  You may wish to use an animation
    or a Timeline for more precise control under some circumstances, or if you want something to happen with
    relatively low latency, you might want to use an on_idle() handler.
*/

class timer
{
public:
    
    timer();
    ~timer();
    static gboolean timer_fired( gpointer data );
    void start(UserData * ud);
    void stop();
    void set_interval(UserData * ud,unsigned int new_interval);
    unsigned int get_interval() const;
    void cancel();

private:
    
    GSource *   source;
    lua_Number  interval;
};

]]

# Class: Timer
# Quite simply; a timer. You can create a timer and set a callback that will run
# every time it fires.

class Timer [[timer*]]
{
    # Constructor: Timer
    # Creates a new Timer object. There are several ways to create a timer.
    # You can pass no parameters and have an empty timer. You can also pass
    # an interval and a callback. And, finally you can pass a table that sets
    # properties individually. As long as the interval and the callback are set
    # when the timer is created, it will start right away.
    #
    # Arguments:
    # interval - In milliseconds, how long until the timer fires.
    # on_timer - A function that will be called when the timer fires.
    #
    # Examples:
    # This one creates a timer that won't start right away (until we call <start>)
    # > timer=Timer()
    # > timer.interval=5000
    # > function timer.on_timer(timer)
    # >   print("TICK")
    # > end
    # > timer:start()
    #
    # This one won't start either, because there is no callback
    # > timer=Timer(5000)
    #
    # This one will start right away and will call 'some_function' in about 5
    # seconds
    # > timer=Timer(5000,some_function)
    #
    # You can also do it like this
    # > timer=Timer{ interval=5000 , on_timer=some_function }
    
    
    Timer( int interval = 0 , function on_timer = 0 )
        [[
            self = lb_construct( timer , new timer );

            if (lua_gettop(L)==2 && lua_istable(L,-2))
            {
                lua_pushvalue(L,-2);
                lb_set_props_from_table(L);
                lua_pop(L,1);
            }
		    else
		    {
				if (interval>0)
				{
				    (self)->set_interval(__ud__,interval);
				}
			    
				if (on_timer)
				{
				    lua_pushvalue(L,on_timer);
				    lb_set_callback(L,"on_timer");
				    lua_pop(L,1);
				}
		    }
	    
	    if (lb_callback_attached(L,self,"on_timer",-1))
		self->start(__ud__);
        ]];
        
    ~Timer()
        [[
            delete self;
        ]];
	
    # Property: interval
    # The interval, in milliseconds, after which the timer fires. 
        
    int interval
        [[interval=self->get_interval();]]
        [[self->set_interval(UserData::get(L),interval);]];
        
    # Function: start
    # Starts the timer if it has not started already
    
    start()
        [[
	    if (lb_callback_attached(L,self,"on_timer",1))
	    {
			self->start(UserData::get(L));
		}
	]];
	
    # Function: stop
    # Stops the timer. It won't tick again unless you start it.
    
    stop()
	[[self->stop();]];

    # Event: on_timer
    # This function gets called every time the timer fires. Timers keep firing
    # until you do one of these things: set the on_timer callback to nil,
    # call <stop> or return false from the on_timer callback.
    #
    # Arguments:
    # timer - The associated Timer
    
    callback on_timer
	[[
	    if(!on_timer)
	    {
			self->stop();
		}
	]];        
}

[[

timer::timer()
:
    source( NULL ),
    interval( 0 ) 
{
}

timer::~timer()
{
    cancel();
}

void timer::start( UserData * ud )
{
    if (source)
		return;

    if (interval<=0)
		return;

    source = g_timeout_source_new( interval );

    g_source_set_callback( source , timer_fired , UserData::Handle::make( ud , this ) , UserData::Handle::destroy );
    g_source_set_priority( source , G_PRIORITY_LOW );
    g_source_attach( source , g_main_context_default()  );
}

void timer::stop()
{
    if (!source)
	return;
    
    g_source_destroy(source);
    g_source_unref(source);
    source=NULL;
}

void timer::set_interval(UserData * ud,unsigned int new_interval)
{
    if (new_interval==interval)
		return;
    
    interval = new_interval;
    
    if(source)
    {
		stop();
		start(ud);
    }
}

unsigned int timer::get_interval() const
{
    return interval;
}
        
void timer::cancel()
{
    stop();
}
      
gboolean timer::timer_fired(gpointer _handle)
{
	UserData::Handle * handle = UserData::Handle::get( _handle );
	
    lua_State * L = handle->get_lua_state();

    g_assert( L );

    timer * self = ( timer* ) handle->get_user();

    if ( ! handle->invoke_callback( "on_timer" , 1 ) )
    {
        self->cancel();
        return FALSE;
    }

    if ( lua_isboolean(L,-1) && !lua_toboolean( L, -1 ) )
    {
        self->cancel();
        lua_pop(L,1);
        return FALSE;
    }
    lua_pop(L,1);
    return TRUE;
}

]]

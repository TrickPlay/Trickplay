module timer;

[[
#include "glib.h"

/*
    You can create a timer in two ways:
    
	Timer( interval , callback )
	Timer{ interval = interval , callback = callback }
	
    If the callback is provided during the constructor, the
    timer will start ticking immediately, otherwise, you
    have to set the callback later and call "start".
    
    If you change the interval to <= 0, remove the callback, call stop
    or return false from the callback, the timer will stop ticking.
*/

class timer
{
public:
    
    timer(lua_State * l );
    ~timer();
    static gboolean timer_fired( gpointer data );
    void start();
    void stop();
    void set_interval(lua_Number new_interval);
    lua_Number get_interval() const;
    void cancel();

private:
    
    lua_State * L;
    GSource *   source;
    lua_Number  interval;
};

]]

class Timer [[timer*]]
{
    Timer( double interval = 0 , function on_timer = 0 )
        [[
            *self = new timer(L);

            if (lua_gettop(L)==2 && lua_istable(L,-2))
            {
                lua_pushvalue(L,-2);
                lb_set_props_from_table(L);
                lua_pop(L,1);
            }
	    else
	    {
		if (interval>0)
		    (*self)->set_interval(interval);
		    
		if (on_timer)
		{
		    lua_pushvalue(L,on_timer);
		    lb_set_callback(L,*self,"on_timer");
		    lua_pop(L,1);
		}
	    }
	    
	    if (lb_callback_attached(L,*self,"on_timer",-1))
		(*self)->start();
        ]];
        
    ~Timer()
        [[
            delete self;
        ]];
        
    double interval
        [[interval=self->get_interval();]]
        [[self->set_interval(interval);]];
        
    callback on_timer
	[[
	    if(!on_timer)
		self->stop();
	]];
        
    start()
        [[
	    if (lb_callback_attached(L,self,"on_timer",1))
		self->start();
	]];
	
    stop()
	[[self->stop();]];
}

[[

timer::timer(lua_State * l )
:
    L(l) ,
    source( NULL ),
    interval( 0 ) 
{
}

timer::~timer()
{
    cancel();
}

void timer::start( )
{
    if (source)
	return;
    
    if (interval<=0)
	return;
    
    source = g_timeout_source_new( interval * 1000 );
	    
    g_source_set_callback( source , timer_fired , this , NULL );
    g_source_attach( source , g_main_context_default()  );
}

void timer::stop()
{
    if (!source)
	return;
    
    g_source_destroy(source);
    g_source_unref(source);
    source=NULL;
}

void timer::set_interval(lua_Number new_interval)
{
    if (new_interval==interval)
	return;
    
    interval = new_interval;
    
    if(source)
    {
	stop();
	start();
    }
}

lua_Number timer::get_interval() const
{
    return interval;
}
        
void timer::cancel()
{
    stop();
}
      
gboolean timer::timer_fired(gpointer data)
{
    timer * self = (timer*)data;
   
    if (!invoke_Timer_on_timer(self->L,self,0,1))
    {
	self->cancel();
	return FALSE;
    }
    
    if (lua_isboolean(self->L,-1) && !lua_toboolean(self->L,-1))
    {
	self->cancel();
	lua_pop(self->L,1);
	return FALSE;
    }
    lua_pop(self->L,1);
    return TRUE;
}

]]

module physics_module;

[[
#include "Box2D/Box2D.h"
#include "clutter/clutter.h"

#include "physics.h"
#include "clutter_util.h"
#include "util.h"
]]

/*===========================================================================*/
/*
	Title: The physics Global Variable and Body Interface

The physics global variable places one or more UIElement-based objects in a two-dimensional environment where they are affected by physics-based forces, such as gravity and collisions.

The physics global variable maintains the physics-based simulation. Similar to the way that objects are added to the screen global variable to show the object on the display, objects are added to the physics variable to place them within the physics world.

Objects added to the physics variable are based on the UIElement interface, such as the Rectangle and Image classes. Before being added to the physics environment, however, the object is enhanced to include the properties, functions and event handlers of the Body interface. The Body interface provides physics-related settings and operations to enable the object to operate within the physics environment.

When the physics world has been configured and the desired objects added to it, the physics simulation can begin by calling the variable's start() function.

The simple program listing shown below creates two Rectangle objects: a dynamic object that will be affected by the physics forces placed upon it and an immobile static object that acts as a ground foundation. As gravity pulls the dynamic object down, the Rectangle falls until it eventually lands on the static ground object.

	(code)
	-- Basic 2D Physics Application

	-- Create a simple rectangle and add it to the screen
	local gBox01 = Rectangle( {
						size     = { 100, 100 },
						position = { (screen.width / 2) - 50, (screen.height / 4) - 50 },
						color    = "SaddleBrown",
	} )
	screen:add( gBox01 )

	-- Make the rectangle a dynamic object, i.e., affected by physics; use default Body settings
	gBox01 = physics:Body( gBox01, { } )

	-- Create a ground so the rectangle doesn't fall off the screen
	local gGround = Rectangle( {
						size     = { screen.width / 2, 2 },
						position = { screen.width / 4, screen.height - (screen.height / 4) },
						color    = "AntiqueWhite",
	} )
	screen:add( gGround )

	-- Make the ground an immobile static object in the physics world
	gGround = physics:Body( gGround, { type = "static" } )

	-- Show the screen
	screen:show()

	-- Start the physics simulation
	physics:start()
	(end)


*/

/*
	InternalInterface: Shape

	The Shape interface is used internally by the Box2D physics engine. It is used to specify the shape of a fixture that is attached to a Body. Shapes can be created by calling the physics global variable's Box(), Edge(), Polygon() and Circle() functions. The Shape object is assigned to the fixture by passing it to the Body interface's add_fixture() function.

*/

interface Shape [[ b2Shape * ]]
{
    Shape()
        [[
            self = lb_construct( b2Shape , lua_touserdata( L , -2 ) );
        ]];

    ~Shape()
        [[
            delete self;
        ]];
}

/*===========================================================================*/

/*
	Interface: Body

The Body interface provides properties, functions and event handlers that define physics-related characteristics that can be applied to a <UIElement>-based object, such as a Rectangle or Image object.

The Body characteristics are defined as an Interface, so it is not possible to create an object of type Body. Instead, the Body characteristics are added to an existing UIElement-based object by calling the Body() function of the <physics> global variable.

*/

interface Body [[ ClutterActor * ]]
{

/***************************************
	Property: handle

	The handle property contains an integer value that uniquely identifies the Body/UIElement object. The handle identifier is assigned automatically to the object when the Body is created by the Body() function of the physics global variable. It is referenced in the various collision-detection event handlers, including on_begin_contact() and on_end_contact().

	Default Setting: a unique integer value

	See Also: the <on_begin_contact>, <on_end_contact>, <on_pre_solve_contact> and <on_post_solve_contact> event handlers
*/

	readonly int handle
        [[
            Physics::Body * me = Physics::Body::get( self );
            handle = me->handle;
        ]];

/***************************************
	Property: type

	The type property is a string specifying whether the Body is static, dynamic or kinematic.

	*Supported Settings:* The type setting is case-sensitive.

	"static" - the body is solid and unmovable when colliding with other objects
	"dynamic" - moves according to the forces placed upon it, such as gravity and collisions. Is affected when colliding into static and kinematic objects.
	"kinematic" - moves according to its velocity, but is not affected by other forces, such as gravity and collisions. Is not affected when colliding into static and dynamic objects.

	*Default Setting:* "dynamic"
*/

	string type
	    [[
            Physics::Body * me = Physics::Body::get( self );
            switch( me->body->GetType() )
            {
                case b2_staticBody:
                    type = "static";
                    break;

                case b2_kinematicBody:
                    type = "kinematic";
                    break;

                case b2_dynamicBody:
                    type = "dynamic";
                    break;

                default:
                    type = 0;
                    break;
            }
	    ]]
	    [[
            Physics::Body * me = Physics::Body::get( self );

            if ( ! type )
            {
                luaL_error( L , "Invalid body type" );
            }
            else
            {
                if ( ! strcmp( type , "static" ) )
                {
                    me->body->SetType( b2_staticBody );
                }
                else if ( ! strcmp( type , "kinematic" ) )
                {
                    me->body->SetType( b2_kinematicBody );
                }
                else if ( ! strcmp( type , "dynamic" ) )
                {
                    me->body->SetType( b2_dynamicBody );
                }
                else
                {
                    luaL_error( L , "Invalid body type '%s'" , type );
                }
            }
	    ]];

/***************************************
	Property: awake

	The awake property is a boolean flag indicating whether the Body/UIElement object is awake or sleeping (true==awake). An awake object is included in any active physics simulation; a sleeping object is not included. Making objects sleep reduces the computational requirements of the physics simulation.

	When an object is no longer in motion, it can be placed automatically in a sleeping state by setting the object's <sleeping_allowed> property to true. If a collision or other force occurs upon the object, it will wake up automatically and be included in the physics simulation. Alternatively, an object can be explicitly woken up by setting its awake property to true.

	*Default Setting:* true

	*See Also:* the <sleeping_allowed> property
*/

	bool awake
		[[
            Physics::Body * me = Physics::Body::get( self );
			awake = me->body->IsAwake();
		]]
		[[
            Physics::Body * me = Physics::Body::get( self );
			me->body->SetAwake( awake );
		]];

/***************************************
	Property: active

	The active property is a boolean flag indicating whether or not the Body/UIElement object is active in the physics simulation (true==active). An inactive object is ignored by the physics simulation, which reduces the simulation's computational requirements.

	*Default Setting:* true

	*See Also:* the <awake> property
*/

	bool active
		[[
            Physics::Body * me = Physics::Body::get( self );
			active = me->body->IsActive();
		]]
		[[
            Physics::Body * me = Physics::Body::get( self );
			me->body->SetActive( active );
		]];

/***************************************
	Property: position

	The position property is a table that contains the current X,Y screen coordinates of the center of the Body/UIElement object.

	*Default Setting:* { X, Y } coordinates of the object's center at the time the Body is created

	*See Also:* the <x>, <y>, <z> and <depth> properties
*/

	table position
		[[
            Physics::Body * me = Physics::Body::get( self );

            const b2Vec2 & pos( me->body->GetPosition() );

			lua_newtable( L );
			lua_pushnumber( L , me->world->world_to_screen( pos.x ) );
			lua_rawseti( L , -2 , 1 );
			lua_pushnumber( L , me->world->world_to_screen( pos.y ) );
			lua_rawseti( L , -2 , 2 );
		]]
		[[
            Physics::Body * me = Physics::Body::get( self );

            lua_rawgeti( L , 2 , 1 );
            lua_rawgeti( L , 2 , 2 );

            const b2Vec2 pos( me->world->screen_to_world( lua_tonumber( L , -2 ) ) ,
                    me->world->screen_to_world( lua_tonumber( L , -1 ) ) );

            lua_pop( L , 2 );

            me->body->SetTransform( pos , me->body->GetAngle() );

            me->synchronize_actor();
		]];

/***************************************
	Property: x

	The x property specifies the current screen position on the X axis of the center of the Body/UIElement object.

	*Default Setting:* 0

	*See Also:* the <y>, <z> and <position> properties
*/

	double x
        [[
            Physics::Body * me = Physics::Body::get( self );

            const b2Vec2 & pos( me->body->GetPosition() );

            x = me->world->world_to_screen( pos.x );
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            b2Vec2 pos( me->body->GetTransform().p );

            pos.x = me->world->screen_to_world( x );

            me->body->SetTransform( pos , me->body->GetAngle() );

            me->synchronize_actor();
        ]];

/***************************************
	Property: y

	The y property specifies the current screen position on the Y axis of the center of the Body/UIElement object.

	The physics variable implements a two-dimensional physics environment that uses the X/Y plane by default. A program can alternatively use the X/Z plane; refer to the physics variable's z_for_y property for details.

	*Default Setting:* 0

	*See Also:* the <x>, <z>, <position> and <physics.z_for_y> properties
*/

    double y
        [[
            Physics::Body * me = Physics::Body::get( self );

            if ( me->world->z_for_y )
            {
                y = clutter_actor_get_y( self );
            }
            else
            {
                const b2Vec2 & pos( me->body->GetPosition() );

                y = me->world->world_to_screen( pos.y );
            }
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            if ( me->world->z_for_y )
            {
                clutter_actor_set_y( self , y );
            }
            else
            {
                b2Vec2 pos( me->body->GetTransform().p );

                pos.y = me->world->screen_to_world( y );

                me->body->SetTransform( pos , me->body->GetAngle() );

                me->synchronize_actor();
            }
        ]];

/***************************************
	Property: z

	The z property specifies the current screen position on the Z axis of the center of the Body/UIElement object.

	The two-dimensional environment controlled by the physics variable does not normally use the Z axis; the physics simulation occurs entirely on the X/Y plane. A program can, however, substitute the X/Y plane with the X/Z plane, causing the physics simulation to occur in depth. Refer to the physics variable's z_for_y property for details.

	*Default Setting:* 0

	*See Also:* the <x>, <y>, <depth> and <physics.z_for_y> properties
*/

    double z
        [[
            Physics::Body * me = Physics::Body::get( self );

            if ( ! me->world->z_for_y )
            {
                z = clutter_actor_get_depth( self );
            }
            else
            {
                const b2Vec2 & pos( me->body->GetPosition() );

                z = me->world->world_to_screen( pos.y );
            }
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            if ( ! me->world->z_for_y )
            {
                clutter_actor_set_depth( self , z );
            }
            else
            {
                b2Vec2 pos( me->body->GetTransform().p );

                pos.y = me->world->screen_to_world( z );

                me->body->SetTransform( pos , me->body->GetAngle() );

                me->synchronize_actor();
            }
        ]];

/***************************************
	Property: depth

	The depth property is equivalent to the <z> property; it specifies the current screen position on the Z axis of the center of the Body/UIElement object. Refer to the description of the <z> property for further details.

	*See Also:* the <x>, <y>, and <z> properties
*/

    double depth
        [[
            Physics::Body * me = Physics::Body::get( self );

            if ( ! me->world->z_for_y )
            {
                depth = clutter_actor_get_depth( self );
            }
            else
            {
                const b2Vec2 & pos( me->body->GetPosition() );

                depth = me->world->world_to_screen( pos.y );
            }
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            if ( ! me->world->z_for_y )
            {
                clutter_actor_set_depth( self , depth );
            }
            else
            {
                b2Vec2 pos( me->body->GetTransform().p );

                pos.y = me->world->screen_to_world( depth );

                me->body->SetTransform( pos , me->body->GetAngle() );

                me->synchronize_actor();
            }
        ]];

/***************************************
	Property: angle

	The angle property specifies the object's rotation in degrees about the Z axis.

	If the physics variable's z_for_y property is true, the object rotates about the Y axis.

	*Default Setting:* 0

	*See Also:* the <rotation> and <physics.z_for_y> properties
*/

	double angle
		[[
            Physics::Body * me = Physics::Body::get( self );
			angle = Physics::World::radians_to_degrees( me->body->GetAngle() );
		]]
		[[
            Physics::Body * me = Physics::Body::get( self );

            b2Vec2 pos( me->body->GetTransform().p );

            me->body->SetTransform( pos , Physics::World::degrees_to_radians( angle ) );

            me->synchronize_actor();
		]];

/***************************************
	Property: rotation

	The rotation property is equivalent to the <angle> property; it specifies the object's rotation in degrees along the Z axis. Refer to the <angle> property for details.

	*See Also:* the <angle> property
*/

    double rotation
        [[
            Physics::Body * me = Physics::Body::get( self );
            rotation = Physics::World::radians_to_degrees( me->body->GetAngle() );
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            b2Vec2 pos( me->body->GetTransform().p );

            me->body->SetTransform( pos , Physics::World::degrees_to_radians( rotation ) );

            me->synchronize_actor();
        ]];

/***************************************
	Property: world_center

	The world_center property is a table containing the { X, Y } coordinates of the center position in the physics environment of the object's mass. Depending upon the number of fixtures attached to a Body and each fixture's density, the center of the object's mass may differ from its screen position, which is based on the center of its Body.

	*Format:* { center-of-mass X coordinate, center-of-mass Y coordinate } where each coordinate is relative to the physics environment

	*See Also:* the <local_center> and <position> properties
*/

    readonly table world_center
        [[
            Physics::Body * me = Physics::Body::get( self );
            const b2Vec2 pos( me->body->GetWorldCenter() );
            lua_newtable( L );
            lua_pushnumber( L , me->world->world_to_screen( pos.x ) );
            lua_rawseti( L , -2 , 1 );
            lua_pushnumber( L , me->world->world_to_screen( pos.y ) );
            lua_rawseti( L , -2 , 2 );
        ]];

/***************************************
	Property: local_center

	The local_center property is a table containing the { X, Y } coordinates of the center position of the object's mass relative to the center of its Body. Depending upon the number of fixtures attached to a Body and each fixture's density, the center of the object's mass may differ from the center of its Body.

	*Format:* { center-of-mass X coordinate, center-of-mass Y coordinate } where each coordinate is relative to the center of the object's Body

	*See Also:* the <world_center> and <position> properties
*/

	readonly table local_center
        [[
            Physics::Body * me = Physics::Body::get( self );
            const b2Vec2 pos( me->body->GetLocalCenter() );
            lua_newtable( L );
            lua_pushnumber( L , me->world->world_to_screen( pos.x ) );
            lua_rawseti( L , -2 , 1 );
            lua_pushnumber( L , me->world->world_to_screen( pos.y ) );
            lua_rawseti( L , -2 , 2 );
        ]];

/***************************************
	Property: linear_velocity

	The linear_velocity property is a table containing the amount of continuous linear velocity to apply along the X and/or Y axis.

	Negative X values push the object to the left; positive X values push it to the right. Negative Y values push the object up; positive Y values push it down.

	To apply a temporary force upon an object, call the <apply_force>() function.

	*Format:* { X-axis velocity, Y-axis velocity }

	*Code Example:* Apply a linear_velocity force to an object to push it up

		(code)
		gBox01.linear_velocity = { 0, -10 }
		(end)

	*See Also:* the <angular_velocity> property and <apply_force> function
*/

	table linear_velocity
		[[
            Physics::Body * me = Physics::Body::get( self );

            b2Vec2 lv( me->body->GetLinearVelocity() );

			lua_newtable( L );
			lua_pushnumber( L , lv.x );
			lua_rawseti( L , -2 , 1 );
			lua_pushnumber( L , lv.y );
			lua_rawseti( L , -2 , 2 );
		]]
		[[
            Physics::Body * me = Physics::Body::get( self );

			lua_rawgeti( L , 2 , 1 );
			lua_rawgeti( L , 2 , 2 );

			me->body->SetLinearVelocity( b2Vec2( lua_tonumber( L , -2 ) , lua_tonumber( L , -1 ) ) );
			lua_pop( L , 2 );
		]];

/***************************************
	Property: angular_velocity

	The angular_velocity property is a double value specifying the object's continuous rotation in degrees around the Z-axis.

	Positive values rotate in a clockwise direction; negative values rotate counter-clockwise.

	To apply a temporary torque to the object, call the <apply_torque> function.

	*See Also:* the <linear_velocity> property and <apply_torque> function
*/

	double angular_velocity
		[[
            Physics::Body * me = Physics::Body::get( self );

			angular_velocity = Physics::World::radians_to_degrees( me->body->GetAngularVelocity() );
		]]
		[[
            Physics::Body * me = Physics::Body::get( self );

			me->body->SetAngularVelocity( Physics::World::degrees_to_radians( angular_velocity ) );
		]];

/***************************************
	Property: mass

	The mass property specifies the mass of the object. Mass is calculated automatically and depends on the density of the body's fixtures.

	*See Also:* the <add_fixture> function
*/

	readonly double mass
        [[
            Physics::Body * me = Physics::Body::get( self );

            mass = me->body->GetMass();
        ]];

/***************************************
	TODO: mass_data
*/

/***************************************
	Property: linear_damping

	The linear_damping property specifies the damping factor to apply to the object's linear velocity. The range of valid settings is 0 to infinity, but common settings are between 0.0 and 0.1.

	*Default Setting:* 0.0

	*See Also:* the <linear_velocity> property
*/

	double linear_damping
        [[
            Physics::Body * me = Physics::Body::get( self );

            linear_damping = me->body->GetLinearDamping();
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->body->SetLinearDamping( linear_damping );
        ]];

/***************************************
	Property: angular_damping

	The angular_damping property specifies the damping factor to apply to the object's angular velocity. The range of valid settings is 0 to infinity, but common settings are between 0.0 and 0.1.

	*Default Setting:* 0.0

	*See Also:* the <angular_velocity> property
*/

	double angular_damping
        [[
            Physics::Body * me = Physics::Body::get( self );

            angular_damping = me->body->GetAngularDamping();
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->body->SetAngularDamping( angular_damping );
        ]];

/***************************************
	Property: bullet

	The bullet property is a boolean flag indicating whether or not the object should be processed as a fast-moving bullet (true=is bullet).

	A fast-moving object can move a long distance between steps of the physics simulation. Because of this speed, it's possible for the object to pass through other objects without a collision being detected. This event is called "tunneling." To prevent tunneling, the fast-moving object should be flagged as a "bullet" to enable "continuous collision detection" (CCD). With CCD enabled, collisions are detected for even fast-moving objects. For performance reasons, CCD is disabled by default.

	The bullet property affects Body objects of type "dynamic" only.

	*Default Setting:* false, i.e., is not a fast-moving object
*/

	bool bullet
        [[
            Physics::Body * me = Physics::Body::get( self );

            bullet = me->body->IsBullet();
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->body->SetBullet( bullet );
        ]];

/***************************************
	Property: sleeping_allowed

	The sleeping_allowed property is a boolean flag indicating whether or not an object that has stopped moving can enter a sleep mode in which the object can be temporarily removed from the physics simulation so as to improve performance (true=sleeping allowed). The object will exit sleep mode automatically if it is involved in a collision or some other force is acted upon it.

	*Default Setting:* true, i.e., can automatically enter sleep mode when inactive

	*See Also:* the <awake> property
*/

	bool sleeping_allowed
        [[
            Physics::Body * me = Physics::Body::get( self );

            sleeping_allowed = me->body->IsSleepingAllowed();
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->body->SetSleepingAllowed( sleeping_allowed );
        ]];

/***************************************
	Property: fixed_rotation

	The fixed_rotation property is a boolean flag indicating whether or not an off-center collision will cause the body to rotate around its Z axis (true=will not rotate).

	Note: Setting an angular_velocity can still cause the object to rotate, regardless of the fixed_rotation setting.

	*Default Setting:* false, i.e., off-center collisions will cause the object to rotate

	*See Also:* the <angular_velocity> property
*/

	bool fixed_rotation
        [[
            Physics::Body * me = Physics::Body::get( self );

            fixed_rotation = me->body->IsFixedRotation();
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->body->SetFixedRotation( fixed_rotation );
        ]];

/***************************************
	Property: contacts

	The contacts property is a table that contains the points on the object where it is touching other Body objects. If the object is not touching any objects, the property's value is nil.

	Each entry in the contacts table includes the following keys.

		enabled - boolean flag indicating whether or not the contact is enabled (true=enabled). A contact can be disabled in the physics global variable's <on_pre_solve_contact> event handler.
		touching - boolean flag indicating whether or not the two objects are touching (true=touching). Note: Contact may occur between the bounding boxes of two objects, but the actual objects do not touch.
		point - table containing two keys. Key "1" contains the contact point's X coordinate. Key "2" contains the contact point's Y coordinate.
		bodies - table containing two keys. Key "1" contains the <handle> for one of the objects. Key "2" contains the handle for the other object.
		other_body - table containing two keys. One key is the <handle> of the current object; its value is the handle of the other object. The second key is the handle of the other object; its value is the handle of the current object. For example, if the object with handle 2 is touching the object with handle 4, the other_body table for the object with handle 2 would contain { 2=4, 4=2 }. This table enables the program to access the other object by using the current object's handle as an index, as in contactObject = Object2.contacts.other_body[ Object2.handle ].
		fixtures - table containing two keys. Key "1" contains the fixture handle for one of the fixtures. Key "2" contains the fixture handle for the other fixture. The fixture handle is returned by the <add_fixture> function.
		other_fixture - table containing two keys. One key is the fixture handle of the current fixture; its value is the fixture handle of the other fixture. The second key is the fixture handle of the other fixture; its value is the fixture handle of the current fixture. For example, if the fixture with handle 3 is touching the fixture with handle 5, the other_fixture table for the fixture with handle 3 would contain { 3=5, 5=3 }. This table enables the program to access the other fixture by using the current fixture's handle as an index, as in contactFixture = ObjectX.contacts.other_fixture[ ObjectXFixtureHandle ].

	*Default Setting:* nil

	*Code Example:*

		(code)
		-- Display the complete contents of an object's contacts table
		if( Object.contacts ~= nil )then
			dumptable( Object.contacts )
		end
		(end)

	*See Also:* the <handle> property, the <add_fixture> function, and the <on_pre_solve_contact> event handler
*/

	readonly table contacts
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->world->push_contact_list( me->body->GetContactList() );
        ]];

/***************************************
	Function: synchronize

	The synchronize() function forces the Body's position and rotation to match that of its related UIElement-based object.

	The synchronize() function may alter the following Body properties: <x>, <y>, <position>, <angle> and <rotation>.

	*Return Value:* None

	*See Also:* the <x>, <y>, <position>, <angle> and <rotation> properties
*/

	synchronize( )
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->synchronize_body();
        ]];

/***************************************
	Function: apply_force

	The apply_force() function applies a temporary directional force on an object.

	Applying force on an object is similar to setting the object's <linear_velocity>, but linear velocity is continuous and always applied to the center of the object's mass, while force is temporary and can be applied to any X,Y coordinate. If force is applied anywhere other than the center of the object's mass, a torque is created which may cause the object to rotate.

	*Arguments:*

		force - table containing the amount of force to apply along the X and Y axes. The format is { X-axis-force, Y-axis-force }. A negative X-axis force pushes the object to the left; positive X-axis force pushes to the right. A negative Y-axis force pushes the object up; a positive Y-axis force pushes the object down.
		point - table of { X, Y } coordinates at which to apply the force

	*Code Example:*

		(code)
		-- Use force to push object up
		gObject:apply_force( { 0, -500 }, { gObject.x, gObject.y } )

		-- Use force to push object left
		gObject:apply_force( { 100, 0 }, { gObject.x, gObject.y } )

		-- Apply an off-center, upward force, creating torque and causing the object to rotate
		gObject:apply_force( { 0, -500 }, { gObject.x - 10, gObject.y } )
		(end)

	*See Also:* the <linear_velocity> property
*/

	apply_force( table force, table point )
		[[
            Physics::Body * me = Physics::Body::get( self );

            lua_rawgeti( L , force , 1 );
            lua_rawgeti( L , force , 2 );

            lua_rawgeti( L , point , 1 );
            lua_rawgeti( L , point , 2 );

			me->body->ApplyForce(
			    b2Vec2( lua_tonumber( L , -4 ) , lua_tonumber( L , -3 ) ) ,
				b2Vec2( me->world->screen_to_world( lua_tonumber( L , -2 ) ),
				        me->world->screen_to_world( lua_tonumber( L , -1 ) ) ) );

			lua_pop( L , 4 );
		]];

/***************************************
	Function: apply_torque

	The apply_torque() function applies a temporary torque upon the object, which, depending upon other forces, can cause the object to rotate.

	Applying torque on an object is similar to setting the object's <angular_velocity>, but angular velocity is continuous, while torque is temporary.

	*Arguments:*

		torque - double value specifying the amount of torque to apply on the object. A positive value applies a clockwise torque; a negative value applies a counter-clockwise torque.

	*See Also:* the <angular_velocity> property and <apply_angular_impulse> function
*/

	apply_torque( double torque )
		[[
            Physics::Body * me = Physics::Body::get( self );

            me->body->ApplyTorque( torque );
		]];

/***************************************
	Function: apply_linear_impulse

	The apply_linear_impulse() function applies a temporary, directional force to the object.

	Applying a linear impulse on an object is similar to applying a force using the <apply_force>() function, but a linear impulse is a sharp and sudden force, like a hammer hitting an object, while a force is a steady pressure, like a person pushing an automobile.

	If a linear impulse is applied anywhere other than the center of the object's mass, a torque is created which may cause the object to rotate.

	*Arguments:*

		force - table containing the amount of impulse to apply along the X and Y axes. The format is { X-axis-impulse, Y-axis-impulse }. A negative X-axis impulse pushes the object to the left; positive X-axis impulse pushes to the right. A negative Y-axis impulse pushes the object up; a positive Y-axis impulse pushes the object down.
		point - table of { X, Y } coordinates at which to apply the impulse

	*Code Example:*

		(code)
		-- Use impulse to push object up
		gObject:apply_force( { 0, -5 }, { gObject.x, gObject.y } )

		-- Use force to push object left
		gObject:apply_force( { 100, 0 }, { gObject.x, gObject.y } )

		-- Apply an off-center, upward force, creating torque and causing the object to rotate
		gObject:apply_force( { 0, -500 }, { gObject.x - 10, gObject.y } )
		(end)

	*See Also:* the <apply_force> function
*/

	apply_linear_impulse( table force, table point )
		[[
            Physics::Body * me = Physics::Body::get( self );

            lua_rawgeti( L , force , 1 );
            lua_rawgeti( L , force , 2 );

            lua_rawgeti( L , point , 1 );
            lua_rawgeti( L , point , 2 );

            me->body->ApplyLinearImpulse(
                    b2Vec2( lua_tonumber( L , -4 ) , lua_tonumber( L , -3 ) ) ,
                    b2Vec2( me->world->screen_to_world( lua_tonumber( L , -2 ) ),
                          me->world->screen_to_world( lua_tonumber( L , -1 ) ) ) );

            lua_pop( L , 4 );
		]];

/***************************************
	Function: apply_angular_impulse

	The apply_angular_impulse() function applies a temporary torque upon the object, which, depending upon other forces, can cause the object to rotate.

	Applying an angular impulse on an object is similar to setting the object's <angular_velocity>, but angular velocity is continuous, while angular impulse is temporary.

	Angular impulse is also similar to torque, as set by the <apply_torque> function, but angular impulse is a sharp and sudden force, like a hammer striking the object; a torque is a steady pressure, like a person pushing a heavy crate.

	*Arguments:*

		impulse - double value specifying the amount of angular impulse to apply on the object. A positive value applies a clockwise impulse; a negative value applies a counter-clockwise impulse.

	*See Also:* the <angular_velocity> property and <apply_torque> function
*/

	apply_angular_impulse( double impulse )
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->body->ApplyAngularImpulse( impulse );
        ]];


#===============================================================================
    # Fixtures

/***************************************
	Property: fixtures

	The fixtures property is a read-only table containing all the fixtures attached to the Body. Each Body object must have one or more fixtures attached to it. Each fixture defines one part of the Body, including its shape, size, density, and other characteristics. When a Body object is created by the <physics.Body> function, a fixture can be specified in the function's arguments. Additional fixtures can be attached to the object by calling the <add_fixture> function.

	Each fixture entry contains the keys shown below.

		handle - unique integer ID value assigned to the fixture. The ID value is generated automatically when the fixture is created by the <add_fixture> function.
		type - string specifying the fixture type. Supported strings are "circle" and "polygon". The string is "circle" if the fixture was created using the <physics.Circle> function. Fixtures of all other shapes have type strings of "polygon."
		density - double value specifying how heavy the fixture is in relation to its area
		friction - double value specifying how slippery the fixture is
		bounce - double value specifying the fixture's springiness or level of rebound when a collision occurs
		sensor - boolean flag indicating whether or not the fixture is a sensor (true=sensor)
		filter - table containing the settings of the collision-filter keys "group", "category" and "mask". Refer to the <add_fixture> function for information about the collision filter.

	*Code Examples:* To access the property for a particular fixture entry in the fixtures table, use the following syntax.

		(code)
		-- Retrieve the density setting for the object's first fixture
		objDensity = bodyObj.fixtures[ 1 ].density
		(end)

	*See Also:* the <add_fixture> and <physics.Body> functions
*/

    readonly table fixtures
        [[
            Physics::Body * me = Physics::Body::get( self );

            lua_newtable( L );
            int t = lua_gettop( L );
            int i = 1;

            for( b2Fixture * f = me->body->GetFixtureList(); f ; f = f->GetNext() , ++i )
            {
                lua_newtable( L );

                lua_pushinteger( L , GPOINTER_TO_INT( f->GetUserData() ) );
                lua_setfield( L , -2 , "handle" );

                switch( f->GetType() )
                {
                    case b2Shape::e_circle:
                        lua_pushstring( L , "circle" );
                        break;

                    case b2Shape::e_polygon:
                        lua_pushstring( L , "polygon" );
                        break;

                    default:
                        lua_pushnil( L );
                }

                lua_setfield( L , -2 , "type" );

                lua_pushboolean( L , f->IsSensor() );
                lua_setfield( L , -2 , "sensor" );

                lua_pushnumber( L , f->GetDensity() );
                lua_setfield( L , -2 , "density" );

                lua_pushnumber( L , f->GetFriction() );
                lua_setfield( L , -2 , "friction" );

                lua_pushnumber( L , f->GetRestitution() );
                lua_setfield( L , -2 , "bounce" );

                // We are going to create a sub-table for the filter
                const b2Filter & filter = f->GetFilterData();

                lua_newtable( L );

                lua_pushinteger( L, filter.groupIndex );
                lua_setfield( L, -2, "group" );

                lua_pushinteger( L, filter.categoryBits );
                Util::convert_bitmask_to_table( L );
                lua_setfield( L, -2, "category" );

                lua_pushinteger( L, filter.maskBits );
                Util::convert_bitmask_to_table( L );
                lua_setfield( L, -2, "mask" );

                lua_setfield( L, -2, "filter" );

                lua_rawseti( L , t , i );
            }
        ]];

/***************************************
	Function: remove_fixture()

	The remove_fixture() function detaches a specified fixture from the Body object.

	After a fixture is removed, its old property values become invalid and undefined; if an application has references or variables to the removed fixture, it should not access them or assume they are still at their previous settings.

	*Arguments:*

		fixture_handle - handle of the fixture to remove. The fixture handle is returned by the <add_fixture> function that created the fixture.

	*Return Value:* boolean flag indicating the operation's success or failure (true=fixture was removed)

	*See Also:* the <fixtures> property and <add_fixture> and <remove_all_fixtures> functions
*/

    bool remove_fixture( int fixture_handle )
        [[
            Physics::Body * me = Physics::Body::get( self );

            result = false;

            for( b2Fixture * f = me->body->GetFixtureList(); f ; f = f->GetNext() )
            {
                if ( GPOINTER_TO_INT( f->GetUserData() ) == fixture_handle )
                {
                    result = true;
                    f->GetBody()->DestroyFixture( f );
                    break;
                }
            }
        ]];

/***************************************
	Function: remove_all_fixtures

	The remove_all_fixtures() function detaches all fixtures currently attached to the Body object.

	After a fixture is removed, its old property values become invalid and undefined; if an application has references or variables to the removed fixture, it should not access them or assume they are still at their previous settings.

	*Arguments:* None

	*Return Value:* None

	*See Also:* the <add_fixture> and <remove_fixture> functions
*/

    remove_all_fixtures()
        [[
            Physics::Body * me = Physics::Body::get( self );

            for( b2Fixture * f = me->body->GetFixtureList(); f ; )
            {
                b2Fixture * next = f->GetNext();

                f->GetBody()->DestroyFixture( f );

                f = next;
            }

        ]];

/***************************************
	Function: add_fixture

	The add_fixture() function creates a new fixture and attaches it to the Body object. The new fixture is automatically assigned a unique integer handle, which is returned by the function. Other properties of the fixture can be defined in a table passed to the argument.

	*Argument:*

		properties - table of key/setting pairs that define the fixture's properties. Supported keys are described below.

	*Supported Property Keys:*

		The properties argument can include any of these keys.

		shape - a Shape object specifying the fixture's shape. A Shape object is returned by the Box(), Edge(), Polygon() and Circle() functions of the <physics> global variable. A single Shape object can be used to create multiple fixtures, provided the Shape's properties are identical for each fixture. Default value: A Box shape large enough to surround the entire object.
		density - double value specifying the heaviness of the fixture in relation to its area. Valid Range: 0(no density) to infinity(maximum density). Default: 1.0
		friction - double value specifying how slippery the fixture is. Valid Range: 0.0(very slippery) to 1.0(not slippery). Default: 0.2
		bounce - double value specifying the fixture's springiness or level of rebound when a collision occurs. Valid Range: 0.0(not springy) to 1.0(maximum springiness). Default: 0.0
		sensor - boolean flag indicating whether or not the fixture is a sensor (true=sensor). A sensor can share space with another object without colliding into it, such as in a top-down view of a bird flying over a tree. Although collisions do not occur, the sensor still generates on_contact()-type events when interacting with other objects. Default: false
		filter - collision filtering. For details, refer to the explanation below.

	*Return Value:* unique integer fixture handle

	*Collision Filtering:*

		By default, a Body fixture will collide with all other Body fixtures. If a fixture's sensor property is true, then the fixture will not collide with any other fixture. Collisions can be more finely tuned by defining a filter property in the add_fixture() function's argument.

		The filter property is a table with the following keys.

			group - signed integer specifying the fixture's group. Default: 0
			category - 16-bit integer specifying the fixture's category ID or table of integers specifying the fixture's category IDs. Each bit in the integer identifies a single category; therefore, an application may have a maximum of 16 category IDs. Valid Range: 0-15 where the value specifies the bit position; 0 is the right-most bit, 15 is the left-most bit. To clear all bits and set to zero, specify an empty table. Default Category ID: 0. Default Category Value: 0x0001. Note: The default Category ID 0 is represented by bit 0 in the category integer. Thus, ID 0 sets bit 0, which results in a category value of 1. Category ID 1 sets bit 1, which results in a category value of 2. ID 2 sets bit 2, which results in a category value of 4. And so on. Got it?
			mask - 16-bit integer specifying the categories the fixture will collide with. Each bit in the integer identifies a collidable category. Valid Range: 0-15 where the value specifies the bit position; 0 is the right-most bit, 15 is the left-most bit. To clear all bits so that the object will not collide with any object, specify an empty table. Default: 0xFFFF (i.e., will collide with all other fixtures)

		The category and mask keys contain 16-bit bit-flag values. The two keys work together to determine whether or not two touching objects are colliding. The category setting identifies the fixture's category. Normally, a fixture belongs to only a single category, but it's possible to place the fixture in multiple categories. The mask setting specifies the categories that the fixture will collide with. An example setting is shown below.

		(code)
		-- Create a fixture in category 3 that will collide with fixtures in categories 3 and 5
		gObj01:add_fixture( { filter = { category = 3, mask = { 3, 5 } } } )

		-- Add a Body to a UIElement object. This will automatically attach a fixture to the Body.
		-- The fixture can be initialized at this point, as well
		gObj02:Body( gObj02, { filter = { category = 3, mask = { 3, 5 } } } )
		(end)

		In order for two touching objects to collide, the category and mask collision determination must be true *for both objects.* For example, assume there are two objects, where one is in category 1 and the other is in category 2. The first is initialized to collide with objects in categories 1 and 2 (i.e., its mask is set to { 1, 2 }), so it will collide with the second object. The second object is initialized to collide with objects in category 2 only (its mask is set to 2), so it will not collide with the first object. If the two objects touch, a collision does *not* occur because both objects do not arrive at a positive collision determination (the first can collide, but the second cannot).

		The group key can be used to organize objects that should either always collide or never collide. If the group key conditions are met, then the group overrides any category and mask settings. The group key is a signed integer and not a bit-flag integer like the category and mask keys. The rules for determining collisions between two objects when using the group key are shown below.

		- If the group key for either object is 0 then the category/mask settings are used to determine the collision
		- If the group keys for both objects are different, the category/mask settings determine collision
		- If the group keys for both objects are the same and positive, the objects collide
		- If the group keys for both objects are the same and negative, the objects do not collide

		(code)
		-- Create a fixture that will never collide with other objects in its group
		gObj01:add_fixture( { filter = { group = -1 } } )

		-- Add a Body to a UIElement object. Define the associated fixture to always collide with
		-- other objects in its group.
		gObj02:Body( gObj02, { filter = { group = 1 } } )
		(end)

		A Body/UIElement object may have multiple fixtures, and these fixtures can overlap each other. Collisions between fixtures are determined on an individual basis. For example, assume a Body object with multiple fixtures that do not overlap. One of the object's fixtures makes contact with another object's fixture. The collision determination is dependent upon the two touching fixtures only; the other fixtures are irrelevant.

		Now assume a Body object with two fixtures that completely overlap each other, i.e., two fixtures having the same size and location. Each fixture, however, may have different collision-filtering settings. When this object makes contact with another, it always touches the other object with both fixtures, simultaneously. Collision determinations occur separately for each fixture. If collision conditions are positively met for the first fixture, a collision occurs, regardless of the collision determination for the second overlapping fixture. If collision conditions are positively met for both fixtures, two collisions occur.

	*See Also:* the <fixtures> property and the <remove_fixture> function
*/

    int add_fixture( table properties )
        [[
            Physics::Body * me = Physics::Body::get( self );

            result = 0;

            b2FixtureDef fd = me->world->create_fixture_def( properties );

            if ( ! fd.shape )
            {
                return luaL_error( L , "Missing shape" );
            }

            result = me->world->get_next_handle();

            fd.userData = GINT_TO_POINTER( result );

            me->body->CreateFixture( & fd );
        ]];

#===============================================================================
    # Joints

/***************************************
	Function: remove_joint

	The remove_joint() function removes a specified joint from the Body and then destroys the joint.

	When an application is cleaning up a Body and its joints, all the joints should be removed before dereferencing the Body/UIElement object.

	*Argument:*

		joint_handle - unique integer handle ID that identifies the joint to remove and destroy. The joint handle is returned by the function that created the joint, such as the <RevoluteJoint> function, among others.

	*Return Value:* boolean flag indicating the success or failure of the operation (true=joint was removed)

	*See Also:* the <DistanceJoint>, <RevoluteJoint> and <PrismaticJoint> functions
*/

    bool remove_joint( int joint_handle )
        [[
            Physics::Body * me = Physics::Body::get( self );

            gpointer h = GINT_TO_POINTER( joint_handle );

            result = false;

            for( b2JointEdge * e = me->body->GetJointList(); e; e = e->next )
            {
                if ( e->joint && e->joint->GetUserData() == h )
                {
                    result = true;

                    me->world->get_world()->DestroyJoint( e->joint );

                    break;
                }
            }
        ]];

/***************************************
	Function: DistanceJoint

	The DistanceJoint() function connects two Body objects and maintains a constant distance between them. The two attached objects should already be positioned at the desired distance at the time the joint is created. An anchor point is defined for each object. This type of joint is considered a "rigid" joint because the distance between the anchor points remains unchanged. The joint can be removed by calling the <remove_joint> function.

(see physics2dDistanceJoint.png)

	Note: It is possible to create a "soft" joint in which two or more objects are connected by DistanceJoints in a web-like structure. When one of the objects moves, the other objects in the web also move, but in a rubbery rather than rigid manner. To create a soft joint, specify values for the frequency and damping_ratio keys in the function's properties argument.

	*Arguments:*

		anchor - table of { X, Y } screen coordinates at which to connect this Body. This is Anchor1 in the diagram above.
		other_body - attached Body object. This is Body2 in the diagram.
		other_anchor - table of { X, Y } screen coordinates at which to connect the Body reference by the other_body argument. This is Anchor2 in the diagram.
		properties - optional table of key/value settings that configure a "soft" distance joint. If using a rigid joint, these properties should not be changed. Supported keys are described below.

	*Joint Properties:* The function's properties argument can contain the following keys.

		frequency - double value specifying the soft joint's frequency in Hertz. The joint's frequency can be considered to be that of a harmonic oscillator or a vibrating guitar string. Typically, the frequency should be less than half the frequency of the physics simulation's time step.
		damping_ratio - double value specifying the damping ratio. Range: 0.0-infinity, but typically 0.0-1.0 where 0.0 is no damping and 1.0 is critical damping where all oscillations should disappear. Default: 1.0

	*Return Value:* unique integer joint handle. This handle can be passed to the <remove_joint> function to detach the two Body objects.

	*Code Example:* Connect two objects with a DistanceJoint

		(code)
		-- Create a static body on which we will attach a distance joint
		gJointBody = Rectangle( {
							size         = { 100, 100 },
							position     = { screen.width / 2, screen.height / 5 },
							color        = "AntiqueWhite",
		} )
		gJointBody.anchor_point = { 50, 50 }
		screen:add( gJointBody )
		gJointBody = physics:Body( gJointBody,
			                       { type = "static",
		} )

		-- Make a rod-shaped rectangle
		gRod = Rectangle( {	size         = { 30, 400 },
							position     = { (screen.width / 2) + 100, (screen.height / 5) + 300 },
							color        = "SlateGray2",
		} )
		gRod.anchor_point = { 15, 200 }
		screen:add( gRod )
		gRod = physics:Body( gRod, { density = 100 } )

		-- Join the rod to the gJointBody
		gJointBody:DistanceJoint( { gJointBody.x, gJointBody.y },	-- middle of gJointBody
			                      gRod,
			                      { gRod.x, gRod.y - 200 },			-- top and center of gRod
			                      { }
		)

		-- Show everything on-screen
		screen:show()

		-- Start the physics simulation
		physics:start()
		(end)

	*See Also:* the <remove_joint> function
*/

    int DistanceJoint( table anchor, Body other_body, table other_anchor, table properties = 0 )
        [[
            lb_check_udata_type( L , other_body , "Body" );

            Physics::Body * me = Physics::Body::get( self );

            Physics::Body * other = Physics::Body::get_from_lua( L , other_body );

            if ( ! other )
            {
                return luaL_error( L , "Invalid body" );
            }

            b2Body * ba = me->body;
            b2Body * bb = other->body;

            lua_rawgeti( L , anchor , 1 );
            lua_rawgeti( L , anchor , 2 );

            float32 ax = me->world->screen_to_world( lua_tonumber( L , -2 ) );
            float32 ay = me->world->screen_to_world( lua_tonumber( L , -1 ) );

            lua_pop( L , 2 );

            lua_rawgeti( L , other_anchor , 1 );
            lua_rawgeti( L , other_anchor , 2 );

            float32 bx = me->world->screen_to_world( lua_tonumber( L , -2 ) );
            float32 by = me->world->screen_to_world( lua_tonumber( L , -1 ) );

            lua_pop( L , 2 );

            b2DistanceJointDef d;

            d.Initialize( ba , bb , b2Vec2( ax , ay ) , b2Vec2( bx , by ) );

            if ( properties )
            {
                lua_getfield( L , properties , "frequency" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    d.frequencyHz = lua_tonumber( L , -1 );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "damping_ratio" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    d.dampingRatio = lua_tonumber( L , -1 );
                }
                lua_pop( L , 1 );
            }

            result = me->world->get_next_handle();

            b2Joint * joint = me->world->get_world()->CreateJoint( & d );

            joint->SetUserData( GINT_TO_POINTER( result ) );

        ]];

/***************************************
	Function: RevoluteJoint

	The RevoluteJoint() function attaches two Body objects together at a single point to create a revolving, hinge-type joint.

	*Arguments:*

		other_body - attached Body object
		anchor - table of { X, Y } screen coordinates at which to attach Body
		properties - optional table of key/value settings that configure the joint. Supported keys are described below.

	*Joint Properties:* The function's properties argument can contain the following keys.

		enable_limit - boolean flag indicating whether or not the joint has an angular limit (true=has limit). If the enable_limit key is true, the limits are specified in the lower_angle and upper_angle keys. Note: The enable_limit key activates both the lower_limit and upper_limit keys. If you want only a single limit, the other limit should be set to something extremely high or low so that it will never realistically be reached.  Default: false, i.e., no limit.
		lower_angle - signed double value specifying the lowest angle limit in degrees. Default: 0.0
		upper_angle - signed double value specifying the highest angle limit in degrees. Default: 0.0
		enable_motor -boolean flag indicating whether or not a constant force should be applied upon the joint (true=apply force). If the enable_motor property is true, the level of force and torque to apply are specified in the motor_speed and max_motor_torque keys. Default: false, i.e., no force.
		motor_speed - signed double value specifying the desired motor speed. Positive values revolve the attached object clockwise; negative values revolve counter-clockwise. Setting the motor_speed to 0.0 will act as a brake, causing the joint to attempt to stand still; this braking effect can be accentuated by also setting a low max_motor_torque value. Combining a motor_speed of 0.0 with a high max_motor_torque value will act to cause the joint to stop quickly and will also require a larger force to move the joint. Default: 0.0
		max_motor_torque - signed double value specifying the maximum motor torque to apply to achieve the desired motor speed. Positive values apply a non-fluctuating torque; negative values apply an indefinitely-increasing torque. Setting a low torque value, the joint may require more time to get up to maximum speed. Default: 0.0

	*Return Value:* unique integer joint handle. This handle can be passed to the <remove_joint> function to detach the two Body objects.

	*Code Example:* Create a revolving propeller using a RevoluteJoint

	(code)
	-- Create a static body on which we will attach a revolute joint
	gJointBody = Rectangle( {
						size         = { 100, 100 },
						position     = { screen.width / 2, screen.height / 2 },
						anchor_point = { 50, 50 },		-- middle of rectangle
						color        = "AntiqueWhite",
	} )
	screen:add( gJointBody )
	gJointBody = physics:Body( gJointBody,
	                           { type = "static",
	} )

	-- Make a propeller-shaped rectangle
	gPropeller = Rectangle( {
						size         = { 700, 30 },
						position     = { screen.width / 2, screen.height / 2 },
						anchor_point = { 350, 15 },		-- middle of rectangle
						color        = "SlateGray2",
	} )
	screen:add( gPropeller )
	gPropeller = physics:Body( gPropeller, { } )

	-- Join the propeller to the gJointBody
	gJointBody:RevoluteJoint( gPropeller,
	                          { gJointBody.x, gJointBody.y  },
	                          { enable_motor = true,
	                            motor_speed = 300,		-- clockwise
	                            max_motor_torque = 100,	-- steady rate
	                          } )
	-- Show the screen
	screen:show()

	-- Start the physics simulation
	physics:start()
	(end)

	*See Also:* the <remove_joint> function
*/

    int RevoluteJoint( Body other_body, table anchor, table properties = 0 )
        [[
            lb_check_udata_type( L , other_body , "Body" );

            Physics::Body * me = Physics::Body::get( self );

            Physics::Body * other = Physics::Body::get_from_lua( L , other_body );

            if ( ! other )
            {
                return luaL_error( L , "Invalid body" );
            }

            b2Body * ba = me->body;
            b2Body * bb = other->body;

            lua_rawgeti( L , anchor , 1 );
            lua_rawgeti( L , anchor , 2 );

            float32 x = me->world->screen_to_world( lua_tonumber( L , -2 ) );
            float32 y = me->world->screen_to_world( lua_tonumber( L , -1 ) );

            lua_pop( L , 2 );

            b2RevoluteJointDef j;

            j.Initialize( ba , bb , b2Vec2( x , y ) );

            if ( properties )
            {
                lua_getfield( L , properties , "enable_limit" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    j.enableLimit = lua_toboolean( L , -1 );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "lower_angle" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    j.lowerAngle = Physics::World::degrees_to_radians( lua_tonumber( L , -1 ) );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "upper_angle" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    j.upperAngle = Physics::World::degrees_to_radians( lua_tonumber( L , -1 ) );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "enable_motor" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    j.enableMotor = lua_toboolean( L , -1 );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "motor_speed" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    j.motorSpeed = Physics::World::degrees_to_radians( lua_tonumber( L , -1 ) );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "max_motor_torque" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    j.maxMotorTorque = lua_tonumber( L , -1 );
                }
                lua_pop( L , 1 );

            }

            result = me->world->get_next_handle();

            b2Joint * joint = me->world->get_world()->CreateJoint( & j );

            joint->SetUserData( GINT_TO_POINTER( result ) );
        ]];

/***************************************
	Function: PrismaticJoint

	The PrismaticJoint() function groups two Body objects and limits their movement to slide along the axis between them. It is also possible to define the range of movement along the axis for each object. At least one of the objects must be a Body of <type> "dynamic" with its <fixed_rotation> property set to false. The two objects may not revolve in relation to each other, but they can revolve together as a single unit.

	*Arguments:*

		other_body - Body object to connect with.
		axis - table of { X, Y } screen coordinates for other Body object's anchor. The anchor and axis coordinates define the axis along which the two Body object's will be able to move.
		properties - optional table of key/value settings that configure the joint. Supported keys are described below. Default: Empty table.
		anchor - table of { X, Y } coordinates reserved for future expansion. Do not specify; use the default setting. Default: { 0, 0 }

	*Joint Properties:* The function's properties argument can contain the following keys.

		enable_limit - boolean flag indicating whether or not the joint has a movement limit (true=has limit). If the enable_limit key is true, the limits are specified in the lower_translation and upper_translation keys. Note: The enable_limit key activates both the lower_translation and upper_translation keys. If you want only a single limit, the other limit should be set to something extremely high or low so that it will never realistically be reached. If enable_limit is true and the lower_translation and upper_translation properties contain the same value, the other_body will be locked in position and will not move. Default: false, i.e., no limit.
		lower_translation - signed double value specifying the lowest movement limit in pixels. Default: 0.0
		upper_translation - signed double value specifying the highest movement limit in degrees. Default: 0.0
		enable_motor -boolean flag indicating whether or not a constant force should be applied upon the joint (true=apply force). If the enable_motor property is true, the level of force and torque to apply are specified in the motor_speed and max_motor_force keys. Default: false, i.e., no force; objects can slide along the joint without any resistance.
		motor_speed - signed double value specifying the desired motor speed. Positive values move the other_body object in the direction of the axis; negative values move it in the opposite direction. Setting the motor_speed to 0.0 will act as a brake, causing the joint to attempt to stand still; this braking effect can be accentuated by also setting a low max_motor_force value. Combining a motor_speed of 0.0 with a high max_motor_torque value will act to cause the joint to stop quickly and will also require a larger force to move the joint. Default: 0.0
		max_motor_force - signed double value specifying the maximum motor force to apply to achieve the desired motor speed. Positive values apply a non-fluctuating force; negative values apply an indefinitely-increasing force. Setting a low force value, the joint may require more time to get up to maximum speed. Default: 0.0

	*Return Value:* unique integer joint handle. This handle can be passed to the <remove_joint> function to detach the two Body objects.

	*Code Example:*


	*See Also:* the <remove_joint> function


	*** Undocumented Arguments and Joint Properties

	The following arguments/properties are undocumented because they should not be necessary. Because the two Body objects should already be accurately positioned before starting the physics simulation, changing the other_body object's rotation via the reference_angle and (reference_)anchor settings should not be necessary.

		reference_angle property - double value in degrees specifying the amount of rotation to perform upon the other_body object. The current Body object will not rotate. Positive values cause clockwise rotation. The rotation occurs at the point specified by the anchor parameter described below.
		anchor parameter - a more-accurate name for this setting would be reference_anchor. It is a table of { X, Y } coordinates that specify the anchor point at which the other_body object will rotate. The coordinates are local to the object's anchor point. The amount of rotation is specified in the reference_angle property.
*/

    int PrismaticJoint( Body other_body, table axis, table properties = 0, table anchor = 0 )
        [[
            lb_check_udata_type( L , other_body , "Body" );

            Physics::Body * me = Physics::Body::get( self );

            Physics::Body * other = Physics::Body::get_from_lua( L , other_body );

            if ( ! other )
            {
                return luaL_error( L , "Invalid body" );
            }

            b2Body * ba = me->body;
            b2Body * bb = other->body;

            // TODO: at least one of the bodies has to be dynamic with a non-fixed rotation

            float32 x = 0;
            float32 y = 0;

            if ( !anchor )
            {
                // Dy default, anchor point is  { 0, 0 } in the screen -- this only matters for relative rotation
                x = me->world->screen_to_world( 0 );
                y = me->world->screen_to_world( 0 );
            } else {
                lua_rawgeti( L , anchor , 1 );
                lua_rawgeti( L , anchor , 2 );

                x = me->world->screen_to_world( lua_tonumber( L , -2 ) );
                y = me->world->screen_to_world( lua_tonumber( L , -1 ) );

                lua_pop( L , 2 );
            }

            lua_rawgeti( L , axis , 1 );
            lua_rawgeti( L , axis , 2 );

            float32 ax = me->world->screen_to_world( -lua_tonumber( L , -2 ) );
            float32 ay = me->world->screen_to_world( -lua_tonumber( L , -1 ) );

            lua_pop( L , 2 );

            b2PrismaticJointDef p;

            p.Initialize( ba , bb , b2Vec2( x , y ) , b2Vec2( ax , ay ) );

            if ( properties )
            {
                lua_getfield( L , properties , "reference_angle" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    p.referenceAngle = Physics::World::degrees_to_radians( lua_tonumber( L , -1 ) );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "enable_limit" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    p.enableLimit = lua_toboolean( L , -1 );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "lower_translation" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    p.lowerTranslation = me->world->screen_to_world( lua_tonumber( L , -1 ) );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "upper_translation" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    p.upperTranslation = me->world->screen_to_world( lua_tonumber( L , -1 ) );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "enable_motor" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    p.enableMotor = lua_toboolean( L , -1 );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "motor_speed" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    p.motorSpeed = lua_tonumber( L , -1 );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "max_motor_force" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    p.maxMotorForce = lua_tonumber( L , -1 );
                }
                lua_pop( L , 1 );
            }

            result = me->world->get_next_handle();

            b2Joint * joint = me->world->get_world()->CreateJoint( & p );

            joint->SetUserData( GINT_TO_POINTER( result ) );
        ]];

	/*
		Event: on_begin_contact

		When a body begins to touch another, this callback is triggered.

		The single argument "contact" is a table with several values
		describing the contact.

		point - A table of X and Y coordinates for the contact point.
		fixtures - A table containing the handles of the fixtures that made contact.
		other_fixture - A table containing the same two handles, but indexed by each other,
		                so that if my fixture handle is 42, I can get the handle of the other fixture
		                by using contact.other_fixture[ 42 ].
        bodies - A table containing the handles of the two bodies that made contact.
        other_body - Same as "other_fixture" but with body handles.
        touching - Whether the contact is touching or not.
        enabled - Whether the contact is enabled. You can actually change this value
                  only during the <on_pre_solve_contact> event.

        *Note:* You should not change bodies in any of the contact callbacks. Instead
        make a note of the event and change things after the step is done.
	*/

    callback on_begin_contact( table contact )
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->world->attach_body_callback( me , Physics::BEGIN_CONTACT , on_begin_contact );
        ]];

	/*
		Event: on_end_contact

		When two fixtures are no longer in contact. The contact details are the same as
		in <on_begin_contact>.
	*/

    callback on_end_contact( table contact )
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->world->attach_body_callback( me , Physics::END_CONTACT , on_end_contact );
        ]];

	/*
		Event: on_pre_solve_contact

		This callback is called after collision detection but before collision resolution. It
		lets you change the "enabled" property on the contact to affect behavior.

		The contact details are the same as in <on_begin_contact>.
	*/

    callback on_pre_solve_contact( table contact )
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->world->attach_body_callback( me , Physics::PRE_SOLVE_CONTACT , on_pre_solve_contact );
        ]];

	/*
		Event: on_post_solve_contact

	    This callback is called after collision resolution and gives you a chance to look at
	    the impulses generated by a collision.

	    The contact details are the same as in <on_begin_contact>.
	*/

    callback on_post_solve_contact( table contact )
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->world->attach_body_callback( me , Physics::POST_SOLVE_CONTACT , on_post_solve_contact );
        ]];
}

/*===========================================================================*/

	/*
		Global: physics

		The physics global lets you create bodies and run a physics simulation.
	*/

global physics [[ Physics::World * ]]
{
	physics()
		[[
            ClutterActor * screen = clutter_get_actor_by_gid( App::get( L )->get_screen_gid() );

			self = lb_construct( Physics::World , new Physics::World( L , screen , 64 ) );
		]];

	~physics()
		[[
			delete self;
		]];

	/*
		Property: pixels_per_meter

		Pixels per meter.
	*/

	double pixels_per_meter
        [[
            pixels_per_meter = self->ppm;
        ]]
        [[
            self->ppm = pixels_per_meter;
        ]];

	/*
		Property: gravity

		Gravity is a table with two values, one for X and another for Y. Either can be
		positive, negative or zero. Setting gravity to { 0 , 0 } means no gravity. A positive
		value for X will push objects to the right, negative to the left. Positive for Y
		will push objects down, negative will push them up.
	*/

    table gravity
        [[
            b2Vec2 g( self->get_world()->GetGravity() );
            lua_newtable( L );
            lua_pushnumber( L , g.x );
            lua_rawseti( L , -2 , 1 );
            lua_pushnumber( L , g.y );
            lua_rawseti( L , -2 , 2 );
        ]]
        [[
            luaL_checktype(L,2,LUA_TTABLE);
            lua_rawgeti( L , 2 , 1 );
            lua_rawgeti( L , 2 , 2 );
            b2Vec2 g( lua_tonumber( L , -2 ) , lua_tonumber( L , -1 ) );
            self->get_world()->SetGravity( g );
            lua_pop( L , 2 );
        ]];

	/*
		Property: auto_clear_forces

		Whether forces should be automatically cleared after each time step.
	*/

    bool auto_clear_forces
        [[
            auto_clear_forces = self->get_world()->GetAutoClearForces();
        ]]
        [[
            self->get_world()->SetAutoClearForces( auto_clear_forces );
        ]];

	/*
		Property: contacts

		A list of all current contacts in the whole physics world.
	*/

    readonly table contacts
        [[
            self->push_contact_list( self->get_world()->GetContactList() );
        ]];

	/*
		Property: running

		Whether the simulation is running.
	*/

    readonly bool running
        [[
            running = self->running();
        ]];

	/*
		Function: start

		Start the physics simulation with the given velocity and position
		iterations. For each step, the <on_step> callback will be called.
	*/

    start( int velocity_iterations = 10, int position_iterations = 10 )
        [[
            self->start( velocity_iterations , position_iterations );
        ]];

	/*
		Function: stop

		Stop the simulation. It can be started again with <start>.
	*/

	stop()
        [[
            self->stop();
        ]];

	/*
	THIS ONE SHOULD BE UNDOCUMENTED AS IT WILL BE DEPRECATED.
	*/

	step( double time_step = 1.0f/60.0f , int velocity_iterations = 10, int position_iterations = 10 )
		[[
            self->step( time_step , velocity_iterations , position_iterations );
		]];

	/*
		Function: clear_forces

		Clears all current forces.
	*/

	clear_forces()
        [[
            self->get_world()->ClearForces();
        ]];

	/*
		Function: draw_debug

		Draws a debug overlay that shows you bodies, fixtures, joints and other information. You
		need to call it after every step.
	*/

	draw_debug( int opacity = 127 )
        [[
            self->draw_debug( opacity );
        ]];

	/*
		Function: clear_debug

		Clears the debug overlay.
	*/

	clear_debug()
        [[
            self->clear_debug();
        ]];

	/*
	NOT IMPLEMENTED COMPLETELY
	*/

	table get_fixtures_in_rectangle( table top_left , table bottom_right )
        [[
            float32 x1;
	        float32 y1;
	        float32 x2;
	        float32 y2;

            lua_rawgeti( L , top_left , 1 );
            x1 = self->screen_to_world( lua_tonumber( L , -1 ) );
            lua_pop( L , 1 );
            lua_rawgeti( L , top_left , 2 );
            y1 = self->screen_to_world( lua_tonumber( L , -1 ) );
            lua_pop( L , 1 );

            lua_rawgeti( L , bottom_right , 1 );
            x2 = self->screen_to_world( lua_tonumber( L , -1 ) );
            lua_pop( L , 1 );
            lua_rawgeti( L , bottom_right , 2 );
            y2 = self->screen_to_world( lua_tonumber( L , -1 ) );
            lua_pop( L , 1 );

            b2AABB a;

            a.lowerBound.x = x1;
            a.lowerBound.y = y1;
            a.upperBound.x = x2;
            a.upperBound.y = y2;

            Physics::AABBQuery q( L );

            self->get_world()->QueryAABB( & q , a );

            // TODO: put results in a table.

            lua_pushnil( L );
        ]];

	/*
		Function: Body

		This function lets you create physics bodies. You pass an existing UIElement that
		is attached directly to the screen and a table of properties for the body.

		This call returns the same UIElement enhanced to provide all the functions
		and properties of a <Body>. If there is a problem, this call can return nil.

		*Note:* This moves the anchor point of the UIElement to its center.

		The "properties" table can include any of the properties of <Body>, such as
		its type. It can also have any of the properties of a fixture. A default
		fixture is always created and, if you do not include a "shape" for the
		fixture, a default rectangular shape is created that fits the dimensions of the
		entire UIElement.
	*/

	Body Body( UIElement element , table properties )
		[[
            lb_check_udata_type( L , element , "actor" );

            // Use default density of 1, because 0 is stupid
            lua_getfield( L , properties , "density" );
            if ( lua_isnil( L , -1 ) )
            {
                lua_pushnumber( L , 1.0 );
                lua_setfield( L , properties , "density" );
            }
            lua_pop( L , 1 );

            int n = self->create_body( element , properties , BODY_METATABLE );

            if ( ! n )
            {
                lua_pushnil( L );
            }
            else
            {
                ClutterUtil::set_props_from_table( L , properties );
            }
		]];

    #..........................................................................
    # Shape factory methods

	/*
		Function: Box

		Creates a box shape that can be used for fixtures.

		size - A table with width and height (in pixels) for the box.
		center - A table of X and Y coordinates relative to the body.
		rotation - The angle (in degrees) of the box along the Z axis relative to its center.
	*/

	Shape Box( table size , table center = 0 , double rotation = 0 )
        [[
            b2PolygonShape * shape = new b2PolygonShape();

            if ( ! center )
            {
                lua_rawgeti( L , size , 1 );
                lua_rawgeti( L , size , 2 );

                shape->SetAsBox( self->screen_to_world( lua_tonumber( L , -2 ) * 0.5 ) ,
                    self->screen_to_world( lua_tonumber( L , -1 ) * 0.5 ) );

                lua_pop( L , 2 );
            }
            else
            {
                lua_rawgeti( L , size , 1 );
                lua_rawgeti( L , size , 2 );

                lua_rawgeti( L , center , 1 );
                lua_rawgeti( L , center , 2 );

                shape->SetAsBox( self->screen_to_world( lua_tonumber( L , -4 ) * 0.5 ) ,
                        self->screen_to_world( lua_tonumber( L , -3 ) * 0.5 ),
                        b2Vec2( self->screen_to_world( lua_tonumber( L , -2 ) ),
                                self->screen_to_world( lua_tonumber( L , -1 ) ) ),
                        Physics::World::degrees_to_radians( rotation ) );

                lua_pop( L , 4 );
            }

            lua_pushlightuserdata( L , shape );

            new_Shape( L );

            lua_remove( L , -2 );
        ]];

	/*
		Function: Edge

		Creates an edge shape (a line) to be used for a fixture.
		You pass two tables, each with X and Y coordinates relative to the center of the body.
	*/

	Shape Edge( table point_a , table point_b )
        [[
            b2EdgeShape * shape = new b2EdgeShape();

            lua_rawgeti( L , point_a , 1 );
            lua_rawgeti( L , point_a , 2 );
            lua_rawgeti( L , point_b , 1 );
            lua_rawgeti( L , point_b , 2 );

            shape->Set( b2Vec2( self->screen_to_world( lua_tonumber( L , -4 ) ) ,
                    self->screen_to_world( lua_tonumber( L , -3 ) ) ),
                    b2Vec2( self->screen_to_world( lua_tonumber( L , -2 ) ) ,
                            self->screen_to_world( lua_tonumber( L , -1 ) ) ) );

            lua_pop( L , 4 );

            lua_pushlightuserdata( L , shape );

            new_Shape( L );

            lua_remove( L , -2 );
        ]];

	/*
		Function: Polygon

		Creates a polygon shape given a table of points, a table of tables, each with X and
		Y coordinates relative to the center of the body.

		*Note:* You should not specify more than 8 points and the resulting shape should be convex.
	*/

	Shape Polygon( table points )
        [[
            std::vector< b2Vec2 > p;

            lua_pushnil( L );

            while( lua_next( L , points ) )
            {
                if ( lua_istable( L , -1 ) )
                {
                    lua_rawgeti( L , -1 , 1 );
                    lua_rawgeti( L , -2 , 2 );

                    p.push_back(
                            b2Vec2( self->screen_to_world( lua_tonumber( L , -2 ) ) ,
                                    self->screen_to_world( lua_tonumber( L , -1 ) ) ) );

                    lua_pop( L , 2 );
                }
                lua_pop( L , 1 );
            }

            if ( p.empty() )
            {
                return luaL_error( L , "Invalid polygon points" );
            }

            b2PolygonShape * shape = new b2PolygonShape();

            shape->Set( & p[ 0 ] , p.size() );

            lua_pushlightuserdata( L , shape );
            new_Shape( L );
            lua_remove( L , -2 );
        ]];

	/*
		Function: Circle

		Creates a circular shape to be used for fixtures.

		radius - The radius of the circle (in pixels).
		center - A table of X and Y coordinates for the center of the circle relative
		          to the center of the body.
	*/

	Shape Circle( double radius , table center = 0 )
        [[
            b2CircleShape * shape = new b2CircleShape();

            shape->m_radius = self->screen_to_world( radius );

            shape->m_p.SetZero();

            if ( center )
            {
                lua_rawgeti( L , center , 1 );
                lua_rawgeti( L , center , 2 );

                shape->m_p.Set( self->screen_to_world( lua_tonumber( L , -2 ) ) ,
                        self->screen_to_world( lua_tonumber( L , -1 ) ) );

                lua_pop( L , 2 );
            }

            lua_pushlightuserdata( L , shape );

            new_Shape( L );

            lua_remove( L , -2 );
        ]];

    #..........................................................................

	/*
		Event: on_step

		This callback occurs every time the physics simulation completes a step. This
		will be at most every 1/60 of a second.

		seconds - The fractional number of seconds since on_step was last called.
	*/

    callback on_step( double seconds );

	/*
		Event: on_begin_contact

		Same as the the callback for each Body, but for the entire world.
	*/

	callback on_begin_contact( table contact )
        [[
            self->attach_global_callback( Physics::BEGIN_CONTACT , on_begin_contact );
        ]];

	/*
		Event: on_end_contact

        Same as the the callback for each Body, but for the entire world.
	*/

    callback on_end_contact( table contact )
        [[
            self->attach_global_callback( Physics::END_CONTACT , on_end_contact );
        ]];

	/*
		Event: on_pre_solve_contact

        Same as the the callback for each Body, but for the entire world.
	*/

    callback on_pre_solve_contact( table contact )
        [[
            self->attach_global_callback( Physics::PRE_SOLVE_CONTACT , on_pre_solve_contact );
        ]];

	/*
		Event: on_post_solve_contact

        Same as the the callback for each Body, but for the entire world.
	*/

    callback on_post_solve_contact( table contact )
        [[
            self->attach_global_callback( Physics::POST_SOLVE_CONTACT , on_post_solve_contact );
        ]];

    /*
        Property: z_for_y

        When set to true, the physics simulation treats the UIElement's z as its y.
    */

    bool z_for_y
        [[
            z_for_y = self->z_for_y;
        ]]
        [[
            self->z_for_y = z_for_y;
        ]];
}

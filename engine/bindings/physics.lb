
module physics_module;

[[
#include "Box2D/Box2D.h"
#define CLUTTER_VERSION_MIN_REQUIRED CLUTTER_VERSION_CUR_STABLE
#include "clutter/clutter.h"

#include "physics.h"
#include "clutter_util.h"
#include "util.h"
]]

/*===========================================================================*/
/*
    Title: The physics Global Variable and Body Interface

The physics global variable places one or more UIElement-based objects in a two-dimensional environment where they are affected by physics-based forces, such as gravity and collisions.

The physics global variable maintains the physics-based simulation. Similar to the way that objects are added to the screen global variable to show the object on the display, objects are added to the physics variable to place them within the physics world.

Objects added to the physics variable are based on the UIElement interface, such as the Rectangle and Image classes. Before being added to the physics environment, however, the object is enhanced to include the properties, functions and event handlers of the Body interface. The Body interface provides physics-related settings and operations to enable the object to operate within the physics environment.

When the physics world has been configured and the desired objects added to it, the physics simulation can begin by calling the variable's start() function.

The simple program listing below creates two Rectangle objects: a dynamic object that will be affected by the physics forces placed upon it and an immobile static object that acts as a ground foundation. As gravity pulls the dynamic object down, the Rectangle falls until it lands on the static ground object.

    (code)
    -- Basic 2D Physics Application

    -- Create a simple rectangle and add it to the screen
    local gBox01 = Rectangle( {
                        size     = { 100, 100 },
                        position = { (screen.width / 2) - 50, (screen.height / 4) - 50 },
                        color    = "SaddleBrown",
    } )
    screen:add( gBox01 )

    -- Make the rectangle a dynamic object, i.e., affected by physics; use default Body settings
    gBox01 = physics:Body( gBox01, { } )

    -- Create a ground so the rectangle doesn't fall off the screen
    local gGround = Rectangle( {
                        size     = { screen.width / 2, 2 },
                        position = { screen.width / 4, screen.height - (screen.height / 4) },
                        color    = "AntiqueWhite",
    } )
    screen:add( gGround )

    -- Make the ground an immobile static object in the physics world
    gGround = physics:Body( gGround, { type = "static" } )

    -- Show the screen
    screen:show()

    -- Start the physics simulation
    physics:start()
    (end)


*/

/*
    InternalInterface: Shape

    The Shape interface is used internally by the Box2D physics engine. It is used to specify the shape of a fixture that is attached to a Body. Shapes can be created by calling the physics global variable's Box(), Edge(), Polygon() and Circle() functions. The Shape object is assigned to the fixture by passing it to the Body interface's add_fixture() function.

*/

interface Shape [[ b2Shape * ]]
{
    Shape()
        [[
            self = lb_construct( b2Shape , lua_touserdata( L , -2 ) );
        ]];

    ~Shape()
        [[
            delete self;
        ]];
}

/*===========================================================================*/

/*
    Interface: Body

The Body interface provides properties, functions and event handlers that define physics-related characteristics that can be applied to a <UIElement>-based object, such as a Rectangle or Image object.

The Body characteristics are defined as an Interface, so it is not possible to create an object of type Body. Instead, the Body characteristics are added to an existing UIElement-based object by calling the Body() function of the <physics> global variable. For complete details, refer to the description of the <physics.Body> function.

*/

interface Body [[ ClutterActor * ]]
{

/***************************************
    Property: handle

    The handle property contains an integer value that uniquely identifies the Body/UIElement object. The handle identifier is assigned automatically to the object when the Body is created by the Body() function of the physics global variable. It is referenced in the various collision-detection event handlers, including those for the on_begin_contact and on_end_contact events.

    *Default Setting:* a unique integer value

    *See Also:* the <physics.Body> function and <on_begin_contact> event
*/

    readonly int handle
        [[
            Physics::Body * me = Physics::Body::get( self );
            handle = me->handle;
        ]];

/***************************************
    Property: type

    The type property is a string specifying whether the Body is static, dynamic or kinematic.

    *Supported Settings:* The type setting is case-sensitive.

    "static" - the body is solid and unmovable when colliding with other objects
    "dynamic" - moves according to the forces placed upon it, such as gravity and collisions. Is affected when colliding into static and kinematic objects.
    "kinematic" - moves according to its velocity, but is not affected by other forces, such as gravity and collisions. Is not affected when colliding into static and dynamic objects.

    *Default Setting:* "dynamic"
*/

    string type
        [[
            Physics::Body * me = Physics::Body::get( self );
            switch( me->body->GetType() )
            {
                case b2_staticBody:
                    type = "static";
                    break;

                case b2_kinematicBody:
                    type = "kinematic";
                    break;

                case b2_dynamicBody:
                    type = "dynamic";
                    break;

                default:
                    type = 0;
                    break;
            }
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            if ( ! type )
            {
                luaL_error( L , "Invalid body type" );
            }
            else
            {
                if ( ! strcmp( type , "static" ) )
                {
                    me->body->SetType( b2_staticBody );
                }
                else if ( ! strcmp( type , "kinematic" ) )
                {
                    me->body->SetType( b2_kinematicBody );
                }
                else if ( ! strcmp( type , "dynamic" ) )
                {
                    me->body->SetType( b2_dynamicBody );
                }
                else
                {
                    luaL_error( L , "Invalid body type '%s'" , type );
                }
            }
        ]];

/***************************************
    Property: awake

    The awake property is a boolean flag indicating whether the Body/UIElement object is awake or sleeping (true=awake). An awake object participates in the physics simulation; a sleeping object does not participate. Making objects sleep reduces the computational requirements of the physics simulation.

    When an object is no longer in motion, it can be placed automatically in a sleeping state by setting the object's <sleeping_allowed> property to true. If a collision occurs or a force is applied to the object, it will wake up automatically and be included in the physics simulation. Alternatively, an object can be forced awake by setting its awake property to true.

    To force an object not to participate in the physics simulation in all situations, including collisions, use the <active> property.

    *Default Setting:* true

    *See Also:* the <sleeping_allowed> and <active> properties
*/

    bool awake
        [[
            Physics::Body * me = Physics::Body::get( self );
            awake = me->body->IsAwake();
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );
            me->body->SetAwake( awake );
        ]];

/***************************************
    Property: active

    The active property is a boolean flag indicating whether or not the Body/UIElement object is active in the physics simulation (true=active). An active object participates in the physics simuation; an inactive object does not participate. Making an object inactive reduces the computational requirements of the physics simulation.

    Unlike objects that are sleeping, an inactive object never becomes active automatically, even in collision situations. To make an inactive object active, the active property must be set explicitly.

    *Default Setting:* true

    *See Also:* the <awake> property
*/

    bool active
        [[
            Physics::Body * me = Physics::Body::get( self );
            active = me->body->IsActive();
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );
            me->body->SetActive( active );
        ]];

/***************************************
    Property: position

    The position property is a table that contains the current X,Y screen coordinates of the center of the Body/UIElement object. The coordinates are of data type double.

    *Default Setting:* { X, Y } coordinates of the object's center at the time the Body is created

    *See Also:* the <x>, <y>, <z> and <depth> properties
*/

    table position
        [[
            Physics::Body * me = Physics::Body::get( self );

            const b2Vec2 & pos( me->body->GetPosition() );

            lua_newtable( L );
            lua_pushnumber( L , me->world->world_to_screen( pos.x ) );
            lua_rawseti( L , -2 , 1 );
            lua_pushnumber( L , me->world->world_to_screen( pos.y ) );
            lua_rawseti( L , -2 , 2 );
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            lua_rawgeti( L , 2 , 1 );
            lua_rawgeti( L , 2 , 2 );

            const b2Vec2 pos( me->world->screen_to_world( lua_tonumber( L , -2 ) ) ,
                    me->world->screen_to_world( lua_tonumber( L , -1 ) ) );

            lua_pop( L , 2 );

            me->body->SetTransform( pos , me->body->GetAngle() );

            me->synchronize_actor();
        ]];

/***************************************
    Property: x

    The x property specifies the Body/UIElement object's screen position along the X axis.

    *Default Setting:* 0

    *See Also:* the <y>, <z> and <position> properties
*/

    double x
        [[
            Physics::Body * me = Physics::Body::get( self );

            const b2Vec2 & pos( me->body->GetPosition() );

            x = me->world->world_to_screen( pos.x );
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            b2Vec2 pos( me->body->GetTransform().p );

            pos.x = me->world->screen_to_world( x );

            me->body->SetTransform( pos , me->body->GetAngle() );

            me->synchronize_actor();
        ]];

/***************************************
    Property: y

    The y property specifies the Body/UIElement object's screen position along the Y axis.

    The physics variable maintains a two-dimensional environment that uses the X/Y plane by default. A program can alternatively use the X/Z plane; refer to the physics variable's z_for_y property for details.

    *Default Setting:* 0

    *See Also:* the <x>, <z>, <position> and <physics.z_for_y> properties
*/

    double y
        [[
            Physics::Body * me = Physics::Body::get( self );

            if ( me->world->z_for_y )
            {
                y = clutter_actor_get_y( self );
            }
            else
            {
                const b2Vec2 & pos( me->body->GetPosition() );

                y = me->world->world_to_screen( pos.y );
            }
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            if ( me->world->z_for_y )
            {
                clutter_actor_set_y( self , y );
            }
            else
            {
                b2Vec2 pos( me->body->GetTransform().p );

                pos.y = me->world->screen_to_world( y );

                me->body->SetTransform( pos , me->body->GetAngle() );

                me->synchronize_actor();
            }
        ]];

/***************************************
    Property: z

    The z property specifies the Body/UIElement object's screen position along the Z axis.

    The two-dimensional environment maintained by the physics variable does not normally use the Z axis; instead, the physics simulation occurs entirely on the X/Y plane. A program can, however, substitute the X/Z plane for the X/Y plane, causing the physics simulation to occur in depth. Refer to the physics variable's z_for_y property for details.

    *Default Setting:* 0

    *See Also:* the <x>, <y>, <depth> and <physics.z_for_y> properties
*/

    double z
        [[
            Physics::Body * me = Physics::Body::get( self );

            if ( ! me->world->z_for_y )
            {
                z = clutter_actor_get_depth( self );
            }
            else
            {
                const b2Vec2 & pos( me->body->GetPosition() );

                z = me->world->world_to_screen( pos.y );
            }
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            if ( ! me->world->z_for_y )
            {
                clutter_actor_set_depth( self , z );
            }
            else
            {
                b2Vec2 pos( me->body->GetTransform().p );

                pos.y = me->world->screen_to_world( z );

                me->body->SetTransform( pos , me->body->GetAngle() );

                me->synchronize_actor();
            }
        ]];

/***************************************
    Property: depth

    The depth property is equivalent to the <z> property; it specifies the Body/UIElement object's screen position along the Z axis. Refer to the description of the <z> property for further details.

    *See Also:* the <x>, <y>, and <z> properties
*/

    double depth
        [[
            Physics::Body * me = Physics::Body::get( self );

            if ( ! me->world->z_for_y )
            {
                depth = clutter_actor_get_depth( self );
            }
            else
            {
                const b2Vec2 & pos( me->body->GetPosition() );

                depth = me->world->world_to_screen( pos.y );
            }
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            if ( ! me->world->z_for_y )
            {
                clutter_actor_set_depth( self , depth );
            }
            else
            {
                b2Vec2 pos( me->body->GetTransform().p );

                pos.y = me->world->screen_to_world( depth );

                me->body->SetTransform( pos , me->body->GetAngle() );

                me->synchronize_actor();
            }
        ]];

/***************************************
    Property: angle

    The angle property specifies the object's rotation in degrees about the Z axis.

    If the physics variable's z_for_y property is true, the object rotates about the Y axis.

    *Default Setting:* 0

    *See Also:* the <rotation> and <physics.z_for_y> properties
*/

    double angle
        [[
            Physics::Body * me = Physics::Body::get( self );
            angle = Physics::World::radians_to_degrees( me->body->GetAngle() );
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            b2Vec2 pos( me->body->GetTransform().p );

            me->body->SetTransform( pos , Physics::World::degrees_to_radians( angle ) );

            me->synchronize_actor();
        ]];

/***************************************
    Property: rotation

    The rotation property is equivalent to the <angle> property; it specifies the object's rotation in degrees about the Z axis. Refer to the <angle> property for details.

    *See Also:* the <angle> property
*/

    double rotation
        [[
            Physics::Body * me = Physics::Body::get( self );
            rotation = Physics::World::radians_to_degrees( me->body->GetAngle() );
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            b2Vec2 pos( me->body->GetTransform().p );

            me->body->SetTransform( pos , Physics::World::degrees_to_radians( rotation ) );

            me->synchronize_actor();
        ]];

/***************************************
    Property: world_center

    The world_center property is a table containing the { X, Y } coordinates of the center position of the object's mass in the physics environment. Depending on the number of fixtures attached to a Body and each fixture's density, the center of the object's mass may differ from its screen position, which is based on the center of its Body.

    *Format:* { center-of-mass X coordinate, center-of-mass Y coordinate } where each coordinate is relative to the physics environment

    *See Also:* the <local_center> and <position> properties
*/

    readonly table world_center
        [[
            Physics::Body * me = Physics::Body::get( self );
            const b2Vec2 pos( me->body->GetWorldCenter() );
            lua_newtable( L );
            lua_pushnumber( L , me->world->world_to_screen( pos.x ) );
            lua_rawseti( L , -2 , 1 );
            lua_pushnumber( L , me->world->world_to_screen( pos.y ) );
            lua_rawseti( L , -2 , 2 );
        ]];

/***************************************
    Property: local_center

    The local_center property is a table containing the { X, Y } coordinates of the center position of the object's mass relative to the center of its Body. Depending upon the number of fixtures attached to a Body and each fixture's density, the center of the object's mass may differ from the center of its Body.

    *Format:* { center-of-mass X coordinate, center-of-mass Y coordinate } where each coordinate is relative to the center of the object's Body

    *See Also:* the <world_center> and <position> properties
*/

    readonly table local_center
        [[
            Physics::Body * me = Physics::Body::get( self );
            const b2Vec2 pos( me->body->GetLocalCenter() );
            lua_newtable( L );
            lua_pushnumber( L , me->world->world_to_screen( pos.x ) );
            lua_rawseti( L , -2 , 1 );
            lua_pushnumber( L , me->world->world_to_screen( pos.y ) );
            lua_rawseti( L , -2 , 2 );
        ]];

/***************************************
    Property: linear_velocity

    The linear_velocity property is a table containing the amount of continuous linear velocity to apply along the X and/or Y axis.

    Negative X values push the object to the left; positive X values push it to the right. Negative Y values push the object up; positive Y values push it down.

    To apply a temporary force upon an object, call the <apply_force> function.

    *Format:* { X-axis velocity, Y-axis velocity }

    *Code Example:* Apply a linear_velocity force to an object to push it up

        (code)
        gBox01.linear_velocity = { 0, -10 }
        (end)

    *See Also:* the <linear_damping> and <angular_velocity> properties and the <apply_force> function
*/

    table linear_velocity
        [[
            Physics::Body * me = Physics::Body::get( self );

            b2Vec2 lv( me->body->GetLinearVelocity() );

            lua_newtable( L );
            lua_pushnumber( L , lv.x );
            lua_rawseti( L , -2 , 1 );
            lua_pushnumber( L , lv.y );
            lua_rawseti( L , -2 , 2 );
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            lua_rawgeti( L , 2 , 1 );
            lua_rawgeti( L , 2 , 2 );

            me->body->SetLinearVelocity( b2Vec2( lua_tonumber( L , -2 ) , lua_tonumber( L , -1 ) ) );
            lua_pop( L , 2 );
        ]];

/***************************************
    Property: angular_velocity

    The angular_velocity property is a double value specifying the object's continuous rotation in degrees about the Z-axis.

    Positive values rotate in a clockwise direction; negative values rotate counter-clockwise.

    To apply a temporary rotational torque to the object, call the <apply_torque> function.

    *See Also:* the <angular_damping> and <linear_velocity> properties and the <apply_torque> function
*/

    double angular_velocity
        [[
            Physics::Body * me = Physics::Body::get( self );

            angular_velocity = Physics::World::radians_to_degrees( me->body->GetAngularVelocity() );
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->body->SetAngularVelocity( Physics::World::degrees_to_radians( angular_velocity ) );
        ]];

/***************************************
    Property: mass

    The mass property specifies the mass of the object. Mass is calculated automatically and depends on the density of the fixture(s) attached to the Body object.

    *See Also:* the <add_fixture> function
*/

    readonly double mass
        [[
            Physics::Body * me = Physics::Body::get( self );

            mass = me->body->GetMass();
        ]];

/***************************************
    TODO: mass_data
*/

/***************************************
    Property: linear_damping

    The linear_damping property specifies the damping factor to apply to the object's linear velocity. The range of valid settings is 0 to infinity, but common settings are between 0.0 and 0.1.

    *Default Setting:* 0.0

    *See Also:* the <linear_velocity> property
*/

    double linear_damping
        [[
            Physics::Body * me = Physics::Body::get( self );

            linear_damping = me->body->GetLinearDamping();
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->body->SetLinearDamping( linear_damping );
        ]];

/***************************************
    Property: angular_damping

    The angular_damping property specifies the damping factor to apply to the object's angular velocity. The range of valid settings is 0 to infinity, but common settings are between 0.0 and 0.1.

    *Default Setting:* 0.0

    *See Also:* the <angular_velocity> property
*/

    double angular_damping
        [[
            Physics::Body * me = Physics::Body::get( self );

            angular_damping = me->body->GetAngularDamping();
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->body->SetAngularDamping( angular_damping );
        ]];

/***************************************
    Property: bullet

    The bullet property is a boolean flag indicating whether or not the object should be processed as a fast-moving bullet (true=is bullet).

    A fast-moving object can move a long distance between steps of the physics simulation. Because of this speed, it's possible for the object to pass through other objects between physics simulation steps without a collision being detected. This passing-through is called "tunneling." To prevent tunneling, the fast-moving object should be flagged as a "bullet" to enable "continuous collision detection" (CCD). With CCD enabled, collisions are detected for even fast-moving objects. Increasing collision checking requires additional computational processing, so it should be enabled for fast-moving objects only. For performance reasons, CCD is disabled by default.

    The bullet property affects Body objects of type "dynamic" only.

    *Default Setting:* false
*/

    bool bullet
        [[
            Physics::Body * me = Physics::Body::get( self );

            bullet = me->body->IsBullet();
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->body->SetBullet( bullet );
        ]];

/***************************************
    Property: sleeping_allowed

    The sleeping_allowed property is a boolean flag indicating whether or not an object that has stopped moving can enter a sleep mode in which the object can be temporarily removed from the physics simulation so as to improve performance (true=sleeping allowed). The object will exit sleep mode automatically if it is involved in a collision or a force is applied to it.

    *Default Setting:* true

    *See Also:* the <awake> property
*/

    bool sleeping_allowed
        [[
            Physics::Body * me = Physics::Body::get( self );

            sleeping_allowed = me->body->IsSleepingAllowed();
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->body->SetSleepingAllowed( sleeping_allowed );
        ]];

/***************************************
    Property: fixed_rotation

    The fixed_rotation property is a boolean flag indicating whether or not an off-center collision will cause the body to rotate about its Z axis (true=will not rotate).

    Note: Setting an angular_velocity can still cause the object to rotate, regardless of the fixed_rotation setting.

    *Default Setting:* false, i.e., off-center collisions will cause the object to rotate

    *See Also:* the <angular_velocity> property
*/

    bool fixed_rotation
        [[
            Physics::Body * me = Physics::Body::get( self );

            fixed_rotation = me->body->IsFixedRotation();
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->body->SetFixedRotation( fixed_rotation );
        ]];

/***************************************
    Property: contacts

    The contacts property is a read-only table containing an entry for each contact that currently exists for all the fixtures attached to the Body. If no contacts exist, the contacts property is nil.

    For complete information about the contacts property, refer to the description of the <physics.contacts> property.

    *Default Setting:* nil

    *Code Example:*

        (code)
        -- Display the complete contents of an object's contacts table
        if( Object.contacts ~= nil )then
            dumptable( Object.contacts )
        end
        (end)

    *See Also:* the <physics.contacts> and <handle> properties, the <add_fixture> function, and the <on_pre_solve_contact> event
*/

    readonly table contacts
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->world->push_contact_list( me->body->GetContactList() );
        ]];

/***************************************
    Function: synchronize

    The synchronize() function forces the Body's position and rotation to match that of its related UIElement-based object.

    The synchronize() function may alter the following Body properties: <x>, <y>, <position>, <angle> and <rotation>.

    *Return Value:* None

    *See Also:* the <x>, <y>, <position>, <angle> and <rotation> properties
*/

    synchronize( )
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->synchronize_body();
        ]];

/***************************************
    Function: apply_force

    The apply_force() function applies a temporary directional force on an object.

    Applying force on an object is similar to setting the object's <linear_velocity>, but linear velocity is continuous and always applied to the center of the object's mass, while force is temporary and can be applied to any X,Y coordinate. If force is applied anywhere other than the center of the object's mass, a torque is created which may cause the object to rotate.

    *Arguments:*

        force - table containing the amount of force to apply along the X and Y axes. The format is { X-axis-force, Y-axis-force }. A negative X-axis force pushes the object to the left; positive X-axis force pushes to the right. A negative Y-axis force pushes the object up; a positive Y-axis force pushes the object down.
        point - table of { X, Y } coordinates at which to apply the force

    *Code Example:*

        (code)
        -- Use force to push object up
        gObject:apply_force( { 0, -500 }, { gObject.x, gObject.y } )

        -- Use force to push object right
        gObject:apply_force( { 100, 0 }, { gObject.x, gObject.y } )

        -- Apply an off-center, upward force, creating torque and causing the object to rotate
        gObject:apply_force( { 0, -500 }, { gObject.x - 10, gObject.y } )
        (end)

    *See Also:* the <linear_velocity> property
*/

    apply_force( table force, table point )
        [[
            Physics::Body * me = Physics::Body::get( self );

            lua_rawgeti( L , force , 1 );
            lua_rawgeti( L , force , 2 );

            lua_rawgeti( L , point , 1 );
            lua_rawgeti( L , point , 2 );

            me->body->ApplyForce(
                b2Vec2( lua_tonumber( L , -4 ) , lua_tonumber( L , -3 ) ) ,
                b2Vec2( me->world->screen_to_world( lua_tonumber( L , -2 ) ),
                        me->world->screen_to_world( lua_tonumber( L , -1 ) ) ) );

            lua_pop( L , 4 );
        ]];

/***************************************
    Function: apply_torque

    The apply_torque() function applies a temporary torque upon the object, which, depending upon other forces, can cause the object to rotate.

    Applying torque on an object is similar to setting the object's <angular_velocity>, but angular velocity is continuous, while torque is temporary.

    *Arguments:*

        torque - double value specifying the amount of torque to apply on the object. A positive value applies a clockwise torque; a negative value applies a counter-clockwise torque.

    *See Also:* the <angular_velocity> property and <apply_angular_impulse> function
*/

    apply_torque( double torque )
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->body->ApplyTorque( torque );
        ]];

/***************************************
    Function: apply_linear_impulse

    The apply_linear_impulse() function applies a temporary, directional force to the object.

    Applying a linear impulse on an object is similar to applying a force using the <apply_force> function, but a linear impulse is a sharp and sudden force, like a hammer hitting an object, while the force used in apply_force() is a steady pressure, like a person pushing an automobile.

    If a linear impulse is applied anywhere other than the center of the object's mass, a torque is created which may cause the object to rotate.

    *Arguments:*

        force - table containing the amount of impulse to apply along the X and Y axes. The format is { X-axis-impulse, Y-axis-impulse }. A negative X-axis impulse pushes the object to the left; positive X-axis impulse pushes to the right. A negative Y-axis impulse pushes the object up; a positive Y-axis impulse pushes the object down.
        point - table of { X, Y } coordinates at which to apply the impulse

    *Code Example:*

        (code)
        -- Use impulse to push object up
        gObject:apply_force( { 0, -5 }, { gObject.x, gObject.y } )

        -- Use force to push object right
        gObject:apply_force( { 100, 0 }, { gObject.x, gObject.y } )

        -- Apply an off-center, upward force, creating torque and causing the object to rotate
        gObject:apply_force( { 0, -500 }, { gObject.x - 10, gObject.y } )
        (end)

    *See Also:* the <apply_force> function
*/

    apply_linear_impulse( table force, table point )
        [[
            Physics::Body * me = Physics::Body::get( self );

            lua_rawgeti( L , force , 1 );
            lua_rawgeti( L , force , 2 );

            lua_rawgeti( L , point , 1 );
            lua_rawgeti( L , point , 2 );

            me->body->ApplyLinearImpulse(
                    b2Vec2( lua_tonumber( L , -4 ) , lua_tonumber( L , -3 ) ) ,
                    b2Vec2( me->world->screen_to_world( lua_tonumber( L , -2 ) ),
                          me->world->screen_to_world( lua_tonumber( L , -1 ) ) ) );

            lua_pop( L , 4 );
        ]];

/***************************************
    Function: apply_angular_impulse

    The apply_angular_impulse() function applies a temporary torque upon the object, which, depending upon other forces, can cause the object to rotate.

    Applying an angular impulse upon an object is similar to setting the object's <angular_velocity>, but angular velocity is continuous, while angular impulse is temporary.

    Angular impulse is also similar to torque, as set by the <apply_torque> function, but angular impulse is a sharp and sudden force, like a hammer striking the object; a torque is a steady pressure, like a person pushing a heavy crate.

    *Arguments:*

        impulse - double value specifying the amount of angular impulse to apply upon the object. A positive value applies a clockwise impulse; a negative value applies a counter-clockwise impulse.

    *See Also:* the <angular_velocity> property and <apply_torque> function
*/

    apply_angular_impulse( double impulse )
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->body->ApplyAngularImpulse( impulse );
        ]];


#===============================================================================
    # Fixtures

/***************************************
    Property: fixtures

    The fixtures property is a read-only table containing an entry for each fixture attached to the Body. A Body object must have one or more fixtures attached to it. Each fixture defines one part of the Body, including its shape, size, density, and other characteristics. When a Body object is created by the <physics.Body> function, a fixture can be specified in the function's arguments. Additional fixtures can be attached to the object by calling the <add_fixture> function.

    Each fixture entry contains the keys shown below.

        handle - unique integer ID value assigned to the fixture. The ID value is generated automatically when the fixture is created by the <add_fixture> function.
        type - string specifying the fixture type. Supported strings are "circle" and "polygon". The string is "circle" if the fixture was created using the <physics.Circle> function. Fixtures of all other shapes have type strings of "polygon."
        density - double value specifying how heavy the fixture is in relation to its area
        friction - double value specifying how slippery the fixture is
        bounce - double value specifying the fixture's springiness or level of rebound when a collision occurs
        sensor - boolean flag indicating whether or not the fixture is a sensor (true=sensor)
        filter - table containing the settings of the collision-filter keys "group", "category" and "mask". Refer to the <add_fixture> function for information about the collision filter.

    *Code Examples:* To access the property for a particular fixture entry in the fixtures table, use the following syntax.

        (code)
        -- Retrieve the density setting for the object's first fixture
        objDensity = bodyObj.fixtures[ 1 ].density
        (end)

    *See Also:* the <add_fixture> and <physics.Body> functions
*/

    readonly table fixtures
        [[
            Physics::Body * me = Physics::Body::get( self );

            lua_newtable( L );
            int t = lua_gettop( L );
            int i = 1;

            for( b2Fixture * f = me->body->GetFixtureList(); f ; f = f->GetNext() , ++i )
            {
                lua_newtable( L );

                lua_pushinteger( L , GPOINTER_TO_INT( f->GetUserData() ) );
                lua_setfield( L , -2 , "handle" );

                switch( f->GetType() )
                {
                    case b2Shape::e_circle:
                        lua_pushstring( L , "circle" );
                        break;

                    case b2Shape::e_polygon:
                        lua_pushstring( L , "polygon" );
                        break;

                    default:
                        lua_pushnil( L );
                }

                lua_setfield( L , -2 , "type" );

                lua_pushboolean( L , f->IsSensor() );
                lua_setfield( L , -2 , "sensor" );

                lua_pushnumber( L , f->GetDensity() );
                lua_setfield( L , -2 , "density" );

                lua_pushnumber( L , f->GetFriction() );
                lua_setfield( L , -2 , "friction" );

                lua_pushnumber( L , f->GetRestitution() );
                lua_setfield( L , -2 , "bounce" );

                // We are going to create a sub-table for the filter
                const b2Filter & filter = f->GetFilterData();

                lua_newtable( L );

                lua_pushinteger( L, filter.groupIndex );
                lua_setfield( L, -2, "group" );

                lua_pushinteger( L, filter.categoryBits );
                Util::convert_bitmask_to_table( L );
                lua_setfield( L, -2, "category" );

                lua_pushinteger( L, filter.maskBits );
                Util::convert_bitmask_to_table( L );
                lua_setfield( L, -2, "mask" );

                lua_setfield( L, -2, "filter" );

                lua_rawseti( L , t , i );
            }
        ]];

/***************************************
    Function: remove_fixture()

    The remove_fixture() function detaches a specified fixture from the Body object.

    After a fixture is removed, its old property values become invalid and undefined; if an application has references or variables to the removed fixture, it should not access them or assume they are still at their previous settings.

    *Arguments:*

        fixture_handle - handle of the fixture to remove. The fixture handle is returned by the <add_fixture> function that created the fixture.

    *Return Value:* Boolean flag indicating the operation's success or failure (true=fixture was removed)

    *See Also:* the <fixtures> property and <add_fixture> and <remove_all_fixtures> functions
*/

    bool remove_fixture( int fixture_handle )
        [[
            Physics::Body * me = Physics::Body::get( self );

            result = false;

            for( b2Fixture * f = me->body->GetFixtureList(); f ; f = f->GetNext() )
            {
                if ( GPOINTER_TO_INT( f->GetUserData() ) == fixture_handle )
                {
                    result = true;
                    f->GetBody()->DestroyFixture( f );
                    break;
                }
            }
        ]];

/***************************************
    Function: remove_all_fixtures

    The remove_all_fixtures() function detaches all fixtures currently attached to the Body object.

    After a fixture is removed, its old property values become invalid and undefined; if an application has references or variables to the removed fixture, it should not access them or assume they are still at their previous settings.

    Note: The fixtures attached to a Body object provide it with its size and mass. Without fixtures, a Body has no substance and, thus, cannot collide with other objects in the physics environment.

    *Arguments:* None

    *Return Value:* None

    *See Also:* the <add_fixture> and <remove_fixture> functions
*/

    remove_all_fixtures()
        [[
            Physics::Body * me = Physics::Body::get( self );

            for( b2Fixture * f = me->body->GetFixtureList(); f ; )
            {
                b2Fixture * next = f->GetNext();

                f->GetBody()->DestroyFixture( f );

                f = next;
            }

        ]];

/***************************************
    Function: add_fixture

    The add_fixture() function creates a new fixture and attaches it to the Body object. The new fixture is automatically assigned a unique integer handle, which is returned by the function. Other properties of the fixture can be defined in a table passed to the function.

    *Argument:*

        properties - table of key/value pairs that define the fixture's properties. Supported keys are described below.

    *Supported Property Keys:*

        The properties argument can include any of these keys.

        shape - a Shape object specifying the fixture's shape. A Shape object is returned by the Box(), Edge(), Polygon() and Circle() functions of the <physics> global variable. A single Shape object can be used to create multiple fixtures, provided the Shape's properties are identical for each fixture. Default value: A Box shape large enough to surround the entire object.
        density - double value specifying the heaviness of the fixture in relation to its area. Valid Range: 0(no density) to infinity(maximum density). Default: 1.0
        friction - double value specifying how slippery the fixture is. Valid Range: 0.0(very slippery) to 1.0(not slippery). Default: 0.2
        bounce - double value specifying the fixture's springiness or level of rebound when a collision occurs. Valid Range: 0.0(not springy) to 1.0(maximum springiness). Default: 0.0
        sensor - boolean flag indicating whether or not the fixture is a sensor (true=sensor). A sensor can share space with another object without colliding into it, such as in a top-down view of a bird flying over a tree. Although collisions do not occur, the sensor still generates contact-type events when it overlaps other fixtures in the physics simulation. Default: false
        filter - collision filtering. For details, refer to the explanation below.

    *Return Value:* Unique integer fixture handle

    *Collision Filtering:*

        Collisions occur between fixtures, not between Body objects. By default, a fixture will collide with all other fixtures. Alternatively, if a fixture's sensor property is true, then the fixture will not collide with any fixtures. Beyond these "all or nothing" conditions, collisions can be more finely tuned by defining a filter property in the add_fixture() function's argument.

        The filter property is a table with the following keys.

            group - signed integer specifying the fixture's group. Default: 0
            category - integer or table of integers specifying the fixture's category ID(s). Valid Range: 0-15. Normally, a fixture belongs to only a single category, but it's possible to place the fixture in multiple categories by specifying the category IDs in the table of integers. Default: 0.
            mask - integer or table of integers specifying the categories the fixture will collide with. A category is specified by its ID. Valid Range: 0-15. To indicate that the fixture should not collide with any fixture, specify an empty table (not a value of 0). Default: 0xFFFF (i.e., fixture will collide with all other fixtures).

        The category and mask keys work together to determine whether or not two touching or overlapping objects are colliding. The category setting identifies the fixture's category (or categories). The mask setting specifies the categories that the fixture will collide with. An example setting is shown below.

        (code)
        -- Create a fixture in category 3 that will collide with fixtures in categories 3 and 5
        gObj01:add_fixture( { filter = { category = 3, mask = { 3, 5 } } } )

        -- Equivalent settings, but performed when the Body is added to a UIElement object. This will
        -- automatically attach a fixture to the Body. The fixture can be initialized at this point, as well.
        gObj02:Body( gObj02, { filter = { category = 3, mask = { 3, 5 } } } )
        (end)

        In order for two touching objects to collide, the category and mask collision determination must be true *for both objects.* For example, assume two objects exist, where one is in category 1 and the other is in category 2. The first is initialized to collide with objects in categories 1 and 2 (i.e., its mask is set to { 1, 2 }), so it will collide with the second object. The second object is initialized to collide with objects in category 2 only (its mask is set to 2), so it will not collide with the first object. If the two objects touch, a collision does *not* occur because both objects do not arrive at a positive collision determination (the first can collide, but the second cannot).

        The group key is a signed integer value that can be used to organize objects that should either always collide or never collide. If the group key conditions are met, then the group overrides any category and mask settings. The rules for determining collisions between two objects when using the group key are shown below.

        - If the group key for either object is 0 then the category/mask settings are used to determine the collision
        - If the group keys for both objects are different, the category/mask settings determine collision
        - If the group keys for both objects are the same and positive, the objects collide
        - If the group keys for both objects are the same and negative, the objects never collide

        (code)
        -- Create a fixture that will never collide with other objects in its group
        gObj01:add_fixture( { filter = { group = -1 } } )

        -- Add a Body to a UIElement object. Define the associated fixture to always collide with
        -- other objects in its group.
        gObj02:Body( gObj02, { filter = { group = 1 } } )
        (end)

        A Body/UIElement object may have multiple fixtures, and these fixtures can overlap each other. Collisions between fixtures are determined on an individual basis. For example, assume a Body object with multiple fixtures that do not overlap. One of the object's fixtures makes contact with another object's fixture. The collision determination is dependent upon the two touching fixtures only; the other fixtures are irrelevant.

        Now assume a Body object with two fixtures that completely overlap each other, i.e., two fixtures having the same size and location. Each fixture, however, may have different collision-filtering settings. When this object makes contact with another, it always touches the other object with both fixtures, simultaneously. Collision determinations occur separately for each fixture. If collision conditions are positively met for the first fixture, a collision occurs, regardless of the collision determination for the second overlapping fixture. If collision conditions are positively met for both fixtures, two collisions occur.

        When a collision is ignored because of filtering, the contact-type event handlers are not invoked. To ignore collisions, but still receive event notifications when the object overlaps another, set the fixture's sensor property (described earlier) to true.

    *See Also:* the <fixtures> property and the <remove_fixture> function
*/

    int add_fixture( table properties )
        [[
            Physics::Body * me = Physics::Body::get( self );

            result = 0;

            b2FixtureDef fd = me->world->create_fixture_def( properties );

            if ( ! fd.shape )
            {
                return luaL_error( L , "Missing shape" );
            }

            result = me->world->get_next_handle();

            fd.userData = GINT_TO_POINTER( result );

            me->body->CreateFixture( & fd );
        ]];

#===============================================================================
    # Joints

/***************************************
    Function: remove_joint

    The remove_joint() function removes a specified joint from the Body and then destroys the joint.

    When an application is cleaning up a Body and its joints, all the joints should be removed before dereferencing the Body/UIElement object.

    *Argument:*

        joint_handle - unique integer handle ID that identifies the joint to remove and destroy. The joint handle is returned by the function that created the joint, such as the <RevoluteJoint> function, among others.

    *Return Value:* Boolean flag indicating the success or failure of the operation (true=joint was removed)

    *See Also:* the <DistanceJoint>, <RevoluteJoint> and <PrismaticJoint> functions
*/

    bool remove_joint( int joint_handle )
        [[
            Physics::Body * me = Physics::Body::get( self );

            gpointer h = GINT_TO_POINTER( joint_handle );

            result = false;

            for( b2JointEdge * e = me->body->GetJointList(); e; e = e->next )
            {
                if ( e->joint && e->joint->GetUserData() == h )
                {
                    result = true;

                    me->world->get_world()->DestroyJoint( e->joint );

                    break;
                }
            }
        ]];

/***************************************
    Function: DistanceJoint

    The DistanceJoint() function connects two Body objects and maintains a constant distance between them. The two attached objects should already be positioned at the desired distance at the time the joint is created. An anchor point is defined for each object. The two anchor points must be neither at the same location nor  extremely close to each other.

    The default joint created is a "rigid" joint because the distance between the anchor points remains unchanged.  It's possible to create a "soft" joint in which two objects are connected in a flexible, web-like structure. When one of the objects moves, the other object also moves, but in a rubbery rather than rigid manner. To create a soft joint, specify values for the frequency and damping_ratio keys in the function's properties argument.

    The joint can be removed by calling the <remove_joint> function.

(see physics2dDistanceJoint.png)

    *Arguments:*

        anchor - table of { X, Y } screen coordinates at which to connect this Body. This is Anchor1 in the diagram above.
        other_body - attached Body object. This is Body2 in the diagram. (Body1 is the object that invoked the DistanceJoint() function.)
        other_anchor - table of { X, Y } screen coordinates at which to connect the Body referenced by the other_body argument. This is Anchor2 in the diagram.
        properties - optional table of key/value settings that configure a "soft" distance joint. If using a rigid joint, these properties should not be changed. Supported keys are described below.

    *Soft Distance Joint Properties:* The properties argument can contain the following keys.

        frequency - double value specifying the soft joint's frequency in Hertz. The joint's frequency can be compared to a harmonic oscillator or vibrating guitar string. The appropriate frequency value depends heavily upon the density of the object, the physics simulation's gravity setting, and the desired level of joint flexibility. Experimentation is required. Start with a value of 1.0 and adjust as necessary; higher values will increase rigidity and lower values increase flexibility. Default: 0.0, which disables softness and creates a rigid joint.
        damping_ratio - double value specifying the damping ratio. Range: 0.0-infinity, but typically 0.0-1.0 where 0.0 is no damping and 1.0 is critical damping where all oscillations should disappear. Default: 0.0 (no damping).

    *Return Value:* Unique integer joint handle. This handle can be passed to the <remove_joint> function to detach the two Body objects.

    *Code Example:* Connect two objects with a DistanceJoint

        (code)
        -- Create a static body on which we will attach a distance joint
        gJointBody = Rectangle( {
                            size         = { 100, 100 },
                            position     = { screen.width / 2, screen.height / 5 },
                            color        = "AntiqueWhite",
        } )
        gJointBody.anchor_point = { 50, 50 }
        screen:add( gJointBody )
        gJointBody = physics:Body( gJointBody,
                                   { type = "static",
        } )

        -- Make a rod-shaped rectangle
        gRod = Rectangle( { size         = { 30, 400 },
                            position     = { (screen.width / 2) + 100, (screen.height / 5) + 300 },
                            color        = "SlateGray2",
        } )
        gRod.anchor_point = { 15, 200 }
        screen:add( gRod )
        gRod = physics:Body( gRod, { density = 100 } )

        -- Join the rod to the gJointBody
        gJointBody:DistanceJoint( { gJointBody.x, gJointBody.y },   -- middle of gJointBody
                                  gRod,
                                  { gRod.x, gRod.y - 200 },         -- top and center of gRod
                                  { }
        )

        -- Show everything on-screen
        screen:show()

        -- Start the physics simulation
        physics:start()
        (end)

    *See Also:* the <remove_joint> function
*/

    int DistanceJoint( table anchor, Body other_body, table other_anchor, table properties = 0 )
        [[
            lb_check_udata_type( L , other_body , "Body" );

            Physics::Body * me = Physics::Body::get( self );

            Physics::Body * other = Physics::Body::get_from_lua( L , other_body );

            if ( ! other )
            {
                return luaL_error( L , "Invalid body" );
            }

            b2Body * ba = me->body;
            b2Body * bb = other->body;

            lua_rawgeti( L , anchor , 1 );
            lua_rawgeti( L , anchor , 2 );

            float32 ax = me->world->screen_to_world( lua_tonumber( L , -2 ) );
            float32 ay = me->world->screen_to_world( lua_tonumber( L , -1 ) );

            lua_pop( L , 2 );

            lua_rawgeti( L , other_anchor , 1 );
            lua_rawgeti( L , other_anchor , 2 );

            float32 bx = me->world->screen_to_world( lua_tonumber( L , -2 ) );
            float32 by = me->world->screen_to_world( lua_tonumber( L , -1 ) );

            lua_pop( L , 2 );

            b2DistanceJointDef d;

            d.Initialize( ba , bb , b2Vec2( ax , ay ) , b2Vec2( bx , by ) );

            if ( properties )
            {
                lua_getfield( L , properties , "frequency" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    d.frequencyHz = lua_tonumber( L , -1 );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "damping_ratio" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    d.dampingRatio = lua_tonumber( L , -1 );
                }
                lua_pop( L , 1 );
            }

            result = me->world->get_next_handle();

            b2Joint * joint = me->world->get_world()->CreateJoint( & d );

            joint->SetUserData( GINT_TO_POINTER( result ) );

        ]];

/***************************************
    Function: RevoluteJoint

    The RevoluteJoint() function attaches two Body objects together at a single point to create a revolving, hinge-type joint. The two Body objects should be positioned at their desired starting locations before creating the joint.

    *Arguments:*

        other_body - attached Body object
        anchor - table of { X, Y } screen coordinates at which to attach Body. The attached Body object will revolve about the Z axis at this anchor point.
        properties - optional table of key/value settings that configure the joint. Supported keys are described below.

    *Revolute Joint Properties:* The properties argument can contain the following keys.

        enable_limit - boolean flag indicating whether or not the joint has an angular limit (true=has limit). If the enable_limit key is true, the limits are specified in the lower_angle and upper_angle keys. Notes: The enable_limit key activates both the lower_limit and upper_limit keys. If you need only a single limit, the other limit should be set to something extremely high or low so that it can never realistically be reached. Also, the limit range should include 0 (which is the joint's starting angle), otherwise the joint will lurch to its new starting angle when the physics simulation begins. Default: false=no angular limits.
        upper_angle - signed double value specifying the highest angle limit in degrees. Default: 0.0
        lower_angle - signed double value specifying the lowest angle limit in degrees. Default: 0.0
        enable_motor - boolean flag indicating whether or not a constant force should be applied upon the joint (true=apply force). If the enable_motor property is true, the level of force and torque to apply are specified in the motor_speed and max_motor_torque keys. Default: false=no continuous force.
        motor_speed - signed double value specifying the desired motor speed. Positive values revolve the attached object clockwise; negative values revolve counter-clockwise. Default: 0.0
        max_motor_torque - signed double value specifying the maximum motor torque to apply to achieve the desired motor speed. Positive values apply a non-fluctuating torque; negative values apply a constantly increasing torque. Setting a low torque value, the joint may require more time to get up to maximum speed. Default: 0.0

    *Return Value:* Unique integer joint handle. This handle can be passed to the <remove_joint> function to detach the two Body objects.

    *Code Example:* Create a revolving propeller using a RevoluteJoint

    (code)
    -- Create a static body on which we will attach a revolute joint
    gJointBody = Rectangle( {
                        size         = { 100, 100 },
                        position     = { screen.width / 2, screen.height / 2 },
                        anchor_point = { 50, 50 },      -- middle of rectangle
                        color        = "AntiqueWhite",
    } )
    screen:add( gJointBody )
    gJointBody = physics:Body( gJointBody,
                               { type = "static",
    } )

    -- Make a propeller-shaped rectangle
    gPropeller = Rectangle( {
                        size         = { 700, 30 },
                        position     = { screen.width / 2, screen.height / 2 },
                        anchor_point = { 350, 15 },     -- middle of rectangle
                        color        = "SlateGray2",
    } )
    screen:add( gPropeller )
    gPropeller = physics:Body( gPropeller, { } )

    -- Join the propeller to the gJointBody
    gJointBody:RevoluteJoint( gPropeller,
                              { gJointBody.x, gJointBody.y  },
                              { enable_motor = true,
                                motor_speed = 300,      -- clockwise
                                max_motor_torque = 100, -- steady rate
                              } )
    -- Show the screen
    screen:show()

    -- Start the physics simulation
    physics:start()
    (end)

    *See Also:* the <remove_joint> function
*/

    int RevoluteJoint( Body other_body, table anchor, table properties = 0 )
        [[
            lb_check_udata_type( L , other_body , "Body" );

            Physics::Body * me = Physics::Body::get( self );

            Physics::Body * other = Physics::Body::get_from_lua( L , other_body );

            if ( ! other )
            {
                return luaL_error( L , "Invalid body" );
            }

            b2Body * ba = me->body;
            b2Body * bb = other->body;

            lua_rawgeti( L , anchor , 1 );
            lua_rawgeti( L , anchor , 2 );

            float32 x = me->world->screen_to_world( lua_tonumber( L , -2 ) );
            float32 y = me->world->screen_to_world( lua_tonumber( L , -1 ) );

            lua_pop( L , 2 );

            b2RevoluteJointDef j;

            j.Initialize( ba , bb , b2Vec2( x , y ) );

            if ( properties )
            {
                lua_getfield( L , properties , "enable_limit" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    j.enableLimit = lua_toboolean( L , -1 );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "lower_angle" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    j.lowerAngle = Physics::World::degrees_to_radians( lua_tonumber( L , -1 ) );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "upper_angle" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    j.upperAngle = Physics::World::degrees_to_radians( lua_tonumber( L , -1 ) );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "enable_motor" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    j.enableMotor = lua_toboolean( L , -1 );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "motor_speed" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    j.motorSpeed = Physics::World::degrees_to_radians( lua_tonumber( L , -1 ) );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "max_motor_torque" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    j.maxMotorTorque = lua_tonumber( L , -1 );
                }
                lua_pop( L , 1 );

            }

            result = me->world->get_next_handle();

            b2Joint * joint = me->world->get_world()->CreateJoint( & j );

            joint->SetUserData( GINT_TO_POINTER( result ) );
        ]];

/***************************************
    Function: PrismaticJoint

    The PrismaticJoint() function groups two Body objects and limits their movement to slide along a defined axis. It's possible to limit the range of movement along the axis for each object. At least one of the objects must be a Body of <type> "dynamic" with its <fixed_rotation> property set to false. The two objects may not revolve in relation to each other, but they can revolve together as a single unit (provided both objects are "dynamic" and have fixed_rotation settings of false).

(see physics2dPrismaticJoint.png)

    *Arguments:*

        other_body - Body object to connect with.
        axis - table of { X, Y } coordinates that defines the axis along which the two Body objects will move. The axis coordinates combine with the base coordinates {0,0} to specify the axis vector. The axis coordinates must be normalized, i.e., converted to unit vectors. Normalizing the axis is discussed further below. The {1,0} axis in the illustration above defines a horizontal axis pointing to the right. The same horizontal axis pointing to the left would use coordinate {-1,0}. A vertical axis pointing down would use coordinate {0,1}. The direction of the axis is relevant when joint limits or a joint motor is used. Limits and a motor are enabled in the properties argument.
        properties - optional table of key/value settings that configures the joint. Supported keys are described below. Default: Empty table.
        anchor - table of { X, Y } coordinates reserved for future expansion. Function invocations should never specify this argument.

    *Prismatic Joint Properties:* The properties argument can contain the following keys.

        enable_limit - boolean flag indicating whether or not the joint has a movement limit (true=has limit). If the enable_limit key is true, the limits are specified in the upper_translation and lower_translation keys. Notes: The enable_limit key activates both the upper_translation and lower_translation keys. If you want only a single limit, the other limit should be set to something extremely high or low so that it can never realistically be reached. If enable_limit is true and the upper_translation and lower_translation properties contain the same value, the other_body will be locked in position and will not move. Finally, the limit range should include 0 (which is the joint's starting location), otherwise the joint will lurch to its new starting location when the physics simulation begins. Default: false, i.e., no limit.
        upper_translation - signed double value specifying the highest movement limit in the direction of the axis. The limit is specified in vector units. Default: 0.0
        lower_translation - signed double value specifying the lowest movement limit in the opposite direction of the axis. The limit is specified in vector units. Default: 0.0
        enable_motor - boolean flag indicating whether or not a constant force should be applied upon the joint (true=apply force). If the enable_motor property is true, the levels of force to apply are specified in the motor_speed and max_motor_force keys. Default: false, i.e., no force; objects can slide along the joint without any resistance.
        motor_speed - signed double value specifying the desired motor speed. Depending upon other conditions in the physics simulation, such as gravity and density, the objects may never actually reach this maximum speed. Positive motor_speed values apply a force upon the other_body object in the direction of the axis; negative values apply force in the opposite direction. This is depicted in the PrismaticJoint illustration shown above. The current Body object (depicted as Body1 in the illustration) has the force applied in reverse, i.e., positive motor_speed applies force in the opposite axis direction. Default: 0.0
        max_motor_force - double value specifying the maximum motor force to apply to achieve the desired motor speed. Setting a low force value, the joint may require more time to get up to maximum speed. Default: 0.0

    *Normalizing the Joint's Axis*

    The table of axis coordinates passed to the PrismaticJoint() function must be normalized. The resulting unit vectors are used as screen units by the movement limitation properties upper_translation and lower_translation.

    To normalize any screen coordinates, add together the square of each coordinate, then calculate the square root of the resulting sum. The final result specifies the length of the vector when using {0,0} as the vector's base. To normalize the coordinates, divide each coordinate by the vector's length. The normalized values should be used to define the joint's axis. The normalize_vector() Lua function listed below accepts X and Y coordinates, calculates their normalized values, and returns the normalized units in a table in the format {X,Y}.

    (code)
        function
        normalize_vector( x, y )

            local   len = 0

            -- Convert the { X, Y } vector to a unit vector
            -- Returns a table of the normalized { X, Y } coordinates

            -- Make sure both values are not zero
            if( x == 0 and y == 0 )then
                return { 0, 0 }
            end

            -- Calculate length of vector, i.e., sqrt( x^2 + y^2 )
            len = ((x^2) + (y^2))^0.5

            -- Normalize by dividing each coordinate by the length
            return { x / len, y / len }

        end
    (end)

    *Return Value:* Unique integer joint handle. This handle can be passed to the <remove_joint> function to detach the two Body objects.

    *Code Example:* Demonstrate a simple use of a PrismaticJoint

    (code)
        -- *********************************************************
        -- Global variables

            gBox01      = nil
            gBox02      = nil

        -- *********************************************************
        function
        pushBoxDown()

            -- Apply a linear impulse to pull the box down
            gBox01:apply_linear_impulse( { 0, 5 }, { gBox01.x, gBox01.y } )

        end

        -- *********************************************************
        -- gBox02 stuff

            -- Create a large rectangle
            gBox02 = Rectangle( { size     = { 100, 100 },
                                  position = { (screen.width / 2) - 25, (screen.height / 4) + 100, 0 },
                                  color    = { 224, 255, 255, 127 }
            } )
            gBox02.anchor_point = { 50, 50 }
            screen:add( gBox02 )

            -- Add the rectangle to the physics world and make it static, i.e., non-moving
            gBox02 = physics:Body( gBox02, { type = "static" } )

        -- gBox01 stuff

            -- Create a smaller rectangle to the right of gBox02
            gBox01 = Rectangle( { size     = { 50, 50 },
                                  position = { gBox02.x + 100, gBox02.y + 50 },
                                  color    = "SaddleBrown",
            } )
            gBox01.anchor_point = { 25, 25 }    -- center of object
            screen:add( gBox01 )

            -- Add the box to the physics world, making it dynamic/movable (which is the default)
            gBox01 = physics:Body( gBox01, { } )

        -- Joint stuff

            -- Create a PrismaticJoint between gBox01 and gBox02
            -- The smaller box can move straight up and down along the joint's axis
            -- Movement is limited along the axis by the upper and lower translation settings
            -- A motor pushes the box up to its upper limit
            -- Pressing any key will pull the box down
            gBox02:PrismaticJoint( gBox01,
                                   { 0, -1 },                       -- axis going straight up
                                   { enable_limit      = true,
                                     upper_translation = 200,       -- 200 vector units up
                                     lower_translation = -400,      -- 400 vector units down
                                     enable_motor      = true,
                                     motor_speed       = 5.0,
                                     max_motor_force   = 10.0,
                                   }
            )

            -- Show the screen
            screen:show()

            -- Start the physics simulation
            physics:start( )

            -- Any keypress will push the box down
            screen:add_onkeydown_listener( pushBoxDown )
    (end)

    *See Also:* the <remove_joint> function
*/

    int PrismaticJoint( Body other_body, table axis, table properties = 0, table anchor = 0 )
        [[
/*
    *** Undocumented Arguments and Joint Properties

    Note: This section is located inside the function because NaturalDocs did not like having two consecutive comment blocks; it skipped generating the function prototype.

    The following arguments/properties are undocumented because they should not be necessary. Because the two Body objects should already be accurately positioned before starting the physics simulation, changing the other_body object's rotation via the reference_angle and (reference_)anchor settings should not be necessary.

        reference_angle property - double value in degrees specifying the amount of rotation to perform upon the other_body object. The current Body object will not rotate. Positive values cause clockwise rotation. The rotation occurs at the point specified by the anchor parameter described below.
        anchor parameter - a more-accurate name for this setting would be reference_anchor. It is a table of { X, Y } coordinates that specify the anchor point at which the other_body object will rotate. The coordinates are local to the object's anchor point. The amount of rotation is specified in the reference_angle property.
*/

            lb_check_udata_type( L , other_body , "Body" );

            Physics::Body * me = Physics::Body::get( self );

            Physics::Body * other = Physics::Body::get_from_lua( L , other_body );

            if ( ! other )
            {
                return luaL_error( L , "Invalid body" );
            }

            b2Body * ba = me->body;
            b2Body * bb = other->body;

            // TODO: at least one of the bodies has to be dynamic with a non-fixed rotation

            float32 x = 0;
            float32 y = 0;

            if ( !anchor )
            {
                // Dy default, anchor point is  { 0, 0 } in the screen -- this only matters for relative rotation
                x = me->world->screen_to_world( 0 );
                y = me->world->screen_to_world( 0 );
            } else {
                lua_rawgeti( L , anchor , 1 );
                lua_rawgeti( L , anchor , 2 );

                x = me->world->screen_to_world( lua_tonumber( L , -2 ) );
                y = me->world->screen_to_world( lua_tonumber( L , -1 ) );

                lua_pop( L , 2 );
            }

            lua_rawgeti( L , axis , 1 );
            lua_rawgeti( L , axis , 2 );

            float32 ax = me->world->screen_to_world( lua_tonumber( L , -2 ) );
            float32 ay = me->world->screen_to_world( lua_tonumber( L , -1 ) );

            lua_pop( L , 2 );

            b2PrismaticJointDef p;

            p.Initialize( ba , bb , b2Vec2( x , y ) , b2Vec2( ax , ay ) );

            if ( properties )
            {
                lua_getfield( L , properties , "reference_angle" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    p.referenceAngle = Physics::World::degrees_to_radians( lua_tonumber( L , -1 ) );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "enable_limit" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    p.enableLimit = lua_toboolean( L , -1 );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "lower_translation" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    p.lowerTranslation = me->world->screen_to_world( lua_tonumber( L , -1 ) );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "upper_translation" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    p.upperTranslation = me->world->screen_to_world( lua_tonumber( L , -1 ) );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "enable_motor" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    p.enableMotor = lua_toboolean( L , -1 );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "motor_speed" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    p.motorSpeed = lua_tonumber( L , -1 );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "max_motor_force" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    p.maxMotorForce = lua_tonumber( L , -1 );
                }
                lua_pop( L , 1 );
            }

            result = me->world->get_next_handle();

            b2Joint * joint = me->world->get_world()->CreateJoint( & p );

            joint->SetUserData( GINT_TO_POINTER( result ) );
        ]];

# ------------------------------------------------------------------------------
#   Event Listeners

/***************************************
    Function: add_onbegincontact_listener

    The add_onbegincontact_listener() function registers a handler function for <on_begin_contact> events.

    *Arguments:*

        f - reference to handler function. The function prototype is described below.

    *Return Value:* Handle to the registered handler. Pass this handle to the remove_onbegincontact_listener() function to unregister the handler.

    *Handler Prototype:*

        (code)
        f( self, contact )
        (end)

    *Handler Arguments:*

        self - Body object containing the Fixture on which the contact occurred.
        contact - table of key/value pairs containing information about the contact. The table's keys are described in the <physics.contacts> property. Note: Because this handler is invoked only when the Fixtures edges touch, the table's touching key will always be true within the handler.

    *Handler Return Value:* None

    When the handler is invoked, the current physics simulation step is still in-progress, and physics-enabled objects are being processed. Because of this, no change should be made that alters any physics-enabled object's location, appearance or physics-related setting. Nor should any physics-enabled object be destroyed or created in this handler. If you wish to alter an object as a result of the contact, you should set up the desired operation (for example, by setting a flag) and then perform the operation when the current physics simulation step has completed, which is signaled by the <physics.on_step> event. Note: The physics engine calculates and performs the necessary physics-related reaction and movement concerning a collision between two objects; it is not necessary for a TrickPlay application to do these tasks itself.

    The on_begin_contact event marks the first in a series of collision detection-related events. As part of the same physics simulation step, the on_pre_solve_contact and on_post_solve_contact events also occur. The simulation step will then complete, which generates a physics.on_step event. As long as contact continues, each subsequent simulation step will repeat this series of on_pre_solve_contact/on_post_solve_contact/on_step events. Finally, when contact no longer occurs, the on_end_contact event occurs. The sequence of collision-detection events is shown below. For further details concerning an individual event, refer to its documentation.

    (code)
    ...
    on_step
    on_step                         -- end of simulation step
    on_begin_contact                -- two Fixtures touch or overlap
        on_pre_solve_contact        -- enables app to ignore this step's collision
        on_post_solve_contact       -- if not ignored, response has been calculated and performed
        on_step                     -- end of simulation step
                                    -- if contact continues in next simulation step...
        on_pre_solve_contact        -- repeat block of events
        on_post_solve_contact
        on_step

        ... Repeat for each step that contact continues

    on_end_contact                  -- Fixtures no longer touch or overlap
    on_step                         -- end of simulation step
    on_step
    ...
    (end)

    *See Also:* the <on_begin_contact> event, the <remove_onbegincontact_listener> function and the <physics.contacts> property
*/

    int add_onbegincontact_listener( function f )
        [[
            result = UserData::get( L )->add_callback( (char*) "on_begin_contact" , L );
            Physics::Body * me = Physics::Body::get( self );
            me->world->attach_body_callback( me , Physics::BEGIN_CONTACT , 1 );
        ]];

/***************************************
    Function: remove_onbegincontact_listener

    The remove_onbegincontact_listener() function unregisters the specified event handler.

    *Arguments:*

        ref - handle for event handler to unregister. This handle is returned by the <add_onbegincontact_listener> function.

    *Return Value:* None

    *See Also:* the <add_onbegincontact_listener> function and the <on_begin_contact> event
*/

    remove_onbegincontact_listener( int ref )
        [[
            UserData::get( L )->remove_callback( (char*) "on_begin_contact" , L );
        ]];

/***************************************
    Function: add_onendcontact_listener

    The add_onendcontact_listener() function registers a handler function for <on_end_contact> events.

    The on_end_contact event occurs when the edges of two Fixture objects no longer touch or overlap. Note: Although the Fixture edges no longer touch, the Fixture AABBs (axis-aligned bounding boxes) may still overlap. For a description of a Fixture's AABB, refer to the discussion in the <physics.contacts> property.

    *Arguments:*

        f - reference to handler function. The function prototype is described below.

    *Return Value:* Handle to the registered handler. Pass this handle to the remove_onendcontact_listener() function to unregister the handler.

    *Handler Prototype:*

        (code)
        f( self, contact )
        (end)

    *Handler Arguments:*

        self - Body object containing the Fixture on which the contact occurred.
        contact - table of key/value pairs containing information about the contact. The table's keys are described in the <physics.contacts> property. Note: Because this handler is invoked only when the Fixtures edges no longer touch, the table's touching key will always be false within the handler.

    *Handler Return Value:* None

        When the handler is invoked, the current physics simulation step is still in-progress, and physics-enabled objects are being processed. Because of this, no change should be made that alters any physics-enabled object's location, appearance or physics-related setting. Nor should any physics-enabled object be destroyed or created in this handler. If you wish to alter an object as a result of contact ending, you should set up the desired operation (for example, by setting a flag) and then perform the operation when the current physics simulation step has completed, which is signaled by the <physics.on_step> event. Note: The physics engine calculates and performs the necessary physics-related reaction and movement concerning a collision between two objects; it is not necessary for a TrickPlay application to do these tasks itself.

        For additional details about the collision-detection events, refer to the <add_onbegincontact_listener> function.

        *See Also:* the <on_end_contact> event and <remove_onendcontact_listener> function
*/

    int add_onendcontact_listener( function f )
        [[
            result = UserData::get( L )->add_callback( (char*) "on_end_contact" , L );
            Physics::Body * me = Physics::Body::get( self );
            me->world->attach_body_callback( me , Physics::END_CONTACT , 1 );
        ]];

/***************************************
    Function: remove_onendcontact_listener

    The remove_onendcontact_listener() function unregisters the specified event handler.

    *Arguments:*

        ref - handle for event handler to unregister. This handle is returned by the <add_onendcontact_listener> function.

    *Return Value:* None

    *See Also:* the <add_onendcontact_listener> function and the <on_end_contact> event
*/

    remove_onendcontact_listener( int ref )
        [[
            UserData::get( L )->remove_callback( (char*) "on_end_contact" , L );
        ]];

/***************************************
    Function: add_onpresolvecontact_listener

    The add_onpresolvecontact_listener() function registers a handler function for <on_pre_solve_contact> events. The event occurs when the edges of two Fixture objects touch or overlap during a simulation step, but prior to the calculation and response to the contact.

    *Arguments:*

        f - reference to handler function. The function prototype is described below.

    *Return Value:* Handle to the registered handler. Pass this handle to the remove_onpresolvecontact_listener() function to unregister the handler.

    *Handler Prototype:*

        (code)
        f( self, contact )
        (end)

    *Handler Arguments:*

        self - Body object containing the Fixture on which the contact occurred.
        contact - table of key/value pairs containing information about the contact. The table's keys are described in the <physics.contacts> property. Note: Because this handler is invoked only when the Fixtures edges touch, the table's touching key will always be true within the handler.

    *Handler Return Value:* None

    When the handler is invoked, the current physics simulation step is still in-progress, and physics-enabled objects are being processed. Because of this, no change should be made that alters any physics-enabled object's location, appearance or physics-related setting, except for those described later in this section. Nor should any physics-enabled object be destroyed or created in this handler. If you wish to alter an object as a result of contact, you should set up the desired operation (for example, by setting a flag) and then perform the operation when the current physics simulation step has completed, which is signaled by the <physics.on_step> event. Note: The physics engine calculates and performs the necessary physics-related reaction and movement concerning a collision between two objects; it is not necessary for a TrickPlay application to do these tasks itself.

    A TrickPlay application can instruct the physics simulation to ignore the contact by setting the enabled key contained in the contact argument to false, as shown below. If the enabled key is set to false, the current simulation step will not calculate or perform any reaction to the contact. This can enable objects to pass through each other, perhaps only under certain conditions, such as allowing objects to pass through a one-way wall. Note: The enabled flag pertains only to the current simulation step. If contact continues in the next step and you wish to ignore it, the enabled flag must be set to false again.

    (code)
    -- Instruct the physics simulation to ignore this contact for this step
    contact.enabled = false
    (end)

    For additional details about the collision-detection events, refer to the <add_onbegincontact_listener> function.

    *See Also:* the <on_pre_solve_contact> event and <remove_onpresolvecontact_listener> function
    */

    int add_onpresolvecontact_listener( function f )
        [[
            result = UserData::get( L )->add_callback( (char*) "on_pre_solve_contact" , L );
            Physics::Body * me = Physics::Body::get( self );
            me->world->attach_body_callback( me , Physics::PRE_SOLVE_CONTACT , 1 );
        ]];

/***************************************
    Function: remove_onpresolvecontact_listener

    The remove_onpresolvecontact_listener() function unregisters the specified event handler.

    *Arguments:*

        ref - handle for event handler to unregister. This handle is returned by the <add_onpresolvecontact_listener> function.

    *Return Value:* None

    *See Also:* the <add_onpresolvecontact_listener> function and the <on_pre_solve_contact> event
*/

    remove_onpresolvecontact_listener( int ref )
        [[
            UserData::get( L )->remove_callback( (char*) "on_pre_solve_contact" , L );
        ]];

/***************************************
    Function: add_onpostsolvecontact_listener

    The add_onpostsolvecontact_listener function registers a handler function for <on_post_solve_contact> events. The event occurs after calculating and responding to two touching or overlapping Fixture objects.

    *Arguments:*

        f - reference to handler function. The function prototype is described below.

    *Return Value:* Handle to the registered handler. Pass this handle to the remove_onpostsolvecontact_listener() function to unregister the handler.

    *Handler Prototype:*

        (code)
        f( self, contact )
        (end)

    *Handler Arguments:*

        self - Body object containing the Fixture on which the contact occurred.
        contact - table of key/value pairs containing information about the contact. The table's keys are described in the <physics.contacts> property.

    *Handler Return Value:* None

    When the handler is invoked, the current physics simulation step is still in-progress, and physics-enabled objects are being processed. Because of this, no change should be made that alters any physics-enabled object's location, appearance or physics-related setting. Nor should any physics-enabled object be destroyed or created in this handler. If you wish to alter an object as a result of contact, you should set up the desired operation (for example, by setting a flag) and then perform the operation when the current physics simulation step has completed, which is signaled by the <physics.on_step> event. Note: The physics engine calculates and performs the necessary physics-related reaction and movement concerning a collision between two objects; it is not necessary for a TrickPlay application to do these tasks itself.

    For additional details about the collision-detection events, refer to the <add_onbegincontact_listener> function.

    *See Also:* the <on_post_solve_contact> event and <remove_onpostsolvecontact_listener> function
*/

    int add_onpostsolvecontact_listener( function f )
        [[
            result = UserData::get( L )->add_callback( (char*) "on_post_solve_contact" , L );
            Physics::Body * me = Physics::Body::get( self );
            me->world->attach_body_callback( me , Physics::POST_SOLVE_CONTACT , 1 );
        ]];

/***************************************
    Function: remove_onpostsolvecontact_listener

    The remove_onpostsolvecontact_listener function unregisters the specified event handler.

    *Arguments:*

        ref - handle for event handler to unregister. This handle is returned by the <add_onpostsolvecontact_listener> function.

    *Return Value:* None

    *See Also:* the <add_onpostsolvecontact_listener> function and the <on_post_solve_contact> event
*/

    remove_onpostsolvecontact_listener( int ref )
        [[
            UserData::get( L )->remove_callback( (char*) "on_post_solve_contact" , L );
        ]];

/***************************************
    Event: on_begin_contact

    The on_begin_contact event occurs when the edges of two Fixture objects first touch. Note: Contact occurs between Fixture objects, not Body objects.

    *See Also:* the <add_onbegincontact_listener> function
*/

    function on_begin_contact
        [[
            return UserData::get( L )->get_last_callback( (char*) "on_begin_contact" , L );
        ]]
        [[
            UserData::get( L )->set_last_callback( (char*) "on_begin_contact" , L );
            Physics::Body * me = Physics::Body::get( self );
            me->world->attach_body_callback( me , Physics::BEGIN_CONTACT , 1 );
        ]];

/***************************************
    Event: on_end_contact

    The on_end_contact event occurs when the edges of two Fixture objects no longer touch or overlap.

    *See Also:* the <add_onendcontact_listener> function
*/

    function on_end_contact
        [[
            return UserData::get( L )->get_last_callback( (char*) "on_end_contact" , L );
        ]]
        [[
            UserData::get( L )->set_last_callback( (char*) "on_end_contact" , L );
            Physics::Body * me = Physics::Body::get( self );
            me->world->attach_body_callback( me , Physics::END_CONTACT , 1 );
        ]];

/***************************************
    Event: on_pre_solve_contact

    The on_pre_solve_contact event occurs when the edges of two Fixture objects touch or overlap during a simulation step, but prior to performing the calculation and response to the contact.

    *See Also:* the <add_onpresolvecontact_listener> function
*/

    function on_pre_solve_contact
        [[
            return UserData::get( L )->get_last_callback( (char*) "on_pre_solve_contact" , L );
        ]]
        [[
            UserData::get( L )->set_last_callback( (char*) "on_pre_solve_contact" , L );
            Physics::Body * me = Physics::Body::get( self );
            me->world->attach_body_callback( me , Physics::PRE_SOLVE_CONTACT , 1 );
        ]];

/***************************************
    Event: on_post_solve_contact

    The on_post_solve_contact event occurs after calculating and responding to two touching or overlapping Fixture objects.

    *See Also:* the <add_onpostsolvecontact_listener> function
*/

    function on_post_solve_contact
        [[
            return UserData::get( L )->get_last_callback( (char*) "on_post_solve_contact" , L );
        ]]
        [[
            UserData::get( L )->set_last_callback( (char*) "on_post_solve_contact" , L );
            Physics::Body * me = Physics::Body::get( self );
            me->world->attach_body_callback( me , Physics::POST_SOLVE_CONTACT , 1 );
        ]];

}

/*===========================================================================*/
/* Note: The physics global variable is not CSS-formatted correctly in Natural Docs when specified as a global, so it's marked as an interface instead. */

/***************************************
        Interface: physics

        The physics global variable implements a two-dimensional physics simulation that UIElement-based objects can participate in.
*/

global physics [[ Physics::World * ]]
{
    physics()
        [[
            ClutterActor * screen = App::get( L )->get_screen();

            self = lb_construct( Physics::World , new Physics::World( L , screen , 64 ) );
        ]];

    ~physics()
        [[
            delete self;
        ]];

/***************************************
        Property: pixels_per_meter

        The pixels_per_meter property defines the number of screen pixels that defines a single meter in the physics environment. While the screen environment is measured in pixels, the physics world operates in meters. Given a screen size of 1920x1020 and a default pixels_per_meter setting of 64, the result is a physics environment of 30 meters wide and 16.875 meters high. The physics simulation can accurately handle moving objects in its world that are between 0.1 and 10 meters in size. Thus, objects that are at least 6.4 pixels and no more than 640 pixels in size will be optimally processed in the default physics world. If an application has objects outside that range, the pixels_per_meter property can be adjusted to better handle them.

        The pixels_per_meter property should be set before calling the physics:start() function, which begins the simulation.

        *Default Setting:* 64
*/

    double pixels_per_meter
        [[
            pixels_per_meter = self->ppm;
        ]]
        [[
            self->ppm = pixels_per_meter;
        ]];

/***************************************
        Property: gravity

        The gravity property is a two-element table that defines the gravitational effect in the physics simulation. Gravity can be applied along the X and Y axes. Each element in the gravity table specifies the amount of gravity to apply along one axis. The gravity table format is {X-axis gravity, Y-axis gravity}. A value of 0 along an axis applies no gravity to that axis; thus, a gravity setting of {0,0} results in a physics world without any gravity.

        A positive X-axis value pushes objects to the right, negative to the left. A positive Y-axis value pulls objects down, negative pushes them up.

        The gravity property can be modified during a physics simulation.

        *Default Setting:* { 0, 10 } which simulates Earth gravity, pulling objects down. Note: Precise Earth gravity is about { 0, 9.8 }.
*/

    table gravity
        [[
            b2Vec2 g( self->get_world()->GetGravity() );
            lua_newtable( L );
            lua_pushnumber( L , g.x );
            lua_rawseti( L , -2 , 1 );
            lua_pushnumber( L , g.y );
            lua_rawseti( L , -2 , 2 );
        ]]
        [[
            luaL_checktype(L,2,LUA_TTABLE);
            lua_rawgeti( L , 2 , 1 );
            lua_rawgeti( L , 2 , 2 );
            b2Vec2 g( lua_tonumber( L , -2 ) , lua_tonumber( L , -1 ) );
            self->get_world()->SetGravity( g );
            lua_pop( L , 2 );
        ]];

/***************************************
        Property: z_for_y

        The z_for_y property is a boolean flag specifying whether the physics simulation should use the X-Y plane or the X-Z plane (true=X-Z plane). When using the X-Y plane, gravity pulls objects toward the bottom of the display. When using the X-Z plane, gravity pulls objects away from the screen, into depth. The following illustration  demonstrates the effect of setting the z_for_y property to true; it is as if the X-Y plane had fallen toward the viewer by 90 degrees.

(see physics2dPlanesXYZ.png)

        *Default Setting:* false, i.e., use X-Y plane
*/

    bool z_for_y
        [[
            z_for_y = self->z_for_y;
        ]]
        [[
            self->z_for_y = z_for_y;
        ]];

/***************************************
        Undocumented_Property: auto_clear_forces

        Note: The Box2D Physics Engine supports "sub-stepping," which is a method to divide a simulation step into fractional parts. Sub-stepping appears to be a technique used when you want a fixed time step, but a variable frame rate. When sub-stepping, the application would set physics.auto_clear_forces to false and then call physics:clear_forces() manually in each sub-step. This does not seem to have a use in the TrickPlay Engine, and so this property and the related clear_forces() function will remain undocumented.

        The auto_clear_forces property is a boolean flag specifying whether or not applied forces are terminated after each physics simulation step (true=terminated).

        *Default Setting:* true, i.e., forces are terminated after each physics simulation step

        *See Also:* the <clear_forces> function
*/

    bool auto_clear_forces
        [[
            auto_clear_forces = self->get_world()->GetAutoClearForces();
        ]]
        [[
            self->get_world()->SetAutoClearForces( auto_clear_forces );
        ]];

/***************************************
    Property: contacts

    The contacts property is a read-only table containing an entry for each contact that currently exists in the physics simulation. If no contacts exist, the contacts property is nil. Note: Contact occurs between Fixture objects, not Body objects.

    The contacts for a particular Body object can be accessed using the object's contacts property. The code segment below illustrates the difference between the contacts in the physics simulation vs. the contacts for a particular Body object. The discussion in this section pertains to both contacts properties.

    (code)
    -- Are there any contacts in the physics simulation, which includes all Body objects?
    if( physics.contacts ~= nil )then
        print( "Contacts exist in the physics simulation" )
    end

    -- Does the gBodyObj have any contacts?
    if( gBodyObj.contacts ~= nil )then
        print( "Contacts exist for gBodyObj" )
    end
    (end)

    Two types of contact are stored in the contacts property: (1) contact between two Fixture's edge boundaries and (2) contact between two Fixture's minimum bounding rectangles, also referred to as the axis-aligned bounding box or AABB. For a square or rectangular Fixture, its AABB may be the same as its edge boundary, depending upon the Fixture's orientation. For all non-rectangular Fixtures, including circles and triangles, the AABB will be the minimum rectangle that can entirely enclose the Fixture. Some examples of Fixture shapes and their AABB bounding boxes are shown below.

(see physics2dAABB.png)

    Each table entry is a key/value pair. The supported keys are described below.

        enabled - boolean flag specifying whether or not the contact is enabled. Default: true, i.e., contact is enabled. The enabled flag can be set only when processing an <on_pre_solve_contact> event.
        touching - boolean flag specifying whether or not the Fixture object's edges touch. If the touching key is true, the edges touch; if false, the axis-aligned bounding boxes of the objects touch. Note: When edges first touch, the <on_begin_contact> event is generated.
        point - when the touching key is true, the point key contains a table of { X, Y } screen coordinates that reference where the contact occurs. When the touching key is false, the value of the point key is undefined.
        fixtures - table containing the handles of the two Fixture objects. For example, if Fixture handles 12 and 24 are in contact, the fixtures table would contain {12,24}.
        other_fixture - additional table containing the handles of the two Fixture objects, indexed by handle value. For example, if Fixture handles 12 and 24 are in contact, referencing contacts.other_fixtures[ 12 ] returns 24, and contacts.other_fixtures[ 24 ] returns 12; all other indices are nil.
        bodies - table containing the handles of the two Body objects on which the contacting Fixtures are attached. For example, if Body handles 36 and 48 are in contact, the bodies table would contain {36,48}.
        other_body - additional table containing the handles of the two Body objects, indexed by handle value. For example, if Body handles 36 and 48 are in contact, referencing contacts.other_body[ 36 ] returns 48, and contacts.other_body[ 48 ] returns 36; all other indices are nil.

    *See Also:* the <on_begin_contact> event
*/

    readonly table contacts
        [[
            self->push_contact_list( self->get_world()->GetContactList() );
        ]];

/***************************************
        Property: running

        The running property is a read-only boolean flag indicating whether or not the physics simulation is currently running. The physics simulation can be started by calling the physics:start() function.

        *Default Setting:* false

        *See Also:* the <start> function
*/

    readonly bool running
        [[
            running = self->running();
        ]];

/***************************************
    Function: start

    The start() function begins the physics simulation.

    *Arguments:*

        velocity_iterations - optional numeric value specifying the number of iterations to perform to handle a velocity-related collision response. Refer to the discussion below for details. Range: Any positive integer value. Default: 10.
        position_iterations - optional numeric value specifying the number of iterations to perform to handle a position-related collision response. Refer to the discussion below for details. Range: Any positive integer value. Default: 10;

    The optional velocity_iterations and position_iterations arguments affect the way objects will react when they collide. When object contact is detected, they have usually advanced enough beyond their initial contact so that they overlap. The physics simulation must calculate the most appropriate movement and/or rotation in response to the contact so that the objects no longer overlap. By performing more iterations of calculations, a more accurate physics simulation can occur, at the expense, however, of execution performance.

    *Return Value:* None

    When contact between Fixture objects occurs, collision-related events fire, such as <on_begin_contact> and <on_end_contact>. The collision events happen while a physics simulation step is in-progress. Modifications to the physics environment are very restricted during a simulation step. Changes to objects in the physics environment, such as creating or destroying objects or modifying their appearance or location, cannot be performed while the simulation step is in-progress; they may occur only "outside" of the step, i.e., after the step has completed. To mark the completion of each simulation step, an <on_step> event occurs. The on_step event is the only physics-related event that takes place outside of the simulation step. Thus, all changes to objects in the physics environment must be performed in a handler hooked into the on_step event. Refer to the <add_onstep_listener> function for additional details.

    *See Also:* the <stop> function and <on_step> and <Body.on_begin_contact> events
*/

    start( int velocity_iterations = 10, int position_iterations = 10 )
        [[
            self->start( velocity_iterations , position_iterations );
        ]];

/***************************************
        Function: stop

        The stop() function halts a running physics simulation. The stopped simulation can be continued by calling the start() function.

        *Arguments:* None

        *Return Value:* None

        *See Also:* the <start> function
*/

    stop()
        [[
            self->stop();
        ]];

/***************************************
        Undocumented_Function: step

        THIS ONE SHOULD BE UNDOCUMENTED AS IT WILL BE DEPRECATED.
*/

    step( double time_step = 1.0f/60.0f , int velocity_iterations = 10, int position_iterations = 10 )
        [[
            self->step( time_step , velocity_iterations , position_iterations );
        ]];

/***************************************
        Undocumented_Function: clear_forces

        Note: Refer to the physics.auto_clear_forces property for a description of this function's use and why it is undocumented.

        The clear_forces() function removes all forces applied in a time step.

        *Arguments:* None

        *Return Value:* None

        *See Also:* the <auto_clear_forces> property
*/

    clear_forces()
        [[
            self->get_world()->ClearForces();
        ]];

/***************************************
        Function: draw_debug

        The draw_debug() function displays a screen overlay that shows all physical aspects of existing Body, Fixture and Joint objects, including their boundaries. Among other uses, this information can be used to visually determine when the AABB bounding boxes of two Fixtures overlap.

        The draw_debug() function should be invoked within an <on_step> event handler.

        *Arguments:*

            opacity - optional numeric value specifying the opacity/transparency of the screen overlay. Range: 0(transparent) to 255(opaque). Default: 127.

        *Return Value:* None

        *See Also:* the <on_step> event and <add_onstep_listener> function
*/

    draw_debug( int opacity = 127 )
        [[
            self->draw_debug( opacity );
        ]];

/***************************************
        Function: clear_debug

        The clear_debug() function removes the screen overlay information displayed by the draw_debug() function. Note: The overlay information is normally overwritten during the screen update on the next physics simulation time-step. The clear_debug() function can be used to ensure all overlay information is removed.

        *Arguments:* None

        *Return Value:* None

        *See Also:* the <draw_debug> function
*/

    clear_debug()
        [[
            self->clear_debug();
        ]];

/***************************************
        Undocumented_Function: get_fixtures_in_rectangle

            NOT IMPLEMENTED COMPLETELY
*/

    table get_fixtures_in_rectangle( table top_left , table bottom_right )
        [[
            float32 x1;
            float32 y1;
            float32 x2;
            float32 y2;

            lua_rawgeti( L , top_left , 1 );
            x1 = self->screen_to_world( lua_tonumber( L , -1 ) );
            lua_pop( L , 1 );
            lua_rawgeti( L , top_left , 2 );
            y1 = self->screen_to_world( lua_tonumber( L , -1 ) );
            lua_pop( L , 1 );

            lua_rawgeti( L , bottom_right , 1 );
            x2 = self->screen_to_world( lua_tonumber( L , -1 ) );
            lua_pop( L , 1 );
            lua_rawgeti( L , bottom_right , 2 );
            y2 = self->screen_to_world( lua_tonumber( L , -1 ) );
            lua_pop( L , 1 );

            b2AABB a;

            a.lowerBound.x = x1;
            a.lowerBound.y = y1;
            a.upperBound.x = x2;
            a.upperBound.y = y2;

            Physics::AABBQuery q( L );

            self->get_world()->QueryAABB( & q , a );

            // TODO: put results in a table.

            lua_pushnil( L );
        ]];

/***************************************
        Function: Body

        The Body() function adds properties, functions, and event handlers to a UIElement-based object, enabling the object to participate in a physics environment.

        Note: The Body() function forces the anchor point of the UIElement-based object to its center.

        *Arguments:*

            element - UIElement-based object, such as <Rectangle> or <Image>
            properties - table of Body and Fixture property initialization values. Details are described below.

        The properties argument is a table of initialization values for the Body and Fixture elements that are added to the UIElement object. The Body properties are any of the properties supported by the Body interface. The supported Fixture properties are those described in the <Body.add_fixture> function. To use default values for all the properties, specify an empty table.

        A Body itself has no volume or size. One or more Fixture objects are attached to a Body object, and these Fixture objects give the Body its size. Further, the size of the attached Fixture(s) is independent of the size of the underlying UIElement object. When a physics-enabled UIElement object participates in the physics environment, the size and location of its Fixture(s) are what determine events, such as collisions.

        The Body() function will create and attach a default Fixture to the UIElement passed into the function. This Fixture object will be a rectangular shape large enough to contain the entire UIElement. A program can override the default Fixture by defining its own Fixture in the function's properties table. To define an explicit Fixture, use the properties described in the <Body.add_fixture> function.

        *Return Value:* If successful, returns the UIElement specified in the element argument, but now containing physics-enabled capabilities. If error, returns nil.

        *Code Examples:* Add physics capabilities to various existing UIElement-based objects

            (code)
            -- Assume all the UIElement-based objects referenced below have already been created

            -- Add physics capabilities to a Rectangle object, using default Body and Fixture property settings
            gRect01 = physics:Body( gRect01, { } )

            -- Do the same to an Image object, but define our own circular Fixture, overriding the default
            radius   = gImage01.width / 2
            gImage01 = physics:Body( gImage01, { shape = Circle( radius ) } )

            -- Make this Rectangle a static object that will act as a ground or floor
            gRect02 = physics:Body( gRect02, { type = "static" } )
            (end)

        *See Also:* the Body properties and the <Body.add_fixture> function
*/

    Body Body( UIElement element, table properties )
        [[
            lb_check_udata_type( L , element , "actor" );

            // Use default density of 1, because 0 is stupid
            lua_getfield( L , properties , "density" );
            if ( lua_isnil( L , -1 ) )
            {
                lua_pushnumber( L , 1.0 );
                lua_setfield( L , properties , "density" );
            }
            lua_pop( L , 1 );

            int n = self->create_body( element , properties , BODY_METATABLE );

            if ( ! n )
            {
                lua_pushnil( L );
            }
            else
            {
                ClutterUtil::set_props_from_table( L , properties );
            }
        ]];

/***************************************
        Function: Box

        The Box() function creates a rectangular shape that is used to define a Fixture. The function's return value is used as the value of the shape property in the <Body.add_fixture> and Body() functions.

        *Arguments:*

            size - table specifying the fixture's width and height in pixels. The format is {width, height}.
            center - optional table specifying the fixture's X,Y center relative to its Body. The format is {X, Y}. If not specified, the Body's center is used.
            rotation - optional value specifying the fixture's angle in degrees. The fixture will be rotated about the Z axis at the fixture's center. If not specified, the rotation angle is 0, i.e., no rotation.

        *Return Value:* Shape object that can be specified in the shape property of the add_fixture() and Body() functions

        *Code Examples:* Define a rectangular shape and use it when creating Fixture objects

            (code)
            -- Add a new Fixture that is slightly larger than the underlying UIElement object
            -- Note: Assume the Rectangle object gRect01 has already been created and added to the physics environment
            gRect01:add_fixture( { shape = Box( { gRect01.width  + 100,
                                                  gRect01.height + 100 } ) } )

            -- Enable a Rectangle to participate in the physics environment, overriding the default Fixture with a larger one
            gRect02:Body( gRect02, { shape = Box( { gRect02.width  + 100,
                                                    gRect02.height + 100 } ) } )
            (end)

        *See Also:* the <Body> and <Body.add_fixture> functions
*/

    Shape Box( table size, table center = 0, double rotation = 0 )
        [[
            b2PolygonShape * shape = new b2PolygonShape();

            if ( ! center )
            {
                lua_rawgeti( L , size , 1 );
                lua_rawgeti( L , size , 2 );

                shape->SetAsBox( self->screen_to_world( lua_tonumber( L , -2 ) * 0.5 ) ,
                    self->screen_to_world( lua_tonumber( L , -1 ) * 0.5 ) );

                lua_pop( L , 2 );
            }
            else
            {
                lua_rawgeti( L , size , 1 );
                lua_rawgeti( L , size , 2 );

                lua_rawgeti( L , center , 1 );
                lua_rawgeti( L , center , 2 );

                shape->SetAsBox( self->screen_to_world( lua_tonumber( L , -4 ) * 0.5 ) ,
                        self->screen_to_world( lua_tonumber( L , -3 ) * 0.5 ),
                        b2Vec2( self->screen_to_world( lua_tonumber( L , -2 ) ),
                                self->screen_to_world( lua_tonumber( L , -1 ) ) ),
                        Physics::World::degrees_to_radians( rotation ) );

                lua_pop( L , 4 );
            }

            lua_pushlightuserdata( L , shape );

            new_Shape( L );

            lua_remove( L , -2 );
        ]];

/***************************************
        Function: Edge

        The Edge() function creates a line shape that is used to define a Fixture. The function's return value is used as the value of the shape property in the <Body.add_fixture> and Body() functions.

        *Arguments:*

            point_a - table containing the {X, Y} coordinates for one end of the line. The coordinates are relative to the <Body.world_center> of the associated Body object.
            point_b - table containing the {X, Y} coordinates for the other end of the line. The coordinates are relative to the <Body.world_center> of the associated Body object.

        *Return Value:* Shape object that can be specified in the shape property of the add_fixture() and Body() functions

        *Code Examples:* Define a line shape and use it when creating Fixture objects

            (code)
            -- Add a new Fixture that is as wide as the screen. This can be used as a floor or ground.
            -- Note: Assume the Rectangle object gRect01 has already been created and added to the physics environment
            gRect01:add_fixture( { shape = Edge( { -(gRect01.world_center[ 1 ]), 0 },
                                                 { screen.width - gRect01.world_center[ 1 ], 0 } ),
                                   type  = "static" } )

            -- Enable a Rectangle to participate in the physics environment, overriding the default Fixture with a long and thin line
            gRect02:Body( gRect02, { shape = Edge( { -(gRect02.world_center[ 1 ], 0 },
                                                     { screen.width - gRect02.world_center[ 1 ], 0 } ),
                                     type  = "static" } )
            (end)

        *See Also:* the <Body> and <Body.add_fixture> functions
*/

    Shape Edge( table point_a, table point_b )
        [[
            b2EdgeShape * shape = new b2EdgeShape();

            lua_rawgeti( L , point_a , 1 );
            lua_rawgeti( L , point_a , 2 );
            lua_rawgeti( L , point_b , 1 );
            lua_rawgeti( L , point_b , 2 );

            shape->Set( b2Vec2( self->screen_to_world( lua_tonumber( L , -4 ) ) ,
                    self->screen_to_world( lua_tonumber( L , -3 ) ) ),
                    b2Vec2( self->screen_to_world( lua_tonumber( L , -2 ) ) ,
                            self->screen_to_world( lua_tonumber( L , -1 ) ) ) );

            lua_pop( L , 4 );

            lua_pushlightuserdata( L , shape );

            new_Shape( L );

            lua_remove( L , -2 );
        ]];

/***************************************
        Function: Polygon

        The Polygon() function creates a polygon shape that is used to define a Fixture. The function's return value is used as the value of the shape property in the <Body.add_fixture> and Body() functions.

        *Arguments:*

            points - table of tables. Each embedded table specifies the {X, Y} coordinates of a single point of the polygon. Each point is relative to the <Body.world_center> of the associated Body object. The shape may have a maximum of 8 points and must be convex all the way around; concave edges will produce odd results in the physics simulation.

        *Return Value:* Shape object that can be specified in the shape property of the add_fixture() and Body() functions

        *Code Examples:* Define a polygon shape and use it when creating Fixture objects

            (code)
            -- Add a four-sided, diamond-shaped Fixture to an object
            -- Note: Assume the Rectangle object gRect01 has already been created and added to the physics environment
            gRect01:add_fixture( { shape = Polygon( { { gRect01.world_center - 50, 0  },
                                                      { 0, gRect01.world_center - 100 },
                                                      { gRect01.world_center + 50, 0  },
                                                      { 0, gRect01.world_center + 100 } } ) } )

            -- Enable a Rectangle to participate in the physics environment, overriding the default Fixture with a four-sided, diamond-shaped one
            gRect02:Body( gRect02, { shape = Polygon( { { gRect02.world_center - 50, 0  },
                                                        { 0, gRect02.world_center - 100 },
                                                        { gRect02.world_center + 50, 0  },
                                                        { 0, gRect02.world_center + 100 } } ) } )
            (end)

        *See Also:* the <Body> and <Body.add_fixture> functions
*/

    Shape Polygon( table points )
        [[
            std::vector< b2Vec2 > p;

            lua_pushnil( L );

            while( lua_next( L , points ) )
            {
                if ( lua_istable( L , -1 ) )
                {
                    lua_rawgeti( L , -1 , 1 );
                    lua_rawgeti( L , -2 , 2 );

                    p.push_back(
                            b2Vec2( self->screen_to_world( lua_tonumber( L , -2 ) ) ,
                                    self->screen_to_world( lua_tonumber( L , -1 ) ) ) );

                    lua_pop( L , 2 );
                }
                lua_pop( L , 1 );
            }

            if ( p.empty() )
            {
                return luaL_error( L , "Invalid polygon points" );
            }

            b2PolygonShape * shape = new b2PolygonShape();

            shape->Set( & p[ 0 ] , p.size() );

            lua_pushlightuserdata( L , shape );
            new_Shape( L );
            lua_remove( L , -2 );
        ]];

/***************************************
        Function: Circle

        The Circle() function creates a circular shape that is used to define a Fixture. The function's return value is used as the value of the shape property in the <Body.add_fixture> and Body() functions.

        *Arguments:*

            radius - circle's radius in pixels
            center - optional table of {X, Y} coordinates specifying the circle's center. The coordinates are relative to the <Body.world_center> of the associated Body object.

        *Return Value:* Shape object that can be specified in the shape property of the add_fixture() and Body() functions

        *Code Examples:* Define a circular shape and use it when creating Fixture objects

            (code)
            -- Add a circular Fixture to an object
            -- Note: Assume the Rectangle object gRect01 has already been created and added to the physics environment
            gRect01:add_fixture( { shape = Circle( 50 ) } )

            -- Enable a Rectangle to participate in the physics environment, overriding the default Fixture with a circular one
            gRect02:Body( gRect02, { shape = Circle( 50 ) } )
            (end)

        *See Also:* the <Body> and <Body.add_fixture> functions
*/

    Shape Circle( double radius, table center = 0 )
        [[
            b2CircleShape * shape = new b2CircleShape();

            shape->m_radius = self->screen_to_world( radius );

            shape->m_p.SetZero();

            if ( center )
            {
                lua_rawgeti( L , center , 1 );
                lua_rawgeti( L , center , 2 );

                shape->m_p.Set( self->screen_to_world( lua_tonumber( L , -2 ) ) ,
                        self->screen_to_world( lua_tonumber( L , -1 ) ) );

                lua_pop( L , 2 );
            }

            lua_pushlightuserdata( L , shape );

            new_Shape( L );

            lua_remove( L , -2 );
        ]];

/***************************************
    Function: add_onstep_listener

    The add_onstep_listener() registers a handler function for <on_step> events. The event occurs at the completion of each physics simulation time-step.

    *Arguments:*

        f - reference to handler function. The function prototype is described below.

    *Return Value:* Handle to the registered handler. Pass this handle to the remove_onstep_listener() function to unregister the handler.

    *Handler Prototype:*

        (code)
        f( double seconds )
        (end)

    *Handler Arguments:*

        seconds - fractional number of seconds since the last on_step event. The physics simulation time-step is configured to perform a maximum of 1/60 second (0.016667 second). The seconds argument value will be a minimum of 1/60 (0.016667), but will commonly be larger.

    *Handler Return Value:* None

    Any changes to physics-enabled objects, such as modifying their properties, creating new objects or destroying existing objects, can be performed in the handler. In fact, such changes should be performed in the handler only and not in the other physics-related handlers, such as those registered for on_begin_contact or on_end_contact events. For a complete discussion of physics-related event handlers and the order in which they occur, refer to the <Body.add_onbegincontact_listener> handler.

    *See Also:* the <Body.add_onbegincontact_listener> function and the <on_step> event
*/

    int add_onstep_listener( function f )
        [[
            result = UserData::get( L )->add_callback( (char*) "on_step" , L );
        ]];

/***************************************
    Function: remove_onstep_listener

    The remove_onstep_listener() function unregisters the specified event handler.

    *Arguments:*

        ref - handle for event handler to unregister. This handle is returned by the <add_onstep_listener> function.

    *Return Value:* None

    *See Also:* the <add_onstep_listener> function and the <on_step> event
*/

    remove_onstep_listener( int ref )
        [[
            UserData::get( L )->remove_callback( (char*) "on_step" , L );
        ]];

/***************************************
    Function: add_onbegincontact_listener

    The add_onbegincontact_listener() function registers a handler function for <on_begin_contact> events. The event occurs when the edges of two Fixture objects first touch.

    *Arguments:*

        f - reference to handler function. The function prototype is described below.

    *Return Value:* Handle to the registered handler. Pass this handle to the remove_onbegincontact_listener() function to unregister the handler.

    *Handler Prototype:*

        (code)
        f( physics, contact )
        (end)

    *Handler Arguments:*

        physics - reference to the physics global variable
        contact - table of key/value pairs containing information about the contact. Refer to the <Body.add_onbegincontact_listener> handler for further details.

    *Handler Return Value:* None

    This handler is related to the <Body.add_onbegincontact_listener> handler, except the self argument in this version references the physics global variable, rather than a Body object. Also, this event occurs for every detected collision in the physics environment, not just for a particular Body/Fixture. Refer to the <Body.add_onbegincontact_listener> description for additional information.

    *See Also:* the <remove_onbegincontact_listener> function and the <on_begin_contact> event
*/

    int add_onbegincontact_listener( function f )
        [[
            result = UserData::get( L )->add_callback( (char*) "on_begin_contact" , L );
            self->attach_global_callback( Physics::BEGIN_CONTACT , 1 );
        ]];

/***************************************
    Function: remove_onbegincontact_listener

    The remove_onbegincontact_listener() function unregisters the specified event handler.

    *Arguments:*

        ref - handle for event handler to unregister. This handle is returned by the <add_onbegincontact_listener> function.

    *Return Value:* None

    *See Also:* the <add_onbegincontact_listener> function and the <on_begin_contact> event
*/

    remove_onbegincontact_listener( int ref )
        [[
            UserData::get( L )->remove_callback( (char*) "on_begin_contact" , L );
        ]];

/***************************************
    Function: add_onendcontact_listener

    The add_onendcontact_listener() function registers a handler function for <on_end_contact> events. The event occurs when the edges of two Fixture objects no longer touch or overlap.

    *Arguments:*

        f - reference to handler function. The function prototype is described below.

    *Return Value:* Handle to the registered handler. Pass this handle to the remove_onendcontact_listener() function to unregister the handler.

    *Handler Prototype:*

        (code)
        f( physics, contact )
        (end)

    *Handler Arguments:*

        physics - reference to the physics global variable
        contact - table of key/value pairs containing information about the contact. Refer to the <Body.add_onendcontact_listener> function for further details.

    *Handler Return Value:* None

    This handler is related to the <Body.add_onendcontact_listener> handler, except the self argument in this version references the physics global variable, rather than a Body object. Also, this event occurs for every detected collision in the physics environment, not just for a particular Body/Fixture. Refer to the <Body.add_onendcontact_listener> description for additional information.

    *See Also:* the <remove_onendcontact_listener> function and the <on_end_contact> event
*/

    int add_onendcontact_listener( function f )
        [[
            result = UserData::get( L )->add_callback( (char*) "on_end_contact" , L );
            self->attach_global_callback( Physics::END_CONTACT , 1 );
        ]];

/***************************************
    Function: remove_onendcontact_listener

    The remove_onendcontact_listener() function unregisters the specified event handler.

    *Arguments:*

        ref - handle for event handler to unregister. This handle is returned by the <add_onendcontact_listener> function.

    *Return Value:* None

    *See Also:* the <add_onendcontact_listener> function and the <on_end_contact> event
*/

    remove_onendcontact_listener( int ref )
        [[
            UserData::get( L )->remove_callback( (char*) "on_end_contact" , L );
        ]];

/***************************************
    Function: add_onpresolvecontact_listener

    The add_onpresolvecontact_listener() function registers a handler function for <on_pre_solve_contact> events. The event occurs when the edges of two Fixture objects touch or overlap during a simulation step, but the calculation and response to the contact has not yet been performed.

    *Arguments:*

        f - reference to handler function. The function prototype is described below.

    *Return Value:* Handle to the registered handler. Pass this handle to the remove_onpresolvecontact_listener() function to unregister the handler.

    *Handler Prototype:*

        (code)
        f( physics, contact )
        (end)

    *Handler Arguments:*

        physics - reference to the physics global variable
        contact - table of key/value pairs containing information about the contact. Refer to the <Body.add_onpresolvecontact_listener> function for further details.

    *Handler Return Value:* None

    This handler is related to the <Body.add_onpresolvecontact_listener> handler, except the self argument in this version references the physics global variable, rather than a Body object. Also, this event occurs for every detected collision in the physics environment, not just for a particular Body/Fixture. Refer to the <Body.add_onpresolvecontact_listener> description for additional information.

    *See Also:* the <remove_onpresolvecontact_listener> function and the <on_pre_solve_contact> event
*/

    int add_onpresolvecontact_listener( function f )
        [[
            result = UserData::get( L )->add_callback( (char*) "on_pre_solve_contact" , L );
            self->attach_global_callback( Physics::PRE_SOLVE_CONTACT , 1 );
        ]];

/***************************************
    Function: remove_onpresolvecontact_listener

    The remove_onpresolvecontact_listener() function unregisters the specified event handler.

    *Arguments:*

        ref - handle for event handler to unregister. This handle is returned by the <add_onpresolvecontact_listener> function.

    *Return Value:* None

    *See Also:* the <add_onpresolvecontact_listener> function and the <on_pre_solve_contact> event
*/

    remove_onpresolvecontact_listener( int ref )
        [[
            UserData::get( L )->remove_callback( (char*) "on_pre_solve_contact" , L );
        ]];

/***************************************
    Function: add_onpostsolvecontact_listener

    The add_onpostsolvecontact_listener() function registers a handler function for <on_post_solve_contact> events. The event occurs after calculating and responding to two touching or overlapping Fixture objects.

    *Arguments:*

        f - reference to handler function. The function prototype is described below.

    *Return Value:* Handle to the registered handler. Pass this handle to the remove_onpostsolvecontact_listener() function to unregister the handler.

    *Handler Prototype:*

        (code)
        f( physics, contact )
        (end)

    *Handler Arguments:*

        physics - reference to the physics global variable
        contact - table of key/value pairs containing information about the contact. Refer to the <Body.add_onpostsolvecontact_listener> function for further details.

    *Handler Return Value:* None

    This handler is related to the <Body.add_onpostsolvecontact_listener> handler, except the self argument in this version references the physics global variable, rather than a Body object. Also, this event occurs for every detected collision in the physics environment, not just for a particular Body/Fixture. Refer to the <Body.add_onpostsolvecontact_listener> description for additional information.

    *See Also:* the <remove_onpostsolvecontact_listener> function and the <on_post_solve_contact> event
*/

    int add_onpostsolvecontact_listener( function f )
        [[
            result = UserData::get( L )->add_callback( (char*) "on_post_solve_contact" , L );
            self->attach_global_callback( Physics::POST_SOLVE_CONTACT , 1 );
        ]];

/***************************************
    Function: remove_onpostsolvecontact_listener

    The remove_onpostsolvecontact_listener() function unregisters the specified event handler.

    *Arguments:*

        ref - handle for event handler to unregister. This handle is returned by the <add_onpostsolvecontact_listener> function.

    *Return Value:* None

    *See Also:* the <add_onpostsolvecontact_listener> function and the <on_post_solve_contact> event
*/

    remove_onpostsolvecontact_listener( int ref )
        [[
            UserData::get( L )->remove_callback( (char*) "on_post_solve_contact" , L );
        ]];

/***************************************
    Event: on_step

    The on_step event occurs at the completion of each physics simulation time-step.

    *See Also:* the <add_onstep_listener> function
*/

    function on_step
        [[
            return UserData::get( L )->get_last_callback( (char*) "on_step" , L );
        ]]
        [[
            UserData::get( L )->set_last_callback( (char*) "on_step" , L );
        ]];

/***************************************
    Event: on_begin_contact

    The on_begin_contact event occurs when the edges of two Fixture objects first touch. This event is related to the <Body.on_begin_contact> event, but it occurs for every detected collision in the physics environment, not just for a particular Body/Fixture.

    Note: Any registered Body.on_begin_contact handlers are invoked prior to the physics.on_begin_contact versions.

    *See Also:* the <add_onbegincontact_listener> and <Body.add_onbegincontact_listener> functions
*/

    function on_begin_contact
        [[
            return UserData::get( L )->get_last_callback( (char*) "on_begin_contact" , L );
        ]]
        [[
            UserData::get( L )->set_last_callback( (char*) "on_begin_contact" , L );
            self->attach_global_callback( Physics::BEGIN_CONTACT , 1 );
        ]];

/***************************************
    Event: on_end_contact

    The on_end_contact event occurs when the edges of two Fixture objects no longer touch or overlap. This event is related to the <Body.on_end_contact> event, but it occurs for every detected collision in the physics environment, not just for a particular Body/Fixture.

    Note: Any registered Body.on_end_contact handlers are invoked prior to the physics.on_end_contact versions.

    *See Also:* the <add_onendcontact_listener> and <Body.add_onbegincontact_listener> functions
*/

    function on_end_contact
        [[
            return UserData::get( L )->get_last_callback( (char*) "on_end_contact" , L );
        ]]
        [[
            UserData::get( L )->set_last_callback( (char*) "on_end_contact" , L );
            self->attach_global_callback( Physics::END_CONTACT , 1 );
        ]];

/***************************************
    Event: on_pre_solve_contact

    The on_pre_solve_contact event occurs when the edges of two Fixture objects touch or overlap during a simulation step, but prior to performing the calculation and response to the contact. This event is related to the <Body.on_pre_solve_contact> event, but it occurs for every detected collision in the physics environment, not just for a particular Body/Fixture.

    Note: Any registered Body.on_pre_solve_contact handlers are invoked prior to the physics.on_pre_solve_contact versions.

    *See Also:* the <add_onpresolvecontact_listener> and <Body.add_onbegincontact_listener> functions
*/

    function on_pre_solve_contact
        [[
            return UserData::get( L )->get_last_callback( (char*) "on_pre_solve_contact" , L );
        ]]
        [[
            UserData::get( L )->set_last_callback( (char*) "on_pre_solve_contact" , L );
            self->attach_global_callback( Physics::PRE_SOLVE_CONTACT , 1 );
        ]];

/***************************************
    Event: on_post_solve_contact

    The on_post_solve_contact event occurs after calculating and responding to two touching or overlapping Fixture objects. This event is related to the <Body.on_post_solve_contact> event, but it occurs for every detected collision in the physics environment, not just for a particular Body/Fixture.

    Note: Any registered Body.on_post_solve_contact handlers are invoked prior to the physics.on_post_solve_contact versions.

    *See Also:* the <add_onpostsolvecontact_listener> and <Body.add_onbegincontact_listener> functions
*/

    function on_post_solve_contact
        [[
            return UserData::get( L )->get_last_callback( (char*) "on_post_solve_contact" , L );
        ]]
        [[
            UserData::get( L )->set_last_callback( (char*) "on_post_solve_contact" , L );
            self->attach_global_callback( Physics::POST_SOLVE_CONTACT , 1 );
        ]];

/***************************************
*/
}

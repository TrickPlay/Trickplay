
module physics_module;

[[
#include "Box2D/Box2D.h"
#include "clutter/clutter.h"

#include "physics.h"
#include "clutter_util.h"
]]

/*===========================================================================*/

interface Shape [[ b2Shape * ]]
{
    Shape()
        [[
            self = lb_construct( b2Shape , lua_touserdata( L , -2 ) );
        ]];

    ~Shape()
        [[
            delete self;
        ]];
}

/*===========================================================================*/

interface Body [[ Physics::Body * ]]
{
	Body()
		[[
			self = lb_construct( Physics::Body , lua_touserdata( L , -2 ) );
		]];
		
	~Body()
		[[
			delete self;
		]];

	readonly int handle
        [[
            handle = self->handle;
        ]];
		
	readonly UIElement source
		[[
            self->check( L );
			ClutterUtil::wrap_concrete_actor( L , self->actor );
		]];

	string type
	    [[
	        self->check( L );
            switch( self->body->GetType() )
            {
                case b2_staticBody:
                    type = "static";
                    break;

                case b2_kinematicBody:
                    type = "kinematic";
                    break;

                case b2_dynamicBody:
                    type = "dynamic";
                    break;

                default:
                    type = 0;
                    break;
            }
	    ]]
	    [[
            self->check( L );

            if ( ! type )
            {
                luaL_error( L , "Invalid body type" );
            }
            else
            {
                if ( ! strcmp( type , "static" ) )
                {
                    self->body->SetType( b2_staticBody );
                }
                else if ( ! strcmp( type , "kinematic" ) )
                {
                    self->body->SetType( b2_kinematicBody );
                }
                else if ( ! strcmp( type , "dynamic" ) )
                {
                    self->body->SetType( b2_dynamicBody );
                }
                else
                {
                    luaL_error( L , "Invalid body type '%s'" , type );
                }
            }
	    ]];
		
	bool awake
		[[
            self->check( L );
			awake = self->body->IsAwake();
		]]
		[[
            self->check( L );
			self->body->SetAwake( awake );
		]];
		
	bool active
		[[
            self->check( L );
			active = self->body->IsActive();
		]]
		[[
            self->check( L );
			self->body->SetActive( active );
		]];

	table position
		[[
            self->check( L );

            const b2Vec2 & pos( self->body->GetPosition() );
			
			lua_newtable( L );
			lua_pushnumber( L , self->world->world_to_screen( pos.x ) );
			lua_rawseti( L , -2 , 1 );
			lua_pushnumber( L , self->world->world_to_screen( pos.y ) );
			lua_rawseti( L , -2 , 2 );
		]]
		[[
		    self->check( L );

            lua_rawgeti( L , 2 , 1 );
            lua_rawgeti( L , 2 , 2 );

            const b2Vec2 pos( self->world->screen_to_world( lua_tonumber( L , -2 ) ) ,
                    self->world->screen_to_world( lua_tonumber( L , -1 ) ) );

            lua_pop( L , 2 );

            self->body->SetTransform( pos , self->body->GetAngle() );

            self->synchronize_actor();
		]];

	double x
        [[
            self->check( L );

            const b2Vec2 & pos( self->body->GetPosition() );

            x = self->world->world_to_screen( pos.x );
        ]]
        [[
            self->check( L );

            b2Vec2 pos( self->body->GetTransform().position );

            pos.x = self->world->screen_to_world( x );

            self->body->SetTransform( pos , self->body->GetAngle() );

            self->synchronize_actor();
        ]];

    double y
        [[
            self->check( L );

            const b2Vec2 & pos( self->body->GetPosition() );

            y = self->world->world_to_screen( pos.y );
        ]]
        [[
            self->check( L );

            b2Vec2 pos( self->body->GetTransform().position );

            pos.y = self->world->screen_to_world( y );

            self->body->SetTransform( pos , self->body->GetAngle() );

            self->synchronize_actor();
        ]];

	double angle
		[[
            self->check( L );
			angle = Physics::World::radians_to_degrees( self->body->GetAngle() );
		]]
		[[
		    self->check( L );

            b2Vec2 pos( self->body->GetTransform().position );

            self->body->SetTransform( pos , Physics::World::degrees_to_radians( angle ) );

            self->synchronize_actor();
		]];

    double rotation
        [[
            self->check( L );
            rotation = Physics::World::radians_to_degrees( self->body->GetAngle() );
        ]]
        [[
            self->check( L );

            b2Vec2 pos( self->body->GetTransform().position );

            self->body->SetTransform( pos , Physics::World::degrees_to_radians( rotation ) );

            self->synchronize_actor();
        ]];

    readonly table world_center
        [[
            self->check( L );
            const b2Vec2 pos( self->body->GetWorldCenter() );
            lua_newtable( L );
            lua_pushnumber( L , self->world->world_to_screen( pos.x ) );
            lua_rawseti( L , -2 , 1 );
            lua_pushnumber( L , self->world->world_to_screen( pos.y ) );
            lua_rawseti( L , -2 , 2 );
        ]];

	readonly table local_center
        [[
            self->check( L );
            const b2Vec2 pos( self->body->GetLocalCenter() );
            lua_newtable( L );
            lua_pushnumber( L , self->world->world_to_screen( pos.x ) );
            lua_rawseti( L , -2 , 1 );
            lua_pushnumber( L , self->world->world_to_screen( pos.y ) );
            lua_rawseti( L , -2 , 2 );
        ]];
		
	table linear_velocity
		[[
            self->check( L );

            b2Vec2 lv( self->body->GetLinearVelocity() );
			
			lua_newtable( L );
			lua_pushnumber( L , lv.x );
			lua_rawseti( L , -2 , 1 );
			lua_pushnumber( L , lv.y );
			lua_rawseti( L , -2 , 2 );	
		]]
		[[
            self->check( L );

			lua_rawgeti( L , 2 , 1 );
			lua_rawgeti( L , 2 , 2 );
			
			self->body->SetLinearVelocity( b2Vec2( lua_tonumber( L , -2 ) , lua_tonumber( L , -1 ) ) );
			lua_pop( L , 2 );
		]];
		
	double angular_velocity
		[[
            self->check( L );

			angular_velocity = Physics::World::radians_to_degrees( self->body->GetAngularVelocity() );
		]]
		[[
            self->check( L );

			self->body->SetAngularVelocity( Physics::World::degrees_to_radians( angular_velocity ) );
		]];

	readonly double mass
        [[
            self->check( L );

            mass = self->body->GetMass();
        ]];

	/* TODO: mass_data */
		
	double linear_damping
        [[
            self->check( L );

            linear_damping = self->body->GetLinearDamping();
        ]]
        [[
            self->check( L );

            self->body->SetLinearDamping( linear_damping );
        ]];

	double angular_damping
        [[
            self->check( L );

            angular_damping = self->body->GetAngularDamping();
        ]]
        [[
            self->check( L );

            self->body->SetAngularDamping( angular_damping );
        ]];

	bool bullet
        [[
            self->check( L );

            bullet = self->body->IsBullet();
        ]]
        [[
            self->check( L );

            self->body->SetBullet( bullet );
        ]];

	bool sleeping_allowed
        [[
            self->check( L );

            sleeping_allowed = self->body->IsSleepingAllowed();
        ]]
        [[
            self->check( L );

            self->body->SetSleepingAllowed( sleeping_allowed );
        ]];

	bool fixed_rotation
        [[
            self->check( L );

            fixed_rotation = self->body->IsFixedRotation();
        ]]
        [[
            self->check( L );

            self->body->SetFixedRotation( fixed_rotation );
        ]];

	readonly table contacts
        [[
            self->check( L );

            self->world->push_contact_list( self->body->GetContactList() );
        ]];

	synchronize( )
        [[
            self->check( L );

            self->synchronize_body();
        ]];

	apply_force( table force , table point )
		[[
            self->check( L );

            lua_rawgeti( L , force , 1 );
            lua_rawgeti( L , force , 2 );

            lua_rawgeti( L , point , 1 );
            lua_rawgeti( L , point , 2 );

			self->body->ApplyForce(
			    b2Vec2( lua_tonumber( L , -4 ) , lua_tonumber( L , -3 ) ) ,
				b2Vec2( self->world->screen_to_world( lua_tonumber( L , -2 ) ),
				        self->world->screen_to_world( lua_tonumber( L , -1 ) ) ) );

			lua_pop( L , 4 );
		]];
		
	apply_torque( double torque )
		[[
            self->check( L );

            self->body->ApplyTorque( torque );
		]];
		
	apply_linear_impulse( table force , table point )
		[[
            self->check( L );

            lua_rawgeti( L , force , 1 );
            lua_rawgeti( L , force , 2 );

            lua_rawgeti( L , point , 1 );
            lua_rawgeti( L , point , 2 );

            self->body->ApplyLinearImpulse(
                    b2Vec2( lua_tonumber( L , -4 ) , lua_tonumber( L , -3 ) ) ,
                    b2Vec2( self->world->screen_to_world( lua_tonumber( L , -2 ) ),
                          self->world->screen_to_world( lua_tonumber( L , -1 ) ) ) );

            lua_pop( L , 4 );
		]];
	
	apply_angular_impulse( double impulse )
        [[
            self->check( L );

            self->body->ApplyAngularImpulse( impulse );
        ]];

    Body set( table props )
        [[
            self->check( L );
            ClutterUtil::set_props_from_table( L , props );
            lua_pushvalue( L , 1 );
        ]];

    #-------------------------------------------------------------------------
    # Fixtures

    readonly table fixtures
        [[
            self->check( L );

            lua_newtable( L );
            int t = lua_gettop( L );
            int i = 1;

            for( b2Fixture * f = self->body->GetFixtureList(); f ; f = f->GetNext() , ++i )
            {
                lua_newtable( L );

                lua_pushinteger( L , GPOINTER_TO_INT( f->GetUserData() ) );
                lua_setfield( L , -2 , "handle" );

                switch( f->GetType() )
                {
                    case b2Shape::e_circle:
                        lua_pushstring( L , "circle" );
                        break;

                    case b2Shape::e_polygon:
                        lua_pushstring( L , "polygon" );
                        break;

                    default:
                        lua_pushnil( L );
                }

                lua_setfield( L , -2 , "type" );

                lua_pushboolean( L , f->IsSensor() );
                lua_setfield( L , -2 , "sensor" );

                lua_pushnumber( L , f->GetDensity() );
                lua_setfield( L , -2 , "density" );

                lua_pushnumber( L , f->GetFriction() );
                lua_setfield( L , -2 , "friction" );

                lua_pushnumber( L , f->GetRestitution() );
                lua_setfield( L , -2 , "bounce" );

                lua_rawseti( L , t , i );
            }
        ]];

    bool remove_fixture( int fixture_handle )
        [[
            self->check( L );

            result = false;

            for( b2Fixture * f = self->body->GetFixtureList(); f ; f = f->GetNext() )
            {
                if ( GPOINTER_TO_INT( f->GetUserData() ) == fixture_handle )
                {
                    result = true;
                    f->GetBody()->DestroyFixture( f );
                    break;
                }
            }
        ]];

    remove_all_fixtures()
        [[
            self->check( L );

            for( b2Fixture * f = self->body->GetFixtureList(); f ; )
            {
                b2Fixture * next = f->GetNext();

                f->GetBody()->DestroyFixture( f );

                f = next;
            }

        ]];

    int add_fixture( table properties )
        [[
            self->check( L );

            result = 0;

            b2FixtureDef fd = self->world->create_fixture_def( properties );

            if ( ! fd.shape )
            {
                return luaL_error( L , "Missing shape" );
            }

            result = self->world->get_next_handle();

            fd.userData = GINT_TO_POINTER( result );

            self->body->CreateFixture( & fd );
        ]];

    #..........................................................................
    # Joints

    bool remove_joint( int joint_handle )
        [[
            self->check( L );

            gpointer h = GINT_TO_POINTER( joint_handle );

            result = false;

            for( b2JointEdge * e = self->body->GetJointList(); e; e = e->next )
            {
                if ( e->joint && e->joint->GetUserData() == h )
                {
                    result = true;

                    self->world->get_world()->DestroyJoint( e->joint );

                    break;
                }
            }
        ]];

    int DistanceJoint( table anchor , Body other_body , table other_anchor , table properties = 0 )
        [[
            self->check( L );

            Physics::Body * other = Physics::Body::get_from_lua( L , other_body );

            if ( ! other )
            {
                return luaL_error( L , "Invalid body" );
            }

            other->check( L );

            b2Body * ba = self->body;
            b2Body * bb = other->body;

            lua_rawgeti( L , anchor , 1 );
            lua_rawgeti( L , anchor , 2 );

            float32 ax = self->world->screen_to_world( lua_tonumber( L , -2 ) );
            float32 ay = self->world->screen_to_world( lua_tonumber( L , -1 ) );

            lua_pop( L , 2 );

            lua_rawgeti( L , other_anchor , 1 );
            lua_rawgeti( L , other_anchor , 2 );

            float32 bx = self->world->screen_to_world( lua_tonumber( L , -2 ) );
            float32 by = self->world->screen_to_world( lua_tonumber( L , -1 ) );

            lua_pop( L , 2 );

            b2DistanceJointDef d;

            d.Initialize( ba , bb , b2Vec2( ax , ay ) , b2Vec2( bx , by ) );

            if ( properties )
            {
                lua_getfield( L , properties , "frequency" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    d.frequencyHz = lua_tonumber( L , -1 );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "damping_ratio" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    d.dampingRatio = lua_tonumber( L , -1 );
                }
                lua_pop( L , 1 );
            }

            result = self->world->get_next_handle();

            b2Joint * joint = self->world->get_world()->CreateJoint( & d );

            joint->SetUserData( GINT_TO_POINTER( result ) );

        ]];

    int RevoluteJoint( Body other_body , table anchor , table properties = 0 )
        [[
            self->check( L );

            Physics::Body * other = Physics::Body::get_from_lua( L , other_body );

            if ( ! other )
            {
                return luaL_error( L , "Invalid body" );
            }

            other->check( L );

            b2Body * ba = self->body;
            b2Body * bb = other->body;

            lua_rawgeti( L , anchor , 1 );
            lua_rawgeti( L , anchor , 2 );

            float32 x = self->world->screen_to_world( lua_tonumber( L , -2 ) );
            float32 y = self->world->screen_to_world( lua_tonumber( L , -1 ) );

            lua_pop( L , 2 );

            b2RevoluteJointDef j;

            j.Initialize( ba , bb , b2Vec2( x , y ) );

            if ( properties )
            {
                lua_getfield( L , properties , "enable_limit" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    j.enableLimit = lua_toboolean( L , -1 );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "lower_angle" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    j.lowerAngle = Physics::World::degrees_to_radians( lua_tonumber( L , -1 ) );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "upper_angle" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    j.upperAngle = Physics::World::degrees_to_radians( lua_tonumber( L , -1 ) );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "enable_motor" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    j.enableMotor = lua_toboolean( L , -1 );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "motor_speed" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    j.motorSpeed = Physics::World::degrees_to_radians( lua_tonumber( L , -1 ) );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "max_motor_torque" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    j.maxMotorTorque = lua_tonumber( L , -1 );
                }
                lua_pop( L , 1 );

            }

            result = self->world->get_next_handle();

            b2Joint * joint = self->world->get_world()->CreateJoint( & j );

            joint->SetUserData( GINT_TO_POINTER( result ) );
        ]];

    callback on_begin_contact( table contact )
        [[
            self->world->attach_body_callback( self , Physics::BEGIN_CONTACT , on_begin_contact );
        ]];

    callback on_end_contact( table contact )
        [[
            self->world->attach_body_callback( self , Physics::END_CONTACT , on_end_contact );
        ]];


    callback on_pre_solve_contact( table contact )
        [[
            self->world->attach_body_callback( self , Physics::PRE_SOLVE_CONTACT , on_pre_solve_contact );
        ]];

    callback on_post_solve_contact( table contact )
        [[
            self->world->attach_body_callback( self , Physics::POST_SOLVE_CONTACT , on_post_solve_contact );
        ]];
}

/*===========================================================================*/

global physics [[ Physics::World * ]]
{
	physics()
		[[
            ClutterActor * screen = clutter_get_actor_by_gid( App::get( L )->get_screen_gid() );

			self = lb_construct( Physics::World , new Physics::World( L , screen , 64 ) );
		]];
		
	~physics()
		[[
			delete self;
		]];

	double pixels_per_meter
        [[
            pixels_per_meter = self->ppm;
        ]]
        [[
            self->ppm = pixels_per_meter;
        ]];

    table gravity
        [[
            b2Vec2 g( self->get_world()->GetGravity() );
            lua_newtable( L );
            lua_pushnumber( L , g.x );
            lua_rawseti( L , -2 , 1 );
            lua_pushnumber( L , g.y );
            lua_rawseti( L , -2 , 2 );
        ]]
        [[
            luaL_checktype(L,2,LUA_TTABLE);
            lua_rawgeti( L , 2 , 1 );
            lua_rawgeti( L , 2 , 2 );
            b2Vec2 g( lua_tonumber( L , -2 ) , lua_tonumber( L , -1 ) );
            self->get_world()->SetGravity( g );
            lua_pop( L , 2 );
        ]];

    readonly table contacts
        [[
            self->push_contact_list( self->get_world()->GetContactList() );
        ]];

    readonly bool running
        [[
            running = self->running();
        ]];

    start( int velocity_iterations = 6, int position_iterations = 2 )
        [[
            self->start( velocity_iterations , position_iterations );
        ]];

	stop()
        [[
            self->stop();
        ]];
		
	step( double time_step = 1.0f/60.0f , int velocity_iterations = 6, int position_iterations = 2 )
		[[
            self->step( time_step , velocity_iterations , position_iterations );
		]];

	draw_debug( int opacity = 127 )
        [[
            self->draw_debug( opacity );
        ]];

	clear_debug()
        [[
            self->clear_debug();
        ]];
		
	Body Body( table properties )
		[[
            int n = self->create_body( properties , new_Body );

            if ( ! n )
            {
                lua_pushnil( L );
            }
            else
            {
                ClutterUtil::set_props_from_table( L , properties );
            }
		]];

    #..........................................................................
    # Shape factory methods

	Shape Box( table size , table center = 0 , double rotation = 0 )
        [[
            b2PolygonShape * shape = new b2PolygonShape();

            if ( ! center )
            {
                lua_rawgeti( L , size , 1 );
                lua_rawgeti( L , size , 2 );

                shape->SetAsBox( self->screen_to_world( lua_tonumber( L , -2 ) * 0.5 ) ,
                    self->screen_to_world( lua_tonumber( L , -1 ) * 0.5 ) );

                lua_pop( L , 2 );
            }
            else
            {
                lua_rawgeti( L , size , 1 );
                lua_rawgeti( L , size , 2 );

                lua_rawgeti( L , center , 1 );
                lua_rawgeti( L , center , 2 );

                shape->SetAsBox( self->screen_to_world( lua_tonumber( L , -4 ) * 0.5 ) ,
                        self->screen_to_world( lua_tonumber( L , -3 ) * 0.5 ),
                        b2Vec2( self->screen_to_world( lua_tonumber( L , -2 ) ),
                                self->screen_to_world( lua_tonumber( L , -1 ) ) ),
                        Physics::World::degrees_to_radians( rotation ) );

                lua_pop( L , 4 );
            }

            lua_pushlightuserdata( L , shape );

            new_Shape( L );

            lua_remove( L , -2 );
        ]];

	Shape Edge( table point_a , table point_b )
        [[
            b2PolygonShape * shape = new b2PolygonShape();

            lua_rawgeti( L , point_a , 1 );
            lua_rawgeti( L , point_a , 2 );
            lua_rawgeti( L , point_b , 1 );
            lua_rawgeti( L , point_b , 2 );

            shape->SetAsEdge( b2Vec2( self->screen_to_world( lua_tonumber( L , -4 ) ) ,
                    self->screen_to_world( lua_tonumber( L , -3 ) ) ),
                    b2Vec2( self->screen_to_world( lua_tonumber( L , -2 ) ) ,
                            self->screen_to_world( lua_tonumber( L , -1 ) ) ) );

            lua_pop( L , 4 );

            lua_pushlightuserdata( L , shape );

            new_Shape( L );

            lua_remove( L , -2 );
        ]];


	Shape Polygon( table points )
        [[
            std::vector< b2Vec2 > p;

            lua_pushnil( L );

            while( lua_next( L , points ) )
            {
                if ( lua_istable( L , -1 ) )
                {
                    lua_rawgeti( L , -1 , 1 );
                    lua_rawgeti( L , -2 , 2 );

                    p.push_back(
                            b2Vec2( self->screen_to_world( lua_tonumber( L , -2 ) ) ,
                                    self->screen_to_world( lua_tonumber( L , -1 ) ) ) );

                    lua_pop( L , 2 );
                }
                lua_pop( L , 1 );
            }

            if ( p.empty() )
            {
                return luaL_error( L , "Invalid polygon points" );
            }

            b2PolygonShape * shape = new b2PolygonShape();

            shape->Set( & p[ 0 ] , p.size() );

            lua_pushlightuserdata( L , shape );
            new_Shape( L );
            lua_remove( L , -2 );
        ]];

	Shape Circle( double radius , table center = 0 )
        [[
            b2CircleShape * shape = new b2CircleShape();

            shape->m_radius = self->screen_to_world( radius );

            shape->m_p.SetZero();

            if ( center )
            {
                lua_rawgeti( L , center , 1 );
                lua_rawgeti( L , center , 2 );

                shape->m_p.Set( self->screen_to_world( lua_tonumber( L , -2 ) ) ,
                        self->screen_to_world( lua_tonumber( L , -1 ) ) );

                lua_pop( L , 2 );
            }

            lua_pushlightuserdata( L , shape );

            new_Shape( L );

            lua_remove( L , -2 );
        ]];

    #..........................................................................


	callback on_begin_contact( table contact )
        [[
            self->attach_global_callback( Physics::BEGIN_CONTACT , on_begin_contact );
        ]];

    callback on_end_contact( table contact )
        [[
            self->attach_global_callback( Physics::END_CONTACT , on_end_contact );
        ]];

    callback on_pre_solve_contact( table contact )
        [[
            self->attach_global_callback( Physics::PRE_SOLVE_CONTACT , on_pre_solve_contact );
        ]];

    callback on_post_solve_contact( table contact )
        [[
            self->attach_global_callback( Physics::POST_SOLVE_CONTACT , on_post_solve_contact );
        ]];
}

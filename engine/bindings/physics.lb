
module physics_module;

[[
#include "Box2D/Box2D.h"
#include "clutter/clutter.h"

#include "physics.h"
#include "clutter_util.h"
]]

/*===========================================================================*/

/*

	Interface: Shape

	TODO

*/

interface Shape [[ b2Shape * ]]
{
    Shape()
        [[
            self = lb_construct( b2Shape , lua_touserdata( L , -2 ) );
        ]];

    ~Shape()
        [[
            delete self;
        ]];
}

/*===========================================================================*/

/*
	Interface: Body

	TODO

*/

interface Body [[ ClutterActor * ]]
{

	/*
		Property: handle

		The handle property is an integer that uniquely identifies this body. It is used in
		collision callbacks to refer to the two bodies that are colliding.
	*/

	readonly int handle
        [[
            Physics::Body * me = Physics::Body::get( self );
            handle = me->handle;
        ]];

	/*
		Property: type

		The type property is a string specifying the Body object's type.

		*Supported Settings:* The type setting is case-sensitive.

		"static" - the body has infinite mass; it is immovable when operating under the influence of the physics engine, but can be moved manually by the user
		"kinematic" - moves according to its velocity, but is not influenced by other forces, such as gravity or collisions. Behaves as if it had infinite mass.
		"dynamic" - moves according to the forces placed upon it, such as gravity and collisions. Has finite, non-zero mass.

		*Default Settings:* "dynamic"

		TODO
	*/

	string type
	    [[
            Physics::Body * me = Physics::Body::get( self );
            switch( me->body->GetType() )
            {
                case b2_staticBody:
                    type = "static";
                    break;

                case b2_kinematicBody:
                    type = "kinematic";
                    break;

                case b2_dynamicBody:
                    type = "dynamic";
                    break;

                default:
                    type = 0;
                    break;
            }
	    ]]
	    [[
            Physics::Body * me = Physics::Body::get( self );

            if ( ! type )
            {
                luaL_error( L , "Invalid body type" );
            }
            else
            {
                if ( ! strcmp( type , "static" ) )
                {
                    me->body->SetType( b2_staticBody );
                }
                else if ( ! strcmp( type , "kinematic" ) )
                {
                    me->body->SetType( b2_kinematicBody );
                }
                else if ( ! strcmp( type , "dynamic" ) )
                {
                    me->body->SetType( b2_dynamicBody );
                }
                else
                {
                    luaL_error( L , "Invalid body type '%s'" , type );
                }
            }
	    ]];

	/*
		Property: awake

		When the physics engine determines that a body has come to rest, it is put to "sleep",
		waiting on a collision to wake it up. You can also explicitly wake up a body by setting
		this property to true.
	*/

	bool awake
		[[
            Physics::Body * me = Physics::Body::get( self );
			awake = me->body->IsAwake();
		]]
		[[
            Physics::Body * me = Physics::Body::get( self );
			me->body->SetAwake( awake );
		]];

	/*
		Property: active

		This property lets you specify whether a body participates in the physics simulation. A body
		that is not active will be ignored.
	*/

	bool active
		[[
            Physics::Body * me = Physics::Body::get( self );
			active = me->body->IsActive();
		]]
		[[
            Physics::Body * me = Physics::Body::get( self );
			me->body->SetActive( active );
		]];

	/*
		Property: position

		A table of X and Y screen coordinates for the position of the center of the body.
	*/

	table position
		[[
            Physics::Body * me = Physics::Body::get( self );

            const b2Vec2 & pos( me->body->GetPosition() );

			lua_newtable( L );
			lua_pushnumber( L , me->world->world_to_screen( pos.x ) );
			lua_rawseti( L , -2 , 1 );
			lua_pushnumber( L , me->world->world_to_screen( pos.y ) );
			lua_rawseti( L , -2 , 2 );
		]]
		[[
            Physics::Body * me = Physics::Body::get( self );

            lua_rawgeti( L , 2 , 1 );
            lua_rawgeti( L , 2 , 2 );

            const b2Vec2 pos( me->world->screen_to_world( lua_tonumber( L , -2 ) ) ,
                    me->world->screen_to_world( lua_tonumber( L , -1 ) ) );

            lua_pop( L , 2 );

            me->body->SetTransform( pos , me->body->GetAngle() );

            me->synchronize_actor();
		]];

	/*
		Property: x

		The X screen coordinate of the body's center.
	*/

	double x
        [[
            Physics::Body * me = Physics::Body::get( self );

            const b2Vec2 & pos( me->body->GetPosition() );

            x = me->world->world_to_screen( pos.x );
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            b2Vec2 pos( me->body->GetTransform().position );

            pos.x = me->world->screen_to_world( x );

            me->body->SetTransform( pos , me->body->GetAngle() );

            me->synchronize_actor();
        ]];

	/*
		Property: y

		The Y screen coordinate of the body's center.
	*/

    double y
        [[
            Physics::Body * me = Physics::Body::get( self );

            if ( me->world->z_for_y )
            {
                y = clutter_actor_get_y( self );
            }
            else
            {
                const b2Vec2 & pos( me->body->GetPosition() );

                y = me->world->world_to_screen( pos.y );
            }
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            if ( me->world->z_for_y )
            {
                clutter_actor_set_y( self , y );
            }
            else
            {
                b2Vec2 pos( me->body->GetTransform().position );

                pos.y = me->world->screen_to_world( y );

                me->body->SetTransform( pos , me->body->GetAngle() );

                me->synchronize_actor();
            }
        ]];


    /*
        Property: z

        The Z coordinate of the body's center.
    */

    double z
        [[
            Physics::Body * me = Physics::Body::get( self );

            if ( ! me->world->z_for_y )
            {
                z = clutter_actor_get_depth( self );
            }
            else
            {
                const b2Vec2 & pos( me->body->GetPosition() );

                z = me->world->world_to_screen( pos.y );
            }
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            if ( ! me->world->z_for_y )
            {
                clutter_actor_set_depth( self , z );
            }
            else
            {
                b2Vec2 pos( me->body->GetTransform().position );

                pos.y = me->world->screen_to_world( z );

                me->body->SetTransform( pos , me->body->GetAngle() );

                me->synchronize_actor();
            }
        ]];

    /*
        Property: depth

        The Z coordinate of the body's center.
    */

    double depth
        [[
            Physics::Body * me = Physics::Body::get( self );

            if ( ! me->world->z_for_y )
            {
                depth = clutter_actor_get_depth( self );
            }
            else
            {
                const b2Vec2 & pos( me->body->GetPosition() );

                depth = - me->world->world_to_screen( pos.y );
            }
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            if ( ! me->world->z_for_y )
            {
                clutter_actor_set_depth( self , depth );
            }
            else
            {
                b2Vec2 pos( me->body->GetTransform().position );

                pos.y = me->world->screen_to_world( - depth );

                me->body->SetTransform( pos , me->body->GetAngle() );

                me->synchronize_actor();
            }
        ]];

	/*
		Property: angle

		The angle of rotation (in degrees) along the Z axis.
	*/

	double angle
		[[
            Physics::Body * me = Physics::Body::get( self );
			angle = Physics::World::radians_to_degrees( me->body->GetAngle() );
		]]
		[[
            Physics::Body * me = Physics::Body::get( self );

            b2Vec2 pos( me->body->GetTransform().position );

            me->body->SetTransform( pos , Physics::World::degrees_to_radians( angle ) );

            me->synchronize_actor();
		]];

	/*
		Property: rotation

		Same as <angle>.
	*/

    double rotation
        [[
            Physics::Body * me = Physics::Body::get( self );
            rotation = Physics::World::radians_to_degrees( me->body->GetAngle() );
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            b2Vec2 pos( me->body->GetTransform().position );

            me->body->SetTransform( pos , Physics::World::degrees_to_radians( rotation ) );

            me->synchronize_actor();
        ]];

	/*
		Property: world_center

		A table of X and Y coordinates for the world center of this body.
	*/

    readonly table world_center
        [[
            Physics::Body * me = Physics::Body::get( self );
            const b2Vec2 pos( me->body->GetWorldCenter() );
            lua_newtable( L );
            lua_pushnumber( L , me->world->world_to_screen( pos.x ) );
            lua_rawseti( L , -2 , 1 );
            lua_pushnumber( L , me->world->world_to_screen( pos.y ) );
            lua_rawseti( L , -2 , 2 );
        ]];

	/*
		Property: local_center

	    A table of X and Y coordinates for this body's center.
	*/

	readonly table local_center
        [[
            Physics::Body * me = Physics::Body::get( self );
            const b2Vec2 pos( me->body->GetLocalCenter() );
            lua_newtable( L );
            lua_pushnumber( L , me->world->world_to_screen( pos.x ) );
            lua_rawseti( L , -2 , 1 );
            lua_pushnumber( L , me->world->world_to_screen( pos.y ) );
            lua_rawseti( L , -2 , 2 );
        ]];

	/*
		Property: linear_velocity

		A table of velocity in X and Y direction.
	*/

	table linear_velocity
		[[
            Physics::Body * me = Physics::Body::get( self );

            b2Vec2 lv( me->body->GetLinearVelocity() );

			lua_newtable( L );
			lua_pushnumber( L , lv.x );
			lua_rawseti( L , -2 , 1 );
			lua_pushnumber( L , lv.y );
			lua_rawseti( L , -2 , 2 );
		]]
		[[
            Physics::Body * me = Physics::Body::get( self );

			lua_rawgeti( L , 2 , 1 );
			lua_rawgeti( L , 2 , 2 );

			me->body->SetLinearVelocity( b2Vec2( lua_tonumber( L , -2 ) , lua_tonumber( L , -1 ) ) );
			lua_pop( L , 2 );
		]];

	/*
		Property: angular_velocity

		The velocity of the body's rotation around the Z axis.
	*/

	double angular_velocity
		[[
            Physics::Body * me = Physics::Body::get( self );

			angular_velocity = Physics::World::radians_to_degrees( me->body->GetAngularVelocity() );
		]]
		[[
            Physics::Body * me = Physics::Body::get( self );

			me->body->SetAngularVelocity( Physics::World::degrees_to_radians( angular_velocity ) );
		]];

	/*
		Property: mass

		The mass of the body.
	*/

	readonly double mass
        [[
            Physics::Body * me = Physics::Body::get( self );

            mass = me->body->GetMass();
        ]];

	/* TODO: mass_data */

	/*
		Property: linear_damping

		Damping value for the body's linear velocity.
	*/

	double linear_damping
        [[
            Physics::Body * me = Physics::Body::get( self );

            linear_damping = me->body->GetLinearDamping();
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->body->SetLinearDamping( linear_damping );
        ]];

	/*
		Property: angular_damping

		Damping value for the body's angular velocity.
	*/

	double angular_damping
        [[
            Physics::Body * me = Physics::Body::get( self );

            angular_damping = me->body->GetAngularDamping();
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->body->SetAngularDamping( angular_damping );
        ]];

	/*
		Property: bullet

		Whether this body is considered a bullet (a very fast-moving body). This
		has implications on collision detection for the body; extra work is performed
		to avoid tunneling.
	*/

	bool bullet
        [[
            Physics::Body * me = Physics::Body::get( self );

            bullet = me->body->IsBullet();
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->body->SetBullet( bullet );
        ]];

	/*
		Property: sleeping_allowed

		Whether the body is allowed to go to sleep when it comes to rest.
	*/

	bool sleeping_allowed
        [[
            Physics::Body * me = Physics::Body::get( self );

            sleeping_allowed = me->body->IsSleepingAllowed();
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->body->SetSleepingAllowed( sleeping_allowed );
        ]];

	/*
		Property: fixed_rotation

		If fixed rotation is set to true, the body will not rotate
		along the Z axis.
	*/

	bool fixed_rotation
        [[
            Physics::Body * me = Physics::Body::get( self );

            fixed_rotation = me->body->IsFixedRotation();
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->body->SetFixedRotation( fixed_rotation );
        ]];

	/*
		Property: contacts

		A table of current contacts for this body (touch points
		with other bodies).
	*/

	readonly table contacts
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->world->push_contact_list( me->body->GetContactList() );
        ]];

	/*
		Function: synchronize

		Explicitly insures that this body and its UIElement are in synch.
	*/

	synchronize( )
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->synchronize_body();
        ]];

	/*
		Function: apply_force

		Apply a force to the body.

		force - A table of X and Y forces.
		point - The point, on the body where the force should be applied. This is a
		        table of X and Y coordinates.
	*/

	apply_force( table force , table point )
		[[
            Physics::Body * me = Physics::Body::get( self );

            lua_rawgeti( L , force , 1 );
            lua_rawgeti( L , force , 2 );

            lua_rawgeti( L , point , 1 );
            lua_rawgeti( L , point , 2 );

			me->body->ApplyForce(
			    b2Vec2( lua_tonumber( L , -4 ) , lua_tonumber( L , -3 ) ) ,
				b2Vec2( me->world->screen_to_world( lua_tonumber( L , -2 ) ),
				        me->world->screen_to_world( lua_tonumber( L , -1 ) ) ) );

			lua_pop( L , 4 );
		]];

	/*
		Function: apply_torque

		A force to apply that will cause the body to rotate.
	*/

	apply_torque( double torque )
		[[
            Physics::Body * me = Physics::Body::get( self );

            me->body->ApplyTorque( torque );
		]];

	/*
		Function: apply_linear_impulse

		A linear impulse to apply to the body.

		force - X and Y force values.
		point - The point, on the body, where the impulse should be applied. This is a
		        table of X and Y coordinates.
	*/

	apply_linear_impulse( table force , table point )
		[[
            Physics::Body * me = Physics::Body::get( self );

            lua_rawgeti( L , force , 1 );
            lua_rawgeti( L , force , 2 );

            lua_rawgeti( L , point , 1 );
            lua_rawgeti( L , point , 2 );

            me->body->ApplyLinearImpulse(
                    b2Vec2( lua_tonumber( L , -4 ) , lua_tonumber( L , -3 ) ) ,
                    b2Vec2( me->world->screen_to_world( lua_tonumber( L , -2 ) ),
                          me->world->screen_to_world( lua_tonumber( L , -1 ) ) ) );

            lua_pop( L , 4 );
		]];

	/*
		Function: apply_angular_impulse

		An impulse that will rotate the body.
	*/

	apply_angular_impulse( double impulse )
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->body->ApplyAngularImpulse( impulse );
        ]];


    #-------------------------------------------------------------------------
    # Fixtures

	/*
		Property: fixtures

		Returns a table of all fixtures belonging to this body. For each fixture, the
		following keys are provided:

		handle - An integer that uniquely identifies the fixture.
		type - "circle" or "polygon".
		sensor - Boolean indicating whether the fixture is a sensor.
		density - The density of the fixture.
		friction - The friction of the fixture.
		bounce - Restitution value for the fixture.
	*/

    readonly table fixtures
        [[
            Physics::Body * me = Physics::Body::get( self );

            lua_newtable( L );
            int t = lua_gettop( L );
            int i = 1;

            for( b2Fixture * f = me->body->GetFixtureList(); f ; f = f->GetNext() , ++i )
            {
                lua_newtable( L );

                lua_pushinteger( L , GPOINTER_TO_INT( f->GetUserData() ) );
                lua_setfield( L , -2 , "handle" );

                switch( f->GetType() )
                {
                    case b2Shape::e_circle:
                        lua_pushstring( L , "circle" );
                        break;

                    case b2Shape::e_polygon:
                        lua_pushstring( L , "polygon" );
                        break;

                    default:
                        lua_pushnil( L );
                }

                lua_setfield( L , -2 , "type" );

                lua_pushboolean( L , f->IsSensor() );
                lua_setfield( L , -2 , "sensor" );

                lua_pushnumber( L , f->GetDensity() );
                lua_setfield( L , -2 , "density" );

                lua_pushnumber( L , f->GetFriction() );
                lua_setfield( L , -2 , "friction" );

                lua_pushnumber( L , f->GetRestitution() );
                lua_setfield( L , -2 , "bounce" );

                lua_rawseti( L , t , i );
            }
        ]];

	/*
		Function: remove_fixture()

		Removes the given fixture from the body.
	*/

    bool remove_fixture( int fixture_handle )
        [[
            Physics::Body * me = Physics::Body::get( self );

            result = false;

            for( b2Fixture * f = me->body->GetFixtureList(); f ; f = f->GetNext() )
            {
                if ( GPOINTER_TO_INT( f->GetUserData() ) == fixture_handle )
                {
                    result = true;
                    f->GetBody()->DestroyFixture( f );
                    break;
                }
            }
        ]];

	/*
		Function: remove_all_fixtures

		Removes all fixtures from the body.
	*/

    remove_all_fixtures()
        [[
            Physics::Body * me = Physics::Body::get( self );

            for( b2Fixture * f = me->body->GetFixtureList(); f ; )
            {
                b2Fixture * next = f->GetNext();

                f->GetBody()->DestroyFixture( f );

                f = next;
            }

        ]];

	/*
		Function: add_fixture

		Adds a new fixture to the body. A fixture can have the following properties:

		friction - Between 0 (slippery) and 1 (not slippery at all).
		restitution or bounce - Between 0 (not bouncy) and 1 (perfectly elastic).
		density - The density of the fixture.
		sensor - Whether the fixture is a sensor. A sensor fixture does not affect
		          other fixtures but detects contacts.
        filter - Collision filtering. (TODO: Complicated, need full explanation).
        shape - The shape for the fixture, this can be created using the <Box>,
                <Edge>, <Polygon> or <Circle> functions on the <physics> global.
	*/

    int add_fixture( table properties )
        [[
            Physics::Body * me = Physics::Body::get( self );

            result = 0;

            b2FixtureDef fd = me->world->create_fixture_def( properties );

            if ( ! fd.shape )
            {
                return luaL_error( L , "Missing shape" );
            }

            result = me->world->get_next_handle();

            fd.userData = GINT_TO_POINTER( result );

            me->body->CreateFixture( & fd );
        ]];

    #..........................................................................
    # Joints

	/*
		Function: remove_joint

		Removes a joint from the body.
	*/

    bool remove_joint( int joint_handle )
        [[
            Physics::Body * me = Physics::Body::get( self );

            gpointer h = GINT_TO_POINTER( joint_handle );

            result = false;

            for( b2JointEdge * e = me->body->GetJointList(); e; e = e->next )
            {
                if ( e->joint && e->joint->GetUserData() == h )
                {
                    result = true;

                    me->world->get_world()->DestroyJoint( e->joint );

                    break;
                }
            }
        ]];

	/*
		Function: DistanceJoint

		Creates a distance joint on this body.

		anchor - The X and Y coordinates for the joint's anchor on this body.
		other_body - The other body this joint will be attached to.
		other_anchor - The X and Y coordinates on the other body.
		properties - "frequency" and "damping_ratio".
	*/

    int DistanceJoint( table anchor , Body other_body , table other_anchor , table properties = 0 )
        [[
            lb_check_udata_type( L , other_body , "Body" );

            Physics::Body * me = Physics::Body::get( self );

            Physics::Body * other = Physics::Body::get_from_lua( L , other_body );

            if ( ! other )
            {
                return luaL_error( L , "Invalid body" );
            }

            b2Body * ba = me->body;
            b2Body * bb = other->body;

            lua_rawgeti( L , anchor , 1 );
            lua_rawgeti( L , anchor , 2 );

            float32 ax = me->world->screen_to_world( lua_tonumber( L , -2 ) );
            float32 ay = me->world->screen_to_world( lua_tonumber( L , -1 ) );

            lua_pop( L , 2 );

            lua_rawgeti( L , other_anchor , 1 );
            lua_rawgeti( L , other_anchor , 2 );

            float32 bx = me->world->screen_to_world( lua_tonumber( L , -2 ) );
            float32 by = me->world->screen_to_world( lua_tonumber( L , -1 ) );

            lua_pop( L , 2 );

            b2DistanceJointDef d;

            d.Initialize( ba , bb , b2Vec2( ax , ay ) , b2Vec2( bx , by ) );

            if ( properties )
            {
                lua_getfield( L , properties , "frequency" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    d.frequencyHz = lua_tonumber( L , -1 );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "damping_ratio" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    d.dampingRatio = lua_tonumber( L , -1 );
                }
                lua_pop( L , 1 );
            }

            result = me->world->get_next_handle();

            b2Joint * joint = me->world->get_world()->CreateJoint( & d );

            joint->SetUserData( GINT_TO_POINTER( result ) );

        ]];

	/*
		Function: RevoluteJoint

		Creates a revolute joint on this body.

		other_body - The other body to attach to.
		anchor - Coordinates for the point where the joint is attached.
		properties -  "enable_limit" (boolean)
		              "lower_angle" (degrees)
		              "upper_angle" (degrees)
		              "enable_motor" (boolean)
		              "motor_speed" (number)
		              "max_motor_torque" (number)
	*/

    int RevoluteJoint( Body other_body , table anchor , table properties = 0 )
        [[
            lb_check_udata_type( L , other_body , "Body" );

            Physics::Body * me = Physics::Body::get( self );

            Physics::Body * other = Physics::Body::get_from_lua( L , other_body );

            if ( ! other )
            {
                return luaL_error( L , "Invalid body" );
            }

            b2Body * ba = me->body;
            b2Body * bb = other->body;

            lua_rawgeti( L , anchor , 1 );
            lua_rawgeti( L , anchor , 2 );

            float32 x = me->world->screen_to_world( lua_tonumber( L , -2 ) );
            float32 y = me->world->screen_to_world( lua_tonumber( L , -1 ) );

            lua_pop( L , 2 );

            b2RevoluteJointDef j;

            j.Initialize( ba , bb , b2Vec2( x , y ) );

            if ( properties )
            {
                lua_getfield( L , properties , "enable_limit" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    j.enableLimit = lua_toboolean( L , -1 );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "lower_angle" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    j.lowerAngle = Physics::World::degrees_to_radians( lua_tonumber( L , -1 ) );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "upper_angle" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    j.upperAngle = Physics::World::degrees_to_radians( lua_tonumber( L , -1 ) );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "enable_motor" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    j.enableMotor = lua_toboolean( L , -1 );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "motor_speed" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    j.motorSpeed = Physics::World::degrees_to_radians( lua_tonumber( L , -1 ) );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "max_motor_torque" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    j.maxMotorTorque = lua_tonumber( L , -1 );
                }
                lua_pop( L , 1 );

            }

            result = me->world->get_next_handle();

            b2Joint * joint = me->world->get_world()->CreateJoint( & j );

            joint->SetUserData( GINT_TO_POINTER( result ) );
        ]];

	/*
		Function: PrismaticJoint

		TODO
	*/

    int PrismaticJoint( Body other_body , table anchor , table axis , table properties = 0 )
        [[
            lb_check_udata_type( L , other_body , "Body" );

            Physics::Body * me = Physics::Body::get( self );

            Physics::Body * other = Physics::Body::get_from_lua( L , other_body );

            if ( ! other )
            {
                return luaL_error( L , "Invalid body" );
            }

            b2Body * ba = me->body;
            b2Body * bb = other->body;

            // TODO: at least one of the bodies has to be dynamic with a non-fixed rotation

            lua_rawgeti( L , anchor , 1 );
            lua_rawgeti( L , anchor , 2 );

            float32 x = me->world->screen_to_world( lua_tonumber( L , -2 ) );
            float32 y = me->world->screen_to_world( lua_tonumber( L , -1 ) );

            lua_pop( L , 2 );

            lua_rawgeti( L , axis , 1 );
            lua_rawgeti( L , axis , 2 );

            float32 ax = me->world->screen_to_world( lua_tonumber( L , -2 ) );
            float32 ay = me->world->screen_to_world( lua_tonumber( L , -1 ) );

            lua_pop( L , 2 );

            b2PrismaticJointDef p;

            p.Initialize( ba , bb , b2Vec2( x , y ) , b2Vec2( ax , ay ) );

            if ( properties )
            {
                lua_getfield( L , properties , "reference_angle" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    p.referenceAngle = Physics::World::degrees_to_radians( lua_tonumber( L , -1 ) );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "enable_limit" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    p.enableLimit = lua_toboolean( L , -1 );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "lower_translation" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    p.lowerTranslation = me->world->screen_to_world( lua_tonumber( L , -1 ) );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "upper_translation" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    p.upperTranslation = me->world->screen_to_world( lua_tonumber( L , -1 ) );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "enable_motor" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    p.enableMotor = lua_toboolean( L , -1 );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "motor_speed" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    p.motorSpeed = Physics::World::degrees_to_radians( lua_tonumber( L , -1 ) );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "max_motor_force" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    p.maxMotorForce = lua_tonumber( L , -1 );
                }
                lua_pop( L , 1 );
            }

            result = me->world->get_next_handle();

            b2Joint * joint = me->world->get_world()->CreateJoint( & p );

            joint->SetUserData( GINT_TO_POINTER( result ) );
        ]];

	/*
		Event: on_begin_contact

		When a body begins to touch another, this callback is triggered.

		The single argument "contact" is a table with several values
		describing the contact.

		point - A table of X and Y coordinates for the contact point.
		fixtures - A table containing the handles of the fixtures that made contact.
		other_fixture - A table containing the same two handles, but indexed by each other,
		                so that if my fixture handle is 42, I can get the handle of the other fixture
		                by using contact.other_fixture[ 42 ].
        bodies - A table containing the handles of the two bodies that made contact.
        other_body - Same as "other_fixture" but with body handles.
        touching - Whether the contact is touching or not.
        enabled - Whether the contact is enabled. You can actually change this value
                  only during the <on_pre_solve_contact> event.

        *Note:* You should not change bodies in any of the contact callbacks. Instead
        make a note of the event and change things after the step is done.
	*/

    callback on_begin_contact( table contact )
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->world->attach_body_callback( me , Physics::BEGIN_CONTACT , on_begin_contact );
        ]];

	/*
		Event: on_end_contact

		When two fixtures are no longer in contact. The contact details are the same as
		in <on_begin_contact>.
	*/

    callback on_end_contact( table contact )
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->world->attach_body_callback( me , Physics::END_CONTACT , on_end_contact );
        ]];

	/*
		Event: on_pre_solve_contact

		This callback is called after collision detection but before collision resolution. It
		lets you change the "enabled" property on the contact to affect behavior.

		The contact details are the same as in <on_begin_contact>.
	*/

    callback on_pre_solve_contact( table contact )
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->world->attach_body_callback( me , Physics::PRE_SOLVE_CONTACT , on_pre_solve_contact );
        ]];

	/*
		Event: on_post_solve_contact

	    This callback is called after collision resolution and gives you a chance to look at
	    the impulses generated by a collision.

	    The contact details are the same as in <on_begin_contact>.
	*/

    callback on_post_solve_contact( table contact )
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->world->attach_body_callback( me , Physics::POST_SOLVE_CONTACT , on_post_solve_contact );
        ]];
}

/*===========================================================================*/

	/*
		Global: physics

		The physics global lets you create bodies and run a physics simulation.
	*/

global physics [[ Physics::World * ]]
{
	physics()
		[[
            ClutterActor * screen = clutter_get_actor_by_gid( App::get( L )->get_screen_gid() );

			self = lb_construct( Physics::World , new Physics::World( L , screen , 64 ) );
		]];

	~physics()
		[[
			delete self;
		]];

	/*
		Property: pixels_per_meter

		Pixels per meter.
	*/

	double pixels_per_meter
        [[
            pixels_per_meter = self->ppm;
        ]]
        [[
            self->ppm = pixels_per_meter;
        ]];

	/*
		Property: gravity

		Gravity is a table with two values, one for X and another for Y. Either can be
		positive, negative or zero. Setting gravity to { 0 , 0 } means no gravity. A positive
		value for X will push objects to the right, negative to the left. Positive for Y
		will push objects down, negative will push them up.
	*/

    table gravity
        [[
            b2Vec2 g( self->get_world()->GetGravity() );
            lua_newtable( L );
            lua_pushnumber( L , g.x );
            lua_rawseti( L , -2 , 1 );
            lua_pushnumber( L , g.y );
            lua_rawseti( L , -2 , 2 );
        ]]
        [[
            luaL_checktype(L,2,LUA_TTABLE);
            lua_rawgeti( L , 2 , 1 );
            lua_rawgeti( L , 2 , 2 );
            b2Vec2 g( lua_tonumber( L , -2 ) , lua_tonumber( L , -1 ) );
            self->get_world()->SetGravity( g );
            lua_pop( L , 2 );
        ]];

	/*
		Property: auto_clear_forces

		Whether forces should be automatically cleared after each time step.
	*/

    bool auto_clear_forces
        [[
            auto_clear_forces = self->get_world()->GetAutoClearForces();
        ]]
        [[
            self->get_world()->SetAutoClearForces( auto_clear_forces );
        ]];

	/*
		Property: contacts

		A list of all current contacts in the whole physics world.
	*/

    readonly table contacts
        [[
            self->push_contact_list( self->get_world()->GetContactList() );
        ]];

	/*
		Property: running

		Whether the simulation is running.
	*/

    readonly bool running
        [[
            running = self->running();
        ]];

	/*
		Function: start

		Start the physics simulation with the given velocity and position
		iterations. For each step, the <on_step> callback will be called.
	*/

    start( int velocity_iterations = 10, int position_iterations = 10 )
        [[
            self->start( velocity_iterations , position_iterations );
        ]];

	/*
		Function: stop

		Stop the simulation. It can be started again with <start>.
	*/

	stop()
        [[
            self->stop();
        ]];

	/*
	THIS ONE SHOULD BE UNDOCUMENTED AS IT WILL BE DEPRECATED.
	*/

	step( double time_step = 1.0f/60.0f , int velocity_iterations = 10, int position_iterations = 10 )
		[[
            self->step( time_step , velocity_iterations , position_iterations );
		]];

	/*
		Function: clear_forces

		Clears all current forces.
	*/

	clear_forces()
        [[
            self->get_world()->ClearForces();
        ]];

	/*
		Function: draw_debug

		Draws a debug overlay that shows you bodies, fixtures, joints and other information. You
		need to call it after every step.
	*/

	draw_debug( int opacity = 127 )
        [[
            self->draw_debug( opacity );
        ]];

	/*
		Function: clear_debug

		Clears the debug overlay.
	*/

	clear_debug()
        [[
            self->clear_debug();
        ]];

	/*
	NOT IMPLEMENTED COMPLETELY
	*/

	table get_fixtures_in_rectangle( table top_left , table bottom_right )
        [[
            float32 x1;
	        float32 y1;
	        float32 x2;
	        float32 y2;

            lua_rawgeti( L , top_left , 1 );
            x1 = self->screen_to_world( lua_tonumber( L , -1 ) );
            lua_pop( L , 1 );
            lua_rawgeti( L , top_left , 2 );
            y1 = self->screen_to_world( lua_tonumber( L , -1 ) );
            lua_pop( L , 1 );

            lua_rawgeti( L , bottom_right , 1 );
            x2 = self->screen_to_world( lua_tonumber( L , -1 ) );
            lua_pop( L , 1 );
            lua_rawgeti( L , bottom_right , 2 );
            y2 = self->screen_to_world( lua_tonumber( L , -1 ) );
            lua_pop( L , 1 );

            b2AABB a;

            a.lowerBound.x = x1;
            a.lowerBound.y = y1;
            a.upperBound.x = x2;
            a.upperBound.y = y2;

            Physics::AABBQuery q( L );

            self->get_world()->QueryAABB( & q , a );

            // TODO: put results in a table.

            lua_pushnil( L );
        ]];

	/*
		Function: Body

		This function lets you create physics bodies. You pass an existing UIElement that
		is attached directly to the screen and a table of properties for the body.

		This call returns the same UIElement enhanced to provide all the functions
		and properties of a <Body>. If there is a problem, this call can return nil.

		*Note:* This moves the anchor point of the UIElement to its center.

		The "properties" table can include any of the properties of <Body>, such as
		its type. It can also have any of the properties of a fixture. A default
		fixture is always created and, if you do not include a "shape" for the
		fixture, a default rectangular shape is created that fits the dimensions of the
		entire UIElement.
	*/

	Body Body( UIElement element , table properties )
		[[
            lb_check_udata_type( L , element , "actor" );

            int n = self->create_body( element , properties , BODY_METATABLE );

            if ( ! n )
            {
                lua_pushnil( L );
            }
            else
            {
                ClutterUtil::set_props_from_table( L , properties );
            }
		]];

    #..........................................................................
    # Shape factory methods

	/*
		Function: Box

		Creates a box shape that can be used for fixtures.

		size - A table with width and height (in pixels) for the box.
		center - A table of X and Y coordinates relative to the body.
		rotation - The angle (in degrees) of the box along the Z axis relative to its center.
	*/

	Shape Box( table size , table center = 0 , double rotation = 0 )
        [[
            b2PolygonShape * shape = new b2PolygonShape();

            if ( ! center )
            {
                lua_rawgeti( L , size , 1 );
                lua_rawgeti( L , size , 2 );

                shape->SetAsBox( self->screen_to_world( lua_tonumber( L , -2 ) * 0.5 ) ,
                    self->screen_to_world( lua_tonumber( L , -1 ) * 0.5 ) );

                lua_pop( L , 2 );
            }
            else
            {
                lua_rawgeti( L , size , 1 );
                lua_rawgeti( L , size , 2 );

                lua_rawgeti( L , center , 1 );
                lua_rawgeti( L , center , 2 );

                shape->SetAsBox( self->screen_to_world( lua_tonumber( L , -4 ) * 0.5 ) ,
                        self->screen_to_world( lua_tonumber( L , -3 ) * 0.5 ),
                        b2Vec2( self->screen_to_world( lua_tonumber( L , -2 ) ),
                                self->screen_to_world( lua_tonumber( L , -1 ) ) ),
                        Physics::World::degrees_to_radians( rotation ) );

                lua_pop( L , 4 );
            }

            lua_pushlightuserdata( L , shape );

            new_Shape( L );

            lua_remove( L , -2 );
        ]];

	/*
		Function: Edge

		Creates an edge shape (a line) to be used for a fixture.
		You pass two tables, each with X and Y coordinates relative to the center of the body.
	*/

	Shape Edge( table point_a , table point_b )
        [[
            b2PolygonShape * shape = new b2PolygonShape();

            lua_rawgeti( L , point_a , 1 );
            lua_rawgeti( L , point_a , 2 );
            lua_rawgeti( L , point_b , 1 );
            lua_rawgeti( L , point_b , 2 );

            shape->SetAsEdge( b2Vec2( self->screen_to_world( lua_tonumber( L , -4 ) ) ,
                    self->screen_to_world( lua_tonumber( L , -3 ) ) ),
                    b2Vec2( self->screen_to_world( lua_tonumber( L , -2 ) ) ,
                            self->screen_to_world( lua_tonumber( L , -1 ) ) ) );

            lua_pop( L , 4 );

            lua_pushlightuserdata( L , shape );

            new_Shape( L );

            lua_remove( L , -2 );
        ]];

	/*
		Function: Polygon

		Creates a polygon shape given a table of points, a table of tables, each with X and
		Y coordinates relative to the center of the body.

		*Note:* You should not specify more than 8 points and the resulting shape should be convex.
	*/

	Shape Polygon( table points )
        [[
            std::vector< b2Vec2 > p;

            lua_pushnil( L );

            while( lua_next( L , points ) )
            {
                if ( lua_istable( L , -1 ) )
                {
                    lua_rawgeti( L , -1 , 1 );
                    lua_rawgeti( L , -2 , 2 );

                    p.push_back(
                            b2Vec2( self->screen_to_world( lua_tonumber( L , -2 ) ) ,
                                    self->screen_to_world( lua_tonumber( L , -1 ) ) ) );

                    lua_pop( L , 2 );
                }
                lua_pop( L , 1 );
            }

            if ( p.empty() )
            {
                return luaL_error( L , "Invalid polygon points" );
            }

            b2PolygonShape * shape = new b2PolygonShape();

            shape->Set( & p[ 0 ] , p.size() );

            lua_pushlightuserdata( L , shape );
            new_Shape( L );
            lua_remove( L , -2 );
        ]];

	/*
		Function: Circle

		Creates a circular shape to be used for fixtures.

		radius - The radius of the circle (in pixels).
		center - A table of X and Y coordinates for the center of the circle relative
		          to the center of the body.
	*/

	Shape Circle( double radius , table center = 0 )
        [[
            b2CircleShape * shape = new b2CircleShape();

            shape->m_radius = self->screen_to_world( radius );

            shape->m_p.SetZero();

            if ( center )
            {
                lua_rawgeti( L , center , 1 );
                lua_rawgeti( L , center , 2 );

                shape->m_p.Set( self->screen_to_world( lua_tonumber( L , -2 ) ) ,
                        self->screen_to_world( lua_tonumber( L , -1 ) ) );

                lua_pop( L , 2 );
            }

            lua_pushlightuserdata( L , shape );

            new_Shape( L );

            lua_remove( L , -2 );
        ]];

    #..........................................................................

	/*
		Event: on_step

		This callback occurs every time the physics simulation completes a step. This
		will be at most every 1/60 of a second.

		seconds - The fractional number of seconds since on_step was last called.
	*/

    callback on_step( double seconds );

	/*
		Event: on_begin_contact

		Same as the the callback for each Body, but for the entire world.
	*/

	callback on_begin_contact( table contact )
        [[
            self->attach_global_callback( Physics::BEGIN_CONTACT , on_begin_contact );
        ]];

	/*
		Event: on_end_contact

        Same as the the callback for each Body, but for the entire world.
	*/

    callback on_end_contact( table contact )
        [[
            self->attach_global_callback( Physics::END_CONTACT , on_end_contact );
        ]];

	/*
		Event: on_pre_solve_contact

        Same as the the callback for each Body, but for the entire world.
	*/

    callback on_pre_solve_contact( table contact )
        [[
            self->attach_global_callback( Physics::PRE_SOLVE_CONTACT , on_pre_solve_contact );
        ]];

	/*
		Event: on_post_solve_contact

        Same as the the callback for each Body, but for the entire world.
	*/

    callback on_post_solve_contact( table contact )
        [[
            self->attach_global_callback( Physics::POST_SOLVE_CONTACT , on_post_solve_contact );
        ]];

    /*
        Property: z_for_y

        When set to true, the physics simulation treats the UIElement's z as its y.
    */

    bool z_for_y
        [[
            z_for_y = self->z_for_y;
        ]]
        [[
            self->z_for_y = z_for_y;
        ]];
}


module physics_module;

[[
#include "Box2D/Box2D.h"
#include "clutter/clutter.h"

#include "clutter_util.h"

class Physx
{
public:

	Physx()
	:
		world( b2Vec2( 0.0f , 10.0f ) , true ), 
		ppm( 64.0f ) // 64 pixels per meter - at 1920 that is 30 meters
	{
    	
	}
	
	~Physx()
	{
		for( b2Body * body = world.GetBodyList(); body; body = body->GetNext() )
		{
			if ( void * ud = body->GetUserData() )
			{
				g_object_set_data( G_OBJECT( ud ) , "tp-physics-body" , NULL );
			}
		}
	}
	
	b2World  	world;
	float32		ppm;
};

#if 0

bool get_actor_screen_point( ClutterActor * actor , const ClutterVertex * actor_point , ClutterVertex * screen_point )
{
	ClutterActor * stage = clutter_stage_get_default();
	
	ClutterActor * screen = NULL;
	
	for( ClutterActor * parent = clutter_actor_get_parent( actor ); parent; parent = clutter_actor_get_parent( parent ) )
	{
		if ( clutter_actor_get_parent( parent ) == stage )
		{
			screen = parent;
			break;
		}
	} 
	
	if ( ! screen )
	{
		return false;
	}
	
	clutter_actor_apply_relative_transform_to_point( actor , screen , actor_point , screen_point );
	
	return true;
} 

#endif

void destroy_actor_body( b2Body * body )
{
	body->GetWorld()->DestroyBody( body );
}

]]

[[

class Body
{
public:

	Body( Physx * _p , b2Body * _b , ClutterActor * _a )
	:
		physx( _p ),
		body( _b ),
		actor( _a )
	{
		g_assert( physx );
		g_assert( body );
		g_assert( actor );
		
		g_object_ref( G_OBJECT( actor ) );
	}
	
	~Body()
	{
		g_object_unref( G_OBJECT( actor ) );
	}
	
	static Body * get( lua_State * L , int n )
    {
	    return ( Body * ) UserData::get_client( L , n );
    }

	Physx  * 		physx;
	b2Body * 		body;
	ClutterActor * 	actor;
};

]]

interface Body [[ Body * ]]
{
	Body()
		[[
			self = lb_construct( Body , lua_touserdata( L , -2 ) );
		]];
		
	~Body()
		[[
			delete self;
		]];
		
	readonly UIElement source
		[[
			ClutterUtil::wrap_concrete_actor( L , self->actor );
		]];
		
	bool awake
		[[
			awake = self->body->IsAwake();
		]]
		[[
			self->body->SetAwake( awake );
		]];
		
	bool active
		[[
			active = self->body->IsActive();
		]]
		[[
			self->body->SetActive( active );
		]];

	readonly table position
		[[
			const b2Vec2 pos( self->body->GetPosition() );
			
			lua_newtable( L );
			lua_pushnumber( L , pos.x * self->physx->ppm );
			lua_rawseti( L , -2 , 1 );
			lua_pushnumber( L , pos.y * self->physx->ppm );
			lua_rawseti( L , -2 , 2 );
		]];
		
	readonly double angle
		[[
			angle = self->body->GetAngle() / ( G_PI / 180.0 );
		]];

	readonly table world_center
        [[
            const b2Vec2 pos( self->body->GetWorldCenter() );
            lua_newtable( L );
            lua_pushnumber( L , pos.x * self->physx->ppm );
            lua_rawseti( L , -2 , 1 );
            lua_pushnumber( L , pos.y * self->physx->ppm );
            lua_rawseti( L , -2 , 2 );
        ]];

	readonly table local_center
        [[
            const b2Vec2 pos( self->body->GetLocalCenter() );
            lua_newtable( L );
            lua_pushnumber( L , pos.x * self->physx->ppm );
            lua_rawseti( L , -2 , 1 );
            lua_pushnumber( L , pos.y * self->physx->ppm );
            lua_rawseti( L , -2 , 2 );
        ]];

		
	table linear_velocity
		[[
			b2Vec2 lv( self->body->GetLinearVelocity() );
			
			lua_newtable( L );
			lua_pushnumber( L , lv.x );
			lua_rawseti( L , -2 , 1 );
			lua_pushnumber( L , lv.y );
			lua_rawseti( L , -2 , 2 );	
		]]
		[[
			lua_rawgeti( L , 2 , 1 );
			lua_rawgeti( L , 2 , 2 );
			
			self->body->SetLinearVelocity( b2Vec2( lua_tonumber( L , -2 ) , lua_tonumber( L , -1 ) ) );
			lua_pop( L , 2 );
		]];
		
	double angular_velocity
		[[
			angular_velocity = self->body->GetAngularVelocity() / ( G_PI / 180.0 );
		]]
		[[
			self->body->SetAngularVelocity( angular_velocity * ( G_PI / 180.0 ) );
		]];

	readonly double mass
        [[
            mass = self->body->GetMass();
        ]];

	/* TODO: mass_data */
		
	double linear_damping
        [[
            linear_damping = self->body->GetLinearDamping();
        ]]
        [[
            self->body->SetLinearDamping( linear_damping );
        ]];

	double angular_damping
        [[
            angular_damping = self->body->GetAngularDamping();
        ]]
        [[
            self->body->SetAngularDamping( angular_damping );
        ]];

	bool bullet
        [[
            bullet = self->body->IsBullet();
        ]]
        [[
            self->body->SetBullet( bullet );
        ]];

	bool sleeping_allowed
        [[
            sleeping_allowed = self->body->IsSleepingAllowed();
        ]]
        [[
            self->body->SetSleepingAllowed( sleeping_allowed );
        ]];

	bool fixed_rotation
        [[
            fixed_rotation = self->body->IsFixedRotation();
        ]]
        [[
            self->body->SetFixedRotation( fixed_rotation );
        ]];


	apply_force( double force_x , double force_y , double x , double y )
		[[
			self->body->ApplyForce( b2Vec2( force_x , force_y ) , 
				b2Vec2( x / self->physx->ppm , y / self->physx->ppm ) );   
		]];
		
	apply_torque( double torque )
		[[
			self->body->ApplyTorque( torque );
		]];
		
	apply_linear_impulse( double impulse_x , double impulse_y , double x , double y )
		[[
			self->body->ApplyLinearImpulse( b2Vec2( impulse_x , impulse_y ) , 
				b2Vec2( x / self->physx->ppm , y / self->physx->ppm ) );   
		]];
	
	apply_angular_impulse( double impulse )
        [[
            self->body->ApplyAngularImpulse( impulse );
        ]];

    Body set( table props )
        [[
            ClutterUtil::set_props_from_table( L , props );
            lua_pushvalue( L , 1 );
        ]];

}


global physics [[ Physx * ]]
{
	physics()
		[[
			self = lb_construct( Physx , new Physx() );
		]];
		
	~physics()
		[[
			delete self;
		]];
		
	int step( double time_step = 1.0f/60.0f , int velocity_iterations = 6, int position_iterations = 2 )
		[[
			int n = 0;
			
			self->world.Step( time_step , velocity_iterations , position_iterations );
			
			for( b2Body * body = self->world.GetBodyList(); body; body = body->GetNext() )
			{
				if ( ! body->IsAwake() || ! body->IsActive() )
				{
					continue;
				}
				
				++n;
				
				ClutterActor * actor = CLUTTER_ACTOR( body->GetUserData() );
				
				if ( actor )
				{
					const b2Vec2 & pos( body->GetPosition() );
					
					clutter_actor_set_position( actor , pos.x * self->ppm , pos.y * self->ppm );
					
					clutter_actor_set_rotation( actor , CLUTTER_Z_AXIS , body->GetAngle () / ( G_PI / 180.0 ) , 0 , 0 , 0 );
				}
			}
			
			result = n;
		]]; 
		
	table gravity
		[[
			b2Vec2 g( self->world.GetGravity() );
			lua_newtable( L );
			lua_pushnumber( L , g.x );
			lua_rawseti( L , -2 , 1 );
			lua_pushnumber( L , g.y );
			lua_rawseti( L , -2 , 2 );
		]]
		[[
            luaL_checktype(L,2,LUA_TTABLE);
            lua_rawgeti( L , 2 , 1 );
            lua_rawgeti( L , 2 , 2 );
            b2Vec2 g( lua_tonumber( L , -2 ) , lua_tonumber( L , -1 ) );
            self->world.SetGravity( g );
            lua_pop( L , 2 );
		]];
		
	Body Body( table properties )
		[[
			lua_getfield( L , properties , "source" );
			
			ClutterActor * actor = ClutterUtil::user_data_to_actor( L , lua_gettop( L ) ); 

			if ( ! actor )
			{
				lua_pop( L , 1 );
				return luaL_error( L , "Invalid or missing body source" );
			}
			
			lua_pop( L , 1 );
			
			//.................................................................
			// Get position and size of the actor
			
			// TODO: We do not do any transformations here - we just use whatever
			// the actor has. If the actor is inside a container, this will
			// be wrong. We also cheat and modify the actor's anchor point...naughty.
			
			gfloat width;
			gfloat height;
			
			clutter_actor_get_size( actor , & width , & height );
			
			clutter_actor_move_anchor_point( actor , width / 2 , height / 2 );

			gfloat x;
			gfloat y;
			
			clutter_actor_get_position( actor , & x , & y );
			
			gfloat rotation;
			gfloat rx;
			gfloat ry;
			
			rotation = clutter_actor_get_rotation( actor , CLUTTER_Z_AXIS , & rx , & ry , NULL );		
			
			//.................................................................
			// Create the body definition
			
			b2BodyDef body_def;
			
			body_def.userData = actor;
			
			body_def.position.Set( x / self->ppm , y / self->ppm );
			body_def.angle = rotation * ( G_PI / 180.0 ); 
			
			b2FixtureDef fixture_def;
			
			//.................................................................
			// Read the rest of the properties
			
			lua_getfield( L , properties , "dynamic" );
			if ( lua_toboolean( L , -1 ) )
			{
				body_def.type = b2_dynamicBody;
			}
			lua_pop( L , 1 );	
			
			lua_getfield( L , properties , "friction" );
			if ( ! lua_isnil( L , -1 ) )
			{
				fixture_def.friction = lua_tonumber( L , -1 );
			}
			lua_pop( L , 1 );
			
			lua_getfield( L , properties , "restitution" );
			if ( ! lua_isnil( L , -1 ) )
			{
				fixture_def.restitution = lua_tonumber( L , -1 );
			}
			lua_pop( L , 1 );
			
			lua_getfield( L , properties , "bounce" );
			if ( ! lua_isnil( L , -1 ) )
			{
				fixture_def.restitution = lua_tonumber( L , -1 );
			}
			lua_pop( L , 1 );

			lua_getfield( L , properties , "density" );
			if ( ! lua_isnil( L , -1 ) )
			{
				fixture_def.density = lua_tonumber( L , -1 );
			}
			lua_pop( L , 1 );
			
			lua_getfield( L , properties , "awake" );
			if ( ! lua_isnil( L , -1 ) )
			{
				body_def.awake = lua_toboolean( L , -1 );
			}
			lua_pop( L , 1 );
				
			lua_getfield( L , properties , "active" );
			if ( ! lua_isnil( L , -1 ) )
			{
				body_def.active = lua_toboolean( L , -1 );
			}
			lua_pop( L , 1 );

			//.................................................................
			// Create the body
			
			b2Body * body = self->world.CreateBody( & body_def );
			
			g_assert( body );
			
			//.................................................................
			// Create a rectangular default shape for the body
			
			b2PolygonShape shape;
#if 0			
			shape.SetAsBox( ( width * 0.5 ) / self->ppm , ( height * 0.5 ) / self->ppm , 
				b2Vec2( rx / self->ppm , ry / self->ppm ) , 
				rotation * ( G_PI / 180.0 ) );
#else
			shape.SetAsBox( ( width * 0.5 ) / self->ppm , ( height * 0.5 ) / self->ppm ) ;
#endif			

			//.................................................................
			// Create the default fixture
			
			fixture_def.shape = & shape;
			
			body->CreateFixture( & fixture_def ); 

			//.................................................................
			// Attach the body to the actor with a destroy notify that will remove the
			// body from the world and destroy it when the actor is destroyed.
			
			// TODO: There may be a problem destroying a body during the step function,
			// which could happen if an actor is collected. 
	
			g_object_set_data_full( G_OBJECT( actor ) , "tp-physics-body" , body , ( GDestroyNotify ) destroy_actor_body );

			//.................................................................
			// Create an instance of a Body for Lua
						
			lua_pushlightuserdata( L , new Body( self , body , actor ) );
			 			
			new_Body(L);
    		lua_remove(L,-2);
		]];

	DistanceJoint( Body body_a , table anchor_a , Body body_b , table anchor_b , table properties = 0 )
	    [[
	        b2DistanceJointDef d;

            b2Body * ba = Body::get( L , body_a )->body;
            b2Body * bb = Body::get( L , body_b )->body;

            lua_rawgeti( L , anchor_a , 1 );
            lua_rawgeti( L , anchor_a , 2 );

            float32 ax = lua_tonumber( L , -2 ) / self->ppm;
            float32 ay = lua_tonumber( L , -1 ) / self->ppm;

            lua_pop( L , 2 );

            lua_rawgeti( L , anchor_b , 1 );
            lua_rawgeti( L , anchor_b , 2 );

            float32 bx = lua_tonumber( L , -2 ) / self->ppm;
            float32 by = lua_tonumber( L , -1 ) / self->ppm;

            lua_pop( L , 2 );

            d.Initialize( ba , bb , b2Vec2( ax , ay ) , b2Vec2( bx , by ) );

            if ( properties )
            {
                lua_getfield( L , properties , "frequency" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    d.frequencyHz = lua_tonumber( L , -1 );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "damping_ratio" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    d.dampingRatio = lua_tonumber( L , -1 );
                }
                lua_pop( L , 1 );
            }

            self->world.CreateJoint( & d );

	    ]];

	RevoluteJoint( Body body_a , Body body_b , table anchor , table properties = 0 )
        [[
            b2Body * ba = Body::get( L , body_a )->body;
            b2Body * bb = Body::get( L , body_b )->body;

            lua_rawgeti( L , anchor , 1 );
            lua_rawgeti( L , anchor , 2 );

            float32 x = lua_tonumber( L , -2 ) / self->ppm;
            float32 y = lua_tonumber( L , -1 ) / self->ppm;

            lua_pop( L , 2 );

            b2RevoluteJointDef j;

            j.Initialize( ba , bb , b2Vec2( x , y ) );

            if ( properties )
            {
                lua_getfield( L , properties , "enable_limit" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    j.enableLimit = lua_toboolean( L , -1 );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "lower_angle" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    j.lowerAngle = lua_tonumber( L , -1 ) * ( G_PI / 180.0 );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "upper_angle" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    j.upperAngle = lua_tonumber( L , -1 ) * ( G_PI / 180.0 );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "enable_motor" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    j.enableMotor = lua_toboolean( L , -1 );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "motor_speed" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    j.motorSpeed = lua_tonumber( L , -1 ) * ( G_PI / 180.0 );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "max_motor_torque" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    j.maxMotorTorque = lua_tonumber( L , -1 );
                }
                lua_pop( L , 1 );

            }

            self->world.CreateJoint( & j );
        ]];
}

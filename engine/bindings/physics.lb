
module physics_module;

[[
#include "Box2D/Box2D.h"
#include "clutter/clutter.h"

#include "physics.h"
#include "clutter_util.h"
]]

/*===========================================================================*/

/*

	Interface: Shape
	
	TODO
	
*/

interface Shape [[ b2Shape * ]]
{
    Shape()
        [[
            self = lb_construct( b2Shape , lua_touserdata( L , -2 ) );
        ]];

    ~Shape()
        [[
            delete self;
        ]];
}

/*===========================================================================*/

/*
	Interface: Body
	
	TODO
	
*/

interface Body [[ ClutterActor * ]]
{

	/* 
		Property: handle
		
		The handle property is an integer that uniquely identifies this body. It is used in 
		collision callbacks to refer to the two bodies that are colliding.
	*/
	
	readonly int handle
        [[
            Physics::Body * me = Physics::Body::get( self );
            handle = me->handle;
        ]];
		
	/*
		Property: type
		
		The type property is a string specifying the Body object's type.
		
		*Supported Settings:* The type setting is case-sensitive.
		
		"static" - the body has infinite mass; it is immovable when operating under the influence of the physics engine, but can be moved manually by the user
		"kinematic" - moves according to its velocity, but is not influenced by other forces, such as gravity or collisions. Behaves as if it had infinite mass.
		"dynamic" - moves according to the forces placed upon it, such as gravity and collisions. Has finite, non-zero mass.
		
		*Default Settings:* "dynamic"
		
		TODO
	*/
	
	string type
	    [[
            Physics::Body * me = Physics::Body::get( self );
            switch( me->body->GetType() )
            {
                case b2_staticBody:
                    type = "static";
                    break;

                case b2_kinematicBody:
                    type = "kinematic";
                    break;

                case b2_dynamicBody:
                    type = "dynamic";
                    break;

                default:
                    type = 0;
                    break;
            }
	    ]]
	    [[
            Physics::Body * me = Physics::Body::get( self );

            if ( ! type )
            {
                luaL_error( L , "Invalid body type" );
            }
            else
            {
                if ( ! strcmp( type , "static" ) )
                {
                    me->body->SetType( b2_staticBody );
                }
                else if ( ! strcmp( type , "kinematic" ) )
                {
                    me->body->SetType( b2_kinematicBody );
                }
                else if ( ! strcmp( type , "dynamic" ) )
                {
                    me->body->SetType( b2_dynamicBody );
                }
                else
                {
                    luaL_error( L , "Invalid body type '%s'" , type );
                }
            }
	    ]];
	    
	/*
		Property: awake
		
		When the physics engine determines that a body has come to rest, it is put to "sleep", 
		waiting on a collision to wake it up. You can also explicitly wake up a body by setting
		this property to true.
	*/	    
		
	bool awake
		[[
            Physics::Body * me = Physics::Body::get( self );
			awake = me->body->IsAwake();
		]]
		[[
            Physics::Body * me = Physics::Body::get( self );
			me->body->SetAwake( awake );
		]];
		
	/*
		Property: active
		
		This property lets you specify whether a body participates in the physics simulation. A body
		that is not active will be ignored.
	*/
	
	bool active
		[[
            Physics::Body * me = Physics::Body::get( self );
			active = me->body->IsActive();
		]]
		[[
            Physics::Body * me = Physics::Body::get( self );
			me->body->SetActive( active );
		]];

	/*
		Property: position
		
		A table of X and Y screen coordinates for the position of the center of the body. 
	*/
	
	table position
		[[
            Physics::Body * me = Physics::Body::get( self );

            const b2Vec2 & pos( me->body->GetPosition() );
			
			lua_newtable( L );
			lua_pushnumber( L , me->world->world_to_screen( pos.x ) );
			lua_rawseti( L , -2 , 1 );
			lua_pushnumber( L , me->world->world_to_screen( pos.y ) );
			lua_rawseti( L , -2 , 2 );
		]]
		[[
            Physics::Body * me = Physics::Body::get( self );

            lua_rawgeti( L , 2 , 1 );
            lua_rawgeti( L , 2 , 2 );

            const b2Vec2 pos( me->world->screen_to_world( lua_tonumber( L , -2 ) ) ,
                    me->world->screen_to_world( lua_tonumber( L , -1 ) ) );

            lua_pop( L , 2 );

            me->body->SetTransform( pos , me->body->GetAngle() );

            me->synchronize_actor();
		]];

	/*
		Property: x
		
		The X screen coordinate of the body's center.
	*/
	
	double x
        [[
            Physics::Body * me = Physics::Body::get( self );

            const b2Vec2 & pos( me->body->GetPosition() );

            x = me->world->world_to_screen( pos.x );
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            b2Vec2 pos( me->body->GetTransform().position );

            pos.x = me->world->screen_to_world( x );

            me->body->SetTransform( pos , me->body->GetAngle() );

            me->synchronize_actor();
        ]];

	/*
		Property: y
		
		The Y screen coordinate of the body's center.
	*/
	
    double y
        [[
            Physics::Body * me = Physics::Body::get( self );
    
            if ( me->world->z_for_y ) 
            {
                y = clutter_actor_get_y( self );
            }
            else
            {
                const b2Vec2 & pos( me->body->GetPosition() );
    
                y = me->world->world_to_screen( pos.y );
            }
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );
    
            if ( me->world->z_for_y ) 
            {
                clutter_actor_set_y( self , y );
            }
            else
            {
                b2Vec2 pos( me->body->GetTransform().position );
    
                pos.y = me->world->screen_to_world( y );
    
                me->body->SetTransform( pos , me->body->GetAngle() );
    
                me->synchronize_actor();
            }
        ]];


    /*
        Property: z
        
        The Z coordinate of the body's center.
    */

    double z
        [[
            Physics::Body * me = Physics::Body::get( self );

            if ( ! me->world->z_for_y ) 
            {
                z = clutter_actor_get_depth( self );
            }
            else
            {
                const b2Vec2 & pos( me->body->GetPosition() );
    
                z = - me->world->world_to_screen( pos.y );
            }
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );
    
            if ( ! me->world->z_for_y ) 
            {
                clutter_actor_set_depth( self , z );
            }
            else
            {
                b2Vec2 pos( me->body->GetTransform().position );
    
                pos.y = me->world->screen_to_world( - z );
    
                me->body->SetTransform( pos , me->body->GetAngle() );
    
                me->synchronize_actor();
            }
        ]];

    /*
        Property: depth
        
        The Z coordinate of the body's center.
    */

    double depth
        [[
            Physics::Body * me = Physics::Body::get( self );

            if ( ! me->world->z_for_y ) 
            {
                depth = clutter_actor_get_depth( self );
            }
            else
            {
                const b2Vec2 & pos( me->body->GetPosition() );
    
                depth = - me->world->world_to_screen( pos.y );
            }
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );
    
            if ( ! me->world->z_for_y ) 
            {
                clutter_actor_set_depth( self , depth );
            }
            else
            {
                b2Vec2 pos( me->body->GetTransform().position );
    
                pos.y = me->world->screen_to_world( - depth );
    
                me->body->SetTransform( pos , me->body->GetAngle() );
    
                me->synchronize_actor();
            }
        ]];

	/*
		Property: angle
		
		The angle of rotation (in degrees) along the Z axis.
	*/
	
	double angle
		[[
            Physics::Body * me = Physics::Body::get( self );
			angle = Physics::World::radians_to_degrees( me->body->GetAngle() );
		]]
		[[
            Physics::Body * me = Physics::Body::get( self );

            b2Vec2 pos( me->body->GetTransform().position );

            me->body->SetTransform( pos , Physics::World::degrees_to_radians( angle ) );

            me->synchronize_actor();
		]];

	/*
		Property: rotation
		
		Same as <angle>.
	*/
	
    double rotation
        [[
            Physics::Body * me = Physics::Body::get( self );
            rotation = Physics::World::radians_to_degrees( me->body->GetAngle() );
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            b2Vec2 pos( me->body->GetTransform().position );

            me->body->SetTransform( pos , Physics::World::degrees_to_radians( rotation ) );

            me->synchronize_actor();
        ]];

	/*
		Property: world_center
		
		A table of X and Y coordinates for the world center of this body.
	*/
	
    readonly table world_center
        [[
            Physics::Body * me = Physics::Body::get( self );
            const b2Vec2 pos( me->body->GetWorldCenter() );
            lua_newtable( L );
            lua_pushnumber( L , me->world->world_to_screen( pos.x ) );
            lua_rawseti( L , -2 , 1 );
            lua_pushnumber( L , me->world->world_to_screen( pos.y ) );
            lua_rawseti( L , -2 , 2 );
        ]];

	/*
		Property: local_center
		
	    A table of X and Y coordinates for this body's center.
	*/
	
	readonly table local_center
        [[
            Physics::Body * me = Physics::Body::get( self );
            const b2Vec2 pos( me->body->GetLocalCenter() );
            lua_newtable( L );
            lua_pushnumber( L , me->world->world_to_screen( pos.x ) );
            lua_rawseti( L , -2 , 1 );
            lua_pushnumber( L , me->world->world_to_screen( pos.y ) );
            lua_rawseti( L , -2 , 2 );
        ]];
		
	/*
		Property: linear_velocity
		
		A table of velocity in X and Y direction.
	*/
	
	table linear_velocity
		[[
            Physics::Body * me = Physics::Body::get( self );

            b2Vec2 lv( me->body->GetLinearVelocity() );
			
			lua_newtable( L );
			lua_pushnumber( L , lv.x );
			lua_rawseti( L , -2 , 1 );
			lua_pushnumber( L , lv.y );
			lua_rawseti( L , -2 , 2 );	
		]]
		[[
            Physics::Body * me = Physics::Body::get( self );

			lua_rawgeti( L , 2 , 1 );
			lua_rawgeti( L , 2 , 2 );
			
			me->body->SetLinearVelocity( b2Vec2( lua_tonumber( L , -2 ) , lua_tonumber( L , -1 ) ) );
			lua_pop( L , 2 );
		]];
		
	/*
		Property: angular_velocity
		
		The velocity of the body's rotation around the Z axis.
	*/
	
	double angular_velocity
		[[
            Physics::Body * me = Physics::Body::get( self );

			angular_velocity = Physics::World::radians_to_degrees( me->body->GetAngularVelocity() );
		]]
		[[
            Physics::Body * me = Physics::Body::get( self );

			me->body->SetAngularVelocity( Physics::World::degrees_to_radians( angular_velocity ) );
		]];

	/*
		Property: mass
		
		The mass of the body.
	*/
	
	readonly double mass
        [[
            Physics::Body * me = Physics::Body::get( self );

            mass = me->body->GetMass();
        ]];

	/* TODO: mass_data */
		
	/*
		Property: linear_damping
		
		Damping value for the body's linear velocity.
	*/
	
	double linear_damping
        [[
            Physics::Body * me = Physics::Body::get( self );

            linear_damping = me->body->GetLinearDamping();
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->body->SetLinearDamping( linear_damping );
        ]];

	/*
		Property: angular_damping
		
		Damping value for the body's angular velocity.
	*/
	
	double angular_damping
        [[
            Physics::Body * me = Physics::Body::get( self );

            angular_damping = me->body->GetAngularDamping();
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->body->SetAngularDamping( angular_damping );
        ]];

	/*
		Property: bullet
		
		Whether this body is considered a bullet (a very fast-moving body). This
		has implications on collision detection for the body; extra work is performed
		to avoid tunneling.
	*/
	
	bool bullet
        [[
            Physics::Body * me = Physics::Body::get( self );

            bullet = me->body->IsBullet();
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->body->SetBullet( bullet );
        ]];

	/*
		Property: sleeping_allowed
		
		Whether the body is allowed to go to sleep when it comes to rest.
	*/
	
	bool sleeping_allowed
        [[
            Physics::Body * me = Physics::Body::get( self );

            sleeping_allowed = me->body->IsSleepingAllowed();
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->body->SetSleepingAllowed( sleeping_allowed );
        ]];

	/*
		Property: fixed_rotation
		
		If fixed rotation is set to true, the body will not rotate 
		along the Z axis.
	*/
	
	bool fixed_rotation
        [[
            Physics::Body * me = Physics::Body::get( self );

            fixed_rotation = me->body->IsFixedRotation();
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->body->SetFixedRotation( fixed_rotation );
        ]];

	/*
		Property: contacts
		
		A table of current contacts for this body (touch points
		with other bodies).
	*/
	
	readonly table contacts
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->world->push_contact_list( me->body->GetContactList() );
        ]];

	/*
		Function: synchronize
		
		Explicitly insures that this body and its UIElement are in synch.
	*/
	
	synchronize( )
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->synchronize_body();
        ]];

	/*
		Function: apply_force
		
		Apply a force to the body.
		
		force - A table of X and Y forces.
		point - The point, on the body where the force should be applied. This is a
		        table of X and Y coordinates.
	*/
	
	apply_force( table force , table point )
		[[
            Physics::Body * me = Physics::Body::get( self );

            lua_rawgeti( L , force , 1 );
            lua_rawgeti( L , force , 2 );

            lua_rawgeti( L , point , 1 );
            lua_rawgeti( L , point , 2 );

			me->body->ApplyForce(
			    b2Vec2( lua_tonumber( L , -4 ) , lua_tonumber( L , -3 ) ) ,
				b2Vec2( me->world->screen_to_world( lua_tonumber( L , -2 ) ),
				        me->world->screen_to_world( lua_tonumber( L , -1 ) ) ) );

			lua_pop( L , 4 );
		]];
		
	/*
		Function: apply_torque
		
		A force to apply that will cause the body to rotate.
	*/
	
	apply_torque( double torque )
		[[
            Physics::Body * me = Physics::Body::get( self );

            me->body->ApplyTorque( torque );
		]];
		
	/*
		Function: apply_linear_impulse
		
		A linear impulse to apply to the body.
		
		force - X and Y force values.
		point - The point, on the body, where the impulse should be applied. This is a
		        table of X and Y coordinates.
	*/
	
	apply_linear_impulse( table force , table point )
		[[
            Physics::Body * me = Physics::Body::get( self );

            lua_rawgeti( L , force , 1 );
            lua_rawgeti( L , force , 2 );

            lua_rawgeti( L , point , 1 );
            lua_rawgeti( L , point , 2 );

            me->body->ApplyLinearImpulse(
                    b2Vec2( lua_tonumber( L , -4 ) , lua_tonumber( L , -3 ) ) ,
                    b2Vec2( me->world->screen_to_world( lua_tonumber( L , -2 ) ),
                          me->world->screen_to_world( lua_tonumber( L , -1 ) ) ) );

            lua_pop( L , 4 );
		]];
	
	/*
		Function: apply_angular_impulse
		
		An impulse that will rotate the body.
	*/
	
	apply_angular_impulse( double impulse )
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->body->ApplyAngularImpulse( impulse );
        ]];


    #-------------------------------------------------------------------------
    # Fixtures

	/*
		Property: fixtures
		
		Returns a table of all fixtures belonging to this body. For each fixture, the
		following keys are provided:
		
		handle - An integer that uniquely identifies the fixture.
		type - "circle" or "polygon".
		sensor - Boolean indicating whether the fixture is a sensor.
		density - The density of the fixture.
		friction - The friction of the fixture.
		bounce - Restitution value for the fixture. 
	*/
	
    readonly table fixtures
        [[
            Physics::Body * me = Physics::Body::get( self );

            lua_newtable( L );
            int t = lua_gettop( L );
            int i = 1;

            for( b2Fixture * f = me->body->GetFixtureList(); f ; f = f->GetNext() , ++i )
            {
                lua_newtable( L );

                lua_pushinteger( L , GPOINTER_TO_INT( f->GetUserData() ) );
                lua_setfield( L , -2 , "handle" );

                switch( f->GetType() )
                {
                    case b2Shape::e_circle:
                        lua_pushstring( L , "circle" );
                        break;

                    case b2Shape::e_polygon:
                        lua_pushstring( L , "polygon" );
                        break;

                    default:
                        lua_pushnil( L );
                }

                lua_setfield( L , -2 , "type" );

                lua_pushboolean( L , f->IsSensor() );
                lua_setfield( L , -2 , "sensor" );

                lua_pushnumber( L , f->GetDensity() );
                lua_setfield( L , -2 , "density" );

                lua_pushnumber( L , f->GetFriction() );
                lua_setfield( L , -2 , "friction" );

                lua_pushnumber( L , f->GetRestitution() );
                lua_setfield( L , -2 , "bounce" );

                lua_rawseti( L , t , i );
            }
        ]];

	/*
		Function: remove_fixture()
		
		Removes the given fixture from the body.
	*/
	
    bool remove_fixture( int fixture_handle )
        [[
            Physics::Body * me = Physics::Body::get( self );

            result = false;

            for( b2Fixture * f = me->body->GetFixtureList(); f ; f = f->GetNext() )
            {
                if ( GPOINTER_TO_INT( f->GetUserData() ) == fixture_handle )
                {
                    result = true;
                    f->GetBody()->DestroyFixture( f );
                    break;
                }
            }
        ]];

	/*
		Function: remove_all_fixtures
		
		Removes all fixtures from the body.
	*/
	
    remove_all_fixtures()
        [[
            Physics::Body * me = Physics::Body::get( self );

            for( b2Fixture * f = me->body->GetFixtureList(); f ; )
            {
                b2Fixture * next = f->GetNext();

                f->GetBody()->DestroyFixture( f );

                f = next;
            }

        ]];

	/*
		Function: add_fixture
		
		Adds a new fixture to the body. A fixture can have the following properties:
		
		friction - Between 0 (slippery) and 1 (not slippery at all).
		restitution or bounce - Between 0 (not bouncy) and 1 (perfectly elastic).
		density - The density of the fixture. 
		sensor - Whether the fixture is a sensor. A sensor fixture does not affect 
		          other fixtures but detects contacts.
        filter - Collision filtering. (TODO: Complicated, need full explanation).
        shape - The shape for the fixture, this can be created using the <Box>, 
                <Edge>, <Polygon> or <Circle> functions on the <physics> global.  		         
	*/
	
    int add_fixture( table properties )
        [[
            Physics::Body * me = Physics::Body::get( self );

            result = 0;

            b2FixtureDef fd = me->world->create_fixture_def( properties );

            if ( ! fd.shape )
            {
                return luaL_error( L , "Missing shape" );
            }

            result = me->world->get_next_handle();

            fd.userData = GINT_TO_POINTER( result );

            me->body->CreateFixture( & fd );
        ]];

    #..........................................................................
    # Joints

	/*
		Function: remove_joint
		
		Removes a joint from the body.
	*/
	
    bool remove_joint( int joint_handle )
        [[
            Physics::Body * me = Physics::Body::get( self );

            gpointer h = GINT_TO_POINTER( joint_handle );

            result = false;

            for( b2JointEdge * e = me->body->GetJointList(); e; e = e->next )
            {
                if ( e->joint && e->joint->GetUserData() == h )
                {
                    result = true;

                    me->world->get_world()->DestroyJoint( e->joint );

                    break;
                }
            }
        ]];

	/*
		Function: DistanceJoint
		
		Creates a distance joint on this body.
		
		anchor - The X and Y coordinates for the joint's anchor on this body.
		other_body - The other body this joint will be attached to.
		other_anchor - The X and Y coordinates on the other body.
		properties - "frequency" and "damping_ratio".
	*/
	
    int DistanceJoint( table anchor , Body other_body , table other_anchor , table properties = 0 )
        [[
            lb_check_udata_type( L , other_body , "Body" );

            Physics::Body * me = Physics::Body::get( self );

            Physics::Body * other = Physics::Body::get_from_lua( L , other_body );

            if ( ! other )
            {
                return luaL_error( L , "Invalid body" );
            }

            b2Body * ba = me->body;
            b2Body * bb = other->body;

            lua_rawgeti( L , anchor , 1 );
            lua_rawgeti( L , anchor , 2 );

            float32 ax = me->world->screen_to_world( lua_tonumber( L , -2 ) );
            float32 ay = me->world->screen_to_world( lua_tonumber( L , -1 ) );

            lua_pop( L , 2 );

            lua_rawgeti( L , other_anchor , 1 );
            lua_rawgeti( L , other_anchor , 2 );

            float32 bx = me->world->screen_to_world( lua_tonumber( L , -2 ) );
            float32 by = me->world->screen_to_world( lua_tonumber( L , -1 ) );

            lua_pop( L , 2 );

            b2DistanceJointDef d;

            d.Initialize( ba , bb , b2Vec2( ax , ay ) , b2Vec2( bx , by ) );

            if ( properties )
            {
                lua_getfield( L , properties , "frequency" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    d.frequencyHz = lua_tonumber( L , -1 );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "damping_ratio" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    d.dampingRatio = lua_tonumber( L , -1 );
                }
                lua_pop( L , 1 );
            }

            result = me->world->get_next_handle();

            b2Joint * joint = me->world->get_world()->CreateJoint( & d );

            joint->SetUserData( GINT_TO_POINTER( result ) );

        ]];

	/*
		Function: RevoluteJoint
		
		Creates a revolute joint on this body.
		
		other_body - The other body to attach to.
		anchor - Coordinates for the point where the joint is attached.
		properties -  "enable_limit" (boolean) 
		              "lower_angle" (degrees) 
		              "upper_angle" (degrees)
		              "enable_motor" (boolean)
		              "motor_speed" (number)
		              "max_motor_torque" (number)
	*/
	
    int RevoluteJoint( Body other_body , table anchor , table properties = 0 )
        [[
            lb_check_udata_type( L , other_body , "Body" );

            Physics::Body * me = Physics::Body::get( self );

            Physics::Body * other = Physics::Body::get_from_lua( L , other_body );

            if ( ! other )
            {
                return luaL_error( L , "Invalid body" );
            }

            b2Body * ba = me->body;
            b2Body * bb = other->body;

            lua_rawgeti( L , anchor , 1 );
            lua_rawgeti( L , anchor , 2 );

            float32 x = me->world->screen_to_world( lua_tonumber( L , -2 ) );
            float32 y = me->world->screen_to_world( lua_tonumber( L , -1 ) );

            lua_pop( L , 2 );

            b2RevoluteJointDef j;

            j.Initialize( ba , bb , b2Vec2( x , y ) );

            if ( properties )
            {
                lua_getfield( L , properties , "enable_limit" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    j.enableLimit = lua_toboolean( L , -1 );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "lower_angle" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    j.lowerAngle = Physics::World::degrees_to_radians( lua_tonumber( L , -1 ) );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "upper_angle" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    j.upperAngle = Physics::World::degrees_to_radians( lua_tonumber( L , -1 ) );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "enable_motor" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    j.enableMotor = lua_toboolean( L , -1 );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "motor_speed" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    j.motorSpeed = Physics::World::degrees_to_radians( lua_tonumber( L , -1 ) );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "max_motor_torque" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    j.maxMotorTorque = lua_tonumber( L , -1 );
                }
                lua_pop( L , 1 );

            }

            result = me->world->get_next_handle();

            b2Joint * joint = me->world->get_world()->CreateJoint( & j );

            joint->SetUserData( GINT_TO_POINTER( result ) );
        ]];

	/*
		Function: PrismaticJoint
		
		TODO
	*/
	
    int PrismaticJoint( Body other_body , table anchor , table axis , table properties = 0 )
        [[
            lb_check_udata_type( L , other_body , "Body" );

            Physics::Body * me = Physics::Body::get( self );

            Physics::Body * other = Physics::Body::get_from_lua( L , other_body );

            if ( ! other )
            {
                return luaL_error( L , "Invalid body" );
            }

            b2Body * ba = me->body;
            b2Body * bb = other->body;

            // TODO: at least one of the bodies has to be dynamic with a non-fixed rotation

            lua_rawgeti( L , anchor , 1 );
            lua_rawgeti( L , anchor , 2 );

            float32 x = me->world->screen_to_world( lua_tonumber( L , -2 ) );
            float32 y = me->world->screen_to_world( lua_tonumber( L , -1 ) );

            lua_pop( L , 2 );

            lua_rawgeti( L , axis , 1 );
            lua_rawgeti( L , axis , 2 );

            float32 ax = me->world->screen_to_world( lua_tonumber( L , -2 ) );
            float32 ay = me->world->screen_to_world( lua_tonumber( L , -1 ) );

            lua_pop( L , 2 );

            b2PrismaticJointDef p;

            p.Initialize( ba , bb , b2Vec2( x , y ) , b2Vec2( ax , ay ) );

            if ( properties )
            {
                lua_getfield( L , properties , "reference_angle" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    p.referenceAngle = Physics::World::degrees_to_radians( lua_tonumber( L , -1 ) );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "enable_limit" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    p.enableLimit = lua_toboolean( L , -1 );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "lower_translation" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    p.lowerTranslation = me->world->screen_to_world( lua_tonumber( L , -1 ) );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "upper_translation" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    p.upperTranslation = me->world->screen_to_world( lua_tonumber( L , -1 ) );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "enable_motor" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    p.enableMotor = lua_toboolean( L , -1 );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "motor_speed" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    p.motorSpeed = Physics::World::degrees_to_radians( lua_tonumber( L , -1 ) );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "max_motor_force" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    p.maxMotorForce = lua_tonumber( L , -1 );
                }
                lua_pop( L , 1 );
            }

            result = me->world->get_next_handle();

            b2Joint * joint = me->world->get_world()->CreateJoint( & p );

            joint->SetUserData( GINT_TO_POINTER( result ) );
        ]];

	/*
		Event: on_begin_contact
		
		When a body begins to touch another, this callback is triggered.
		
		The single argument "contact" is a table with several values
		describing the contact.
		
		point - A table of X and Y coordinates for the contact point.
		fixtures - A table containing the handles of the fixtures that made contact.
		other_fixture - A table containing the same two handles, but indexed by each other, 
		                so that if my fixture handle is 42, I can get the handle of the other fixture
		                by using contact.other_fixture[ 42 ].
        bodies - A table containing the handles of the two bodies that made contact.
        other_body - Same as "other_fixture" but with body handles.
        touching - Whether the contact is touching or not.
        enabled - Whether the contact is enabled. You can actually change this value
                  only during the <on_pre_solve_contact> event.  		         
                  
        *Note:* You should not change bodies in any of the contact callbacks. Instead 
        make a note of the event and change things after the step is done.                         
	*/
	
    callback on_begin_contact( table contact )
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->world->attach_body_callback( me , Physics::BEGIN_CONTACT , on_begin_contact );
        ]];

	/*
		Event: on_end_contact
		
		When two fixtures are no longer in contact. The contact details are the same as
		in <on_begin_contact>.
	*/
	
    callback on_end_contact( table contact )
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->world->attach_body_callback( me , Physics::END_CONTACT , on_end_contact );
        ]];

	/*
		Event: on_pre_solve_contact
		
		This callback is called after collision detection but before collision resolution. It 
		lets you change the "enabled" property on the contact to affect behavior.
		
		The contact details are the same as in <on_begin_contact>.
	*/
	
    callback on_pre_solve_contact( table contact )
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->world->attach_body_callback( me , Physics::PRE_SOLVE_CONTACT , on_pre_solve_contact );
        ]];

	/*
		Event: on_post_solve_contact
		
	    This callback is called after collision resolution and gives you a chance to look at
	    the impulses generated by a collision.
	    
	    The contact details are the same as in <on_begin_contact>.
	*/
	
    callback on_post_solve_contact( table contact )
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->world->attach_body_callback( me , Physics::POST_SOLVE_CONTACT , on_post_solve_contact );
        ]];
}

/*===========================================================================*/

	/*
		Global: physics
		
		The physics global lets you create bodies and run a physics simulation.
	*/
	
global physics [[ Physics::World * ]]
{
	physics()
		[[
            ClutterActor * screen = clutter_get_actor_by_gid( App::get( L )->get_screen_gid() );

			self = lb_construct( Physics::World , new Physics::World( L , screen , 64 ) );
		]];
		
	~physics()
		[[
			delete self;
		]];

	/*
		Property: pixels_per_meter
		
		Pixels per meter.
	*/
	
	double pixels_per_meter
        [[
            pixels_per_meter = self->ppm;
        ]]
        [[
            self->ppm = pixels_per_meter;
        ]];

	/*
		Property: gravity
		
		Gravity is a table with two values, one for X and another for Y. Either can be 
		positive, negative or zero. Setting gravity to { 0 , 0 } means no gravity. A positive
		value for X will push objects to the right, negative to the left. Positive for Y
		will push objects down, negative will push them up.
	*/
	
    table gravity
        [[
            b2Vec2 g( self->get_world()->GetGravity() );
            lua_newtable( L );
            lua_pushnumber( L , g.x );
            lua_rawseti( L , -2 , 1 );
            lua_pushnumber( L , g.y );
            lua_rawseti( L , -2 , 2 );
        ]]
        [[
            luaL_checktype(L,2,LUA_TTABLE);
            lua_rawgeti( L , 2 , 1 );
            lua_rawgeti( L , 2 , 2 );
            b2Vec2 g( lua_tonumber( L , -2 ) , lua_tonumber( L , -1 ) );
            self->get_world()->SetGravity( g );
            lua_pop( L , 2 );
        ]];

	/*
		Property: auto_clear_forces
		
		Whether forces should be automatically cleared after each time step.
	*/
	
    bool auto_clear_forces
        [[
            auto_clear_forces = self->get_world()->GetAutoClearForces();
        ]]
        [[
            self->get_world()->SetAutoClearForces( auto_clear_forces );
        ]];

	/*
		Property: contacts
		
		A list of all current contacts in the whole physics world.
	*/
	
    readonly table contacts
        [[
            self->push_contact_list( self->get_world()->GetContactList() );
        ]];

	/*
		Property: running
		
		Whether the simulation is running.
	*/
	
    readonly bool running
        [[
            running = self->running();
        ]];

	/*
		Function: start
		
		Start the physics simulation with the given velocity and position
		iterations. For each step, the <on_step> callback will be called.
	*/
	
    start( int velocity_iterations = 10, int position_iterations = 10 )
        [[
            self->start( velocity_iterations , position_iterations );
        ]];

	/*
		Function: stop
		
		Stop the simulation. It can be started again with <start>.
	*/
	
	stop()
        [[
            self->stop();
        ]];
		
	/*
	THIS ONE SHOULD BE UNDOCUMENTED AS IT WILL BE DEPRECATED.
	*/
	
	step( double time_step = 1.0f/60.0f , int velocity_iterations = 10, int position_iterations = 10 )
		[[
            self->step( time_step , velocity_iterations , position_iterations );
		]];

	/*
		Function: clear_forces
		
		Clears all current forces.
	*/
	
	clear_forces()
        [[
            self->get_world()->ClearForces();
        ]];

	/*
		Function: draw_debug
		
		Draws a debug overlay that shows you bodies, fixtures, joints and other information. You 
		need to call it after every step.
	*/
	
	draw_debug( int opacity = 127 )
        [[
            self->draw_debug( opacity );
        ]];

	/*
		Function: clear_debug
		
		Clears the debug overlay.
	*/
	
	clear_debug()
        [[
            self->clear_debug();
        ]];

	/*
	NOT IMPLEMENTED COMPLETELY 
	*/
	
	table get_fixtures_in_rectangle( table top_left , table bottom_right )
        [[
            float32 x1;
	        float32 y1;
	        float32 x2;
	        float32 y2;

            lua_rawgeti( L , top_left , 1 );
            x1 = self->screen_to_world( lua_tonumber( L , -1 ) );
            lua_pop( L , 1 );
            lua_rawgeti( L , top_left , 2 );
            y1 = self->screen_to_world( lua_tonumber( L , -1 ) );
            lua_pop( L , 1 );

            lua_rawgeti( L , bottom_right , 1 );
            x2 = self->screen_to_world( lua_tonumber( L , -1 ) );
            lua_pop( L , 1 );
            lua_rawgeti( L , bottom_right , 2 );
            y2 = self->screen_to_world( lua_tonumber( L , -1 ) );
            lua_pop( L , 1 );

            b2AABB a;

            a.lowerBound.x = x1;
            a.lowerBound.y = y1;
            a.upperBound.x = x2;
            a.upperBound.y = y2;

            Physics::AABBQuery q( L );

            self->get_world()->QueryAABB( & q , a );
            
            // TODO: put results in a table.
            
            lua_pushnil( L );
        ]];
		
	/*
		Function: Body
		
		This function lets you create physics bodies. You pass an existing UIElement that 
		is attached directly to the screen and a table of properties for the body.
		
		This call returns the same UIElement enhanced to provide all the functions
		and properties of a <Body>. If there is a problem, this call can return nil.
		
		*Note:* This moves the anchor point of the UIElement to its center.
		
		The "properties" table can include any of the properties of <Body>, such as
		its type. It can also have any of the properties of a fixture. A default 
		fixture is always created and, if you do not include a "shape" for the
		fixture, a default rectangular shape is created that fits the dimensions of the 
		entire UIElement.
	*/
	
	Body Body( UIElement element , table properties )
		[[
            lb_check_udata_type( L , element , "actor" );

            int n = self->create_body( element , properties , BODY_METATABLE );

            if ( ! n )
            {
                lua_pushnil( L );
            }
            else
            {
                ClutterUtil::set_props_from_table( L , properties );
            }
		]];

    #..........................................................................
    # Shape factory methods

	/*
		Function: Box
		
		Creates a box shape that can be used for fixtures. 
		
		size - A table with width and height (in pixels) for the box.
		center - A table of X and Y coordinates relative to the body.
		rotation - The angle (in degrees) of the box along the Z axis relative to its center.
	*/
	
	Shape Box( table size , table center = 0 , double rotation = 0 )
        [[
            b2PolygonShape * shape = new b2PolygonShape();

            if ( ! center )
            {
                lua_rawgeti( L , size , 1 );
                lua_rawgeti( L , size , 2 );

                shape->SetAsBox( self->screen_to_world( lua_tonumber( L , -2 ) * 0.5 ) ,
                    self->screen_to_world( lua_tonumber( L , -1 ) * 0.5 ) );

                lua_pop( L , 2 );
            }
            else
            {
                lua_rawgeti( L , size , 1 );
                lua_rawgeti( L , size , 2 );

                lua_rawgeti( L , center , 1 );
                lua_rawgeti( L , center , 2 );

                shape->SetAsBox( self->screen_to_world( lua_tonumber( L , -4 ) * 0.5 ) ,
                        self->screen_to_world( lua_tonumber( L , -3 ) * 0.5 ),
                        b2Vec2( self->screen_to_world( lua_tonumber( L , -2 ) ),
                                self->screen_to_world( lua_tonumber( L , -1 ) ) ),
                        Physics::World::degrees_to_radians( rotation ) );

                lua_pop( L , 4 );
            }

            lua_pushlightuserdata( L , shape );

            new_Shape( L );

            lua_remove( L , -2 );
        ]];

	/*
		Function: Edge
		
		Creates an edge shape (a line) to be used for a fixture.
		You pass two tables, each with X and Y coordinates relative to the center of the body.
	*/
	
	Shape Edge( table point_a , table point_b )
        [[
            b2PolygonShape * shape = new b2PolygonShape();

            lua_rawgeti( L , point_a , 1 );
            lua_rawgeti( L , point_a , 2 );
            lua_rawgeti( L , point_b , 1 );
            lua_rawgeti( L , point_b , 2 );

            shape->SetAsEdge( b2Vec2( self->screen_to_world( lua_tonumber( L , -4 ) ) ,
                    self->screen_to_world( lua_tonumber( L , -3 ) ) ),
                    b2Vec2( self->screen_to_world( lua_tonumber( L , -2 ) ) ,
                            self->screen_to_world( lua_tonumber( L , -1 ) ) ) );

            lua_pop( L , 4 );

            lua_pushlightuserdata( L , shape );

            new_Shape( L );

            lua_remove( L , -2 );
        ]];

	/*
		Function: Polygon
		
		Creates a polygon shape given a table of points, a table of tables, each with X and
		Y coordinates relative to the center of the body.
		
		*Note:* You should not specify more than 8 points and the resulting shape should be convex. 
	*/
	
	Shape Polygon( table points )
        [[
            std::vector< b2Vec2 > p;

            lua_pushnil( L );

            while( lua_next( L , points ) )
            {
                if ( lua_istable( L , -1 ) )
                {
                    lua_rawgeti( L , -1 , 1 );
                    lua_rawgeti( L , -2 , 2 );

                    p.push_back(
                            b2Vec2( self->screen_to_world( lua_tonumber( L , -2 ) ) ,
                                    self->screen_to_world( lua_tonumber( L , -1 ) ) ) );

                    lua_pop( L , 2 );
                }
                lua_pop( L , 1 );
            }

            if ( p.empty() )
            {
                return luaL_error( L , "Invalid polygon points" );
            }

            b2PolygonShape * shape = new b2PolygonShape();

            shape->Set( & p[ 0 ] , p.size() );

            lua_pushlightuserdata( L , shape );
            new_Shape( L );
            lua_remove( L , -2 );
        ]];

	/*
		Function: Circle
		
		Creates a circular shape to be used for fixtures.
		
		radius - The radius of the circle (in pixels).
		center - A table of X and Y coordinates for the center of the circle relative 
		          to the center of the body.
	*/
	
	Shape Circle( double radius , table center = 0 )
        [[
            b2CircleShape * shape = new b2CircleShape();

            shape->m_radius = self->screen_to_world( radius );

            shape->m_p.SetZero();

            if ( center )
            {
                lua_rawgeti( L , center , 1 );
                lua_rawgeti( L , center , 2 );

                shape->m_p.Set( self->screen_to_world( lua_tonumber( L , -2 ) ) ,
                        self->screen_to_world( lua_tonumber( L , -1 ) ) );

                lua_pop( L , 2 );
            }

            lua_pushlightuserdata( L , shape );

            new_Shape( L );

            lua_remove( L , -2 );
        ]];

    #..........................................................................

	/*
		Event: on_step
		
		This callback occurs every time the physics simulation completes a step. This
		will be at most every 1/60 of a second.
		
		seconds - The fractional number of seconds since on_step was last called.
	*/
	
    callback on_step( double seconds );

	/*
		Event: on_begin_contact
		
		Same as the the callback for each Body, but for the entire world.
	*/
	
	callback on_begin_contact( table contact )
        [[
            self->attach_global_callback( Physics::BEGIN_CONTACT , on_begin_contact );
        ]];

	/*
		Event: on_end_contact
		
        Same as the the callback for each Body, but for the entire world.
	*/
	
    callback on_end_contact( table contact )
        [[
            self->attach_global_callback( Physics::END_CONTACT , on_end_contact );
        ]];

	/*
		Event: on_pre_solve_contact
		
        Same as the the callback for each Body, but for the entire world.
	*/
	
    callback on_pre_solve_contact( table contact )
        [[
            self->attach_global_callback( Physics::PRE_SOLVE_CONTACT , on_pre_solve_contact );
        ]];

	/*
		Event: on_post_solve_contact
		
        Same as the the callback for each Body, but for the entire world.
	*/
	
    callback on_post_solve_contact( table contact )
        [[
            self->attach_global_callback( Physics::POST_SOLVE_CONTACT , on_post_solve_contact );
        ]];

    /*
        Property: z_for_y
        
        When set to true, the physics simulation treats the UIElement's z as its y. 
    */
            
    bool z_for_y
        [[
            z_for_y = self->z_for_y;
        ]]
        [[
            self->z_for_y = z_for_y;
        ]];        
}

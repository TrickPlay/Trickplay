
module physics_module;

[[
#include "Box2D/Box2D.h"
#include "clutter/clutter.h"

#include "physics.h"
#include "clutter_util.h"
#include "util.h"
]]

/*===========================================================================*/
/*
	Title: The physics Global Variable and Body Interface

*NOTE:* The 2D physics environment described in this section is EXPERIMENTAL and in-progress. Significant changes may occur to the environment's properties, functions and event handlers prior to its official release.

The physics global variable places one or more UIElement-based objects in a two-dimensional environment where they are affected by physics-based forces, such as gravity and collisions.

The physics global variable maintains the physics-based simulation. Similar to the way that objects are added to the screen global variable to show the object on the display, objects are added to the physics variable to place them within the physics world.

Objects added to the physics variable are based on the UIElement interface, such as the Rectangle and Image classes. Before being added to the physics environment, however, the object is enhanced to include the properties, functions and event handlers of the Body interface. The Body interface provides physics-related settings and operations to enable the object to operate within the physics environment.

When the physics world has been configured and the desired objects added to it, the physics simulation can begin by calling the variable's start() function.

The simple program listing shown below creates two Rectangle objects: a dynamic object that will be affected by the physics forces placed upon it and an immobile static object that acts as a ground foundation. As gravity pulls the dynamic object down, the Rectangle falls until it eventually lands on the static ground object.

	(code)
	-- Basic 2D Physics Application

	-- Create a simple rectangle and add it to the screen
	local gBox01 = Rectangle( { 
						size     = { 100, 100 },
						position = { (screen.width / 2) - 50, (screen.height / 4) - 50 },
						color    = "SaddleBrown",
	} )
	screen:add( gBox01 )

	-- Make the rectangle a dynamic object, i.e., affected by physics; use default Body settings
	gBox01 = physics:Body( gBox01, { } )

	-- Create a ground so the rectangle doesn't fall off the screen
	local gGround = Rectangle( {
						size     = { screen.width / 2, 2 },
						position = { screen.width / 4, screen.height - (screen.height / 4) },
						color    = "AntiqueWhite",
	} )
	screen:add( gGround )

	-- Make the ground an immobile static object in the physics world
	gGround = physics:Body( gGround, { type = "static" } )

	-- Show the screen
	screen:show()

	-- Start the physics simulation
	physics:start()
	(end)
	

*/

/*
	InternalInterface: Shape

	The Shape interface is used internally by the Box2D physics engine. It is used to specify the shape of a fixture that is attached to a Body. Shapes can be created by calling the physics global variable's Box(), Edge(), Polygon() and Circle() functions. The Shape object is assigned to the fixture by passing it to the Body interface's add_fixture() function.

*/

interface Shape [[ b2Shape * ]]
{
    Shape()
        [[
            self = lb_construct( b2Shape , lua_touserdata( L , -2 ) );
        ]];

    ~Shape()
        [[
            delete self;
        ]];
}

/*===========================================================================*/

/*
	Interface: Body

The Body interface provides properties, functions and event handlers that define physics-related characteristics that can be applied to a <UIElement>-based object, such as a Rectangle or Image object.

The Body characteristics are defined as an Interface, so it is not possible to create an object of type Body. Instead, the Body characteristics are added to an existing UIElement-based object by calling the Body() function of the <physics> global variable.

*/

interface Body [[ ClutterActor * ]]
{

/***************************************
	Property: handle

	The handle property contains an integer value that uniquely identifies the Body/UIElement object. The handle identifier is assigned automatically to the object when the Body is created by the Body() function of the physics global variable. It is referenced in the various collision-detection event handlers, including on_begin_contact() and on_end_contact().

	Default Setting: a unique integer value

	See Also: the <on_begin_contact>, <on_end_contact>, <on_pre_solve_contact> and <on_post_solve_contact> event handlers
*/

	readonly int handle
        [[
            Physics::Body * me = Physics::Body::get( self );
            handle = me->handle;
        ]];

/***************************************
	Property: type

	The type property is a string specifying whether the Body is static, dynamic or kinematic.

	*Supported Settings:* The type setting is case-sensitive.

	"static" - the body is solid and unmovable when colliding with other objects
	"dynamic" - moves according to the forces placed upon it, such as gravity and collisions. Is affected when colliding into static and kinematic objects.
	"kinematic" - moves according to its velocity, but is not affected by other forces, such as gravity and collisions. Is not affected when colliding into static and dynamic objects.

	*Default Setting:* "dynamic"
*/

	string type
	    [[
            Physics::Body * me = Physics::Body::get( self );
            switch( me->body->GetType() )
            {
                case b2_staticBody:
                    type = "static";
                    break;

                case b2_kinematicBody:
                    type = "kinematic";
                    break;

                case b2_dynamicBody:
                    type = "dynamic";
                    break;

                default:
                    type = 0;
                    break;
            }
	    ]]
	    [[
            Physics::Body * me = Physics::Body::get( self );

            if ( ! type )
            {
                luaL_error( L , "Invalid body type" );
            }
            else
            {
                if ( ! strcmp( type , "static" ) )
                {
                    me->body->SetType( b2_staticBody );
                }
                else if ( ! strcmp( type , "kinematic" ) )
                {
                    me->body->SetType( b2_kinematicBody );
                }
                else if ( ! strcmp( type , "dynamic" ) )
                {
                    me->body->SetType( b2_dynamicBody );
                }
                else
                {
                    luaL_error( L , "Invalid body type '%s'" , type );
                }
            }
	    ]];

/***************************************
	Property: awake

	The awake property is a boolean flag indicating whether the Body/UIElement object is awake or sleeping (true==awake). An awake object is included in any active physics simulation; a sleeping object is not included. Making objects sleep reduces the computational requirements of the physics simulation.

	When an object is no longer in motion, it can be placed automatically in a sleeping state by setting the object's <sleeping_allowed> property to true. If a collision or other force occurs upon the object, it will wake up automatically and be included in the physics simulation. Alternatively, an object can be explicitly woken up by setting its awake property to true.

	*Default Setting:* true

	*See Also:* the <sleeping_allowed> property
*/

	bool awake
		[[
            Physics::Body * me = Physics::Body::get( self );
			awake = me->body->IsAwake();
		]]
		[[
            Physics::Body * me = Physics::Body::get( self );
			me->body->SetAwake( awake );
		]];

/***************************************
	Property: active

	The active property is a boolean flag indicating whether or not the Body/UIElement object is active in the physics simulation (true==active). An inactive object is ignored by the physics simulation, which reduces the simulation's computational requirements.

	*Default Setting:* true

	*See Also:* the <awake> property
*/

	bool active
		[[
            Physics::Body * me = Physics::Body::get( self );
			active = me->body->IsActive();
		]]
		[[
            Physics::Body * me = Physics::Body::get( self );
			me->body->SetActive( active );
		]];

/***************************************
	Property: position

	The position property is a table that contains the current X,Y screen coordinates of the center of the Body/UIElement object.

	*Default Setting:* { X, Y } coordinates of the object's center at the time the Body is created

	*See Also:* the <x>, <y>, <z> and <depth> properties
*/

	table position
		[[
            Physics::Body * me = Physics::Body::get( self );

            const b2Vec2 & pos( me->body->GetPosition() );

			lua_newtable( L );
			lua_pushnumber( L , me->world->world_to_screen( pos.x ) );
			lua_rawseti( L , -2 , 1 );
			lua_pushnumber( L , me->world->world_to_screen( pos.y ) );
			lua_rawseti( L , -2 , 2 );
		]]
		[[
            Physics::Body * me = Physics::Body::get( self );

            lua_rawgeti( L , 2 , 1 );
            lua_rawgeti( L , 2 , 2 );

            const b2Vec2 pos( me->world->screen_to_world( lua_tonumber( L , -2 ) ) ,
                    me->world->screen_to_world( lua_tonumber( L , -1 ) ) );

            lua_pop( L , 2 );

            me->body->SetTransform( pos , me->body->GetAngle() );

            me->synchronize_actor();
		]];

/***************************************
	Property: x

	The x property specifies the current screen position on the X axis of the center of the Body/UIElement object.

	*Default Setting:* 0
	
	*See Also:* the <y>, <z> and <position> properties
*/

	double x
        [[
            Physics::Body * me = Physics::Body::get( self );

            const b2Vec2 & pos( me->body->GetPosition() );

            x = me->world->world_to_screen( pos.x );
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            b2Vec2 pos( me->body->GetTransform().position );

            pos.x = me->world->screen_to_world( x );

            me->body->SetTransform( pos , me->body->GetAngle() );

            me->synchronize_actor();
        ]];

/***************************************
	Property: y

	The y property specifies the current screen position on the Y axis of the center of the Body/UIElement object.
	
	The physics variable implements a two-dimensional physics environment that uses the X/Y plane by default. A program can alternatively use the X/Z plane; refer to the physics variable's z_for_y property for details.
	
	*Default Setting:* 0
	
	*See Also:* the <x>, <z>, <position> and <physics.z_for_y> properties
*/

    double y
        [[
            Physics::Body * me = Physics::Body::get( self );

            if ( me->world->z_for_y )
            {
                y = clutter_actor_get_y( self );
            }
            else
            {
                const b2Vec2 & pos( me->body->GetPosition() );

                y = me->world->world_to_screen( pos.y );
            }
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            if ( me->world->z_for_y )
            {
                clutter_actor_set_y( self , y );
            }
            else
            {
                b2Vec2 pos( me->body->GetTransform().position );

                pos.y = me->world->screen_to_world( y );

                me->body->SetTransform( pos , me->body->GetAngle() );

                me->synchronize_actor();
            }
        ]];

/***************************************
	Property: z

	The z property specifies the current screen position on the Z axis of the center of the Body/UIElement object.
	
	The two-dimensional environment controlled by the physics variable does not normally use the Z axis; the physics simulation occurs entirely on the X/Y plane. A program can, however, substitute the X/Y plane with the X/Z plane, causing the physics simulation to occur in depth. Refer to the physics variable's z_for_y property for details.
	
	*Default Setting:* 0
	
	*See Also:* the <x>, <y>, <depth> and <physics.z_for_y> properties
*/

    double z
        [[
            Physics::Body * me = Physics::Body::get( self );

            if ( ! me->world->z_for_y )
            {
                z = clutter_actor_get_depth( self );
            }
            else
            {
                const b2Vec2 & pos( me->body->GetPosition() );

                z = me->world->world_to_screen( pos.y );
            }
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            if ( ! me->world->z_for_y )
            {
                clutter_actor_set_depth( self , z );
            }
            else
            {
                b2Vec2 pos( me->body->GetTransform().position );

                pos.y = me->world->screen_to_world( z );

                me->body->SetTransform( pos , me->body->GetAngle() );

                me->synchronize_actor();
            }
        ]];

/***************************************
	Property: depth

	The depth property is equivalent to the <z> property; it specifies the current screen position on the Z axis of the center of the Body/UIElement object. Refer to the description of the <z> property for further details.
	
	*See Also:* the <x>, <y>, and <z> properties
*/

    double depth
        [[
            Physics::Body * me = Physics::Body::get( self );

            if ( ! me->world->z_for_y )
            {
                depth = clutter_actor_get_depth( self );
            }
            else
            {
                const b2Vec2 & pos( me->body->GetPosition() );

                depth = me->world->world_to_screen( pos.y );
            }
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            if ( ! me->world->z_for_y )
            {
                clutter_actor_set_depth( self , depth );
            }
            else
            {
                b2Vec2 pos( me->body->GetTransform().position );

                pos.y = me->world->screen_to_world( depth );

                me->body->SetTransform( pos , me->body->GetAngle() );

                me->synchronize_actor();
            }
        ]];

/***************************************
	Property: angle

	The angle property specifies the object's rotation in degrees along the Z axis.
	
	If the physics variable's z_for_y property is true, the object rotates along the Y axis.
	
	*Default Setting:* 0
	
	*See Also:* the <rotation> and <physics.z_for_y> properties
*/

	double angle
		[[
            Physics::Body * me = Physics::Body::get( self );
			angle = Physics::World::radians_to_degrees( me->body->GetAngle() );
		]]
		[[
            Physics::Body * me = Physics::Body::get( self );

            b2Vec2 pos( me->body->GetTransform().position );

            me->body->SetTransform( pos , Physics::World::degrees_to_radians( angle ) );

            me->synchronize_actor();
		]];

/***************************************
	Property: rotation

	The rotation property is equivalent to the <angle> property; it specifies the object's rotation in degrees along the Z axis. Refer to the <angle> property for details.
	
	*See Also:* the <angle> property
*/

    double rotation
        [[
            Physics::Body * me = Physics::Body::get( self );
            rotation = Physics::World::radians_to_degrees( me->body->GetAngle() );
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            b2Vec2 pos( me->body->GetTransform().position );

            me->body->SetTransform( pos , Physics::World::degrees_to_radians( rotation ) );

            me->synchronize_actor();
        ]];

/***************************************
	Property: world_center

	The world_center property is a table containing the { X, Y } coordinates of the center position in the physics environment of the object's mass. Depending upon the number of fixtures attached to a Body and each fixture's density, the center of the object's mass may differ from its screen position, which is based on the center of its Body.

	*Format:* { center-of-mass X coordinate, center-of-mass Y coordinate } where each coordinate is relative to the physics environment

	*See Also:* the <local_center> and <position> properties
*/

    readonly table world_center
        [[
            Physics::Body * me = Physics::Body::get( self );
            const b2Vec2 pos( me->body->GetWorldCenter() );
            lua_newtable( L );
            lua_pushnumber( L , me->world->world_to_screen( pos.x ) );
            lua_rawseti( L , -2 , 1 );
            lua_pushnumber( L , me->world->world_to_screen( pos.y ) );
            lua_rawseti( L , -2 , 2 );
        ]];

/***************************************
	Property: local_center

	The local_center property is a table containing the { X, Y } coordinates of the center position of the object's mass relative to the center of its Body. Depending upon the number of fixtures attached to a Body and each fixture's density, the center of the object's mass may differ from the center of its Body.
	
	*Format:* { center-of-mass X coordinate, center-of-mass Y coordinate } where each coordinate is relative to the center of the object's Body
	
	*See Also:* the <world_center> and <position> properties
*/

	readonly table local_center
        [[
            Physics::Body * me = Physics::Body::get( self );
            const b2Vec2 pos( me->body->GetLocalCenter() );
            lua_newtable( L );
            lua_pushnumber( L , me->world->world_to_screen( pos.x ) );
            lua_rawseti( L , -2 , 1 );
            lua_pushnumber( L , me->world->world_to_screen( pos.y ) );
            lua_rawseti( L , -2 , 2 );
        ]];

/***************************************
	Property: linear_velocity

	The linear_velocity property is a table containing the amount of linear velocity to apply along the X and/or Y axis.
	
	Negative X values push the object to the left; positive X values push it to the right. Negative Y values push the object up; positive Y values push it down.
	
	*Format:* { X-axis velocity, Y-axis velocity }
	
	*Code Example:* Apply a linear_velocity force to an object to push it up
	
		(code)
		gBox01.linear_velocity = { 0, -10 }
		(end)
		
	*See Also:* the <angular_velocity> property
*/

	table linear_velocity
		[[
            Physics::Body * me = Physics::Body::get( self );

            b2Vec2 lv( me->body->GetLinearVelocity() );

			lua_newtable( L );
			lua_pushnumber( L , lv.x );
			lua_rawseti( L , -2 , 1 );
			lua_pushnumber( L , lv.y );
			lua_rawseti( L , -2 , 2 );
		]]
		[[
            Physics::Body * me = Physics::Body::get( self );

			lua_rawgeti( L , 2 , 1 );
			lua_rawgeti( L , 2 , 2 );

			me->body->SetLinearVelocity( b2Vec2( lua_tonumber( L , -2 ) , lua_tonumber( L , -1 ) ) );
			lua_pop( L , 2 );
		]];

/***************************************
	Property: angular_velocity

	The angular_velocity property is a double value specifying the object's rotation in degrees around the Z-axis.
	
	Positive values rotate in a clockwise direction; negative values rotate counter-clockwise.

	*See Also:* the <linear_velocity> property
*/

	double angular_velocity
		[[
            Physics::Body * me = Physics::Body::get( self );

			angular_velocity = Physics::World::radians_to_degrees( me->body->GetAngularVelocity() );
		]]
		[[
            Physics::Body * me = Physics::Body::get( self );

			me->body->SetAngularVelocity( Physics::World::degrees_to_radians( angular_velocity ) );
		]];

/***************************************
	Property: mass

	The mass property specifies the mass of the object. Mass is calculated automatically and depends on the density of the body's fixtures.
	
	*See Also:* the <add_fixture> function
*/

	readonly double mass
        [[
            Physics::Body * me = Physics::Body::get( self );

            mass = me->body->GetMass();
        ]];

/***************************************
	TODO: mass_data
*/

/***************************************
	Property: linear_damping

	The linear_damping property specifies the damping factor to apply to the object's linear velocity. The range of valid settings is 0 to infinity, but common settings are between 0.0 and 0.1.

	*Default Setting:* 0.0
	
	*See Also:* the <linear_velocity> property
*/

	double linear_damping
        [[
            Physics::Body * me = Physics::Body::get( self );

            linear_damping = me->body->GetLinearDamping();
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->body->SetLinearDamping( linear_damping );
        ]];

/***************************************
	Property: angular_damping

	The angular_damping property specifies the damping factor to apply to the object's angular velocity. The range of valid settings is 0 to infinity, but common settings are between 0.0 and 0.1.
	
	*Default Setting:* 0.0
	
	*See Also:* the <angular_velocity> property
*/

	double angular_damping
        [[
            Physics::Body * me = Physics::Body::get( self );

            angular_damping = me->body->GetAngularDamping();
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->body->SetAngularDamping( angular_damping );
        ]];

/***************************************
	Property: bullet

	The bullet property is a boolean flag indicating whether or not the object should be processed as a fast-moving bullet (true=is bullet).
	
	A fast-moving object can move a long distance between steps of the physics simulation. Because of this speed, it's possible for the object to pass through other objects without a collision being detected. This event is called "tunneling." To prevent tunneling, the fast-moving object should be flagged as a "bullet" to enable "continuous collision detection" (CCD). With CCD enabled, collisions are detected for even fast-moving objects. For performance reasons, CCD is disabled by default.
	
	The bullet property affects Body objects of type "dynamic" only.
	
	*Default Setting:* false, i.e., is not a fast-moving object
*/

	bool bullet
        [[
            Physics::Body * me = Physics::Body::get( self );

            bullet = me->body->IsBullet();
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->body->SetBullet( bullet );
        ]];

/***************************************
	Property: sleeping_allowed

	The sleeping_allowed property is a boolean flag indicating whether or not an object that has stopped moving can enter a sleep mode in which the object can be temporarily removed from the physics simulation so as to improve performance (true=sleeping allowed). The object will exit sleep mode automatically if it is involved in a collision or some other force is acted upon it.
	
	*Default Setting:* true, i.e., can automatically enter sleep mode when inactive
	
	*See Also:* the <awake> property
*/

	bool sleeping_allowed
        [[
            Physics::Body * me = Physics::Body::get( self );

            sleeping_allowed = me->body->IsSleepingAllowed();
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->body->SetSleepingAllowed( sleeping_allowed );
        ]];

/***************************************
	UndocumentedProperty: fixed_rotation

	Note: The fixed_rotation property has no effect. With fixed_rotation set to true, the object will still rotate by setting the angular_velocity property.  Grep'ing the Box2D source code shows no calls to the underlying SetFixedRotation() and IsFixedRotation() functions. Also, on-line forums also show people claiming that SetFixedRotation() has no effect. Until this property can be shown to work as expected, it will remain undocumented.
	
	The fixed_rotation property is a boolean flag indicating whether or not the body can rotate around the Z axis (true==cannot rotate).
	
	*Default Setting:* false, i.e., the object can rotate
	
	*See Also:* the <angular_velocity> property
*/

	bool fixed_rotation
        [[
            Physics::Body * me = Physics::Body::get( self );

            fixed_rotation = me->body->IsFixedRotation();
        ]]
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->body->SetFixedRotation( fixed_rotation );
        ]];

/***************************************
	Property: contacts

	The contacts property is a table that contains the points on the object where it is touching other Body objects. If the object is not touching any objects, the property's value is nil.
	
	Each entry in the contacts table includes the following keys.
	
		enabled - boolean flag indicating whether or not the contact is enabled (true==enabled). A contact can be disabled in the physics global variable's <on_pre_solve_contact> event handler.
		touching - boolean flag indicating whether or not the two objects are touching (true==touching). Note: Contact may occur between the bounding boxes of two objects, but the actual objects do not touch.
		point - table containing two keys. Key "1" contains the contact point's X coordinate. Key "2" contains the contact point's Y coordinate.
		bodies - table containing two keys. Key "1" contains the <handle> for one of the objects. Key "2" contains the handle for the other object.
		other_body - table containing two keys. One key is the <handle> of the current object; its value is the handle of the other object. The second key is the handle of the other object; its value is the handle of the current object. For example, if the object with handle 2 is touching the object with handle 4, the other_body table for the object with handle 2 would contain { 2=4, 4=2 }. This table enables the program to access the other object by using the current object's handle as an index, as in contactObject = Object2.contacts.other_body[ Object2.handle ].
		fixtures - table containing two keys. Key "1" contains the fixture handle for one of the fixtures. Key "2" contains the fixture handle for the other fixture. The fixture handle is returned by the <add_fixture> function.
		other_fixture - table containing two keys. One key is the fixture handle of the current fixture; its value is the fixture handle of the other fixture. The second key is the fixture handle of the other fixture; its value is the fixture handle of the current fixture. For example, if the fixture with handle 3 is touching the fixture with handle 5, the other_fixture table for the fixture with handle 3 would contain { 3=5, 5=3 }. This table enables the program to access the other fixture by using the current fixture's handle as an index, as in contactFixture = ObjectX.contacts.other_fixture[ ObjectXFixtureHandle ].
	
	*Default Setting:* nil
	
	*Code Example:*
	
		(code)
		-- Display the complete contents of an object's contacts table
		if( Object.contacts ~= nil )then
			dumptable( Object.contacts )
		end
		(end)
	
	*See Also:* the <handle> property, the <add_fixture> function, and the <on_pre_solve_contact> event handler
*/

	readonly table contacts
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->world->push_contact_list( me->body->GetContactList() );
        ]];

/***************************************
	Function: synchronize

	The synchronize() function forces the Body's position and rotation to match that of its related UIElement-based object.
	
	The synchronize() function may alter the following Body properties: <x>, <y>, <position>, <angle> and <rotation>.
	
	*Return Value:* None
	
	*See Also:* the <x>, <y>, <position>, <angle> and <rotation> properties
*/

	synchronize( )
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->synchronize_body();
        ]];

/***************************************
	Function: apply_force

	The apply_force() function applies a directional force on an object.
	
	Applying force on an object is similar to setting the object's <linear_velocity>, but linear velocity is always applied to the center of the object's mass, while force can be applied to any X,Y coordinate. If force is applied anywhere other than the center of the object's mass, a torque is created which affects the <angular_velocity>.
	
	*Code Example:*
	
		(code)
		-- Use force to push object up
		gObject:apply_force( { 0, -500 }, { gObject.x, gObject.y } )
		
		-- Use force to push object left
		gObject:apply_force( { 100, 0 }, { gObject.x, gObject.y } )
		(end)



		Apply a force to the body.

		force - A table of X and Y forces.
		point - The point, on the body where the force should be applied. This is a
		        table of X and Y coordinates.
*/

	apply_force( table force, table point )
		[[
            Physics::Body * me = Physics::Body::get( self );

            lua_rawgeti( L , force , 1 );
            lua_rawgeti( L , force , 2 );

            lua_rawgeti( L , point , 1 );
            lua_rawgeti( L , point , 2 );

			me->body->ApplyForce(
			    b2Vec2( lua_tonumber( L , -4 ) , lua_tonumber( L , -3 ) ) ,
				b2Vec2( me->world->screen_to_world( lua_tonumber( L , -2 ) ),
				        me->world->screen_to_world( lua_tonumber( L , -1 ) ) ) );

			lua_pop( L , 4 );
		]];

	/*
		Function: apply_torque

		A force to apply that will cause the body to rotate.
	*/

	apply_torque( double torque )
		[[
            Physics::Body * me = Physics::Body::get( self );

            me->body->ApplyTorque( torque );
		]];

	/*
		Function: apply_linear_impulse

		A linear impulse to apply to the body.

		force - X and Y force values.
		point - The point, on the body, where the impulse should be applied. This is a
		        table of X and Y coordinates.
	*/

	apply_linear_impulse( table force , table point )
		[[
            Physics::Body * me = Physics::Body::get( self );

            lua_rawgeti( L , force , 1 );
            lua_rawgeti( L , force , 2 );

            lua_rawgeti( L , point , 1 );
            lua_rawgeti( L , point , 2 );

            me->body->ApplyLinearImpulse(
                    b2Vec2( lua_tonumber( L , -4 ) , lua_tonumber( L , -3 ) ) ,
                    b2Vec2( me->world->screen_to_world( lua_tonumber( L , -2 ) ),
                          me->world->screen_to_world( lua_tonumber( L , -1 ) ) ) );

            lua_pop( L , 4 );
		]];

	/*
		Function: apply_angular_impulse

		An impulse that will rotate the body.
	*/

	apply_angular_impulse( double impulse )
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->body->ApplyAngularImpulse( impulse );
        ]];


    #-------------------------------------------------------------------------
    # Fixtures

	/*
		Property: fixtures

		Returns a table of all fixtures belonging to this body. For each fixture, the
		following keys are provided:

		handle - An integer that uniquely identifies the fixture.
		type - "circle" or "polygon".
		sensor - Boolean indicating whether the fixture is a sensor.
		density - The density of the fixture.
		friction - The friction of the fixture.
		bounce - Restitution value for the fixture.
	*/

    readonly table fixtures
        [[
            Physics::Body * me = Physics::Body::get( self );

            lua_newtable( L );
            int t = lua_gettop( L );
            int i = 1;

            for( b2Fixture * f = me->body->GetFixtureList(); f ; f = f->GetNext() , ++i )
            {
                lua_newtable( L );

                lua_pushinteger( L , GPOINTER_TO_INT( f->GetUserData() ) );
                lua_setfield( L , -2 , "handle" );

                switch( f->GetType() )
                {
                    case b2Shape::e_circle:
                        lua_pushstring( L , "circle" );
                        break;

                    case b2Shape::e_polygon:
                        lua_pushstring( L , "polygon" );
                        break;

                    default:
                        lua_pushnil( L );
                }

                lua_setfield( L , -2 , "type" );

                lua_pushboolean( L , f->IsSensor() );
                lua_setfield( L , -2 , "sensor" );

                lua_pushnumber( L , f->GetDensity() );
                lua_setfield( L , -2 , "density" );

                lua_pushnumber( L , f->GetFriction() );
                lua_setfield( L , -2 , "friction" );

                lua_pushnumber( L , f->GetRestitution() );
                lua_setfield( L , -2 , "bounce" );

                // We are going to create a sub-table for the filter
                const b2Filter & filter = f->GetFilterData();

                lua_newtable( L );

                lua_pushinteger( L, filter.groupIndex );
                lua_setfield( L, -2, "group" );

                lua_pushinteger( L, filter.categoryBits );
                Util::convert_bitmask_to_table( L );
                lua_setfield( L, -2, "category" );

                lua_pushinteger( L, filter.maskBits );
                Util::convert_bitmask_to_table( L );
                lua_setfield( L, -2, "mask" );

                lua_setfield( L, -2, "filter" );

                lua_rawseti( L , t , i );
            }
        ]];

	/*
		Function: remove_fixture()

		Removes the given fixture from the body.
	*/

    bool remove_fixture( int fixture_handle )
        [[
            Physics::Body * me = Physics::Body::get( self );

            result = false;

            for( b2Fixture * f = me->body->GetFixtureList(); f ; f = f->GetNext() )
            {
                if ( GPOINTER_TO_INT( f->GetUserData() ) == fixture_handle )
                {
                    result = true;
                    f->GetBody()->DestroyFixture( f );
                    break;
                }
            }
        ]];

	/*
		Function: remove_all_fixtures

		Removes all fixtures from the body.
	*/

    remove_all_fixtures()
        [[
            Physics::Body * me = Physics::Body::get( self );

            for( b2Fixture * f = me->body->GetFixtureList(); f ; )
            {
                b2Fixture * next = f->GetNext();

                f->GetBody()->DestroyFixture( f );

                f = next;
            }

        ]];

	/*
		Function: add_fixture

		Adds a new fixture to the body. A fixture can have the following properties:

		friction - Between 0 (slippery) and 1 (not slippery at all).
		restitution or bounce - Between 0 (not bouncy) and 1 (perfectly elastic).
		density - The density of the fixture.
		sensor - Whether the fixture is a sensor. A sensor fixture does not affect
		          other fixtures but detects contacts.
        filter - Collision filtering. (TODO: Complicated, need full explanation).
        shape - The shape for the fixture, this can be created using the <Box>,
                <Edge>, <Polygon> or <Circle> functions on the <physics> global.
	*/

    int add_fixture( table properties )
        [[
            Physics::Body * me = Physics::Body::get( self );

            result = 0;

            b2FixtureDef fd = me->world->create_fixture_def( properties );

            if ( ! fd.shape )
            {
                return luaL_error( L , "Missing shape" );
            }

            result = me->world->get_next_handle();

            fd.userData = GINT_TO_POINTER( result );

            me->body->CreateFixture( & fd );
        ]];

    #..........................................................................
    # Joints

	/*
		Function: remove_joint

		Removes a joint from the body.
	*/

    bool remove_joint( int joint_handle )
        [[
            Physics::Body * me = Physics::Body::get( self );

            gpointer h = GINT_TO_POINTER( joint_handle );

            result = false;

            for( b2JointEdge * e = me->body->GetJointList(); e; e = e->next )
            {
                if ( e->joint && e->joint->GetUserData() == h )
                {
                    result = true;

                    me->world->get_world()->DestroyJoint( e->joint );

                    break;
                }
            }
        ]];

	/*
		Function: DistanceJoint

		Creates a distance joint on this body.

		anchor - The X and Y coordinates for the joint's anchor on this body.
		other_body - The other body this joint will be attached to.
		other_anchor - The X and Y coordinates on the other body.
		properties - "frequency" and "damping_ratio".
	*/

    int DistanceJoint( table anchor , Body other_body , table other_anchor , table properties = 0 )
        [[
            lb_check_udata_type( L , other_body , "Body" );

            Physics::Body * me = Physics::Body::get( self );

            Physics::Body * other = Physics::Body::get_from_lua( L , other_body );

            if ( ! other )
            {
                return luaL_error( L , "Invalid body" );
            }

            b2Body * ba = me->body;
            b2Body * bb = other->body;

            lua_rawgeti( L , anchor , 1 );
            lua_rawgeti( L , anchor , 2 );

            float32 ax = me->world->screen_to_world( lua_tonumber( L , -2 ) );
            float32 ay = me->world->screen_to_world( lua_tonumber( L , -1 ) );

            lua_pop( L , 2 );

            lua_rawgeti( L , other_anchor , 1 );
            lua_rawgeti( L , other_anchor , 2 );

            float32 bx = me->world->screen_to_world( lua_tonumber( L , -2 ) );
            float32 by = me->world->screen_to_world( lua_tonumber( L , -1 ) );

            lua_pop( L , 2 );

            b2DistanceJointDef d;

            d.Initialize( ba , bb , b2Vec2( ax , ay ) , b2Vec2( bx , by ) );

            if ( properties )
            {
                lua_getfield( L , properties , "frequency" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    d.frequencyHz = lua_tonumber( L , -1 );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "damping_ratio" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    d.dampingRatio = lua_tonumber( L , -1 );
                }
                lua_pop( L , 1 );
            }

            result = me->world->get_next_handle();

            b2Joint * joint = me->world->get_world()->CreateJoint( & d );

            joint->SetUserData( GINT_TO_POINTER( result ) );

        ]];

	/*
		Function: RevoluteJoint

		Creates a revolute joint on this body.

		other_body - The other body to attach to.
		anchor - Coordinates for the point where the joint is attached.
		properties -  "enable_limit" (boolean)
		              "lower_angle" (degrees)
		              "upper_angle" (degrees)
		              "enable_motor" (boolean)
		              "motor_speed" (number)
		              "max_motor_torque" (number)
	*/

    int RevoluteJoint( Body other_body , table anchor , table properties = 0 )
        [[
            lb_check_udata_type( L , other_body , "Body" );

            Physics::Body * me = Physics::Body::get( self );

            Physics::Body * other = Physics::Body::get_from_lua( L , other_body );

            if ( ! other )
            {
                return luaL_error( L , "Invalid body" );
            }

            b2Body * ba = me->body;
            b2Body * bb = other->body;

            lua_rawgeti( L , anchor , 1 );
            lua_rawgeti( L , anchor , 2 );

            float32 x = me->world->screen_to_world( lua_tonumber( L , -2 ) );
            float32 y = me->world->screen_to_world( lua_tonumber( L , -1 ) );

            lua_pop( L , 2 );

            b2RevoluteJointDef j;

            j.Initialize( ba , bb , b2Vec2( x , y ) );

            if ( properties )
            {
                lua_getfield( L , properties , "enable_limit" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    j.enableLimit = lua_toboolean( L , -1 );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "lower_angle" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    j.lowerAngle = Physics::World::degrees_to_radians( lua_tonumber( L , -1 ) );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "upper_angle" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    j.upperAngle = Physics::World::degrees_to_radians( lua_tonumber( L , -1 ) );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "enable_motor" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    j.enableMotor = lua_toboolean( L , -1 );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "motor_speed" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    j.motorSpeed = Physics::World::degrees_to_radians( lua_tonumber( L , -1 ) );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "max_motor_torque" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    j.maxMotorTorque = lua_tonumber( L , -1 );
                }
                lua_pop( L , 1 );

            }

            result = me->world->get_next_handle();

            b2Joint * joint = me->world->get_world()->CreateJoint( & j );

            joint->SetUserData( GINT_TO_POINTER( result ) );
        ]];

	/*
		Function: PrismaticJoint

		TODO
	*/

    int PrismaticJoint( Body other_body , table anchor , table axis , table properties = 0 )
        [[
            lb_check_udata_type( L , other_body , "Body" );

            Physics::Body * me = Physics::Body::get( self );

            Physics::Body * other = Physics::Body::get_from_lua( L , other_body );

            if ( ! other )
            {
                return luaL_error( L , "Invalid body" );
            }

            b2Body * ba = me->body;
            b2Body * bb = other->body;

            // TODO: at least one of the bodies has to be dynamic with a non-fixed rotation

            lua_rawgeti( L , anchor , 1 );
            lua_rawgeti( L , anchor , 2 );

            float32 x = me->world->screen_to_world( lua_tonumber( L , -2 ) );
            float32 y = me->world->screen_to_world( lua_tonumber( L , -1 ) );

            lua_pop( L , 2 );

            lua_rawgeti( L , axis , 1 );
            lua_rawgeti( L , axis , 2 );

            float32 ax = me->world->screen_to_world( lua_tonumber( L , -2 ) );
            float32 ay = me->world->screen_to_world( lua_tonumber( L , -1 ) );

            lua_pop( L , 2 );

            b2PrismaticJointDef p;

            p.Initialize( ba , bb , b2Vec2( x , y ) , b2Vec2( ax , ay ) );

            if ( properties )
            {
                lua_getfield( L , properties , "reference_angle" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    p.referenceAngle = Physics::World::degrees_to_radians( lua_tonumber( L , -1 ) );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "enable_limit" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    p.enableLimit = lua_toboolean( L , -1 );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "lower_translation" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    p.lowerTranslation = me->world->screen_to_world( lua_tonumber( L , -1 ) );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "upper_translation" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    p.upperTranslation = me->world->screen_to_world( lua_tonumber( L , -1 ) );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "enable_motor" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    p.enableMotor = lua_toboolean( L , -1 );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "motor_speed" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    p.motorSpeed = Physics::World::degrees_to_radians( lua_tonumber( L , -1 ) );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "max_motor_force" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    p.maxMotorForce = lua_tonumber( L , -1 );
                }
                lua_pop( L , 1 );
            }

            result = me->world->get_next_handle();

            b2Joint * joint = me->world->get_world()->CreateJoint( & p );

            joint->SetUserData( GINT_TO_POINTER( result ) );
        ]];

	/*
		Event: on_begin_contact

		When a body begins to touch another, this callback is triggered.

		The single argument "contact" is a table with several values
		describing the contact.

		point - A table of X and Y coordinates for the contact point.
		fixtures - A table containing the handles of the fixtures that made contact.
		other_fixture - A table containing the same two handles, but indexed by each other,
		                so that if my fixture handle is 42, I can get the handle of the other fixture
		                by using contact.other_fixture[ 42 ].
        bodies - A table containing the handles of the two bodies that made contact.
        other_body - Same as "other_fixture" but with body handles.
        touching - Whether the contact is touching or not.
        enabled - Whether the contact is enabled. You can actually change this value
                  only during the <on_pre_solve_contact> event.

        *Note:* You should not change bodies in any of the contact callbacks. Instead
        make a note of the event and change things after the step is done.
	*/

    callback on_begin_contact( table contact )
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->world->attach_body_callback( me , Physics::BEGIN_CONTACT , on_begin_contact );
        ]];

	/*
		Event: on_end_contact

		When two fixtures are no longer in contact. The contact details are the same as
		in <on_begin_contact>.
	*/

    callback on_end_contact( table contact )
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->world->attach_body_callback( me , Physics::END_CONTACT , on_end_contact );
        ]];

	/*
		Event: on_pre_solve_contact

		This callback is called after collision detection but before collision resolution. It
		lets you change the "enabled" property on the contact to affect behavior.

		The contact details are the same as in <on_begin_contact>.
	*/

    callback on_pre_solve_contact( table contact )
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->world->attach_body_callback( me , Physics::PRE_SOLVE_CONTACT , on_pre_solve_contact );
        ]];

	/*
		Event: on_post_solve_contact

	    This callback is called after collision resolution and gives you a chance to look at
	    the impulses generated by a collision.

	    The contact details are the same as in <on_begin_contact>.
	*/

    callback on_post_solve_contact( table contact )
        [[
            Physics::Body * me = Physics::Body::get( self );

            me->world->attach_body_callback( me , Physics::POST_SOLVE_CONTACT , on_post_solve_contact );
        ]];
}

/*===========================================================================*/

	/*
		Global: physics

		The physics global lets you create bodies and run a physics simulation.
	*/

global physics [[ Physics::World * ]]
{
	physics()
		[[
            ClutterActor * screen = clutter_get_actor_by_gid( App::get( L )->get_screen_gid() );

			self = lb_construct( Physics::World , new Physics::World( L , screen , 64 ) );
		]];

	~physics()
		[[
			delete self;
		]];

	/*
		Property: pixels_per_meter

		Pixels per meter.
	*/

	double pixels_per_meter
        [[
            pixels_per_meter = self->ppm;
        ]]
        [[
            self->ppm = pixels_per_meter;
        ]];

	/*
		Property: gravity

		Gravity is a table with two values, one for X and another for Y. Either can be
		positive, negative or zero. Setting gravity to { 0 , 0 } means no gravity. A positive
		value for X will push objects to the right, negative to the left. Positive for Y
		will push objects down, negative will push them up.
	*/

    table gravity
        [[
            b2Vec2 g( self->get_world()->GetGravity() );
            lua_newtable( L );
            lua_pushnumber( L , g.x );
            lua_rawseti( L , -2 , 1 );
            lua_pushnumber( L , g.y );
            lua_rawseti( L , -2 , 2 );
        ]]
        [[
            luaL_checktype(L,2,LUA_TTABLE);
            lua_rawgeti( L , 2 , 1 );
            lua_rawgeti( L , 2 , 2 );
            b2Vec2 g( lua_tonumber( L , -2 ) , lua_tonumber( L , -1 ) );
            self->get_world()->SetGravity( g );
            lua_pop( L , 2 );
        ]];

	/*
		Property: auto_clear_forces

		Whether forces should be automatically cleared after each time step.
	*/

    bool auto_clear_forces
        [[
            auto_clear_forces = self->get_world()->GetAutoClearForces();
        ]]
        [[
            self->get_world()->SetAutoClearForces( auto_clear_forces );
        ]];

	/*
		Property: contacts

		A list of all current contacts in the whole physics world.
	*/

    readonly table contacts
        [[
            self->push_contact_list( self->get_world()->GetContactList() );
        ]];

	/*
		Property: running

		Whether the simulation is running.
	*/

    readonly bool running
        [[
            running = self->running();
        ]];

	/*
		Function: start

		Start the physics simulation with the given velocity and position
		iterations. For each step, the <on_step> callback will be called.
	*/

    start( int velocity_iterations = 10, int position_iterations = 10 )
        [[
            self->start( velocity_iterations , position_iterations );
        ]];

	/*
		Function: stop

		Stop the simulation. It can be started again with <start>.
	*/

	stop()
        [[
            self->stop();
        ]];

	/*
	THIS ONE SHOULD BE UNDOCUMENTED AS IT WILL BE DEPRECATED.
	*/

	step( double time_step = 1.0f/60.0f , int velocity_iterations = 10, int position_iterations = 10 )
		[[
            self->step( time_step , velocity_iterations , position_iterations );
		]];

	/*
		Function: clear_forces

		Clears all current forces.
	*/

	clear_forces()
        [[
            self->get_world()->ClearForces();
        ]];

	/*
		Function: draw_debug

		Draws a debug overlay that shows you bodies, fixtures, joints and other information. You
		need to call it after every step.
	*/

	draw_debug( int opacity = 127 )
        [[
            self->draw_debug( opacity );
        ]];

	/*
		Function: clear_debug

		Clears the debug overlay.
	*/

	clear_debug()
        [[
            self->clear_debug();
        ]];

	/*
	NOT IMPLEMENTED COMPLETELY
	*/

	table get_fixtures_in_rectangle( table top_left , table bottom_right )
        [[
            float32 x1;
	        float32 y1;
	        float32 x2;
	        float32 y2;

            lua_rawgeti( L , top_left , 1 );
            x1 = self->screen_to_world( lua_tonumber( L , -1 ) );
            lua_pop( L , 1 );
            lua_rawgeti( L , top_left , 2 );
            y1 = self->screen_to_world( lua_tonumber( L , -1 ) );
            lua_pop( L , 1 );

            lua_rawgeti( L , bottom_right , 1 );
            x2 = self->screen_to_world( lua_tonumber( L , -1 ) );
            lua_pop( L , 1 );
            lua_rawgeti( L , bottom_right , 2 );
            y2 = self->screen_to_world( lua_tonumber( L , -1 ) );
            lua_pop( L , 1 );

            b2AABB a;

            a.lowerBound.x = x1;
            a.lowerBound.y = y1;
            a.upperBound.x = x2;
            a.upperBound.y = y2;

            Physics::AABBQuery q( L );

            self->get_world()->QueryAABB( & q , a );

            // TODO: put results in a table.

            lua_pushnil( L );
        ]];

	/*
		Function: Body

		This function lets you create physics bodies. You pass an existing UIElement that
		is attached directly to the screen and a table of properties for the body.

		This call returns the same UIElement enhanced to provide all the functions
		and properties of a <Body>. If there is a problem, this call can return nil.

		*Note:* This moves the anchor point of the UIElement to its center.

		The "properties" table can include any of the properties of <Body>, such as
		its type. It can also have any of the properties of a fixture. A default
		fixture is always created and, if you do not include a "shape" for the
		fixture, a default rectangular shape is created that fits the dimensions of the
		entire UIElement.
	*/

	Body Body( UIElement element , table properties )
		[[
            lb_check_udata_type( L , element , "actor" );

            // Use default density of 1, because 0 is stupid
            lua_getfield( L , properties , "density" );
            if ( lua_isnil( L , -1 ) )
            {
                lua_pushnumber( L , 1.0 );
                lua_setfield( L , properties , "density" );
            }
            lua_pop( L , 1 );

            int n = self->create_body( element , properties , BODY_METATABLE );

            if ( ! n )
            {
                lua_pushnil( L );
            }
            else
            {
                ClutterUtil::set_props_from_table( L , properties );
            }
		]];

    #..........................................................................
    # Shape factory methods

	/*
		Function: Box

		Creates a box shape that can be used for fixtures.

		size - A table with width and height (in pixels) for the box.
		center - A table of X and Y coordinates relative to the body.
		rotation - The angle (in degrees) of the box along the Z axis relative to its center.
	*/

	Shape Box( table size , table center = 0 , double rotation = 0 )
        [[
            b2PolygonShape * shape = new b2PolygonShape();

            if ( ! center )
            {
                lua_rawgeti( L , size , 1 );
                lua_rawgeti( L , size , 2 );

                shape->SetAsBox( self->screen_to_world( lua_tonumber( L , -2 ) * 0.5 ) ,
                    self->screen_to_world( lua_tonumber( L , -1 ) * 0.5 ) );

                lua_pop( L , 2 );
            }
            else
            {
                lua_rawgeti( L , size , 1 );
                lua_rawgeti( L , size , 2 );

                lua_rawgeti( L , center , 1 );
                lua_rawgeti( L , center , 2 );

                shape->SetAsBox( self->screen_to_world( lua_tonumber( L , -4 ) * 0.5 ) ,
                        self->screen_to_world( lua_tonumber( L , -3 ) * 0.5 ),
                        b2Vec2( self->screen_to_world( lua_tonumber( L , -2 ) ),
                                self->screen_to_world( lua_tonumber( L , -1 ) ) ),
                        Physics::World::degrees_to_radians( rotation ) );

                lua_pop( L , 4 );
            }

            lua_pushlightuserdata( L , shape );

            new_Shape( L );

            lua_remove( L , -2 );
        ]];

	/*
		Function: Edge

		Creates an edge shape (a line) to be used for a fixture.
		You pass two tables, each with X and Y coordinates relative to the center of the body.
	*/

	Shape Edge( table point_a , table point_b )
        [[
            b2PolygonShape * shape = new b2PolygonShape();

            lua_rawgeti( L , point_a , 1 );
            lua_rawgeti( L , point_a , 2 );
            lua_rawgeti( L , point_b , 1 );
            lua_rawgeti( L , point_b , 2 );

            shape->SetAsEdge( b2Vec2( self->screen_to_world( lua_tonumber( L , -4 ) ) ,
                    self->screen_to_world( lua_tonumber( L , -3 ) ) ),
                    b2Vec2( self->screen_to_world( lua_tonumber( L , -2 ) ) ,
                            self->screen_to_world( lua_tonumber( L , -1 ) ) ) );

            lua_pop( L , 4 );

            lua_pushlightuserdata( L , shape );

            new_Shape( L );

            lua_remove( L , -2 );
        ]];

	/*
		Function: Polygon

		Creates a polygon shape given a table of points, a table of tables, each with X and
		Y coordinates relative to the center of the body.

		*Note:* You should not specify more than 8 points and the resulting shape should be convex.
	*/

	Shape Polygon( table points )
        [[
            std::vector< b2Vec2 > p;

            lua_pushnil( L );

            while( lua_next( L , points ) )
            {
                if ( lua_istable( L , -1 ) )
                {
                    lua_rawgeti( L , -1 , 1 );
                    lua_rawgeti( L , -2 , 2 );

                    p.push_back(
                            b2Vec2( self->screen_to_world( lua_tonumber( L , -2 ) ) ,
                                    self->screen_to_world( lua_tonumber( L , -1 ) ) ) );

                    lua_pop( L , 2 );
                }
                lua_pop( L , 1 );
            }

            if ( p.empty() )
            {
                return luaL_error( L , "Invalid polygon points" );
            }

            b2PolygonShape * shape = new b2PolygonShape();

            shape->Set( & p[ 0 ] , p.size() );

            lua_pushlightuserdata( L , shape );
            new_Shape( L );
            lua_remove( L , -2 );
        ]];

	/*
		Function: Circle

		Creates a circular shape to be used for fixtures.

		radius - The radius of the circle (in pixels).
		center - A table of X and Y coordinates for the center of the circle relative
		          to the center of the body.
	*/

	Shape Circle( double radius , table center = 0 )
        [[
            b2CircleShape * shape = new b2CircleShape();

            shape->m_radius = self->screen_to_world( radius );

            shape->m_p.SetZero();

            if ( center )
            {
                lua_rawgeti( L , center , 1 );
                lua_rawgeti( L , center , 2 );

                shape->m_p.Set( self->screen_to_world( lua_tonumber( L , -2 ) ) ,
                        self->screen_to_world( lua_tonumber( L , -1 ) ) );

                lua_pop( L , 2 );
            }

            lua_pushlightuserdata( L , shape );

            new_Shape( L );

            lua_remove( L , -2 );
        ]];

    #..........................................................................

	/*
		Event: on_step

		This callback occurs every time the physics simulation completes a step. This
		will be at most every 1/60 of a second.

		seconds - The fractional number of seconds since on_step was last called.
	*/

    callback on_step( double seconds );

	/*
		Event: on_begin_contact

		Same as the the callback for each Body, but for the entire world.
	*/

	callback on_begin_contact( table contact )
        [[
            self->attach_global_callback( Physics::BEGIN_CONTACT , on_begin_contact );
        ]];

	/*
		Event: on_end_contact

        Same as the the callback for each Body, but for the entire world.
	*/

    callback on_end_contact( table contact )
        [[
            self->attach_global_callback( Physics::END_CONTACT , on_end_contact );
        ]];

	/*
		Event: on_pre_solve_contact

        Same as the the callback for each Body, but for the entire world.
	*/

    callback on_pre_solve_contact( table contact )
        [[
            self->attach_global_callback( Physics::PRE_SOLVE_CONTACT , on_pre_solve_contact );
        ]];

	/*
		Event: on_post_solve_contact

        Same as the the callback for each Body, but for the entire world.
	*/

    callback on_post_solve_contact( table contact )
        [[
            self->attach_global_callback( Physics::POST_SOLVE_CONTACT , on_post_solve_contact );
        ]];

    /*
        Property: z_for_y

        When set to true, the physics simulation treats the UIElement's z as its y.
    */

    bool z_for_y
        [[
            z_for_y = self->z_for_y;
        ]]
        [[
            self->z_for_y = z_for_y;
        ]];
}

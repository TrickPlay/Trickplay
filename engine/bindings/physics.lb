
module physics_module;

[[
#include "Box2D/Box2D.h"
#include "clutter/clutter.h"

#include "clutter_util.h"

void populate_fixture_from_table( lua_State * L , int properties , b2FixtureDef & fixture_def )
{
    lua_getfield( L , properties , "friction" );
    if ( ! lua_isnil( L , -1 ) )
    {
        fixture_def.friction = lua_tonumber( L , -1 );
    }
    lua_pop( L , 1 );

    lua_getfield( L , properties , "restitution" );
    if ( ! lua_isnil( L , -1 ) )
    {
        fixture_def.restitution = lua_tonumber( L , -1 );
    }
    lua_pop( L , 1 );

    lua_getfield( L , properties , "bounce" );
    if ( ! lua_isnil( L , -1 ) )
    {
        fixture_def.restitution = lua_tonumber( L , -1 );
    }
    lua_pop( L , 1 );

    lua_getfield( L , properties , "density" );
    if ( ! lua_isnil( L , -1 ) )
    {
        fixture_def.density = lua_tonumber( L , -1 );
    }
    lua_pop( L , 1 );

    lua_getfield( L , properties , "sensor" );
    if ( ! lua_isnil( L , -1 ) )
    {
        fixture_def.isSensor = lua_toboolean( L , -1 );
    }
    lua_pop( L , 1 );

    lua_getfield( L , properties , "filter" );
    if ( lua_istable( L , -1 ) )
    {
        int f = lua_gettop( L );

        lua_getfield( L , f , "group" );
        if ( ! lua_isnil( L , -1 ) )
        {
            fixture_def.filter.groupIndex = lua_tointeger( L , -1 );
        }
        lua_pop( L , 1 );

        lua_getfield( L , f , "category" );
        if ( lua_isnumber( L , -1 ) )
        {
            fixture_def.filter.categoryBits = 1 << lua_tointeger( L , -1 );
        }
        else if ( lua_istable( L , -1 ) )
        {
            fixture_def.filter.categoryBits = 0;

            int t = lua_gettop( L );

            lua_pushnil( L );

            while( lua_next( L , t ) )
            {
                if ( lua_isnumber( L , -1 ) )
                {
                    fixture_def.filter.categoryBits |= 1 << lua_tointeger( L , -1 );
                }
                lua_pop( L , 1 );
            }
        }
        lua_pop( L , 1 );

        lua_getfield( L , f , "mask" );
        if ( lua_isnumber( L , -1 ) )
        {
            fixture_def.filter.maskBits = 1 << lua_tointeger( L , -1 );
        }
        else if ( lua_istable( L , -1 ) )
        {
            fixture_def.filter.maskBits = 0;

            int t = lua_gettop( L );

            lua_pushnil( L );

            while( lua_next( L , t ) )
            {
                if ( lua_isnumber( L , -1 ) )
                {
                    fixture_def.filter.maskBits |= 1 << lua_tointeger( L , -1 );
                }
                lua_pop( L , 1 );
            }
        }
        lua_pop( L , 1 );
    }
    lua_pop( L , 1 );
}

void synchronize_actor( ClutterActor * actor , b2Body* body , double ppm )
{
    if ( actor )
    {
        const b2Vec2 & pos( body->GetPosition() );

        clutter_actor_set_position( actor , pos.x * ppm , pos.y * ppm );

        clutter_actor_set_rotation( actor , CLUTTER_Z_AXIS , body->GetAngle () / ( G_PI / 180.0 ) , 0 , 0 , 0 );
    }
}

class Physx : private b2ContactListener
{
public:

	Physx()
	:
		world( b2Vec2( 0.0f , 10.0f ) , true ), 
		ppm( 64.0f ) // 64 pixels per meter - at 1920 that is 30 meters
	{
//	    world.SetContactListener( this );
	}
	
	~Physx()
	{
		for( b2Body * body = world.GetBodyList(); body; body = body->GetNext() )
		{
			if ( void * ud = body->GetUserData() )
			{
				g_object_set_data( G_OBJECT( ud ) , "tp-physics-body" , NULL );
			}
		}
	}
	
	b2World  	world;
	float32		ppm;

private:

    // b2ContactListener methods

    virtual void BeginContact( b2Contact * contact )
    {
        g_debug( "BEGIN CONTACT" );

        b2WorldManifold wm;

        contact->GetWorldManifold( & wm );

        for ( int32 i = 0; i < 3; ++i )
        {
            g_debug( "    POINT %d : %f , %f" , i , wm.points[ i ].x , wm.points[ i ].y );
        }

        /*
        const b2Manifold * m = contact->GetManifold();

        if ( ! m )
        {
            g_debug( "  NO MANIFOLD" );
        }
        else
        {
            g_debug( "  POINTS = %d" , m->pointCount );

            for ( int32 i = 0; i < m->pointCount; ++i )
            {
                g_debug( "    POINT %d : %f , %f" , i , m->points[ i ].localPoint.x , m->points[ i ].localPoint.y );
            }
        }
        */
    }

    virtual void EndContact( b2Contact * contact )
    {
        g_debug( "END CONTACT" );
    }

    virtual void PreSolve( b2Contact * contact , const b2Manifold * oldManifold )
    {

    }

    virtual void PostSolve( b2Contact * contact , const b2ContactImpulse * impulse )
    {

    }
};

#if 0

bool get_actor_screen_point( ClutterActor * actor , const ClutterVertex * actor_point , ClutterVertex * screen_point )
{
	ClutterActor * stage = clutter_stage_get_default();
	
	ClutterActor * screen = NULL;
	
	for( ClutterActor * parent = clutter_actor_get_parent( actor ); parent; parent = clutter_actor_get_parent( parent ) )
	{
		if ( clutter_actor_get_parent( parent ) == stage )
		{
			screen = parent;
			break;
		}
	} 
	
	if ( ! screen )
	{
		return false;
	}
	
	clutter_actor_apply_relative_transform_to_point( actor , screen , actor_point , screen_point );
	
	return true;
} 

#endif

void destroy_actor_body( b2Body * body )
{
	body->GetWorld()->DestroyBody( body );
}

]]

[[

class Body
{
public:

	Body( Physx * _p , b2Body * _b , ClutterActor * _a )
	:
		physx( _p ),
		body( _b ),
		actor( _a ),
		next_fixture_handle( 2 )
	{
		g_assert( physx );
		g_assert( body );

		if ( actor )
		{
		    g_object_ref( G_OBJECT( actor ) );
		}
	}
	
	~Body()
	{
        if ( actor )
        {
            g_object_unref( G_OBJECT( actor ) );
        }
	}
	
	static Body * get( lua_State * L , int n )
    {
	    return ( Body * ) UserData::get_client( L , n );
    }

	Physx  * 		physx;
	b2Body * 		body;
	ClutterActor * 	actor;
	int             next_fixture_handle;
};

]]

interface Shape [[ b2Shape * ]]
{
    Shape()
        [[
            self = lb_construct( b2Shape , lua_touserdata( L , -2 ) );
        ]];

    ~Shape()
        [[
            delete self;
        ]];
}

interface Body [[ Body * ]]
{
	Body()
		[[
			self = lb_construct( Body , lua_touserdata( L , -2 ) );
		]];
		
	~Body()
		[[
			delete self;
		]];
		
	readonly UIElement source
		[[
			ClutterUtil::wrap_concrete_actor( L , self->actor );
		]];
		
	bool awake
		[[
			awake = self->body->IsAwake();
		]]
		[[
			self->body->SetAwake( awake );
		]];
		
	bool active
		[[
			active = self->body->IsActive();
		]]
		[[
			self->body->SetActive( active );
		]];

	table position
		[[
			const b2Vec2 & pos( self->body->GetPosition() );
			
			lua_newtable( L );
			lua_pushnumber( L , pos.x * self->physx->ppm );
			lua_rawseti( L , -2 , 1 );
			lua_pushnumber( L , pos.y * self->physx->ppm );
			lua_rawseti( L , -2 , 2 );
		]]
		[[
		    lua_rawgeti( L , 2 , 1 );
            lua_rawgeti( L , 2 , 2 );

            b2Vec2 pos( lua_tonumber( L , -2 ) / self->physx->ppm , lua_tonumber( L , -1 ) / self->physx->ppm );

            lua_pop( L , 2 );

            self->body->SetTransform( pos , self->body->GetAngle() );

            synchronize_actor( self->actor , self->body , self->physx->ppm );
		]];

	double x
        [[
            const b2Vec2 & pos( self->body->GetPosition() );

            x = pos.x * self->physx->ppm;
        ]]
        [[
            b2Vec2 pos( self->body->GetPosition() );

            pos.x = x / self->physx->ppm;

            self->body->SetTransform( pos , self->body->GetAngle() );

            synchronize_actor( self->actor , self->body , self->physx->ppm );
        ]];
		
    double y
        [[
            const b2Vec2 & pos( self->body->GetPosition() );

            y = pos.y * self->physx->ppm;
        ]]
        [[
            b2Vec2 pos( self->body->GetPosition() );

            pos.y = y / self->physx->ppm;

            self->body->SetTransform( pos , self->body->GetAngle() );

            synchronize_actor( self->actor , self->body , self->physx->ppm );
        ]];

	double angle
		[[
			angle = self->body->GetAngle() / ( G_PI / 180.0 );
		]]
		[[
		    self->body->SetTransform( self->body->GetPosition() , angle * ( G_PI / 180 ) );

            synchronize_actor( self->actor , self->body , self->physx->ppm );
		]];

    double rotation
        [[
            rotation = self->body->GetAngle() / ( G_PI / 180.0 );
        ]]
        [[
            self->body->SetTransform( self->body->GetPosition() , rotation * ( G_PI / 180 ) );

            synchronize_actor( self->actor , self->body , self->physx->ppm );
        ]];

    readonly table world_center
        [[
            const b2Vec2 pos( self->body->GetWorldCenter() );
            lua_newtable( L );
            lua_pushnumber( L , pos.x * self->physx->ppm );
            lua_rawseti( L , -2 , 1 );
            lua_pushnumber( L , pos.y * self->physx->ppm );
            lua_rawseti( L , -2 , 2 );
        ]];

	readonly table local_center
        [[
            const b2Vec2 pos( self->body->GetLocalCenter() );
            lua_newtable( L );
            lua_pushnumber( L , pos.x * self->physx->ppm );
            lua_rawseti( L , -2 , 1 );
            lua_pushnumber( L , pos.y * self->physx->ppm );
            lua_rawseti( L , -2 , 2 );
        ]];

		
	table linear_velocity
		[[
			b2Vec2 lv( self->body->GetLinearVelocity() );
			
			lua_newtable( L );
			lua_pushnumber( L , lv.x );
			lua_rawseti( L , -2 , 1 );
			lua_pushnumber( L , lv.y );
			lua_rawseti( L , -2 , 2 );	
		]]
		[[
			lua_rawgeti( L , 2 , 1 );
			lua_rawgeti( L , 2 , 2 );
			
			self->body->SetLinearVelocity( b2Vec2( lua_tonumber( L , -2 ) , lua_tonumber( L , -1 ) ) );
			lua_pop( L , 2 );
		]];
		
	double angular_velocity
		[[
			angular_velocity = self->body->GetAngularVelocity() / ( G_PI / 180.0 );
		]]
		[[
			self->body->SetAngularVelocity( angular_velocity * ( G_PI / 180.0 ) );
		]];

	readonly double mass
        [[
            mass = self->body->GetMass();
        ]];

	/* TODO: mass_data */
		
	double linear_damping
        [[
            linear_damping = self->body->GetLinearDamping();
        ]]
        [[
            self->body->SetLinearDamping( linear_damping );
        ]];

	double angular_damping
        [[
            angular_damping = self->body->GetAngularDamping();
        ]]
        [[
            self->body->SetAngularDamping( angular_damping );
        ]];

	bool bullet
        [[
            bullet = self->body->IsBullet();
        ]]
        [[
            self->body->SetBullet( bullet );
        ]];

	bool sleeping_allowed
        [[
            sleeping_allowed = self->body->IsSleepingAllowed();
        ]]
        [[
            self->body->SetSleepingAllowed( sleeping_allowed );
        ]];

	bool fixed_rotation
        [[
            fixed_rotation = self->body->IsFixedRotation();
        ]]
        [[
            self->body->SetFixedRotation( fixed_rotation );
        ]];


	apply_force( double force_x , double force_y , double x , double y )
		[[
			self->body->ApplyForce( b2Vec2( force_x , force_y ) , 
				b2Vec2( x / self->physx->ppm , y / self->physx->ppm ) );   
		]];
		
	apply_torque( double torque )
		[[
			self->body->ApplyTorque( torque );
		]];
		
	apply_linear_impulse( double impulse_x , double impulse_y , double x , double y )
		[[
			self->body->ApplyLinearImpulse( b2Vec2( impulse_x , impulse_y ) , 
				b2Vec2( x / self->physx->ppm , y / self->physx->ppm ) );   
		]];
	
	apply_angular_impulse( double impulse )
        [[
            self->body->ApplyAngularImpulse( impulse );
        ]];

    Body set( table props )
        [[
            ClutterUtil::set_props_from_table( L , props );
            lua_pushvalue( L , 1 );
        ]];

    #-------------------------------------------------------------------------
    # Fixtures

    readonly table fixtures
        [[
            lua_newtable( L );
            int t = lua_gettop( L );
            int i = 1;

            for( b2Fixture * f = self->body->GetFixtureList(); f ; f = f->GetNext() , ++i )
            {
                lua_newtable( L );

                lua_pushinteger( L , GPOINTER_TO_INT( f->GetUserData() ) );
                lua_setfield( L , -2 , "handle" );

                switch( f->GetType() )
                {
                    case b2Shape::e_circle:
                        lua_pushstring( L , "circle" );
                        break;

                    case b2Shape::e_polygon:
                        lua_pushstring( L , "polygon" );
                        break;

                    default:
                        lua_pushnil( L );
                }

                lua_setfield( L , -2 , "type" );

                lua_pushboolean( L , f->IsSensor() );
                lua_setfield( L , -2 , "sensor" );

                lua_pushnumber( L , f->GetDensity() );
                lua_setfield( L , -2 , "density" );

                lua_pushnumber( L , f->GetFriction() );
                lua_setfield( L , -2 , "friction" );

                lua_pushnumber( L , f->GetRestitution() );
                lua_setfield( L , -2 , "bounce" );

                lua_rawseti( L , t , i );
            }
        ]];

    bool remove_fixture( int fixture_handle )
        [[
            result = false;

            for( b2Fixture * f = self->body->GetFixtureList(); f ; f = f->GetNext() )
            {
                if ( GPOINTER_TO_INT( f->GetUserData() ) == fixture_handle )
                {
                    result = true;
                    f->GetBody()->DestroyFixture( f );
                    break;
                }
            }
        ]];

    int add_fixture( table properties )
        [[
            result = 0;

            lua_getfield( L , properties , "shape" );
            if ( lua_type( L , -1 ) != LUA_TUSERDATA )
            {
                lua_pop( L , 1 );
                return luaL_error( L , "Missing shape" );
            }

            b2Shape * shape = ( b2Shape * ) UserData::get_client( L , lua_gettop( L ) );

            if ( ! shape )
            {
                lua_pop( L , 1 );
                return luaL_error( L , "Invalid shape" );
            }

            lua_pop( L , 1 );

            b2FixtureDef fixture_def;

            populate_fixture_from_table( L , properties , fixture_def );

            fixture_def.shape = shape;

            result = self->next_fixture_handle++;

            fixture_def.userData = GINT_TO_POINTER( result );

            self->body->CreateFixture( & fixture_def );
        ]];
}


global physics [[ Physx * ]]
{
	physics()
		[[
			self = lb_construct( Physx , new Physx() );
		]];
		
	~physics()
		[[
			delete self;
		]];
		
	bool step( double time_step = 1.0f/60.0f , int velocity_iterations = 6, int position_iterations = 2 )
		[[
			self->world.Step( time_step , velocity_iterations , position_iterations );
			
			for( b2Body * body = self->world.GetBodyList(); body; body = body->GetNext() )
			{
				if ( ! body->IsAwake() || ! body->IsActive() )
				{
					continue;
				}
				
				ClutterActor * actor = CLUTTER_ACTOR( body->GetUserData() );
				
				if ( actor )
				{
				    synchronize_actor( actor , body , self->ppm );
				}
			}
			
			result = self->world.GetContactList() != 0;
		]]; 
		
	table gravity
		[[
			b2Vec2 g( self->world.GetGravity() );
			lua_newtable( L );
			lua_pushnumber( L , g.x );
			lua_rawseti( L , -2 , 1 );
			lua_pushnumber( L , g.y );
			lua_rawseti( L , -2 , 2 );
		]]
		[[
            luaL_checktype(L,2,LUA_TTABLE);
            lua_rawgeti( L , 2 , 1 );
            lua_rawgeti( L , 2 , 2 );
            b2Vec2 g( lua_tonumber( L , -2 ) , lua_tonumber( L , -1 ) );
            self->world.SetGravity( g );
            lua_pop( L , 2 );
		]];
		
	Body Body( table properties )
		[[
            ClutterActor * actor = NULL;

			lua_getfield( L , properties , "source" );
			
			if ( ! lua_isnil( L , -1 ) )
			{
			    actor = ClutterUtil::user_data_to_actor( L , lua_gettop( L ) );

                if ( ! actor )
                {
                    lua_pop( L , 1 );
                    return luaL_error( L , "Invalid or missing body source" );
                }
			}
			
			lua_pop( L , 1 );
			
			//.................................................................
			// Get position and size of the actor
			
			// TODO: We do not do any transformations here - we just use whatever
			// the actor has. If the actor is inside a container, this will
			// be wrong. We also cheat and modify the actor's anchor point...naughty.
			
			gfloat width = 0;
			gfloat height = 0;

			// Get the size from the actor

			if ( actor )
			{
			    clutter_actor_get_size( actor , & width , & height );

			    clutter_actor_move_anchor_point( actor , width / 2 , height / 2 );
			}
			
			// See if there is another size
			
            lua_getfield( L , properties , "size" );
            if ( lua_type( L , -1 ) == LUA_TTABLE )
            {
                lua_rawgeti( L , -1 , 1 );
                lua_rawgeti( L , -2 , 2 );

                width = lua_tonumber( L , -2 );
                height = lua_tonumber( L , -1 );

                lua_pop( L , 2 );
            }
            lua_pop( L , 1 );

            // Get the position

			gfloat x = 0;
			gfloat y = 0;
			
			if ( actor )
			{
			    clutter_actor_get_position( actor , & x , & y );
			}

			lua_getfield( L , properties , "position" );
			if ( lua_type( L , -1 ) == LUA_TTABLE )
			{
                lua_rawgeti( L , -1 , 1 );
                lua_rawgeti( L , -2 , 2 );

                x = lua_tonumber( L , -2 );
                y = lua_tonumber( L , -1 );

                lua_pop( L , 2 );
			}
			lua_pop( L , 1 );
			
			// Rotation

			gfloat rotation = 0 ;
			gfloat rx = 0;
			gfloat ry = 0;
			
			if ( actor )
			{
			    rotation = clutter_actor_get_rotation( actor , CLUTTER_Z_AXIS , & rx , & ry , NULL );
			}

			lua_getfield( L , properties , "rotation" );
			if ( ! lua_isnil( L , -1 ) )
			{
			    rotation = lua_tonumber( L , -1 );
			}
			lua_pop( L , 1 );
			
			//.................................................................
			// Create the body definition
			
			b2BodyDef body_def;
			
			body_def.userData = actor;
			
			body_def.position.Set( x / self->ppm , y / self->ppm );
			body_def.angle = rotation * ( G_PI / 180.0 ); 
			
			b2FixtureDef fixture_def;
			
			//.................................................................
			// Read fixture properties

			populate_fixture_from_table( L , properties , fixture_def );

			//.................................................................
			// Read the rest of the properties
			
			lua_getfield( L , properties , "dynamic" );
			if ( lua_toboolean( L , -1 ) )
			{
				body_def.type = b2_dynamicBody;
			}
			lua_pop( L , 1 );	
			
			lua_getfield( L , properties , "awake" );
			if ( ! lua_isnil( L , -1 ) )
			{
				body_def.awake = lua_toboolean( L , -1 );
			}
			lua_pop( L , 1 );
				
			lua_getfield( L , properties , "active" );
			if ( ! lua_isnil( L , -1 ) )
			{
				body_def.active = lua_toboolean( L , -1 );
			}
			lua_pop( L , 1 );

			//.................................................................
			// Create the body
			
			b2Body * body = self->world.CreateBody( & body_def );
			
			g_assert( body );
			
            //.................................................................
			// See if the definition included a shape

			fixture_def.shape = NULL;

			lua_getfield( L , properties , "shape" );
			if ( ! lua_isnil( L , -1 ) )
			{
			    fixture_def.shape = ( b2Shape * ) UserData::get_client( L , lua_gettop( L ) );
			}
			lua_pop( L , 1 );

			//.................................................................
			// If not, create a rectangular default shape for the body

            b2PolygonShape polygon;

            if ( ! fixture_def.shape )
			{
                polygon.SetAsBox( ( width * 0.5 ) / self->ppm , ( height * 0.5 ) / self->ppm ) ;

                fixture_def.shape = & polygon;
			}
			
			//.................................................................
			// Create the default fixture
			
			// This is the 'handle' for the fixture - we always start with 1

			fixture_def.userData = GINT_TO_POINTER( 1 );

			body->CreateFixture( & fixture_def ); 

			//.................................................................
			// Attach the body to the actor with a destroy notify that will remove the
			// body from the world and destroy it when the actor is destroyed.
			
			// TODO: There may be a problem destroying a body during the step function,
			// which could happen if an actor is collected. 
	
			if ( actor )
			{
			    g_object_set_data_full( G_OBJECT( actor ) , "tp-physics-body" , body , ( GDestroyNotify ) destroy_actor_body );
			}
			//.................................................................
			// Create an instance of a Body for Lua
						
			lua_pushlightuserdata( L , new Body( self , body , actor ) );
			 			
			new_Body(L);
    		lua_remove(L,-2);
		]];

	DistanceJoint( Body body_a , table anchor_a , Body body_b , table anchor_b , table properties = 0 )
	    [[
	        b2DistanceJointDef d;

            b2Body * ba = Body::get( L , body_a )->body;
            b2Body * bb = Body::get( L , body_b )->body;

            lua_rawgeti( L , anchor_a , 1 );
            lua_rawgeti( L , anchor_a , 2 );

            float32 ax = lua_tonumber( L , -2 ) / self->ppm;
            float32 ay = lua_tonumber( L , -1 ) / self->ppm;

            lua_pop( L , 2 );

            lua_rawgeti( L , anchor_b , 1 );
            lua_rawgeti( L , anchor_b , 2 );

            float32 bx = lua_tonumber( L , -2 ) / self->ppm;
            float32 by = lua_tonumber( L , -1 ) / self->ppm;

            lua_pop( L , 2 );

            d.Initialize( ba , bb , b2Vec2( ax , ay ) , b2Vec2( bx , by ) );

            if ( properties )
            {
                lua_getfield( L , properties , "frequency" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    d.frequencyHz = lua_tonumber( L , -1 );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "damping_ratio" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    d.dampingRatio = lua_tonumber( L , -1 );
                }
                lua_pop( L , 1 );
            }

            self->world.CreateJoint( & d );

	    ]];

	RevoluteJoint( Body body_a , Body body_b , table anchor , table properties = 0 )
        [[
            b2Body * ba = Body::get( L , body_a )->body;
            b2Body * bb = Body::get( L , body_b )->body;

            lua_rawgeti( L , anchor , 1 );
            lua_rawgeti( L , anchor , 2 );

            float32 x = lua_tonumber( L , -2 ) / self->ppm;
            float32 y = lua_tonumber( L , -1 ) / self->ppm;

            lua_pop( L , 2 );

            b2RevoluteJointDef j;

            j.Initialize( ba , bb , b2Vec2( x , y ) );

            if ( properties )
            {
                lua_getfield( L , properties , "enable_limit" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    j.enableLimit = lua_toboolean( L , -1 );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "lower_angle" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    j.lowerAngle = lua_tonumber( L , -1 ) * ( G_PI / 180.0 );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "upper_angle" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    j.upperAngle = lua_tonumber( L , -1 ) * ( G_PI / 180.0 );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "enable_motor" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    j.enableMotor = lua_toboolean( L , -1 );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "motor_speed" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    j.motorSpeed = lua_tonumber( L , -1 ) * ( G_PI / 180.0 );
                }
                lua_pop( L , 1 );

                lua_getfield( L , properties , "max_motor_torque" );
                if ( ! lua_isnil( L , -1 ) )
                {
                    j.maxMotorTorque = lua_tonumber( L , -1 );
                }
                lua_pop( L , 1 );

            }

            self->world.CreateJoint( & j );
        ]];

    #..........................................................................
    # Shape factory methods

	Shape Box( table size , table center = 0 , double rotation = 0 )
        [[
            b2PolygonShape * shape = new b2PolygonShape();

            if ( ! center )
            {
                lua_rawgeti( L , size , 1 );
                lua_rawgeti( L , size , 2 );

                shape->SetAsBox( ( lua_tonumber( L , -2 ) * 0.5 ) / self->ppm ,
                    ( lua_tonumber( L , -1 ) * 0.5 ) / self->ppm );

                lua_pop( L , 2 );
            }
            else
            {
                lua_rawgeti( L , size , 1 );
                lua_rawgeti( L , size , 2 );

                lua_rawgeti( L , center , 1 );
                lua_rawgeti( L , center , 2 );

                shape->SetAsBox( ( lua_tonumber( L , -4 ) * 0.5 ) / self->ppm,
                        ( lua_tonumber( L , -3 ) * 0.5 ) / self->ppm,
                        b2Vec2( lua_tonumber( L , -2 ) / self->ppm ,
                                lua_tonumber( L , -1 ) / self->ppm ),
                        rotation * ( G_PI / 180.0 ) );

                lua_pop( L , 4 );
            }

            lua_pushlightuserdata( L , shape );

            new_Shape( L );

            lua_remove( L , -2 );
        ]];

	Shape Edge( table point_a , table point_b )
        [[
            b2PolygonShape * shape = new b2PolygonShape();

            lua_rawgeti( L , point_a , 1 );
            lua_rawgeti( L , point_a , 2 );
            lua_rawgeti( L , point_b , 1 );
            lua_rawgeti( L , point_b , 2 );

            shape->SetAsEdge( b2Vec2( lua_tonumber( L , -4 ) / self->ppm ,
                    lua_tonumber( L , -3 ) / self->ppm ),
                    b2Vec2( lua_tonumber( L , -2 ) / self->ppm ,
                            lua_tonumber( L , -1 ) / self->ppm ) );

            lua_pop( L , 4 );

            lua_pushlightuserdata( L , shape );

            new_Shape( L );

            lua_remove( L , -2 );
        ]];
/*
	Shape Polygon( table points )
        [[
            // TODO : formed from a table of vertices
        ]];
*/

	Shape Circle( double radius , table center = 0 )
        [[
            b2CircleShape * shape = new b2CircleShape();

            shape->m_radius = radius / self->ppm;

            shape->m_p.SetZero();

            if ( center )
            {
                lua_rawgeti( L , center , 1 );
                lua_rawgeti( L , center , 2 );

                shape->m_p.Set( lua_tonumber( L , -2 ) / self->ppm ,
                        lua_tonumber( L , -1 ) / self->ppm );

                lua_pop( L , 2 );
            }

            lua_pushlightuserdata( L , shape );

            new_Shape( L );

            lua_remove( L , -2 );
        ]];

}


module physics_module;

[[
#include "Box2D/Box2D.h"
#include "clutter/clutter.h"

#include "clutter_util.h"

class Physx
{
public:

	Physx()
	:
		world( b2Vec2( 0.0f , 10.0f ) , true ), 
		ppm( 64.0f ) // 64 pixels per meter - at 1920 that is 30 meters
	{
    	
	}
	
	~Physx()
	{
		for( b2Body * body = world.GetBodyList(); body; body = body->GetNext() )
		{
			if ( void * ud = body->GetUserData() )
			{
				g_object_set_data( G_OBJECT( ud ) , "tp-physics-body" , NULL );
			}
		}
	}
	
	b2World  	world;
	float32		ppm;
};

#if 0

bool get_actor_screen_point( ClutterActor * actor , const ClutterVertex * actor_point , ClutterVertex * screen_point )
{
	ClutterActor * stage = clutter_stage_get_default();
	
	ClutterActor * screen = NULL;
	
	for( ClutterActor * parent = clutter_actor_get_parent( actor ); parent; parent = clutter_actor_get_parent( parent ) )
	{
		if ( clutter_actor_get_parent( parent ) == stage )
		{
			screen = parent;
			break;
		}
	} 
	
	if ( ! screen )
	{
		return false;
	}
	
	clutter_actor_apply_relative_transform_to_point( actor , screen , actor_point , screen_point );
	
	return true;
} 

#endif

void destroy_actor_body( b2Body * body )
{
	body->GetWorld()->DestroyBody( body );
}

]]

[[

class Body
{
public:

	Body( Physx * _p , b2Body * _b , ClutterActor * _a )
	:
		physx( _p ),
		body( _b ),
		actor( _a )
	{
		g_assert( physx );
		g_assert( body );
		g_assert( actor );
		
		g_object_ref( G_OBJECT( actor ) );
	}
	
	~Body()
	{
		g_object_unref( G_OBJECT( actor ) );
	}
	
	Physx  * 		physx;
	b2Body * 		body;
	ClutterActor * 	actor;
};

]]

interface Body [[ Body * ]]
{
	Body()
		[[
			self = lb_construct( Body , lua_touserdata( L , -2 ) );
		]];
		
	~Body()
		[[
			delete self;
		]];
		
	readonly UIElement source
		[[
			ClutterUtil::wrap_concrete_actor( L , self->actor );
		]];
		
	bool awake
		[[
			awake = self->body->IsAwake();
		]]
		[[
			self->body->SetAwake( awake );
		]];
		
	bool active
		[[
			active = self->body->IsActive();
		]]
		[[
			self->body->SetActive( active );
		]];

	readonly table position
		[[
			const b2Vec2 pos( self->body->GetPosition() );
			
			lua_newtable( L );
			lua_pushnumber( L , pos.x * self->physx->ppm );
			lua_rawseti( L , -2 , 1 );
			lua_pushnumber( L , pos.y * self->physx->ppm );
			lua_rawseti( L , -2 , 2 );
		]];
		
	readonly double angle
		[[
			angle = self->body->GetAngle() / ( G_PI / 180.0 );
		]];
		
	table linear_velocity
		[[
			b2Vec2 lv( self->body->GetLinearVelocity() );
			
			lua_newtable( L );
			lua_pushnumber( L , lv.x );
			lua_rawseti( L , -2 , 1 );
			lua_pushnumber( L , lv.y );
			lua_rawseti( L , -2 , 2 );	
		]]
		[[
			lua_rawgeti( L , 2 , 1 );
			lua_rawgeti( L , 2 , 2 );
			
			self->body->SetLinearVelocity( b2Vec2( lua_tonumber( L , -2 ) , lua_tonumber( L , -1 ) ) );
			lua_pop( L , 2 );
		]];
		
	double angular_velocity
		[[
			angular_velocity = self->body->GetAngularVelocity() / ( G_PI / 180.0 );
		]]
		[[
			self->body->SetAngularVelocity( angular_velocity * ( G_PI / 180.0 ) );
		]];
		
	apply_force( double force_x , double force_y , double x , double y )
		[[
			self->body->ApplyForce( b2Vec2( force_x , force_y ) , 
				b2Vec2( x / self->physx->ppm , y / self->physx->ppm ) );   
		]];
		
	apply_torque( double torque )
		[[
			self->body->ApplyTorque( torque );
		]];
		
	apply_linear_impulse( double impulse_x , double impulse_y , double x , double y )
		[[
			self->body->ApplyLinearImpulse( b2Vec2( impulse_x , impulse_y ) , 
				b2Vec2( x / self->physx->ppm , y / self->physx->ppm ) );   
		]];
	
}


global physics [[ Physx * ]]
{
	physics()
		[[
			self = lb_construct( Physx , new Physx() );
		]];
		
	~physics()
		[[
			delete self;
		]];
		
	int step( double time_step = 1.0f/60.0f , int velocity_iterations = 6, int position_iterations = 2 )
		[[
			int n = 0;
			
			self->world.Step( time_step , velocity_iterations , position_iterations );
			
			for( b2Body * body = self->world.GetBodyList(); body; body = body->GetNext() )
			{
				if ( ! body->IsAwake() || ! body->IsActive() )
				{
					continue;
				}
				
				++n;
				
				ClutterActor * actor = CLUTTER_ACTOR( body->GetUserData() );
				
				if ( actor )
				{
					const b2Vec2 & pos( body->GetPosition() );
					
					clutter_actor_set_position( actor , pos.x * self->ppm , pos.y * self->ppm );
					
					clutter_actor_set_rotation( actor , CLUTTER_Z_AXIS , body->GetAngle () / ( G_PI / 180.0 ) , 0 , 0 , 0 );
				}
			}
			
			result = n;
		]]; 
		
	table gravity
		[[
			b2Vec2 g( self->world.GetGravity() );
			lua_newtable( L );
			lua_pushnumber( L , g.x );
			lua_rawseti( L , -2 , 1 );
			lua_pushnumber( L , g.y );
			lua_rawseti( L , -2 , 2 );
		]]
		[[
            luaL_checktype(L,2,LUA_TTABLE);
            lua_rawgeti( L , 2 , 1 );
            lua_rawgeti( L , 2 , 2 );
            b2Vec2 g( lua_tonumber( L , -2 ) , lua_tonumber( L , -1 ) );
            self->world.SetGravity( g );
            lua_pop( L , 2 );
		]];
		
	Body Body( table properties )
		[[
			lua_getfield( L , properties , "source" );
			
			ClutterActor * actor = ClutterUtil::user_data_to_actor( L , lua_gettop( L ) ); 

			if ( ! actor )
			{
				lua_pop( L , 1 );
				return luaL_error( L , "Invalid or missing body source" );
			}
			
			lua_pop( L , 1 );
			
			//.................................................................
			// Get position and size of the actor
			
			// TODO: We do not do any transformations here - we just use whatever
			// the actor has. If the actor is inside a container, this will
			// be wrong. We also cheat and modify the actor's anchor point...naughty.
			
			gfloat width;
			gfloat height;
			
			clutter_actor_get_size( actor , & width , & height );
			
			clutter_actor_move_anchor_point( actor , width / 2 , height / 2 );

			gfloat x;
			gfloat y;
			
			clutter_actor_get_position( actor , & x , & y );
			
			gfloat rotation;
			gfloat rx;
			gfloat ry;
			
			rotation = clutter_actor_get_rotation( actor , CLUTTER_Z_AXIS , & rx , & ry , NULL );		
			
			//.................................................................
			// Create the body definition
			
			b2BodyDef body_def;
			
			body_def.userData = actor;
			
			body_def.position.Set( x / self->ppm , y / self->ppm );
			body_def.angle = rotation * ( G_PI / 180.0 ); 
			
			b2FixtureDef fixture_def;
			
			//.................................................................
			// Read the rest of the properties
			
			lua_getfield( L , properties , "dynamic" );
			if ( lua_toboolean( L , -1 ) )
			{
				body_def.type = b2_dynamicBody;
			}
			lua_pop( L , 1 );	
			
			lua_getfield( L , properties , "friction" );
			if ( ! lua_isnil( L , -1 ) )
			{
				fixture_def.friction = lua_tonumber( L , -1 );
			}
			lua_pop( L , 1 );
			
			lua_getfield( L , properties , "restitution" );
			if ( ! lua_isnil( L , -1 ) )
			{
				fixture_def.restitution = lua_tonumber( L , -1 );
			}
			lua_pop( L , 1 );
			
			lua_getfield( L , properties , "bounce" );
			if ( ! lua_isnil( L , -1 ) )
			{
				fixture_def.restitution = lua_tonumber( L , -1 );
			}
			lua_pop( L , 1 );

			lua_getfield( L , properties , "density" );
			if ( ! lua_isnil( L , -1 ) )
			{
				fixture_def.density = lua_tonumber( L , -1 );
			}
			lua_pop( L , 1 );
			
			lua_getfield( L , properties , "awake" );
			if ( ! lua_isnil( L , -1 ) )
			{
				body_def.awake = lua_toboolean( L , -1 );
			}
			lua_pop( L , 1 );
				
			lua_getfield( L , properties , "active" );
			if ( ! lua_isnil( L , -1 ) )
			{
				body_def.active = lua_toboolean( L , -1 );
			}
			lua_pop( L , 1 );

			//.................................................................
			// Create the body
			
			b2Body * body = self->world.CreateBody( & body_def );
			
			g_assert( body );
			
			//.................................................................
			// Create a rectangular default shape for the body
			
			b2PolygonShape shape;
#if 0			
			shape.SetAsBox( ( width * 0.5 ) / self->ppm , ( height * 0.5 ) / self->ppm , 
				b2Vec2( rx / self->ppm , ry / self->ppm ) , 
				rotation * ( G_PI / 180.0 ) );
#else
			shape.SetAsBox( ( width * 0.5 ) / self->ppm , ( height * 0.5 ) / self->ppm ) ;
#endif			

			//.................................................................
			// Create the default fixture
			
			fixture_def.shape = & shape;
			
			body->CreateFixture( & fixture_def ); 

			//.................................................................
			// Attach the body to the actor with a destroy notify that will remove the
			// body from the world and destroy it when the actor is destroyed.
			
			// TODO: There may be a problem destroying a body during the step function,
			// which could happen if an actor is collected. 
	
			g_object_set_data_full( G_OBJECT( actor ) , "tp-physics-body" , body , ( GDestroyNotify ) destroy_actor_body );

			//.................................................................
			// Create an instance of a Body for Lua
						
			lua_pushlightuserdata( L , new Body( self , body , actor ) );
			 			
			new_Body(L);
    		lua_remove(L,-2);
		]];
		
}
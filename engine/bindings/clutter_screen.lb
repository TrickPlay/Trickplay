module clutter_screen;

[[
#include "clutter/clutter.h"
#include "context.h"
#include "clutter_util.h"
#include "toast.h"
#include "bitmap.h"

]]

/*
    Global: screen 
    
    The screen is a <UIElement> and also a <Container>. TrickPlay creates it 
    for you automatically before your app is loaded. 
    
    Initially, the screen has the fixed dimension of 1920x1080 (1080p). It also
    has x and y scale factors such that it will be automatically scaled to fit the
    real display dimensions. There is a property called <display_size> which gives
    you the actual dimensions of the display.
    
    Although screen has all the properties and methods of a <UIElement>, some are
    overriden. For example, the screen's <parent> property will always return nil.
*/

global screen [[ClutterActor*]] actor , container
{
    screen()
	[[
		// Screen is a global and we don't want its reference toggling all the
		// time, so we take an extra one and hold on to it.
		
		self=clutter_get_actor_by_gid(App::get(L)->get_screen_gid() );		
	    self=lb_construct_gobject( ClutterActor , g_object_ref( self ) );
	    
	    ClutterUtil::initialize_actor(L,self,SCREEN_METATABLE);
	]];
    
    ~screen()
	[[
	    Toast::hide(App::get(L)->get_context());
		g_object_unref( self );
	]];

    #..........................................................................
    # We have to override these from regular actors, so that app developers
    # cannot reach outside their screen
    
    /*
    	Function: show
    	
    	Shows the screen. Unlike <show_all>, calling this function does not 
    	show any elements that were explicitly hidden.
    */
    
    show()
        [[
	    	clutter_actor_show(self);
	    	// Show the stage as well
	    	clutter_actor_show(clutter_stage_get_default());
		]];
        
    /*
    	Function: show_all
    	
    	Shows the screen and all of its child elements, including hidden ones.
   	*/
   	
    show_all()
        [[
	    	clutter_actor_show_all(self);
	    	// Show the stage as well
	    	clutter_actor_show(clutter_stage_get_default());
		]];
	
	/*
		Property: parent
		
		This property always returns nil, because the screen's parent is private to
		TrickPlay.
	*/
	
    readonly UIElement parent
		[[
		    lua_pushnil(L);
		]];

	/*
		Property: display_size
		
		Returns a table containing the width and height of the underlying display.
	*/	
	
    readonly table display_size
        [[

            gfloat w;
            gfloat h;

            clutter_actor_get_size( clutter_stage_get_default(), &w, &h );

            lua_newtable( L );
            lua_pushnumber( L, w );
            lua_rawseti( L, -2, 1 );
            lua_pushnumber( L, h );
            lua_rawseti( L, -2, 2 );
        ]];

	/*
		Function: unparent
		
		Calling unparent on the screen has no effect, because the screen's parent
		is private to TrickPlay.
	*/
	
    unparent()
		[[
		    // Cannot let the app developer remove his screen from the stage,
		    // because he would not have a way to put it back
		]];
	
    #..........................................................................	
    # These are stage properties
    

    # TODO
    # This can potentionally let an app get an actor outside its group, so I'll
    # have to rework it.
    
    /*
    udata key_focus
	[[
	    wrap_concrete_actor(L,clutter_stage_get_key_focus(CLUTTER_STAGE(clutter_stage_get_default())));
	]]
	[[
	    ClutterActor *k=user_data_to_actor(L,2);
	    if (k)
	    {
		clutter_stage_set_key_focus(CLUTTER_STAGE(clutter_stage_get_default()),k);
	    }
	]];
    
    
    # This doesn't seem to work
    
    udata get_object_at( double x , double y )
	[[
	    wrap_concrete_actor(L,clutter_stage_get_actor_at_pos(CLUTTER_STAGE(clutter_stage_get_default()),CLUTTER_PICK_ALL,x,y));
	]];
    */		    
    
	
/*
    // App developers cannot control the color of the stage - and their new 'screen'
    // doesn't have a color, since it is a group.
    
    table color
        [[
            ClutterColor color;
            clutter_stage_get_color(CLUTTER_STAGE(self),&color);
            push_clutter_color(L,&color);
        ]]
        [[
            ClutterColor color;
            to_clutter_color(L,2,&color);
            clutter_stage_set_color(CLUTTER_STAGE(self),&color);            
        ]];
*/	
    table perspective
	[[
	    ClutterPerspective p;
	    clutter_stage_get_perspective(CLUTTER_STAGE(clutter_stage_get_default()),&p);
	    lua_newtable(L);
	    lua_pushnumber(L,p.fovy);
	    lua_rawseti(L,-2,1);
	    lua_pushnumber(L,p.aspect);
	    lua_rawseti(L,-2,2);
	    lua_pushnumber(L,p.z_near);
	    lua_rawseti(L,-2,3);
	    lua_pushnumber(L,p.z_far);
	    lua_rawseti(L,-2,4);
	]]
	[[
	    luaL_checktype(L,2,LUA_TTABLE);
        lua_rawgeti(L,2,1);
        lua_rawgeti(L,2,2);
        lua_rawgeti(L,2,3);
        lua_rawgeti(L,2,4);
	    ClutterPerspective p = {lua_tonumber(L,-4),lua_tonumber(L,-3),
		lua_tonumber(L,-2),lua_tonumber(L,-1)};
        clutter_stage_set_perspective(CLUTTER_STAGE(clutter_stage_get_default()),&p);
        lua_pop(L,4);
	]];	


    bool toast( string title , string prompt , Bitmap bitmap = 0 )
        [[
            Image * image = bitmap ? Bitmap::get_image( L , bitmap ) : 0;

            result = Toast::show( L , title , prompt , image );
        ]];

    callback on_toast;
}


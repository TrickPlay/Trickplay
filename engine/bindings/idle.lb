[[
#include "clutter/clutter.h"
#include "app.h"
]]

[[
struct idle
{
    idle(lua_State * L)
    :
        source(0),
        lsp(App::get(L)->ref_lua_state_proxy()),
        timer(g_timer_new())
    {

    }

    ~idle()
    {
        clear();
        lsp->unref();
        g_timer_destroy(timer);
    }

    void set()
    {
        clear();
        source=clutter_threads_add_idle(on_idle,this);
        g_timer_start(timer);
        //source=clutter_threads_add_frame_source(60,on_idle,this);
    }

    void clear()
    {
        if (source)
        {
            g_source_remove(source);
            source=0;
        }
        g_timer_stop(timer);
    }

    static gboolean on_idle(gpointer data);

    guint           source;
    LuaStateProxy * lsp;
    GTimer *        timer;
};
]]

/*
    Global: idle
    
    Idle lets you set a function that will be called as often as possible, leaving
    time for rendering. It can be used to implement a game loop or animations.
    
    Note that idle may be rate limited (to 60 invocations per second, for example), 
    and can slow down when TrickPlay receives events. 
*/

global idle [[idle*]]
{
    idle()
	[[
	    self=lb_construct( idle , new idle(L) );    
	]];
	
    ~idle()
	[[
	    delete self;
	]];
	
	/*
		Event: on_idle
		
		When this is set to a function, it will be called as often as possible, until
		you set it back to nil.
		
		This example, will set a function that sums up the elapsed seconds and stops
		after it reaches six.
		
		(code)
		local total = 0
		function idle.on_idle( idle , seconds )
		  total = total + seconds 
		  if total >= 6 then
		  	idle.on_idle = nil
		  end 
		end
		(end)
		
		Arguments:
		
			idle - The idle.
			
			elapsed_seconds - The fractional seconds elapsed since the function was called
							  the last time.
	*/
	
    callback on_idle( idle idle , double elapsed_seconds )
	[[
	    if (on_idle)
	    {
			self->set();
	    }
	    else
	    {
			self->clear();
	    }
	]];
}

[[
gboolean idle::on_idle(gpointer data)
{
    idle * self=(idle*)data;

    if (self->lsp->is_valid())
    {
		double elapsed = g_timer_elapsed(self->timer,NULL);
		     	
		// If it is less than one ms, we bail
		
		if ( elapsed < 0.001 )
		{
			return TRUE;
		}
    
        lua_pushnumber(self->lsp->get_lua_state(),elapsed);
        g_timer_start(self->timer);
        lb_invoke_callback(self->lsp->get_lua_state(),self,IDLE_METATABLE,"on_idle",1,0);
    }
    
    return TRUE;
}   
]]


[[
#include "clutter/clutter.h"
#include "app.h"
]]

[[
struct idle
{
    idle(lua_State * L)
    :
        source(0),
        lsp(App::get(L)->ref_lua_state_proxy()),
        timer(g_timer_new()),
        limit(0.001)
    {

    }

    ~idle()
    {
        clear();
        lsp->unref();
        g_timer_destroy(timer);
    }

    void set()
    {
        clear();
        source=g_idle_add_full( TRICKPLAY_PRIORITY , on_idle , this , 0 );
        g_timer_start(timer);
    }

    void clear()
    {
        if (source)
        {
            g_source_remove(source);
            source=0;
        }
        g_timer_stop(timer);
    }

    static gboolean on_idle(gpointer data);

    guint           source;
    LuaStateProxy * lsp;
    GTimer *        timer;
    double          limit;
};
]]

/*
    Global: idle
    
    Idle lets you set a function that will be called as often as possible, leaving
    time for rendering. It can be used to implement a game loop or animations.
    
    Note that idle may be rate limited (to 60 invocations per second, for example), 
    and can slow down when TrickPlay receives events. 
*/

global idle [[idle*]]
{
    idle()
	[[
	    self=lb_construct( idle , new idle(L) );    
	]];
	
    ~idle()
	[[
	    delete self;
	]];

    /*
        Property: limit

        Throttles the number of <on_idle> calls to the given number of seconds between calls.
        The smallest valid value is one millisecond (0.001).
    */

    double limit
    [[
        limit = self->limit;
    ]]
    [[
        self->limit = std::max( limit , 0.001 );
    ]];
	
	/*
		Event: on_idle
		
		When this is set to a function, it will be called as often as possible, until
		you set it back to nil.
		
		This example, will set a function that sums up the elapsed seconds and stops
		after it reaches six.
		
		(code)
		local total = 0
		function idle.on_idle( idle , seconds )
		  total = total + seconds 
		  if total >= 6 then
		  	idle.on_idle = nil
		  end 
		end
		(end)
		
		Arguments:
		
			idle - The idle.
			
			elapsed_seconds - The fractional seconds elapsed since the function was called
							  the last time.
	*/
	
    callback on_idle( idle idle , double elapsed_seconds )
	[[
	    if (on_idle)
	    {
			self->set();
	    }
	    else
	    {
			self->clear();
	    }
	]];
}

[[
gboolean idle::on_idle(gpointer data)
{
    idle * self = ( idle * ) data;

    if ( lua_State * L = self->lsp->get_lua_state() )
    {
		double elapsed = g_timer_elapsed( self->timer , NULL );
		     	
		// If it is less than one ms, we bail
		
		if ( elapsed < self->limit )
		{
			return TRUE;
		}

		g_timer_start( self->timer );
    
        lua_pushnumber( L , elapsed );
        lb_invoke_callback( L , self , IDLE_METATABLE , "on_idle" , 1 , 0 );
    }
    
    return TRUE;
}   
]]


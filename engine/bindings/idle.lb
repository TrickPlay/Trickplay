[[
#include "clutter/clutter.h"
#include "app.h"
]]

[[
struct idle
{
    idle(lua_State * L)
    :
        source(0),
        lsp(App::get(L)->ref_lua_state_proxy()),
        timer(g_timer_new())
    {

    }

    ~idle()
    {
        clear();
        lsp->unref();
        g_timer_destroy(timer);
    }

    void set()
    {
        clear();
        source=clutter_threads_add_idle(on_idle,this);
        //source=clutter_threads_add_frame_source(60,on_idle,this);
    }

    void clear()
    {
        if (source)
        {
            g_source_remove(source);
            source=0;
        }
    }

    static gboolean on_idle(gpointer data);

    guint           source;
    LuaStateProxy * lsp;
    GTimer *        timer;
};
]]

/*
    Global: idle 
*/

global idle [[idle*]]
{
    idle()
	[[
	    self=lb_construct( idle , new idle(L) );    
	]];
	
    ~idle()
	[[
	    delete self;
	]];
	
    callback on_idle
	[[
	    if (on_idle)
	    {
			self->set();
	    }
	    else
	    {
			self->clear();
	    }
	]];
}

[[
gboolean idle::on_idle(gpointer data)
{
    idle * self=(idle*)data;

    if (self->lsp->is_valid())
    {
		double elapsed = g_timer_elapsed(self->timer,NULL);
		     	
		// If it is less than one ms, we bail
		
		if ( elapsed < 0.001 )
		{
			return TRUE;
		}
    
        lua_pushnumber(self->lsp->get_lua_state(),elapsed);
        g_timer_start(self->timer);
        lb_invoke_callback(self->lsp->get_lua_state(),self,IDLE_METATABLE,"on_idle",1,0);
    }
    
    return TRUE;
}   
]]


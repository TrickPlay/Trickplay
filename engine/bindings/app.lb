[[
#include "app.h"
#include "context.h"
#include "sysdb.h"

void app_loaded_handler(TPContext *,const char *,void * l);
void app_closing_handler(TPContext *,const char *,void * l);
]]

# Global: app
# This global object represents the current application. It has properties for
# accessing application metadata and events.

global app [[App*]]
{
    app()
        [[
            self=lb_construct( App , App::get(L) );
	
            self->add_notification_handler(TP_NOTIFICATION_APP_LOADED,app_loaded_handler,L);
            self->add_notification_handler(TP_NOTIFICATION_APP_CLOSING,app_closing_handler,L);
        ]];
    
    # Property: id
    # Returns the id of the current application
    
    readonly string id
        [[id=self->get_metadata().id.c_str();]];
        
    # Property: name
    # Returns the name of the current application
    
    readonly string name
        [[name=self->get_metadata().name.c_str();]];
        
    # Property: author
    # Returns the author, if any, of the current application
    
    readonly string author
        [[author=self->get_metadata().author.c_str();]];
    
    # Property: description
    # Returns the description, if any, of the current application
    
    readonly string description
        [[description=self->get_metadata().description.c_str();]];
    
    # Property: copyright
    # Returns the copyright information, if any, of the current application
    
    readonly string copyright
        [[copyright=self->get_metadata().copyright.c_str();]];
    
    # Property: release
    # Returns the release number of the current application. This number is for
    # internal use only and should not be displayed to users.
    
    readonly int release
        [[release=self->get_metadata().release;]];
    
    # Property: version
    # Returns the version string of the current application
    
    readonly string version
        [[version=self->get_metadata().version.c_str();]];

    # Property: attributes
    # Returns a table containing any attributes defined in the app file. The
    # attributes are the keys of the table, and the values are always true.

    readonly table attributes
        [[
            lua_newtable( L );
            const App::Metadata & md( self->get_metadata() );

            for ( StringSet::const_iterator it = md.attributes.begin(); it != md.attributes.end(); ++it )
            {
                lua_pushstring( L , it->c_str() );
                lua_pushboolean( L , true );
                lua_rawset( L , -3 );
            }
        ]];

    # Property: contents
    # Returns a table containing the names of all files contained
    # in the app's bundle.

    readonly table contents
        [[
            // TODO: THIS WON'T WORK FOR APPS LAUNCHED FROM A REMOTE URI.
            
            String root = self->get_metadata().sandbox.get_root_native_path();
            
            if ( root.empty() )
            {
                g_warning( "CANNOT GET APP CONTENTS" );
                lua_pushnil( L );
            }
            else
            {
                lua_newtable( L );
                int t = lua_gettop( L );
                int index = 1;

                StringList stack;
    
                stack.push_back( String() );
    
                while ( ! stack.empty() )
                {
                    String base( stack.front() );
    
                    stack.pop_front();
    
                    gchar * path = g_build_filename( root.c_str() , base.empty() ? NULL : base.c_str() , NULL );
    
                    GDir * d = g_dir_open( path , 0 , NULL );
    
                    if ( d )
                    {
                        for ( const gchar * name = g_dir_read_name( d ); name ; name = g_dir_read_name( d ) )
                        {
                            gchar * sub = g_build_filename( path , name , NULL );
    
                            if ( g_file_test( sub , G_FILE_TEST_IS_DIR ) )
                            {
                                if ( base.empty() )
                                {
                                    stack.push_back( name );
                                }
                                else
                                {
                                    gchar * sub_base = g_build_filename( base.c_str() , name , NULL );
                                    stack.push_back( sub_base );
                                    g_free( sub_base );
                                }
                            }
                            else if ( g_file_test( sub , G_FILE_TEST_IS_REGULAR ) )
                            {
                                if ( base.empty() )
                                {
                                    lua_pushstring( L , name );
                                    lua_rawseti( L , t , index );
                                }
                                else
                                {
                                    gchar * sub_base = g_build_filename( base.c_str() , name , NULL );
                                    lua_pushstring( L , sub_base );
                                    lua_rawseti( L , t , index );
                                    g_free( sub_base );
                                }
    
                                ++index;
                            }
                            g_free( sub );
                        }
                        g_dir_close( d );
                    }
                    g_free( path );
                }
            }
        ]]
        
    # Property: launch
    # Returns information about how this app was launched. The
    # result is a table that has the fields below. All of them may
    # be nil.
    #
    # caller - 	The id of the app that launched this one.
    #
    # action - 	The name of the action that was invoked. 
    #
    # uri -     If the app was invoked by an action, the URI attached 
    #			to the action.
    #
    # type -	The mime type for the URI. 
    #
    # parameters - Any parameters that the caller passed.
    
    readonly table launch
    	[[
    		const App::LaunchInfo & info( App::get( L )->get_launch_info() );
    		
    		lua_newtable( L );
    		
    		if ( ! info.caller.empty() )
    		{
    			lua_pushstring( L, info.caller.c_str() );
    			lua_setfield( L, -2, "caller" );
    		}
    		
    		if ( ! info.action.empty() )
    		{
    			lua_pushstring( L, info.action.c_str() );
    			lua_setfield( L, -2, "action" );
    		}
    		
    		if ( ! info.uri.empty() )
    		{
    			lua_pushstring( L, info.uri.c_str() );
    			lua_setfield( L, -2, "uri" );
    		}
    		
    		if ( ! info.type.empty() )
    		{
    			lua_pushstring( L, info.type.c_str() );
    			lua_setfield( L, -2, "type" );
    		}
    		
    		if ( ! info.parameters.empty() )
    		{
				String statement( "return " + info.parameters );
	
				if ( luaL_dostring( L, statement.c_str() ) != 0 )
				{
					// Pop the error

					lua_pop( L, 1 );
				}
				else
				{
				    // The result of dostring should be at the top of the stack
				    	    
    				lua_setfield( L, -2, "parameters" );
			    }
    		}
    	]];
    	
	# Function: set_badge
	# Sets a badge that will be visible in the app launcher. Badges 
	# can surface important information to the user.
	#
	# Arguments:
	# style - A named badge style.
	# text - The text to include in the badge. This should be short.
	
	set_badge( string style, string text )
		[[
			self->get_context()->get_db()->set_app_badge( self->get_id(), style, text );
		]];    	
		
	# Function: clear_badge
	# Clears the app's badge, if any.
	
	clear_badge()
		[[
			self->get_context()->get_db()->set_app_badge( self->get_id(), "", "" );
		]];
        
    # Event: on_loaded
    # This callback is invoked after the app has finished loading.
    
    callback on_loaded;
    
    # Event: on_closing
    # This callback is invoked just before the app is about to close.
    
    callback on_closing;

    callback on_audio_match;
}

[[
void app_loaded_handler(TPContext *,const char *,void * l)
{
    lua_State * L=(lua_State*)l;
    invoke_app_on_loaded(L,App::get(L),0,0);
}

void app_closing_handler(TPContext *,const char *,void * l)
{
    lua_State * L=(lua_State*)l;
    invoke_app_on_closing(L,App::get(L),0,0);
}
]]

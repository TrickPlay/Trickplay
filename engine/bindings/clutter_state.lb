module clutter_state;

[[
#include "clutter/clutter.h"
#include "util.h"
#include "clutter_util.h"

void AnimationState_on_completed(ClutterState *state, lua_State*L);

int set_state_value(lua_State * L, int index, ClutterState* state, const String & source, 
				    const String & target ,ClutterActor *object, const String & name, const String & mode)
{
	GValue gvalue={0};
	double value;
	const char *k = name.c_str();
	gulong nmode=ClutterUtil::to_clutter_animation_mode(mode.c_str());
	double pre_delay;
    double post_delay;
    const char *source_name;
    
    if(source.compare("*") != 0)
    {
        source_name = source.c_str();
    } else {
        source_name = NULL;
    }

	if (lua_type(L, index+1) == LUA_TNUMBER) 
	{
		pre_delay = lua_tonumber(L, index + 1);
	} 
	else 
	{
		return luaL_error(L, "incorrect argument, failed to set the fifth argument of keys : number expected");
	}

	if (lua_type(L, index+2) == LUA_TNUMBER) 
	{
		post_delay = lua_tonumber(L, index + 2);
	}
	else 
	{
		return luaL_error(L, "incorrect argument, failed to set the sixth argument of keys : number expected");
	}

	if (!strcmp("x",k)||!strcmp("y",k)||!strcmp("w",k)||!strcmp("width",k)||!strcmp("h",k)||!strcmp("height",k)||
		!strcmp("z",k)||!strcmp("depth",k)||!strcmp("opacity",k))
	{
		if (lua_type(L, index) == LUA_TNUMBER) 
		{
			value = lua_tonumber(L, index);

			g_value_init(&gvalue,G_TYPE_FLOAT);
			g_value_set_float(&gvalue,value);

			clutter_state_set_key(state, source_name, target.c_str(), G_OBJECT(object), name.c_str(), nmode, &gvalue, pre_delay, post_delay);
            g_value_unset(&gvalue);
		} 
		else 
		{
		    return luaL_error(L, "incorrect argument, failed to set the fourth argument of keys : number expected");
		}
	}
	else if (!strcmp("position",k))
	{
		if (lua_type(L,index)==LUA_TTABLE)
		{

			lua_rawgeti(L,index,1);
			value = lua_tonumber(L, -1);
			g_value_init(&gvalue,G_TYPE_FLOAT);
			g_value_set_float(&gvalue, value);
			lua_pop(L,1);
			clutter_state_set_key(state, source_name, target.c_str(), G_OBJECT(object), "x", nmode, &gvalue, pre_delay, post_delay);
			    
			lua_rawgeti(L,index,2);
			value = lua_tonumber(L, -1);
			g_value_unset(&gvalue);
			g_value_init(&gvalue,G_TYPE_FLOAT);
			g_value_set_float(&gvalue,value);
			lua_pop(L,1);
			clutter_state_set_key(state, source_name, target.c_str(), G_OBJECT(object), "y", nmode, &gvalue, pre_delay, post_delay);
            g_value_unset(&gvalue);
		}
		else 
		{
		    return luaL_error(L, "incorrect argument, failed to set the fourth argument of keys : table expected");
		}
	} 
	else if (!strcmp("size",k))
	{
		if (lua_type(L,index)==LUA_TTABLE)
		{

			lua_rawgeti(L,index,1);
			value = lua_tonumber(L, -1);
			g_value_init(&gvalue,G_TYPE_FLOAT);
			g_value_set_float(&gvalue, value);
			lua_pop(L,1);
			clutter_state_set_key(state, source_name, target.c_str(), G_OBJECT(object), "width", nmode, &gvalue, pre_delay, post_delay);
			    
			lua_rawgeti(L,index,2);
			value = lua_tonumber(L, -1);
			g_value_unset(&gvalue);
			g_value_init(&gvalue,G_TYPE_FLOAT);
			g_value_set_float(&gvalue,value);
			lua_pop(L,1);
			clutter_state_set_key(state, source.c_str(), target.c_str(), G_OBJECT(object), "height", nmode, &gvalue, pre_delay, post_delay);
            g_value_unset(&gvalue);
		}			
		else 
		{
		    return luaL_error(L, "incorrect argument, failed to set the fourth argument of keys : table expected");
		}
	}
	else if (!strcmp("scale",k))
	{
		if (lua_type(L,index)==LUA_TTABLE)
		{

			lua_rawgeti(L,index,1);
			value = lua_tonumber(L, -1);
			g_value_init(&gvalue,G_TYPE_DOUBLE);
			g_value_set_double(&gvalue, value);
			lua_pop(L,1);
			clutter_state_set_key(state, source_name, target.c_str(), G_OBJECT(object), "scale-x", nmode, &gvalue, pre_delay, post_delay);
			    
			lua_rawgeti(L,index,2);
			value = lua_tonumber(L, -1);
			g_value_unset(&gvalue);
			g_value_init(&gvalue,G_TYPE_DOUBLE);
			g_value_set_double(&gvalue,value);
			lua_pop(L,1);
			clutter_state_set_key(state, source_name, target.c_str(), G_OBJECT(object), "scale-y", nmode, &gvalue, pre_delay, post_delay);
            g_value_unset(&gvalue);
		}			
		else 
		{
		    return luaL_error(L, "incorrect argument, failed to set the third argument of keys : table expected");
		}
	}
	else if (!strcmp("x_rotation",k))
	{
		if (lua_type(L,index)==LUA_TTABLE)
		{
			    
		}
		else
		{
			value = lua_tonumber(L, -1);
			g_value_init(&gvalue,G_TYPE_DOUBLE);
			g_value_set_double(&gvalue,value);
			clutter_state_set_key(state, source_name, target.c_str(), G_OBJECT(object), "rotation-angle-x", nmode, &gvalue, pre_delay, post_delay);
            g_value_unset(&gvalue);
		}
	}
	else if (!strcmp("y_rotation",k))
	{
		if (lua_type(L,index)==LUA_TTABLE)
		{
		
		}
		else
		{
			value = lua_tonumber(L, -1);
			g_value_init(&gvalue,G_TYPE_DOUBLE);
			g_value_set_double(&gvalue,value);
			clutter_state_set_key(state, source_name, target.c_str(), G_OBJECT(object), "rotation-angle-y", nmode, &gvalue, pre_delay, post_delay);
            g_value_unset(&gvalue);
		}
	}
	else if (!strcmp("z_rotation",k))
	{
		if (lua_type(L,index)==LUA_TTABLE)
		{
			    
		}
		else
		{
			value = lua_tonumber(L, -1);
			g_value_init(&gvalue,G_TYPE_DOUBLE);
			g_value_set_double(&gvalue,value);
			clutter_state_set_key(state, source_name, target.c_str(), G_OBJECT(object), "rotation-angle-z", nmode, &gvalue, pre_delay, post_delay);
            g_value_unset(&gvalue);
		}
	}
	else if (!strcmp("color",k))
	{
		if ((lua_type(L,index)==LUA_TTABLE) || (lua_type(L, index) == LUA_TSTRING))
		{
			ClutterColor color;
			ClutterUtil::to_clutter_color(L, index, &color);

			//ClutterColor color = ClutterUtil::string_to_color(lua_tostring(L, index));

			g_value_init(&gvalue,CLUTTER_TYPE_COLOR);
			clutter_value_set_color(&gvalue, &color);
			clutter_state_set_key(state, source_name, target.c_str(), G_OBJECT(object), "color", nmode, &gvalue, pre_delay, post_delay);
            g_value_unset(&gvalue);			    
		}
		else 
		{
		    return luaL_error(L, "incorrect argument, failed to set the fourth argument of keys : table expected");
		}
	}
	return 0;
}

int populate_state( lua_State * L, int index, ClutterState* state )
{

    if (lua_type(L, index) != LUA_TTABLE) 
		return luaL_error(L, "incorrect argument, table expected");

	double duration = 1000;

	lua_getfield(L, index, "duration");
	if(!lua_isnil(L, -1)) 
	{
		if(!lua_isnumber(L, -1))
		{
			return luaL_error(L, "incorrect argument, failed to set \'duration\' : number expected");
		}
		duration =  lua_tonumber(L, -1);
		if (!(duration > 0 ))
		{	
			return luaL_error(L, "incorrect argument, failed to set \'duration\' : positive number expected");
		}
	}
    lua_pop(L, 1);
	//clutter_state_set_duration(state,NULL,NULL,duration);

	//transitions 
	lua_getfield(L, index, "transitions");
	if (!lua_istable(L, -1))
	{
		return luaL_error(L, "incorrect argument, fail to set \'transitions\' : table expected");
	}
			
	int pt = lua_gettop(L);

	lua_pushnil(L);
	while(lua_next(L, pt) != 0) {
		if (!lua_istable(L, -1)) 
		{
			return luaL_error(L, "incorrect argument, fail to set \'transitions\' elements : table expected");
		}

		// source 
		lua_getfield(L, -1, "source");
		const char * csource = lua_tostring(L,-1);
		if (!csource) 
		{
			return luaL_error(L, "incorrect argument, fail to set \'source\' : string expected");
		}
		String source = csource; 
	    lua_pop(L,1);

		// target 
		lua_getfield(L, -1, "target");
		const char * ctarget = lua_tostring(L,-1);
		if (!ctarget) 
		{
			return luaL_error(L, "incorrect argument, fail to set \'target\' : string expected");
		}
		String target = ctarget; 
	    lua_pop(L,1);

		// duration 
		lua_getfield(L, -1, "duration");
		double sduration = lua_tonumber(L,-1);
		/*
		if (sduration) 
		{
			clutter_state_set_duration(state,source.c_str(),target.c_str(),sduration);
			printf("%s,%s,%f\n", source.c_str(),target.c_str(),sduration);
		}
		else
		{
			clutter_state_set_duration(state,source.c_str(),target.c_str(),duration);
			printf("%s,%s,%f\n", source.c_str(),target.c_str(),duration);
		}
		*/
	    lua_pop(L,1);

		// keys 
		lua_getfield(L, -1, "keys");
		if (!lua_isnil(L, -1))
		{
			if (!lua_istable(L,-1))
			{
				return luaL_error(L, "incorrect argument, failed to set \'keys\' : table expected");
			}

			int kt = lua_gettop(L);

			lua_pushnil(L); 
			while(lua_next(L, kt) != 0) 
			{
				if (!lua_istable(L,-1))
				{
					return luaL_error(L, "incorrect argument, failed to set \'keys\' element : table expected");
				}

				// default parameter
    	    	String mode = "LINEAR"; 
	
		 		lua_rawgeti(L,-1,1);
		 		lua_rawgeti(L,-2,2);
		 		lua_rawgeti(L,-3,3);
		 		lua_rawgeti(L,-4,4);
		 		lua_rawgeti(L,-5,5);
		 		lua_rawgeti(L,-6,6);

				// object 
				ClutterActor * object = ClutterUtil::user_data_to_actor(L, -6);
				if(!object)
				{
					return luaL_error(L, "incorrect argument, failed to set the first argument of keys : userdata expected");
				}

				// property-name 
				const char * cname = lua_tostring(L,-5);
				if (!cname) 
				{
					return luaL_error(L, "incorrect argument, failed to set the second argument of keys: string expected");
				}
				String name = cname; 

				// mode, value  
				if ((lua_type(L, -4) == LUA_TNUMBER)||(lua_type(L, -4) == LUA_TTABLE))
				{
					set_state_value(L, -4, state, source, target, object, name , mode);
				}
				else if(lua_isstring(L, -4)) 
				{
					const char* cmode = lua_tostring(L,-4); 
					if (cmode)
					{
						mode  = cmode;
					}
			    	if((lua_isnumber(L, -3))||(lua_istable(L, -3))) 
					{
						set_state_value(L, -3, state, source, target, object, name , mode);
					}
				} 
				else 
				{
					return luaL_error (L, "incorrect argument, failed to set keys value"); 
				}
				lua_pop(L,7);
		 	}
		 }
		 else
		 {
			lua_pop(L, 1);
			// animator 
			lua_getfield(L, -1, "animator");
			ClutterAnimator* animator = ClutterUtil::user_data_to_animator(L, -1);
			if(!animator)
			{
				return luaL_error(L, "incorrect argument, failed to set \'animator\' : Animator expected");
			}
			clutter_state_set_animator (state, source.c_str(), target.c_str(), animator);  
		 }
	     lua_pop(L,2);
		 if (sduration) 
		 {
			clutter_state_set_duration(state,source.c_str(),target.c_str(),sduration);
			printf("%s,%s,%f\n", source.c_str(),target.c_str(),sduration);
		 }
		 else
		 {
			clutter_state_set_duration(state,source.c_str(),target.c_str(),duration);
			printf("%s,%s,%f\n", source.c_str(),target.c_str(),duration);
		 }
	 }
	 lua_pop(L,1);

	 clutter_state_set_duration(state,NULL,NULL,duration);

     return 0;
}

]]

/*
    Class: AnimationState

	The AnimationState class provides a method of organizing an animation as a group of different states and transitions from one state to another. Each state transition defines one or more objects to animate, their properties to modify, and the final property values they should transition to. During the transition from one state to another, the object's properties gradually change, and the animation results. When the target state is eventually reached, the program receives notification by having the AnimationState object's on_completed() event handler invoked. Upon arriving at the target state, the animation may continue by immediately transitioning to a new target state, but this is not a requirement. In fact, one strength of AnimationState-based animations is that they can transition from one state to another at different points in a running program, with transitions being determined by any number of factors, including user input. For example, the user clicking on a menu header may cause an animation to transition to a state that expands the menu and then waits for further user input. Subsequent user actions may cause the animation to transition to a different state which closes the menu. An indeterminate amount of time and program activity may pass before movement to any particular state occurs.
	
	The animation may be controlled by key frames defined in the AnimationState object itself or, alternatively, the animation may be driven by an external Animator object. For simple animations, it may be most convenient to have everything handled by the AnimationState object. For complex animations, it usually makes sense to have an Animator object perform the processing. By dividing responsibilities between the two objects--with the AnimationState object handling the state transitions and the Animator object performing the complex animation--each object performs the task it is most efficiently suited for.
	
	All the states and state-transitions are defined in the AnimationState's constructor. Also in the constructor, the default duration for a transition animation can optionally be specified. The skeleton structure for an AnimationState constructor is shown below.
	
	(code)
	aStates = AnimationState( { duration = 2000,  -- default duration for each transition animation. Optional. If not specified, defaults to 1000.
					transitions = {
						{ -- Transition #1
							...
						},
						
						{ -- Transition #2
							...
						}
					}  -- end of transitions table
			  } )
	(end)
	
	The duration property shown above specifies the default duration in milliseconds for any transition animation that does not set its duration explicitly. The duration property is optional. If it is not set, a default duration of 1000 milliseconds will be assigned to any transition that does not define its own duration.
	
	The remainder of the constructor definition consists of a table of transitions. Each transition must include the following components.
	
	source - unique string identifying a particular beginning state. Can also be "*", which will act as a wildcard starting state.
	target - unique string identifying a particular ending state
	duration - Optional. Positive numeric value specifying the time in milliseconds required to transition from the source state to the target state. If not specified, the value specified in the constructor's duration property is used. If the constructor's duration property is not specified, a value of 1000 is used. The maximum duration value is 86,400,000 (24 hours).
	animator - Animator object used to drive animation. Each transition table contains either an animator property or a keys table, but never both.
	keys - table of key frames specifying the objects and properties to animate and various characteristics of the animation. Additional information about the contents and format of the keys table is described below. Each transition table contains either a keys table or an animator property, but never both.

	The transition's source and target properties specify the starting and ending states, respectively. During processing of an AnimationState, one state is always current. Setting a new state causes a transition to occur between the current, source state and the new, target state. When a new state is set, the AnimationState object selects the appropriate transition to perform based on these source and target states. If the object contains a transition that explicitly specifies the current source and new target states, that transition is selected and the associated animation is executed. If no matching transition is found, the AnimationState searches for a transition with the specified target state and a source state with a wildcard value of "*", which matches all states.
	
	For example, assume an AnimationState that defines the following state transitions: (#1) State1 to State3 and (#2) "*" to State3. If the current state is State1 and the state is changed to State3 then the AnimationState object performs the animation associated with transition (#1) which explicitly matches the move from State1 to State3. If the current state is State2 and the state is changed to State3, the AnimationState does not have a transition that explicitly matches a move from State2 to State3. But transition (#2) matches moving to State3 from any state that does not have an explicitly defined source state, so the animation associated with transition (#2) is performed.
	
	The duration property specifies the length of time in milliseconds of the transition to the target state. This instance of duration applies only to the current transition. If not specified, any value specified in the default duration property specified outside of the transitions table is used. If the default duration property is not specified, a default value of 1000 milliseconds (1 second) is used.
	
	Finally, each entry in the transitions table must contain either an animator property or a keys property, but not both. Both properties specify the animation to perform when the states change from the source to the target states. The animator property specifies an <Animator> object that defines the associated animation. The keys property specifies a table of key frame entries that define the associated animation. Each key frame is itself a table containing the following six components.
	
	(code)
	{ AnimatedObject, AnimatedProperty, AlphaMode, FinalValue, PreDelay, PostDelay }
	(end)

	AnimatedObject - the UIElement-based object to animate
	AnimatedProperty - a string identifying the property to animate. A list of recognized property strings is shown below.
	AlphaMode - a string identifying the Alpha mode to use in the animation. Supported Alpha modes are described in <Alpha.mode>.
	FinalValue - a table or numeric value specifying the final value of the animated property at the conclusion of the animation
	PreDelay - numeric value between 0.0 and 1.0, inclusive, specifying the percentage of total time (duration) that the animation should delay *before* starting. The PreDelay time is taken from the animation's duration time, thereby causing the animation to run faster than if no PreDelay had been specified.
	PostDelay - numeric value between 0.0 and 1.0, inclusive, specifying the percentage of total time (duration) that the animation should delay *after* completing. The PostDelay time is taken from the animation's duration time, thereby causing the animation to run faster than if no PostDelay had been specified.
	
	By setting the PreDelay and PostDelay fields, the animation can be divided into sections. For example, one key frame can set a PostDelay value of .5 so that it will run in the first half of the animation. A second key frame can set its PreDelay to .5 so it runs in the animation's second half, after the first key frame has completed. An example using this technique is shown later in this section.
	
	The recognized properties that can be specified in the AnimatedProperty field and their associated FinalValue data types and formats are listed below.
	
	"x", "y", "z", "depth" - float
	"width", "w", "height", "h" - float
	"opacity" - float
	"position" - table of { float x, float y }
	"size" - table of { float width, float height }
	"scale" - table of { double scale_x, double scale_y }
	"x_rotation" - double specifying rotation angle
	"y_rotation" - double specifying rotation angle
	"z_rotation" - double specifying rotation angle
	"color" - table or string specifying color. The format is described in <RGB/Alpha Color Formats>.
	
	An AnimatedObject may modify any particular property exactly one time in a keys table. For example, the following AnimatedObject-AnimatedProperty definitions are valid.
	
	(code)
	keys = {
		{ Obj, "position", "LINEAR", { 100, 100 }, 0, 0 },  -- animate Obj's position
		{ Obj, "scale", "LINEAR", { 2.0, 2.0 }, 0, 0 },     -- animate Obj's scale
		{ Obj, "z_rotation", "LINEAR", 45, 0, 0 },          -- animate Obj's rotation along Z-axis
		{ Obj2, "position", "LINEAR", { 300, 300 }, 0, 0 }  -- animate Obj2's position. This is okay; you can modify the same property for DIFFERENT objects
	}
	(end)
	
	The following definition is not valid because the animated object's "position" property is modified more than once in the same keys table.
	
	(code)
	keys = {
		{ Obj, "position", "LINEAR", { 100, 100 }, 0.0, 0.5 },  -- in the first half of the animation, move Obj to {100,100}
		{ Obj, "position", "LINEAR", { 300, 300 }, 0.5, 0.0 )   -- in the second half, move Obj to {300,300} ***DOES NOT WORK!***
		                                                        -- Cannot modify same property for same object in same keys table
	}
	(end)
	
	To animate the same property for the same object as part of a transition animation, you must break up the animation into two separate states and have the object's on_completed() event handler transition from the first part to the second. (Note: In the preceding example, you could employ a trick by replacing the second modification of the "position" property with two additional key frames that modify the "x" and "y" properties.)
		
	Some sample transition table entries are shown below. The first transition uses an Animator object to control the animation, while the second transition defines the animation in its keys table.
	
	(code)
	menuStates = AnimationState( {
					transitions = {
						{ -- Transition #1 - From closed to opened
							source = "MenuClosed",
							target = "MenuOpened",
							-- An Animator object will handle this transition's animation, including its duration
							animator = OpenMenuAnimator
						},
						
						{ -- Transition #2 - From opened to closed
							source = "MenuOpened",
							target = "MenuClosed",
							duration = 500,
							-- Animation Key Frames
							-- In the first half of the animation, close the submenu. Notice that by setting the PostDelay to .5, the key
							-- frame's animation will run in the first half of the animation.
							-- In the second half, close the main menu. Notice for this key frame that the PreDelay setting is .5.
							keys = {
								{ submenu, "scale", "EASE_OUT_QUAD", {0,0}, 0, 0.5 },
								{ menu,    "scale", "EASE_OUT_QUAD", {0,0}, 0.5, 0 }
							}
						}
					}  -- end of transitions table
			  } )

	(end)
	
	An AnimationState object's current state is stored in its <state> property. Initially, the object's state is nil. Setting the state property changes the current state and potentially performs a transition animation if one is defined for the two states. Notice that because an object's initial state is nil, the first time the state property is explicitly set, if a transition definition has a target of that first state and a wildcard source of "*", its associated animation will run.
	
	It is possible to change the current state and bypass any associated transition animation by calling the object's <warp> function.
	
	When the animation has completed, the program is notified by calling the object's <on_completed> event handler. This enables the program to perform any desired operations, including immediately transitioning to another state to daisy-chain animations.
	
	*Code Example:* Animate a sphere in two states: (1) from Appear State to Disappear State and (2) from Disappear State to Appear State. For demonstration purposes, the program loops from one state to the other; in a real application, some activity, such as user input, would commonly cause the state transitions. All the AnimationState code is located in the bottom portion of the code sample.
	
	(code)
	-- Create a screen background
	bckgnd = Canvas( 1920, 1080 )
	bckgnd:set_source_color( "ffffffFF" )
	bckgnd:paint()
	bckgndImage = bckgnd:Image()
	bckgndImage.name = "Background"
	screen:add( bckgndImage )

	-- Create a rectangular demo area
	demoArea = Rectangle {
					color = { 100, 100, 100, 255 },
					border_color = { 0, 0, 0, 255 },
					border_width = 4,
					name = "demoArea",
					position = { 746, 96, 0 },
					size = { 308, 308 },
					opacity = 255,
				}
	screen:add( demoArea )

	-- Create a sphere image using Canvas
	sphere = Canvas( 40, 40 )
	sphere:set_source_radial_pattern( 12, 12, 2, 20, 20, 20 )
	sphere:add_source_pattern_color_stop( 0.0, "d00000FF" )
	sphere:add_source_pattern_color_stop( 1.0, "000000FF" )
	sphere:arc( 20, 20, 20, 0, 360 )
	sphere:fill()

	-- Convert Canvas object to Image object and show on the screen
	sphereImage = sphere:Image()
	sphereImage.position = { 900, 220 }
	sphereImage.name = "Sphere"
	sphereImage.anchor_point = { 20, 20 }
	screen:add( sphereImage )

	-- Define an AnimationState for the sphere
	sphereAnimationState = AnimationState( {
			duration = 2000,  -- default transition duration
			transitions = {
				{ -- Appear->Disappear
				  source = "appear",
				  target = "disappear",
				  keys = {
				  		{ sphereImage, "scale", "EASE_IN_OUT_QUAD", {0.0, 0.0}, 0, 0 },
				  }
				},
				{ -- Disappear->Appear
				  source = "disappear",
				  target = "appear",
				  keys = {
				  		{ sphereImage, "scale", "EASE_IN_OUT_QUAD", {2.0, 2.0}, 0, 0 },
				  }
				}
			}
	} )

	-- Define an on_completed() event handler for the sphere's AnimationState so we can daisy-chain states
	function sphereAnimationState:on_completed()
		-- Depending on completed state, toggle to other state
		if( sphereAnimationState.state == "disappear" )then
			sphereAnimationState.state = "appear"
		else
			sphereAnimationState.state = "disappear"
		end
	end
	(end)
	
*/

class AnimationState [[ClutterState*]]
{

	/*
		Constructor: AnimationState
		
		The AnimationState() constructor creates a new AnimationState object. All the object's states and transitions must be defined in the constructor, as described in the opening section of this page.
		
		The current state of the object can be changed by setting the <state> property.
		
		*Arguments:*
		
		props - table defining object's states and transitions
		
		*Return Value:* AnimationState object containing the defined states and transitions
		
		*See Also:* the <state> property
	*/
	
    AnimationState( table props )
    	[[
    		self=clutter_state_new();
    		g_object_ref(self);
    		self=lb_construct_gobject(ClutterState,self);
    		populate_state(L, props, self);
        	g_object_unref(self);
    	]];
	
    ~AnimationState()
    	[[
    	]];
	
	/*
		Property: duration
		
		The duration property contains the default duration value specified in the AnimationState object's constructor. The duration is an integer value specifying the length of time in milliseconds. If no default duration is specified in the constructor, a default value of 1000 milliseconds (1 second) is used.
		
		Note: All durations for transitions must be defined in the object's constructor. Setting the duration property after the constructor has completed has no effect.
		
		*Default Value:* 1000
		
		*See Also:* setting duration values in the AnimationState constructor described in the beginning of this section
	*/

    int duration
    	[[duration=clutter_state_get_duration(self,NULL,NULL);]]
    	[[clutter_state_set_duration(self,NULL,NULL,duration);]];

 	/*
		Property: timeline
		
		The timeline property contains the <Timeline> object associated with the AnimationState. The Timeline is used to drive animations defined in the transition's keys table only; animations controlled by an Animator object are not driven by this Timeline object. The Timeline object's properties and functions can be utilized to control aspects of the key-frame-based animation.
		
		The Timeline object is created automatically and is owned by the AnimationState object.
		
		*See Also:* the <Timeline> object
	*/

	readonly Timeline timeline
    	[[
        	ClutterUtil::wrap_timeline(L , clutter_state_get_timeline(self));
    	]];
    	
    /*
        Property: state

		The state property contains a string specifying the current state of the AnimationState object. By changing the state property, a transition animation may be run if an associated transition from the original (source) state to the new (target) state has been defined.
		
		When the transition animation, if any, has completed, the object's on_completed() event handler is invoked.
		
		To change the state without performing the transition's animation, use the <warp> function.
		
		*Default Value:* nil
		
		*See Also:* the <warp> function and the <on_completed> event handler
    */

	string state
    	[[ state = clutter_state_get_state(self);]]
    	[[ clutter_state_set_state (self, state); ]];

	/*
		Function: warp
		
		The warp() function changes to a specified target state immediately, skipping any defined animation and setting all modified properties to their final values. Calling the warp() function also sets the object's <state> property to the target state.
		
		*Argument:*
		
		target_state_name - string specifying the new current state
		
		*Return Value:* None
		
		*See Also:* the <state> property
	*/	

	warp(string target_state_name)
    	[[
    		clutter_state_warp_to_state(self, target_state_name);
    	]];

	 /*
    	Event: on_completed
    	
    	The on_completed() event handler is called when a new state has been assigned by either setting the object's <state> property or calling the <warp> function. If changing the state caused a transition animation to run, the on_competed() handler is called when the animation completes.
    	
		*Arguments:* None
		
		*Return Value:* None
		
		*See Also:* the <state> property and the <warp> function
     */
     
    callback on_completed
    	[[
    	    UserData::get(L)->connect_signal_if(
    			on_completed,
    			"on_completed",
    			"completed",
    			G_CALLBACK(AnimationState_on_completed),
    			L);	    	    
    	]];
}

[[
void AnimationState_on_completed(ClutterState*state,lua_State*L)
{
    UserData::invoke_callback(G_OBJECT(state),"on_completed",0,0,L);
}
]]

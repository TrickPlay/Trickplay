module clutter_state;

[[
#include "clutter/clutter.h"
#include "util.h"
#include "clutter_util.h"

void AnimationState_on_completed(ClutterState *state, lua_State*L);

int set_state_value(lua_State * L, int index, ClutterState* state, const String & source, 
				    const String & target ,ClutterActor *object, const String & name, const String & mode)
{
	GValue gvalue={0};
	double value;
	const char *k = name.c_str();
	gulong nmode=ClutterUtil::to_clutter_animation_mode(mode.c_str());
	double pre_delay;
    double post_delay;

	if (lua_type(L, index+1) == LUA_TNUMBER) 
	{
		pre_delay = lua_tonumber(L, index + 1);
	} 
	else 
	{
		return luaL_error(L, "incorrect argument, failed to set the fifth argument of keys : number expected");
	}

	if (lua_type(L, index+2) == LUA_TNUMBER) 
	{
		post_delay = lua_tonumber(L, index + 2);
	}
	else 
	{
		return luaL_error(L, "incorrect argument, failed to set the sixth argument of keys : number expected");
	}

	if (!strcmp("x",k)||!strcmp("y",k)||!strcmp("w",k)||!strcmp("width",k)||!strcmp("h",k)||!strcmp("height",k)||
		!strcmp("z",k)||!strcmp("depth",k)||!strcmp("opacity",k))
	{
		if (lua_type(L, index) == LUA_TNUMBER) 
		{
			value = lua_tonumber(L, index);

			g_value_init(&gvalue,G_TYPE_FLOAT);
			g_value_set_float(&gvalue,value);

			clutter_state_set_key(state, source.c_str(), target.c_str(), G_OBJECT(object), name.c_str(), nmode, &gvalue, pre_delay, post_delay);
            g_value_unset(&gvalue);
		} 
		else 
		{
		    return luaL_error(L, "incorrect argument, failed to set the fourth argument of keys : number expected");
		}
	}
	else if (!strcmp("position",k))
	{
		if (lua_type(L,index)==LUA_TTABLE)
		{

			lua_rawgeti(L,index,1);
			value = lua_tonumber(L, -1);
			g_value_init(&gvalue,G_TYPE_FLOAT);
			g_value_set_float(&gvalue, value);
			lua_pop(L,1);
			clutter_state_set_key(state, source.c_str(), target.c_str(), G_OBJECT(object), "x", nmode, &gvalue, pre_delay, post_delay);
			    
			lua_rawgeti(L,index,2);
			value = lua_tonumber(L, -1);
			g_value_unset(&gvalue);
			g_value_init(&gvalue,G_TYPE_FLOAT);
			g_value_set_float(&gvalue,value);
			lua_pop(L,1);
			clutter_state_set_key(state, source.c_str(), target.c_str(), G_OBJECT(object), "y", nmode, &gvalue, pre_delay, post_delay);
            g_value_unset(&gvalue);
		}
		else 
		{
		    return luaL_error(L, "incorrect argument, failed to set the fourth argument of keys : table expected");
		}
	} 
	else if (!strcmp("size",k))
	{
		if (lua_type(L,index)==LUA_TTABLE)
		{

			lua_rawgeti(L,index,1);
			value = lua_tonumber(L, -1);
			g_value_init(&gvalue,G_TYPE_FLOAT);
			g_value_set_float(&gvalue, value);
			lua_pop(L,1);
			clutter_state_set_key(state, source.c_str(), target.c_str(), G_OBJECT(object), "width", nmode, &gvalue, pre_delay, post_delay);
			    
			lua_rawgeti(L,index,2);
			value = lua_tonumber(L, -1);
			g_value_unset(&gvalue);
			g_value_init(&gvalue,G_TYPE_FLOAT);
			g_value_set_float(&gvalue,value);
			lua_pop(L,1);
			clutter_state_set_key(state, source.c_str(), target.c_str(), G_OBJECT(object), "height", nmode, &gvalue, pre_delay, post_delay);
            g_value_unset(&gvalue);
		}			
		else 
		{
		    return luaL_error(L, "incorrect argument, failed to set the fourth argument of keys : table expected");
		}
	}
	else if (!strcmp("scale",k))
	{
		if (lua_type(L,index)==LUA_TTABLE)
		{

			lua_rawgeti(L,index,1);
			value = lua_tonumber(L, -1);
			g_value_init(&gvalue,G_TYPE_DOUBLE);
			g_value_set_float(&gvalue, value);
			lua_pop(L,1);
			clutter_state_set_key(state, source.c_str(), target.c_str(), G_OBJECT(object), "scale-x", nmode, &gvalue, pre_delay, post_delay);
			    
			lua_rawgeti(L,index,2);
			value = lua_tonumber(L, -1);
			g_value_unset(&gvalue);
			g_value_init(&gvalue,G_TYPE_DOUBLE);
			g_value_set_float(&gvalue,value);
			lua_pop(L,1);
			clutter_state_set_key(state, source.c_str(), target.c_str(), G_OBJECT(object), "scale-y", nmode, &gvalue, pre_delay, post_delay);
            g_value_unset(&gvalue);
		}			
		else 
		{
		    return luaL_error(L, "incorrect argument, failed to set the third argument of keys : table expected");
		}
	}
	else if (!strcmp("x_rotation",k))
	{
		if (lua_type(L,index)==LUA_TTABLE)
		{
			    
		}
		else
		{
			value = lua_tonumber(L, -1);
			g_value_init(&gvalue,G_TYPE_DOUBLE);
			g_value_set_float(&gvalue,value);
			clutter_state_set_key(state, source.c_str(), target.c_str(), G_OBJECT(object), "rotation-angle-x", nmode, &gvalue, pre_delay, post_delay);
            g_value_unset(&gvalue);
		}
	}
	else if (!strcmp("y_rotation",k))
	{
		if (lua_type(L,index)==LUA_TTABLE)
		{
		
		}
		else
		{
			value = lua_tonumber(L, -1);
			g_value_init(&gvalue,G_TYPE_DOUBLE);
			g_value_set_float(&gvalue,value);
			clutter_state_set_key(state, source.c_str(), target.c_str(), G_OBJECT(object), "rotation-angle-y", nmode, &gvalue, pre_delay, post_delay);
            g_value_unset(&gvalue);
		}
	}
	else if (!strcmp("z_rotation",k))
	{
		if (lua_type(L,index)==LUA_TTABLE)
		{
			    
		}
		else
		{
			value = lua_tonumber(L, -1);
			g_value_init(&gvalue,G_TYPE_DOUBLE);
			g_value_set_float(&gvalue,value);
			clutter_state_set_key(state, source.c_str(), target.c_str(), G_OBJECT(object), "rotation-angle-z", nmode, &gvalue, pre_delay, post_delay);
            g_value_unset(&gvalue);
		}
	}
	else if (!strcmp("color",k))
	{
		if ((lua_type(L,index)==LUA_TTABLE) || (lua_type(L, index) == LUA_TSTRING))
		{
			ClutterColor color;
			ClutterUtil::to_clutter_color(L, index, &color);

			//ClutterColor color = ClutterUtil::string_to_color(lua_tostring(L, index));

			g_value_init(&gvalue,CLUTTER_TYPE_COLOR);
			clutter_value_set_color(&gvalue, &color);
			clutter_state_set_key(state, source.c_str(), target.c_str(), G_OBJECT(object), "color", nmode, &gvalue, pre_delay, post_delay);
            g_value_unset(&gvalue);			    
		}
		else 
		{
		    return luaL_error(L, "incorrect argument, failed to set the fourth argument of keys : table expected");
		}
	}
	return 0;
}

int populate_state( lua_State * L, int index, ClutterState* state )
{

    if (lua_type(L, index) != LUA_TTABLE) 
		return luaL_error(L, "incorrect argument, table expected");

	double duration = 1000;

	lua_getfield(L, index, "duration");
	if(!lua_isnil(L, -1)) 
	{
		if(!lua_isnumber(L, -1))
		{
			return luaL_error(L, "incorrect argument, failed to set \'duration\' : number expected");
		}
		duration =  lua_tonumber(L, -1);
		if (!(duration > 0 ))
		{	
			return luaL_error(L, "incorrect argument, failed to set \'duration\' : positive number expected");
		}
	}
    lua_pop(L, 1);
	//clutter_state_set_duration(state,NULL,NULL,duration);

	//transitions 
	lua_getfield(L, index, "transitions");
	if (!lua_istable(L, -1))
	{
		return luaL_error(L, "incorrect argument, fail to set \'transitions\' : table expected");
	}
			
	int pt = lua_gettop(L);

	lua_pushnil(L);
	while(lua_next(L, pt) != 0) {
		if (!lua_istable(L, -1)) 
		{
			return luaL_error(L, "incorrect argument, fail to set \'transitions\' elements : table expected");
		}

		// source 
		lua_getfield(L, -1, "source");
		const char * csource = lua_tostring(L,-1);
		if (!csource) 
		{
			return luaL_error(L, "incorrect argument, fail to set \'source\' : string expected");
		}
		String source = csource; 
	    lua_pop(L,1);

		// target 
		lua_getfield(L, -1, "target");
		const char * ctarget = lua_tostring(L,-1);
		if (!ctarget) 
		{
			return luaL_error(L, "incorrect argument, fail to set \'target\' : string expected");
		}
		String target = ctarget; 
	    lua_pop(L,1);

		// duration 
		lua_getfield(L, -1, "duration");
		double sduration = lua_tonumber(L,-1);
		if (sduration) 
		{
			clutter_state_set_duration(state,source.c_str(),target.c_str(),sduration);
			printf("%s,%s,%f\n", source.c_str(),target.c_str(),sduration);
		}
		else
		{
			clutter_state_set_duration(state,source.c_str(),target.c_str(),duration);
			printf("%s,%s,%f\n", source.c_str(),target.c_str(),duration);
		}
	    lua_pop(L,1);

		// keys 
		lua_getfield(L, -1, "keys");
		if (!lua_isnil(L, -1))
		{
			if (!lua_istable(L,-1))
			{
				return luaL_error(L, "incorrect argument, failed to set \'keys\' : table expected");
			}

			int kt = lua_gettop(L);

			lua_pushnil(L); 
			while(lua_next(L, kt) != 0) 
			{
				if (!lua_istable(L,-1))
				{
					return luaL_error(L, "incorrect argument, failed to set \'keys\' element : table expected");
				}

				// default parameter
    	    	String mode = "LINEAR"; 
	
		 		lua_rawgeti(L,-1,1);
		 		lua_rawgeti(L,-2,2);
		 		lua_rawgeti(L,-3,3);
		 		lua_rawgeti(L,-4,4);
		 		lua_rawgeti(L,-5,5);
		 		lua_rawgeti(L,-6,6);

				// object 
				ClutterActor * object = ClutterUtil::user_data_to_actor(L, -6);
				if(!object)
				{
					return luaL_error(L, "incorrect argument, failed to set the first arguement of keys : userdata expected");
				}

				// property-name 
				const char * cname = lua_tostring(L,-5);
				if (!cname) 
				{
					return luaL_error(L, "incorrect argument, failed to set the second arguement of keys: string expected");
				}
				String name = cname; 

				// mode, value  
				if ((lua_type(L, -4) == LUA_TNUMBER)||(lua_type(L, -4) == LUA_TTABLE))
				{
					set_state_value(L, -4, state, source, target, object, name , mode);
				}
				else if(lua_isstring(L, -4)) 
				{
					const char* cmode = lua_tostring(L,-4); 
					if (cmode)
					{
						mode  = cmode;
					}
			    	if((lua_isnumber(L, -3))||(lua_istable(L, -3))) 
					{
						set_state_value(L, -3, state, source, target, object, name , mode);
					}
				} 
				else 
				{
					return luaL_error (L, "incorrect argument, failed to set keys value"); 
				}
				lua_pop(L,7);
		 	}
		 }
		 else
		 {
			lua_pop(L, 1);
			// animator 
			lua_getfield(L, -1, "animator");
			ClutterAnimator* animator = ClutterUtil::user_data_to_animator(L, -1);
			if(!animator)
			{
				return luaL_error(L, "incorrect argument, failed to set \'animator\' : Animator expected");
			}
			clutter_state_set_animator (state, source.c_str(), target.c_str(), animator);  
		 }
	     lua_pop(L,2);
	 }
	 lua_pop(L,1);

	 clutter_state_set_duration(state,NULL,NULL,duration);
	 printf("default duration %f\n", duration);


     return 0;
}

]]

/*
    Class: AnimationState

	An AnimationState is state machine with animated transitions.
*/

class AnimationState [[ClutterState*]]
{
    AnimationState( table props )
    	[[
    		self=clutter_state_new();
    		g_object_ref(self);
    		self=lb_construct_gobject(ClutterState,self);
    		populate_state(L, props, self);
        	g_object_unref(self);
    	]];
	
    ~AnimationState()
    	[[
    	]];
	
	/*
		Property: duration
		The duration of the state in milliseconds.
	*/

    int duration
    	[[duration=clutter_state_get_duration(self,NULL,NULL);]]
    	[[clutter_state_set_duration(self,NULL,NULL,duration);]];

 	/*
		Property: timeline
	*/

	readonly Timeline timeline
    	[[
        	ClutterUtil::wrap_timeline(L , clutter_state_get_timeline(self));
    	]];
    	
    /*
        Property: state
        
        The name of the current state. If you set it to a new state, the transition
        to it will begin.
    */

	string state
    	[[ state = clutter_state_get_state(self);]]
    	[[ clutter_state_set_state (self, state); ]];

	/*
		Function: warp 
		Change to the specified target state immediately with no animation.
		Arguments:
			target_state_name - the state to transition to
	*/	

	warp(string target_state_name)
    	[[
    		clutter_state_warp_to_state(self, target_state_name);
    	]];

	 /*
    	Event: on_completed
    	
		Called whenever an AnimationState reaches the target state specified by <state> or <warp>.
     */
     
    callback on_completed
    	[[
    	    UserData::get(L)->connect_signal_if(
    			on_completed,
    			"on_completed",
    			"completed",
    			G_CALLBACK(AnimationState_on_completed),
    			L);	    	    
    	]];
}

[[
void AnimationState_on_completed(ClutterState*state,lua_State*L)
{
    UserData::invoke_callback(G_OBJECT(state),"on_completed",0,0,L);
}
]]

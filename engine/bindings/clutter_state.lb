module clutter_state;

[[
#include "clutter/clutter.h"
#include "util.h"
#include "clutter_util.h"

void AnimationState_on_completed(ClutterState *state, lua_State*L);

int set_state_value(lua_State * L, int index, ClutterState* state, const String & source, 
				    const String & target ,ClutterActor *object, const String & name, const String & mode)
{
	GValue gvalue={0};
	double value;
	const char *k = name.c_str();
	gulong nmode=ClutterUtil::to_clutter_animation_mode(mode.c_str());
	double pre_delay;
    double post_delay;
    const char *source_name;
    
    if(source.compare("*") != 0)
    {
        source_name = source.c_str();
    } else {
        source_name = NULL;
    }

    // Check if there are pre/post arguments
    if (!lua_isnoneornil(L, index+1))
    {
        if (lua_type(L, index+1) == LUA_TNUMBER) 
        {
            pre_delay = lua_tonumber(L, index + 1);
        } 
        else 
        {
			pre_delay = 0;
            /*return luaL_error(L, "Incorrect argument, failed to set the fifth argument of keys : number expected");*/
        }
    
        if (lua_type(L, index+2) == LUA_TNUMBER) 
        {
            post_delay = lua_tonumber(L, index + 2);
        }
        else 
        {
			post_delay = 0;
            /*return luaL_error(L, "Incorrect argument, failed to set the sixth argument of keys : number expected");*/
        }
    }
    else
    {
        // Use default pre and post of 0.0
        pre_delay = 0.0;
        post_delay = 0.0;
    }

	if (!strcmp("x",k)||!strcmp("y",k)||!strcmp("width",k)||!strcmp("height",k)||!strcmp("depth",k))
	{
		if (lua_type(L, index) == LUA_TNUMBER) 
		{
			value = lua_tonumber(L, index);
            g_value_init(&gvalue,G_TYPE_FLOAT);
            g_value_set_float(&gvalue,value);

			clutter_state_set_key(state, source_name, target.c_str(), G_OBJECT(object), name.c_str(), nmode, &gvalue, pre_delay, post_delay);
            g_value_unset(&gvalue);
		} 
		else 
		{
		    return luaL_error(L, "Incorrect argument, failed to set the fourth argument of keys : number expected");
		}
	}
	else if (!strcmp("z",k)||!strcmp("w",k)||!strcmp("h",k))
	{
		if (lua_type(L, index) == LUA_TNUMBER) 
		{
			value = lua_tonumber(L, index);
            g_value_init(&gvalue,G_TYPE_FLOAT);
            g_value_set_float(&gvalue,value);


			if(!strcmp("z",k))
			{
				clutter_state_set_key(state, source_name, target.c_str(), G_OBJECT(object), "depth", nmode, &gvalue, pre_delay, post_delay);
			}
			else if (!strcmp("w",k))
			{
				clutter_state_set_key(state, source_name, target.c_str(), G_OBJECT(object), "width", nmode, &gvalue, pre_delay, post_delay);
			}
			else if (!strcmp("h",k))
			{	
				clutter_state_set_key(state, source_name, target.c_str(), G_OBJECT(object), "height", nmode, &gvalue, pre_delay, post_delay);
			}

            g_value_unset(&gvalue);
		} 
		else 
		{
		    return luaL_error(L, "Incorrect argument, failed to set the fourth argument of keys : number expected");
		}
	}
	else if (!strcmp("opacity", k))
	{
		if (lua_type(L, index) == LUA_TNUMBER) 
		{
			value = lua_tonumber(L, index);

            g_value_init(&gvalue,G_TYPE_UINT);
            g_value_set_uint(&gvalue,value);

			clutter_state_set_key(state, source_name, target.c_str(), G_OBJECT(object), name.c_str(), nmode, &gvalue, pre_delay, post_delay);
            g_value_unset(&gvalue);
		} 
		else 
		{
		    return luaL_error(L, "Incorrect argument, failed to set the fourth argument of keys : number expected");
		}
	}
	else if (!strcmp("position",k))
	{
		if (lua_type(L,index)==LUA_TTABLE)
		{

			lua_rawgeti(L,index,1);
			value = lua_tonumber(L, -1);
			g_value_init(&gvalue,G_TYPE_FLOAT);
			g_value_set_float(&gvalue, value);
			lua_pop(L,1);
			clutter_state_set_key(state, source_name, target.c_str(), G_OBJECT(object), "x", nmode, &gvalue, pre_delay, post_delay);
			    
			lua_rawgeti(L,index,2);
			value = lua_tonumber(L, -1);
			g_value_unset(&gvalue);
			g_value_init(&gvalue,G_TYPE_FLOAT);
			g_value_set_float(&gvalue,value);
			lua_pop(L,1);
			clutter_state_set_key(state, source_name, target.c_str(), G_OBJECT(object), "y", nmode, &gvalue, pre_delay, post_delay);
            g_value_unset(&gvalue);
		}
		else 
		{
		    return luaL_error(L, "Incorrect argument, failed to set the fourth argument of keys : table expected");
		}
	} 
	else if (!strcmp("size",k))
	{
		if (lua_type(L,index)==LUA_TTABLE)
		{

			lua_rawgeti(L,index,1);
			value = lua_tonumber(L, -1);
			g_value_init(&gvalue,G_TYPE_FLOAT);
			g_value_set_float(&gvalue, value);
			lua_pop(L,1);
			clutter_state_set_key(state, source_name, target.c_str(), G_OBJECT(object), "width", nmode, &gvalue, pre_delay, post_delay);
			    
			lua_rawgeti(L,index,2);
			value = lua_tonumber(L, -1);
			g_value_unset(&gvalue);
			g_value_init(&gvalue,G_TYPE_FLOAT);
			g_value_set_float(&gvalue,value);
			lua_pop(L,1);
			clutter_state_set_key(state, source_name, target.c_str(), G_OBJECT(object), "height", nmode, &gvalue, pre_delay, post_delay);
            g_value_unset(&gvalue);
		}			
		else 
		{
		    return luaL_error(L, "Incorrect argument, failed to set the fourth argument of keys : table expected");
		}
	}
	else if (!strcmp("scale",k))
	{
		if (lua_type(L,index)==LUA_TTABLE)
		{

			lua_rawgeti(L,index,1);
			value = lua_tonumber(L, -1);
			g_value_init(&gvalue,G_TYPE_DOUBLE);
			g_value_set_double(&gvalue, value);
			lua_pop(L,1);
			clutter_state_set_key(state, source_name, target.c_str(), G_OBJECT(object), "scale-x", nmode, &gvalue, pre_delay, post_delay);
			    
			lua_rawgeti(L,index,2);
			value = lua_tonumber(L, -1);
			g_value_unset(&gvalue);
			g_value_init(&gvalue,G_TYPE_DOUBLE);
			g_value_set_double(&gvalue,value);
			lua_pop(L,1);
			clutter_state_set_key(state, source_name, target.c_str(), G_OBJECT(object), "scale-y", nmode, &gvalue, pre_delay, post_delay);
            g_value_unset(&gvalue);
		}			
		else 
		{
		    return luaL_error(L, "Incorrect argument, failed to set the third argument of keys : table expected");
		}
	}
	else if (!strcmp("x_rotation",k))
	{
		if (lua_type(L,index)==LUA_TTABLE)
		{
			    
		}
		else
		{
			value = lua_tonumber(L, index);
			g_value_init(&gvalue,G_TYPE_DOUBLE);
			g_value_set_double(&gvalue,value);
			clutter_state_set_key(state, source_name, target.c_str(), G_OBJECT(object), "rotation-angle-x", nmode, &gvalue, pre_delay, post_delay);
            g_value_unset(&gvalue);
		}
	}
	else if (!strcmp("y_rotation",k))
	{
		if (lua_type(L,index)==LUA_TTABLE)
		{
		
		}
		else
		{
			value = lua_tonumber(L, index);
			g_value_init(&gvalue,G_TYPE_DOUBLE);
			g_value_set_double(&gvalue,value);
			clutter_state_set_key(state, source_name, target.c_str(), G_OBJECT(object), "rotation-angle-y", nmode, &gvalue, pre_delay, post_delay);
            g_value_unset(&gvalue);
		}
	}
	else if (!strcmp("z_rotation",k))
	{
		if (lua_type(L,index)==LUA_TTABLE)
		{
			    
		}
		else
		{
			value = lua_tonumber(L, index);
			g_value_init(&gvalue,G_TYPE_DOUBLE);
			g_value_set_double(&gvalue,value);
			clutter_state_set_key(state, source_name, target.c_str(), G_OBJECT(object), "rotation-angle-z", nmode, &gvalue, pre_delay, post_delay);
            g_value_unset(&gvalue);
		}
	}
	else if (!strcmp("color",k))
	{
		if ((lua_type(L,index)==LUA_TTABLE) || (lua_type(L, index) == LUA_TSTRING))
		{
			ClutterColor color;
			ClutterUtil::to_clutter_color(L, index, &color);

			//ClutterColor color = ClutterUtil::string_to_color(lua_tostring(L, index));

			g_value_init(&gvalue,CLUTTER_TYPE_COLOR);
			clutter_value_set_color(&gvalue, &color);
			clutter_state_set_key(state, source_name, target.c_str(), G_OBJECT(object), "color", nmode, &gvalue, pre_delay, post_delay);
            g_value_unset(&gvalue);			    
		}
		else 
		{
		    return luaL_error(L, "Incorrect argument, failed to set the fourth argument of keys : table expected");
		}
	}
	return 0;
}

int populate_state( lua_State * L, int index, ClutterState* state )
{

    if (lua_type(L, index) != LUA_TTABLE) 
		return luaL_error(L, "Incorrect argument, table expected");

	guint duration=0;
    // Default mode for the whole ClutterState
	String source_mode = "LINEAR";

	lua_getfield(L, index, "duration");
	if(!lua_isnil(L, -1)) 
	{
		if(!lua_isnumber(L, -1))
		{
			return luaL_error(L, "Incorrect argument, failed to set \'duration\' : number expected");
		}
		duration =  lua_tointeger(L, -1);
		if (!(duration > 0 ))
		{	
			return luaL_error(L, "Incorrect argument, failed to set \'duration\' : positive number expected");
		}
	}
    lua_pop(L, 1);

    lua_getfield(L, index, "mode");
    if(!lua_isnil(L, -1))
    {
        // The state has a default mode defined
        const char * smode = lua_tostring(L, -1);
        if(!smode)
        {
            return luaL_error(L, "Incorrect argument, failed to set 'mode' : string expected");
        }
        source_mode = smode;
    }
    lua_pop(L, 1);

	//transitions 
	lua_getfield(L, index, "transitions");
	if (!lua_istable(L, -1))
	{
		return luaL_error(L, "Incorrect argument, fail to set \'transitions\' : table expected");
	}
			
	int pt = lua_gettop(L);

	lua_pushnil(L);
	while(lua_next(L, pt) != 0) {
		if (!lua_istable(L, -1)) 
		{
			return luaL_error(L, "Incorrect argument, fail to set \'transitions\' elements : table expected");
		}

        // Transition's default mode -- default to source mode
        String transition_mode = source_mode;

        lua_getfield(L, -1, "mode");
        if(!lua_isnil(L, -1))
        {
            const char * tmode = lua_tostring(L, -1);
            if(!tmode)
            {
                return luaL_error(L, "Incorrect argument, failed to set 'mode' : string expected");
            }
            transition_mode = tmode;
        }
        lua_pop(L,1);

		// source 
		lua_getfield(L, -1, "source");
		const char * csource = lua_tostring(L,-1);
		if (!csource) 
		{
			return luaL_error(L, "Incorrect argument, fail to set \'source\' : string expected");
		}
		String source = csource;

        const char *source_name;
        
        if(source.compare("*") != 0)
        {
            source_name = source.c_str();
        } else {
            source_name = NULL;
        }

	    lua_pop(L,1);

		// target 
		lua_getfield(L, -1, "target");
		const char * ctarget = lua_tostring(L,-1);
		if (!ctarget) 
		{
			return luaL_error(L, "Incorrect argument, fail to set \'target\' : string expected");
		}
		String target = ctarget; 
	    lua_pop(L,1);

		// duration 
		lua_getfield(L, -1, "duration");
		guint sduration = lua_tointeger(L,-1);
		if (!(sduration > 0 ))
		{	
			return luaL_error(L, "Incorrect argument, failed to set \'duration\' : positive number expected");
		}

	    lua_pop(L,1);

		// keys 
		lua_getfield(L, -1, "keys");
		if (!lua_isnil(L, -1))
		{
			if (!lua_istable(L,-1))
			{
				return luaL_error(L, "Incorrect argument, failed to set \'keys\' : table expected");
			}

			int kt = lua_gettop(L);

			lua_pushnil(L); 
			while(lua_next(L, kt) != 0) 
			{
				if (!lua_istable(L,-1))
				{
					return luaL_error(L, "Incorrect argument, failed to set \'keys\' element : table expected");
				}

				// default parameter
    	    	String mode = transition_mode; 
	
		 		lua_rawgeti(L,-1,1);
		 		lua_rawgeti(L,-2,2);
		 		lua_rawgeti(L,-3,3);
		 		lua_rawgeti(L,-4,4);
		 		lua_rawgeti(L,-5,5);
		 		lua_rawgeti(L,-6,6);

				// object 
				ClutterActor * object = ClutterUtil::user_data_to_actor(L, -6);
				if(!object)
				{
					return luaL_error(L, "Incorrect argument, failed to set the first argument of keys : userdata expected");
				}

				// property-name 
				const char * cname = lua_tostring(L,-5);
				if (!cname) 
				{
					return luaL_error(L, "Incorrect argument, failed to set the second argument of keys: string expected");
				}
				String name = cname; 
				
				if (!lua_isnil(L, -3))
				{
					if (lua_isstring(L, -4) &&  lua_isnumber(L, -3))
					{
						if (!lua_isnil(L, -1)) 
						{
							// object, property-name, mode(string), value(number), value(number), value (number)
							const char* cmode = lua_tostring(L,-4); 
							if (cmode)
							{
								mode  = cmode;
							}
							set_state_value(L, -3, state, source, target, object, name , mode);
						}
						else if (!strcmp(name.c_str(), "color"))
						{
							// object, property-name, value(string), pre-delay(number) , post-delay(number), null 
							set_state_value(L, -4, state, source, target, object, name , mode);
						}
						else  
						{
							// object, property-name, mode(string), value(number), pre-delay, null 
							const char* cmode = lua_tostring(L,-4); 
							if (cmode)
							{
								mode  = cmode;
							}
							set_state_value(L, -3, state, source, target, object, name , mode);
						} 
					}
					else if ((lua_isstring(L, -4) && lua_isstring(L, -3)) || (lua_isstring(L, -4) && (lua_type(L, -3) == LUA_TTABLE)))
					{
						// object, property-name, mode, value 
						const char* cmode = lua_tostring(L,-4); 
						if (cmode)
						{
							mode  = cmode;
						}
						set_state_value(L, -3, state, source, target, object, name , mode);
					}
					else if (((lua_type(L, -4) == LUA_TNUMBER) && (lua_type(L, -3) == LUA_TNUMBER)) || 
							((lua_type(L, -4) == LUA_TTABLE) && (lua_type(L, -3) == LUA_TNUMBER)))
					{
						// object, property-name, value, pre-delay
						set_state_value(L, -4, state, source, target, object, name , mode);
					}
					else 
					{
						return luaL_error (L, "Incorrect argument, failed to set keys value"); 
					}
				}
				else 
				{
					// object, property-name, value 
					set_state_value(L, -4, state, source, target, object, name , mode);
				}

/*
				// mode, value  
				if ((lua_type(L, -4) == LUA_TNUMBER)||(lua_type(L, -4) == LUA_TTABLE))
				{
					set_state_value(L, -4, state, source, target, object, name , mode);
				}
				else if(lua_isstring(L, -4)) 
				{
					const char* cmode = lua_tostring(L,-4); 
					if (cmode)
					{
						mode  = cmode;
					}
			    	if((lua_isnumber(L, -3))||(lua_istable(L, -3))) 
					{
						set_state_value(L, -3, state, source, target, object, name , mode);
					}
				} 
				else 
				{
					return luaL_error (L, "Incorrect argument, failed to set keys value"); 
				}
*/
				lua_pop(L,7);
		 	}
		 }
		 else
		 {
			lua_pop(L, 1);
			// animator 
			lua_getfield(L, -1, "animator");
			ClutterAnimator* animator = ClutterUtil::user_data_to_animator(L, -1);
			if(!animator)
			{
				return luaL_error(L, "Incorrect argument, failed to set \'animator\' : Animator expected");
			}
			clutter_state_set_animator (state, source_name, target.c_str(), animator);  
		 }
	     lua_pop(L,2);

         if (sduration) 
         {
            clutter_state_set_duration(state,source_name,target.c_str(),sduration);
         }

	 }
	 lua_pop(L,1);

    if(duration)
    {
	    clutter_state_set_duration(state,NULL,NULL,duration);
    }

     return 0;
}

]]

/*
    Class: AnimationState

	The AnimationState class provides a method of organizing an animation as a group of different states and transitions from one state to another. Each state transition defines one or more objects to animate, their properties to modify, and the final property values they should transition to. During the transition from one state to another, the object's properties gradually change, and the animation results. When the target state is eventually reached, the program receives notification by having the AnimationState object's on_completed() event handler invoked. Upon arriving at the target state, the animation may continue by immediately transitioning to a new target state, but this is not a requirement. In fact, one strength of AnimationState-based animations is that they can transition from one state to another at different points in a running program, with transitions being determined by any number of factors, including user input. For example, the user clicking on a menu header may cause an animation to transition to a state that expands the menu and then waits for further user input. Subsequent user actions may cause the animation to transition to a different state which closes the menu. An indeterminate amount of time and program activity may pass before movement to any particular state occurs.
	
	The animation may be controlled by key frames defined in the AnimationState object itself or, alternatively, the animation may be driven by an external Animator object. For simple animations, it may be most convenient to have everything handled by the AnimationState object. For complex animations, it usually makes sense to have an Animator object perform the processing. By dividing responsibilities between the two objects--with the AnimationState object handling the state transitions and the Animator object performing the complex animation--each object performs the task it is most efficiently suited for.
	
	All the states and state-transitions are defined in the AnimationState's constructor. Also in the constructor, the default duration and Alpha mode for a transition animation can optionally be specified. The skeleton structure for an AnimationState constructor is shown below.
	
	(code)
	aStates = AnimationState( {
					duration = 2000,           -- default duration for each transition animation. Optional. If not specified, defaults to 1000.
	                mode = "EASE_OUT_SINE",    -- default Alpha mode for each transition animation. Optional. If not specified, defaults to "LINEAR".
					transitions = {
						{ -- Transition #1
							...
						},
						
						{ -- Transition #2
							...
						}
					}  -- end of transitions table
			  } )
	(end)
	
	The duration property shown above specifies the default duration in milliseconds for any transition animation that does not set its duration explicitly. The duration property is optional. If it is not set, a default duration of 1000 milliseconds will be assigned to any transition that does not define its own duration.
	
	The mode property specifies the default Alpha mode for any transition animation that does not set its Alpha mode explicitly. The mode property is optional. If it is not set, a default mode of "LINEAR" is used.  Supported Alpha modes are decribed in <Alpha.mode>.
	
	The remainder of the constructor definition consists of a table of transitions. Each transition includes the following components.
	
	source - unique string identifying a particular beginning state. Can also be "*", which will act as a wildcard starting state.
	target - unique string identifying a particular ending state
	duration - Optional. Positive numeric value specifying the time in milliseconds required to transition from the source state to the target state. If not specified, the value specified in the constructor's duration property is used. If the constructor's duration property is not specified, a value of 1000 is used. The maximum duration value is 86,400,000 (24 hours).
	mode - Optional. String identifying the Alpha mode to use in the transition's animation. Supported Alpha modes are described in <Alpha.mode>. If not specified, the mode setting specified in the constructor's mode property is used. If the constructor's mode property is not specified, the "LINEAR" mode is used.
	animator - Animator object used to drive animation. Each transition table contains either an animator property or a keys table, but never both.
	keys - table of key frames specifying the objects and properties to animate and various characteristics of the animation. Additional information about the contents and format of the keys table is described below. Each transition table contains either a keys table or an animator property, but never both.

	The transition's source and target properties specify the starting and ending states, respectively. During processing of an AnimationState, one state is always current. Setting a new state causes a transition to occur between the current, source state and the new, target state. When a new state is set, the AnimationState object selects the appropriate transition to perform based on these source and target states. If the object contains a transition that explicitly specifies the current source and new target states, that transition is selected and the associated animation is executed. If no matching transition is found, the AnimationState searches for a transition with the specified target state and a source state with a wildcard value of "*", which matches all states.
	
	For example, assume an AnimationState that defines the following state transitions: (#1) State1 to State3 and (#2) "*" to State3. If the current state is State1 and the state is changed to State3 then the AnimationState object performs the animation associated with transition (#1) which explicitly matches the move from State1 to State3. If the current state is State2 and the state is changed to State3, the AnimationState does not have a transition that explicitly matches a move from State2 to State3. But transition (#2) matches moving to State3 from any state that does not have an explicitly defined source state, so the animation associated with transition (#2) is performed.
	
	The duration property specifies the length of time in milliseconds of the transition to the target state. This instance of duration applies only to the current transition.
	
	The mode property specifies the Alpha mode to use in the transition's animation. This instance of mode applies only to the current transition.
	
	Finally, each entry in the transitions table must contain either an animator property or a keys property, but not both. Both properties specify the animation to perform when the state changes from the source to the target.
	
	The animator property specifies an <Animator> object that defines the associated animation. When using an Animator-based animation, the duration and mode properties defined in the AnimationState object are ignored. Instead, these properties should be set in the Animator object.
	
	The keys property specifies a table of key frame entries that define the associated animation. Each key frame is itself a table containing the following components.
	
	(code)
	{ AnimatedObject, AnimatedProperty, [AlphaMode,] FinalValue [, PreDelay, PostDelay] }
	(end)

	AnimatedObject - the UIElement-based object to animate
	AnimatedProperty - a string identifying the property to animate. A list of recognized property strings is shown below.
	AlphaMode - Optional. String identifying the Alpha mode to use in this portion of the animation. Supported Alpha modes are described in <Alpha.mode>. If not specified, any mode defined for the transition is used. If no transition mode is specified, the mode defined in the AnimationState's constructor is used. If no constructor mode is specified, then a "LINEAR" mode is used.
	FinalValue - a table or numeric value specifying the final value of the animated property at the conclusion of the animation
	PreDelay - Optional. Numeric value between 0.0 and 1.0, inclusive, specifying the percentage of total time (duration) that the animation should delay *before* starting. The PreDelay time is taken from the animation's duration time, thereby causing the animation to run faster than if no PreDelay had been specified. If not specified then no predelay is used. Note: If the PostDelay property is set then PreDelay must also be set, even if it is set to 0.0.
	PostDelay - Optional. Numeric value between 0.0 and 1.0, inclusive, specifying the percentage of total time (duration) that the animation should delay *after* completing. The PostDelay time is taken from the animation's duration time, thereby causing the animation to run faster than if no PostDelay had been specified. If not specified then no postdelay is used. Note: If the PreDelay property is set then PostDelay must also be set, even if it is set to 0.0.
	
	By setting the PreDelay and PostDelay fields, the animation can be divided into sections. For example, one key frame can set a PostDelay value of .5 so that it will run in the first half of the animation. A second key frame can set its PreDelay to .5 so it runs in the animation's second half, after the first key frame has completed. An example using this technique is shown later in this section.
	
	The recognized properties that can be specified in the AnimatedProperty field and their associated FinalValue data types and formats are listed below.
	
	"x", "y", "z", "depth" - float
	"width", "w", "height", "h" - float
	"opacity" - unsigned integer
	"position" - table of { float x, float y }
	"size" - table of { float width, float height }
	"scale" - table of { double scale_x, double scale_y }
	"x_rotation" - double specifying rotation angle
	"y_rotation" - double specifying rotation angle
	"z_rotation" - double specifying rotation angle
	"color" - table or string specifying color. The format is described in <RGB/Alpha Color Formats>.
	
	An AnimatedObject may modify any particular property exactly one time in a keys table. For example, the following AnimatedObject-AnimatedProperty definition is valid.
	
	(code)
	keys = {
		{ Obj,  "position", { 100, 100 } },  -- animate Obj's position
		{ Obj2, "position", { 300, 300 } }   -- animate Obj2's position. This is okay; you can modify the same property for DIFFERENT objects
	}
	(end)
	
	The following definition is not valid because the animated object's "position" property is modified more than once in the same keys table.
	
	(code)
	keys = {
		{ Obj, "position", { 100, 100 }, 0.0, 0.5 },  -- in the first half of the animation, move Obj to {100,100}
		{ Obj, "position", { 300, 300 }, 0.5, 0.0 )   -- in the second half, move Obj to {300,300} ***DOES NOT WORK!***
		                                              -- Cannot modify same property for same object in same keys table
	}
	(end)
	
	To animate the same property for the same object as part of a transition animation, you must break up the animation into two separate states and have the object's on_completed() event handler transition from the first part to the second. (Note: In the preceding example, you could employ a trick by replacing the second modification of the "position" property with two additional key frames that modify the "x" and "y" properties.)
		
	Some sample transition table entries are shown below. The first transition uses an Animator object to control the animation, while the second transition defines the animation in a keys table.
	
	(code)
	menuStates = AnimationState( {
					mode = "EASE_IN_OUT_QUAD",  -- default Alpha mode for all transitions
					transitions = {
						{ -- Transition #1 - From closed to opened
							source = "MenuClosed",
							target = "MenuOpened",
							-- An Animator object will handle this transition's animation, including its duration and Alpha mode
							animator = OpenMenuAnimator
						},
						
						{ -- Transition #2 - From opened to closed
							source = "MenuOpened",
							target = "MenuClosed",
							duration = 500,
							mode = "EASE_OUT_SINE", -- default Alpha mode for all keys in this transition
							-- Animation Key Frames
							-- In the first half of the animation, close the submenu. Notice that by setting the PostDelay to .5, the key
							-- frame's animation will run in the first half of the animation.
							-- In the second half, close the main menu. Notice for this key frame that the PreDelay setting is .5.
							keys = {
								{ submenu, "scale", "EASE_IN_OUT_SINE", {0,0}, 0, 0.5 }, -- explicit Alpha mode for this key
								{ menu,    "scale",                     {0,0}, 0.5, 0 }  -- uses default Alpha mode for this transition ("EASE_OUT_SINE")
							}
						}
					}  -- end of transitions table
			  } )

	(end)
	
	An AnimationState object's current state is stored in its <state> property. Initially, the object's state is nil. Setting the state property changes the current state and potentially performs a transition animation if one is defined for the two states. Notice that because an object's initial state is nil, the first time the state property is explicitly set, if a transition definition has a target of that state and a wildcard source of "*", its associated animation will run.
	
	It is possible to change the current state and bypass any associated transition animation by calling the object's <warp> function.
	
	When the animation has completed, the program is notified by calling the object's <on_completed> event handler. This enables the program to perform any desired operations, including immediately transitioning to another state to daisy-chain animations.
	
	*Code Example:* Animate a sphere in two states: (1) from wildcard-source State to Disappear State and (2) from Disappear State to Appear State. For demonstration purposes, the program loops from one state to the other; in a real application, some activity, such as user input, would commonly cause the state transitions. All the AnimationState code is located in the bottom portion of the code sample.
	
	(code)
	-- Create a screen background
	bckgnd = Canvas( 1920, 1080 )
	bckgnd:set_source_color( "ffffffFF" )
	bckgnd:paint()
	bckgndImage = bckgnd:Image()
	bckgndImage.name = "Background"
	screen:add( bckgndImage )

	-- Create a rectangular demo area
	demoArea = Rectangle {
					color = { 100, 100, 100, 255 },
					border_color = { 0, 0, 0, 255 },
					border_width = 4,
					name = "demoArea",
					position = { 746, 96, 0 },
					size = { 308, 308 },
					opacity = 255,
				}
	screen:add( demoArea )

	-- Create a sphere image using Canvas
	sphere = Canvas( 40, 40 )
	sphere:set_source_radial_pattern( 12, 12, 2, 20, 20, 20 )
	sphere:add_source_pattern_color_stop( 0.0, "d00000FF" )
	sphere:add_source_pattern_color_stop( 1.0, "000000FF" )
	sphere:arc( 20, 20, 20, 0, 360 )
	sphere:fill()

	-- Convert Canvas object to Image object and show on the screen
	sphereImage = sphere:Image()
	sphereImage.position = { 900, 220 }
	sphereImage.name = "Sphere"
	sphereImage.anchor_point = { 20, 20 }
	screen:add( sphereImage )

	-- Define an AnimationState for the sphere
	sphereAnimationState = AnimationState( {
			duration = 2000,            -- default transition duration
			mode = "EASE_IN_OUT_QUAD",  -- default Alpha mode for all transitions
			transitions = {
				{ -- Wildcard state--->Disappear
				  source = "*",
				  target = "disappear",
				  keys = {
				  		{ sphereImage, "scale", {0.0, 0.0} },
				  }
				},
				{ -- Disappear--->Appear
				  source = "disappear",
				  target = "appear",
				  keys = {
				  		{ sphereImage, "scale", {2.0, 2.0} },
				  }
				}
			}
	} )

	-- Define an on_completed() event handler for the sphere's AnimationState so we can daisy-chain states
	function sphereAnimationState:on_completed()
		-- Depending on completed state, toggle to other state
		if( sphereAnimationState.state == "disappear" )then
			sphereAnimationState.state = "appear"
		else
			sphereAnimationState.state = "disappear"
		end
	end

	-- Start the animation
	sphereAnimationState.state = "disappear"  -- Matches the wildcard "*" source transition
	(end)
	
	The animation generated by the code example is shown below.
	
(see animationStateDemo.gif)

*/

class AnimationState [[ClutterState*]]
{

	/*
		Constructor: AnimationState
		
		The AnimationState() constructor creates a new AnimationState object. All the object's states and transitions must be defined in the constructor, as described in the opening section of this page.
		
		The current state of the object can be changed by setting the <state> property.
		
		*Arguments:*
		
		props - table defining object's states and transitions
		
		*Return Value:* AnimationState object containing the defined states and transitions
		
		*See Also:* the <state> property
	*/
	
    AnimationState( table props )
    	[[
    		self=clutter_state_new();
    		g_object_ref(self);
    		self=lb_construct_gobject(ClutterState,self);
    		populate_state(L, props, self);
        	g_object_unref(self);
    	]];
	
    ~AnimationState()
    	[[
    	]];
	
	/*
		Property: duration
		
		The duration property contains the default duration value specified in the AnimationState object's constructor. The duration is an integer value specifying the length of time in milliseconds. If no default duration is specified in the constructor, a default value of 1000 milliseconds (1 second) is used.
		
		Note: All durations for transitions must be defined in the object's constructor. Setting the duration property after the constructor has completed has no effect.
		
		*Default Value:* 1000
		
		*See Also:* setting duration values in the AnimationState constructor described in the beginning of this section
	*/

    int duration
    	[[duration=clutter_state_get_duration(self,NULL,NULL);]]
    	[[clutter_state_set_duration(self,NULL,NULL,duration);]];

 	/*
		Property: timeline
		
		The timeline property contains the <Timeline> object associated with the AnimationState. The Timeline is used to drive animations defined in the transition's keys table only; animations controlled by an Animator object are not driven by this Timeline object. The Timeline object's properties and functions can be utilized to control aspects of the key-frame-based animation.
		
		The Timeline object is created automatically and is owned by the AnimationState object.
		
		*See Also:* the <Timeline> object
	*/

	readonly Timeline timeline
    	[[
        	ClutterUtil::wrap_timeline(L , clutter_state_get_timeline(self));
    	]];
    	
    /*
        Property: state

		The state property contains a string specifying the current state of the AnimationState object. By changing the state property, a transition animation may be run if an associated transition from the original (source) state to the new (target) state has been defined.
		
		When the transition animation, if any, has completed, the object's on_completed() event handler is invoked.
		
		To change the state without performing the transition's animation, use the <warp> function.
		
		*Default Value:* nil
		
		*See Also:* the <warp> function and the <on_completed> event handler
    */

	string state
    	[[ state = clutter_state_get_state(self);]]
    	[[ clutter_state_set_state (self, state); ]];

	/*
		Function: warp
		
		The warp() function changes to a specified target state immediately, skipping any defined animation and setting all modified properties to their final values. Calling the warp() function also sets the object's <state> property to the target state.
		
		*Argument:*
		
		target_state_name - string specifying the new current state
		
		*Return Value:* None
		
		*See Also:* the <state> property
	*/	

	warp(string target_state_name)
    	[[
    		clutter_state_warp_to_state(self, target_state_name);
    	]];

	 /*
    	Event: on_completed
    	
    	The on_completed() event handler is called when a new state has been assigned by either setting the object's <state> property or calling the <warp> function. If changing the state caused a transition animation to run, the on_competed() handler is called when the animation completes.
    	
		*Arguments:* None
		
		*Return Value:* None
		
		*See Also:* the <state> property and the <warp> function
     */
     
    callback on_completed
    	[[
    	    UserData::get(L)->connect_signal_if(
    			on_completed,
    			"on_completed",
    			"completed",
    			G_CALLBACK(AnimationState_on_completed),
    			L);	    	    
    	]];
}

[[
void AnimationState_on_completed(ClutterState*state,lua_State*L)
{
    UserData::invoke_callback(G_OBJECT(state),"on_completed",0,0,L);
}
]]

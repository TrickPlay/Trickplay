[[
#include "controller_delegates.h"
#include "json.h"
#include "app.h"
#include "app_resource.h"
]]

#==============================================================================

/*
    Interface: Controller
    
    The Controller interface provides access to external devices connected to the TrickPlay Engine. Typical external devices include TV remote controls, keyboards, and pointer-type devices, such as mice. It is also possible to connect to smart devices, such as Apple iPads and iPhones, Android devices, and other smart devices.
    
    Devices connect to the TrickPlay Engine automatically if: (1) the Engine has enabled external connections and (2) the external device searches for other devices to connect to. By default, external connections are disabled. The Engine can enable external connections by performing either of the following tasks.
    
    - Set the controllers_enabled configuration key in the application's .trickplay file to "TRUE". This will enable external connections to the current application only.
    - Define the system's TP_controllers_enabled environment variable to "TRUE". This will enable external connections to any TrickPlay application.
    
    The connection is performed by using either the mDNS (multicast DNS) or UPnP (Universal Plug and Play) protocol. By default, mDNS is enabled and UPnP is disabled. Each protocol can be enabled/disabled by setting their respective TrickPlay configuration key (controllers_mdns_enabled and controllers_upnp_enabled). 
    
    Additional information about the controllers_enabled and related configuration keys can be found in <TrickPlay Configuration Keys>.
    
    Because devices are connected automatically--in fact, automatic connection is the only method available to connect devices--there is no need for a program to create Controller objects; a new Controller object is created automatically when the device connects. A list of connected devices can be retrieved by accessing the <controllers.connected> property. Also, when a new device connects to the TrickPlay Engine, the <controllers.on_controller_connected> event handler is invoked. By accessing the controllers.connected property and/or hooking the on_controller_connected() event handler, a program can access any Controller object connected to the system.
    
    The Controller interface provides properties, functions and event handlers that enable a program to determine a device's capabilities, request resources from the device, and receive notification of events generated by the device.

*/

interface Controller [[ControllerDelegate*]]
{
    Controller()
        [[
            self=lb_construct( ControllerDelegate , lua_touserdata(L,-2) );
        ]];
        
    ~Controller()
        [[
            delete self;    
        ]];
        
    /*
        Property: is_connected
        
        The is_connected property is a Boolean flag indicating whether or not the device is still connected to the TrickPlay Engine (true=still connected).
        
        While a device is connected to the TrickPlay Engine, a Controller object associated with the device will exist in the <controllers.connected> table of connected devices. After a device disconnects from the Engine, its associated Controller object will no longer exist in the controllers.connected table. However, if a TrickPlay application creates and maintains its own variable reference to a Controller object, that object will still exist even though its associated device is no longer connected. In such cases, before the application accesses a Controller object's properties and functions, it should always verify that the device is still connected by checking its is_connected property. Alternatively, the application could hook the object's <on_disconnected> event handler and, when the device disconnects, the program can "terminate" or nullify its Controller variable reference, for example, by setting it to nil.
        
        *Possible Settings:* true=the device is connected, false=the device has disconnected
        
        *See Also:* the <controllers.connected> property and the <on_disconnected> event handler
    */
    
    readonly bool is_connected
        [[
            is_connected=self->get_controller()->is_connected();    
        ]];
    
    /*
        Property: name
        
        The name property is a string the external device has defined to identify itself. Each connected device is guaranteed to have a unique name property.
        
		*See Also:* the <id> property
    */
        
    readonly string name
        [[
            String s(self->get_controller()->get_name());
            name=s.c_str();    
        ]];
        
    /*
        Property: id
        
        The id property is a string that uniquely identifies the device.
        
        Note: When a device disconnects and reconnects, its id property is not guaranteed to remain the same for each session.

		*See Also:* the <name> property        
    */        
    
    readonly string id
        [[
           String s( self->get_controller()->get_id());
           id = s.c_str();
        ]];
        
    /*
        Property: ui_size
        
        The ui_size property is a table specifying the width and height in pixels of the device's user-interface display area. If the device has no display, the width and height values will be zero.
        
        *Table Format:* { width, height }
        
        *See Also:* the <has_ui> property
    */    
    
    readonly table ui_size
        [[
            unsigned int w;
            unsigned int h;
            
            self->get_controller()->get_ui_size(w,h);
            
            lua_newtable(L);
            lua_pushinteger(L,w);
            lua_rawseti(L,-2,1);
            lua_pushinteger(L,h);
            lua_rawseti(L,-2,2);
        ]];
        
    /*
        Property: input_size
        
        The input_size property is a table specifying the width and height in pixels of the device's area used for touch-type events. If the device does not support touch-type events, the width and height values will be zero.
        
        *Table Format:* { width, height }
        
        *See Also:* the <has_touches> property
    */
    
    readonly table input_size
        [[
            unsigned int w;
            unsigned int h;
            
            self->get_controller()->get_input_size(w,h);
            
            lua_newtable(L);
            lua_pushinteger(L,w);
            lua_rawseti(L,-2,1);
            lua_pushinteger(L,h);
            lua_rawseti(L,-2,2);
        ]];
    
    /*
        Property: has_keys
        
        The has_keys property is a Boolean flag indicating whether or not the device has the capability to send key-related events, such as key-up and key-down (true=can send key events). If the has_keys property is true, the application can hook the object's <on_key_up> and <on_key_down> event handlers to monitor the events.
        
        If the has_keys property is true, key events are enabled automatically; it is not necessary to start key events. Also, it is not possible to stop the generation of key events.
        
        *Possible Settings:* true=device can send key-related events, else false
        
        *See Also:* the <on_key_up> and <on_key_down> event handlers
    */
    
    readonly bool has_keys
        [[
            has_keys=self->has_cap(TP_CONTROLLER_HAS_KEYS);    
        ]];

    /*
        Property: has_accelerometer

		The has_accelerometer property is a Boolean flag indicating whether or not the device has the capability to send accelerometer events (true=can send accelerometer events). Accelerometer data can be interpreted to determine the device's orientation and movement.
		
		If the has_accelerometer property is true, the application can enable/disable the generation of accelerometer events by calling the object's <start_accelerometer> and <stop_accelerometer> functions. To monitor accelerometer events, the program can hook the object's <on_accelerometer> event handler.
		
		*Possible Settings:* true=device can send accelerometer events, else false
		
		*See Also:* the <start_accelerometer> and <stop_accelerometer> functions and the <on_accelerometer> event handler
    */
    
    readonly bool has_accelerometer
        [[
            has_accelerometer=self->has_cap(TP_CONTROLLER_HAS_ACCELEROMETER);
        ]];
        
        
    /*
    	UndocumentedProperty: has_clicks
    	
    	*** This is a non-existent capability.
    */
    readonly bool has_clicks
        [[
            has_clicks=false;
        ]];

    /*
        Property: has_pointer

		The has_pointer property is a Boolean flag indicating whether or not the device has the capability to send pointer-type events, typical of mouse-type devices (true=can send pointer-type events).
		
		If the has_pointer property is true, the application can enable/disable the generation of pointer-type events by calling the object's <start_pointer> and <stop_pointer> functions. To monitor the pointer-type events, the program can hook the object's <on_pointer_move>, <on_pointer_button_down> and <on_pointer_button_up> event handlers.
		
		*Possible Settings:* true=device can send pointer-type events, else false
		
		*See Also:* the <start_pointer> and <stop_pointer> functions and the <on_pointer_move>, <on_pointer_button_down> and <on_pointer_button_up> event handlers
    */
    
    readonly bool has_pointer
        [[
            has_pointer=self->has_cap(TP_CONTROLLER_HAS_POINTER);
        ]];
    
    /*
        Property: has_touches
        
        The has_touches property is a Boolean flag indicating whether or not the device has the capability to send touch-related events, typical of touchscreens (true=can send touch-related events).
        
        If the has_touches property is true, the application can enable/disable the generation of touch-related events by calling the object's <start_touches> and <stop_touches> functions. To monitor the touch-related events, the program can hook the object's <on_touch_move>, <on_touch_up> and <on_touch_down> event handlers.
        
        *Possible Settings:* true=device can send touch-related events, else false
        
        *See Also:* the <start_touches> and <stop_touches> functions and the <on_touch_move>, <on_touch_up> and <on_touch_down> event handlers
    */    
    
    readonly bool has_touches
        [[
            has_touches=self->has_cap(TP_CONTROLLER_HAS_TOUCHES);    
        ]];
        
    /*
        Property: has_scroll
        
        The has_scroll property is a Boolean flag indicating whether or not the device has the capability to send scroll wheel events (true=can send scroll wheel events). Scroll wheels are commonly found on computer mice, but are also available on other input devices.
        
        To monitor scroll-related events, a program can hook an object's <on_scroll> event handler.
        
        *Possible Settings:* true=device can send scroll-related events, else false
        
        *See Also:* the <on_scroll> event handler
    */
    
    readonly bool has_scroll
        [[
            has_scroll = self->has_cap( TP_CONTROLLER_HAS_SCROLL );    
        ]];
    
    /*
        Property: has_multiple_choice
        
        The has_multiple_choice property is a Boolean flag indicating whether or not the device has the capability to display a multiple-choice query and accept an input response (true=can display query and accept input response). The input response takes the form of selecting from a list of choices.
        
        If the has_multiple_choice property is true, the application can define and display a simple multiple-choice form by calling the <show_multiple_choice> function. When the user selects a choice, an <on_ui_event> is fired; the program can hook that handler to process the response.
        
        *Possible Settings:* true=device can display a multiple-choice form and accept an input response, else false
        
        *See Also:* the <show_multiple_choice> function and <on_ui_event> event handler
    */
        
    readonly bool has_multiple_choice
        [[
            has_multiple_choice=self->has_cap(TP_CONTROLLER_HAS_MULTIPLE_CHOICE); 
        ]];
        
    /*
        Property: has_sound
        
        The has_sound property is a Boolean flag indicating whether or not the device has the capability to process audio data (true=can process audio).
        
        If the has_sound property is true, the application can play an audio resource by calling the <play_sound> function.
        
        *Possible Settings:* true=device can process audio data, else false
        
        *See Also:* the <play_sound> and <declare_resource> functions
    */        
    
    readonly bool has_sound
        [[
            has_sound=self->has_cap(TP_CONTROLLER_HAS_SOUND);    
        ]];
    
    /*
        Property: has_ui
        
        The has_ui property is a Boolean flag indicating whether or not the device supports a user-interface display (true=supports a display).
        
        If the has_ui property is true, the application can manipulate the contents of the display by calling various functions, such as <clear_ui>, <set_ui_background> and <set_ui_image>.
        
        *Possible Settings:* true=device supports a user-interface display, else false
        
        *See Also:* the <clear_ui>, <set_ui_background> and <set_ui_image> functions
    */
        
    readonly bool has_ui
        [[
            has_ui=self->has_cap(TP_CONTROLLER_HAS_UI);
        ]];
        
    /*
        Property: has_text_entry
        
        The has_text_entry property is a Boolean flag indicating whether or not the device has the capability to display a query and accept a text response (true=can display query and accept text response). The text response can be input using either an actual or on-screen keyboard.
        
        If the has_text_entry property is true, the application can display a query and a text-entry field by calling the <enter_text> function. When the user finishes entering the text, an <on_ui_event> is fired; the program can hook that handler to process the response.
        
        *Possible Settings:* true=device can display a query and accept a text response, else false
        
        *See Also:* the <enter_text> function and <on_ui_event> event handler
    */
           
    readonly bool has_text_entry
        [[
            has_text_entry=self->has_cap(TP_CONTROLLER_HAS_TEXT_ENTRY);
        ]];
    
    /*
        Property: has_images
        
        The has_images property is a Boolean flag indicating whether or not the device can send images (true=can send images).
        
        If the has_images property is true, the application can request the device to send an image by calling the <request_image> function.
        
        *Possible Settings:* true=device can send images, else false
        
        *See Also:* the <request_image> function
    */
           
    readonly bool has_images
        [[
            has_images=self->has_cap(TP_CONTROLLER_HAS_IMAGES);
        ]];
    
    /*
        UndocumentedProperty: has_audio_clips
        
        *** There is currently nothing a program can do with an audio clip, so leave this property undocumented.
        
        The has_audio_clips property is a Boolean flag indicating whether or not the device can send audio clips (true=can send audio).
        
        If the has_audio_clips property is true, the application can request the device to send an audio clip by calling the <request_audio_clip> function.
        
        *Possible Settings:* true=device can send audio clips, else false
        
        *See Also:* the <request_audio_clip> function and <on_audio_clip> and <on_audio_clip_cancelled> event handlers
    */
           
    readonly bool has_audio_clips
        [[
            has_audio_clips=self->has_cap(TP_CONTROLLER_HAS_AUDIO_CLIPS);
        ]];
    
    /*
        Property: has_advanced_ui
        
        The has_advanced_ui property is a Boolean flag indicating whether or not the device or application running on the device provides dedicated TrickPlay support (true=supports TrickPlay).
        
        *Possible Settings:* true=device supports TrickPlay, else false
        
        *See Also:* the <on_advanced_ui_ready> event handler
    */
    /* Possible new names for "AdvancedUI": has_trickplay_support

    readonly bool has_advanced_ui
        [[
            has_advanced_ui = self->has_cap( TP_CONTROLLER_HAS_ADVANCED_UI );
        ]];
        
    /*
        InternalProperty: is_advanced_ui_ready
        
        *** This property is used by the "Advanced UI" Lua library to communicate with the TakeControl framework. It should never be accessed directly by a TrickPlay application. Therefore, it will remain undocumented to the public.
        
        The is_advanced_ui_ready property is a Boolean flag indicating whether or not the device's support for "Advanced UI" is ready (true="Advanced UI" is ready).
        
        *Possible Settings:* true="Advanced UI" is ready, else false
        
        *See Also:* the <on_advanced_ui_ready> event handler
    */
    
    readonly bool is_advanced_ui_ready
        [[
            is_advanced_ui_ready = self->get_controller()->is_advanced_ui_ready();
        ]];
        
    /*
        Property: has_virtual_remote
        
        The has_virtual_remote property is a Boolean flag indicating whether or not the device supports a virtual, on-screen remote control (true=supports virtual remote).
        
        If the has_virtual_remote property is true, the application can display or hide the virtual remote control by calling the object's <show_virtual_remote> or <hide_virtual_remote> functions. Input with the virtual remote generates regular key events, regardless of the actual input device used. Key events are processed through the <on_key_up> and <on_key_down> event handlers.
        
		*Possible Settings:* true=device supports a virtual remote control, else false
		
		*See Also:* the <show_virtual_remote> and <hide_virtual_remote> functions
    */        
    
    readonly bool has_virtual_remote
        [[
            has_virtual_remote = self->has_cap( TP_CONTROLLER_HAS_VIRTUAL_REMOTE );
        ]];

    /*
        Function: reset
        
        The reset() function resets the device to its default state. The device will stop sending events, except for key events. If the device has a user interface display, the display is cleared.
        
        *Arguments:* None
        
        *Return Value:* true if device was reset, else false
    */
        
    bool reset()
        [[
            result=self->get_controller()->reset();    
        ]];
        
    /*
        Function: start_accelerometer
        
        The start_accelerometer() function instructs the device to start sending accelerometer events. For this function to have an effect, the object's <has_accelerometer> property must be true.
        
        Accelerometer events can be monitored by hooking the <on_accelerometer> event handler. Accelerometer events can be stopped by calling the <stop_accelerometer> function.
        
        *Arguments:*
        
        	filter - string specifying a filter to apply to the raw accelerometer data. A low-pass filter reduces the effect of brief accelerations and smoothes the acceleration curve. A high-pass filter reduces the influence of gravity on the accelerometer and focuses on the device's movements. For iPhone and iPad devices, general-purpose low-pass and high-pass software filters are provided in the TrickPlay SDK libraries. A filter argument of "L" filters the accelerometer data through the low-pass filter; an argument of "H" filters the data through the high-pass filter.  If an empty string is specified, no filter is used, and raw accelerometer data is sent. Other accelerometer-enabled devices may support their own filters.
        	interval - floating point interval in seconds between accelerometer events. This value is a suggestion; the actual events may occur more or less frequently.
        
        *Return Value:* true if accelerometer events were started, else false

		*See Also:* the <has_accelerometer> property, <stop_accelerometer> function and the <on_accelerometer> event handler  
    */

    bool start_accelerometer(string filter, double interval)
        [[
            Controller::AccelerometerFilter f=Controller::NONE;
            
            if (filter)
            {
                if (*filter=='L'||*filter=='l')
                {
                    f=Controller::LOW;
                }
                else if (*filter=='H'||*filter=='h')
                {
                    f=Controller::HIGH;
                }
            }

            result=self->get_controller()->start_accelerometer(f,interval);
        ]];

    /*
        Function: stop_accelerometer
        
        The stop_accelerometer() function instructs the device to stop sending accelerometer events.
        
        *Arguments:* None
        
        *Return Value:* true if accelerometer events were stopped, else false
        
        *See Also:* the <has_accelerometer> property and <start_accelerometer> function
    */
            
    bool stop_accelerometer()
        [[
            result=self->get_controller()->stop_accelerometer();    
        ]];
        

    /*
        Function: start_pointer
        
        The start_pointer() function instructs the device to begin sending pointer-type events. For this function to have an effect, the object's <has_pointer> property must be true.
        
        Pointer-type events can be monitored by hooking the <on_pointer_move>, <on_pointer_button_up> and <on_pointer_button_down> event handlers. Pointer-type events can be stopped by calling the <stop_pointer> function.
        
        *Arguments:* None
        
        *Return Value:* true if pointer-type events were started, else false
        
        *See Also:* the <has_pointer> property, the <stop_pointer> function, and the <on_pointer_move>, <on_pointer_button_up> and <on_pointer_button_down> event handlers
    */

    bool start_pointer()
        [[
            result=self->get_controller()->start_pointer();
        ]];
        
    /*
        Function: stop_pointer
        
        The stop_pointer() function instructs the device to stop sending pointer-type events.
        
        *Arguments:* None
        
        *Return Value:* true if pointer-type events were stopped, else false
        
        *See Also:* the <has_pointer> property and <start_pointer> function
    */

    bool stop_pointer()
        [[
            result=self->get_controller()->stop_pointer();
        ]];
    
    /*
        Function: start_touches
        
        The start_touches() function instructs the device to start sending touch-related events. For this function to have an effect, the object's <has_touches> property must be true.
        
        Touch-related events can be monitored by hooking the <on_touch_move>, <on_touch_up> and <on_touch_down> event handlers. Touch-related events can be stopped by calling the <stop_touches> function.
        
        *Arguments:* None
        
        *Return Value:* true if touch-related events were started, else false
        
        *See Also:* the <has_touches> property, the <stop_touches> function, and the <on_touch_move>, <on_touch_up> and <on_touch_down> event handlers
    */
        
    bool start_touches()
        [[
            result=self->get_controller()->start_touches();
        ]];
        
    /*
        Function: stop_touches
        
        The stop_touches() function instructs the device to stop sending touch-related events.
        
        *Arguments:* None
        
        *Return Value:* true if touch-related events were stopped, else false
        
        *See Also:* the <has_touches> property and <start_touches> function
    */
    
    bool stop_touches()
        [[
            result=self->get_controller()->stop_touches();
        ]];

	/*
		DeprecatedFunction: show_multiple_choice_ui
		
		*** Deprecated, use show_multiple_choice() instead
	*/
    
    bool show_multiple_choice_ui()
        [[
            g_warning("DEPRECATED CALL TO Controller:show_multiple_choice_ui");
            result=false;
        ]];
        
    /*
        Function: show_multiple_choice
        
        The show_multiple_choice() function displays a query and list of choices and enables the user to make a selection. For this function to have an effect, the object's <has_multiple_choice> property must be true.
        
        The query and list of choices are defined in the function's arguments described below. Making a selection fires the <on_ui_event> handler, which a program can hook to retrieve the selection.
        
        The display does not automatically clear after a selection is made; to clear the display, the program must call the <clear_ui> function.
        
        *Prototype:*
        
        	(code)
        	bool show_multiple_choice( string label, string choice01_id, string choice01, ... )
        	(end)
        
        *Arguments:*
        
        	label - query string. The device will typically display this string above the list of choices.
        	choice01_id - unique string ID associated with choice01. If choice01 is selected, its associated ID is passed to the on_ui_event() event handler.
        	choice01 - string for one choice in the list
        	choiceNN_id, choiceNN - subsequent ID/choice pairs to form list of available choices
        	
        	Some sample multiple-choice forms are shown below.
        	
        	(code)
        	device:show_multiple_choice( "Sound",
        	                                 "1", "On",
        	                                 "2", "Off" )
        	device:show_multiple_choice( "Text Size",
        	                                 "1", "Large",
        	                                 "2", "Medium",
        	                                 "3", "Small" )
        	device:show_multiple_choice( "There are unsaved changes",
        	                                 "1", "Close without saving",
        	                                 "2", "Save and close",
        	                                 "3", "Cancel" )
        	(end)
        	
        *Return Value:* true if query and list of choices were displayed, else false
        
        *See Also:* the <has_multiple_choice> property, <clear_ui> function and <on_ui_event> event handler
    */
            
    bool show_multiple_choice(string label,...)
        [[
            StringPairList list;
            
            int count=lua_gettop(L);
            
            for (int i=3;i+1<=count;i+=2)
            {
                const char * id=lua_tostring(L,i);
                const char * choice=lua_tostring(L,i+1);                

                if (id && choice)
                    list.push_back(StringPair(String(id),String(choice)));
            }
            
            result=list.empty()?false:self->get_controller()->show_multiple_choice(label,list);
        ]];

    /*
        Function: clear_ui
        
        The clear_ui() function clears the device's display. For this function to have an effect, one or more of the following properties must be true: <has_multiple_choice>, <has_ui>, <has_text_entry>.
        
        *Arguments:* None
        
        *Return Value:* true if the device's display was cleared, else false
        
        *See Also:* the <show_multiple_choice>, <set_ui_background>, <set_ui_image> and <enter_text> functions
    */
    
    bool clear_ui()
        [[
            result=self->get_controller()->clear_ui();    
        ]];
    
    /*
    	DeprecatedFunction: set_background()
    	
    	*** Deprecated, use set_ui_background() instead
    */
    
    bool set_background(string resource)
        [[
            g_warning("DEPRECATED CALL TO controller:set_background");            
            result=false;
        ]];

    /*
        Function: set_ui_background
        
        The set_ui_background() function instructs the device to set its background to a specified image. The image must already have been declared by calling the <declare_resource> function. If the image does not exactly fit the display, various positioning methods are available. For this function to have an effect, the object's <has_ui> property must be true.
        
        *Arguments:*
        
        	resource - string name of the image resource declared by the declare_resource() function
        	mode - string specifying the positioning method to use if the image does not exactly fit the display. Supported modes are described below.
        	
        *Supported mode Values:*
        
        	"C" - center the image in the display using the image's original size
        	"T" - tile the image both vertically and horizontally to fill the display
        	"STRETCH" - scale the image vertically and horizontally to fill the display. If no mode argument is specified, the Stretch mode is the default.

		*Return Value:* true if the background was set, else false
		
		*See Also:* the <has_ui> property and <set_ui_image> function
    */
    
    bool set_ui_background(string resource, string mode="STRETCH")
        [[
            Controller::UIBackgroundMode m = Controller::STRETCH;
            
            if (mode)
            {
                if (*mode=='C'||*mode=='c')
                {
                    m=Controller::CENTER;
                }
                else if (*mode=='T'||*mode=='t')
                {
                    m=Controller::TILE;
                }
            }
            
            result=self->get_controller()->set_ui_background(resource,m);
        ]];

    /*
        Function: set_ui_image
        
        The set_ui_image() function instructs the device to position an image at specified X,Y coordinates. The image must already have been declared by calling the <declare_resource> function. For this function to have an effect, the <has_ui> property must be true.
               
        The amount of space the image should cover is specified in the function's arguments. When the specified space does not exactly match the image's size, individual systems may process the image differently. For example, the system may scale or clip the image to fill the space or it may display the image at its original size and leave any remaining area blank.

        *Arguments:*
        
        	resource - string name of the image resource declared by the declare_resource() function
        	x, y - X,Y display coordinate at which to place the image. The upper-left corner of the image will be positioned at this location.
        	width - image's numeric width in pixels
        	height - image's numeric height in pixels

		*Return Value:* true if the image was displayed, else false
		
		*See Also:* the <has_ui> property and the <set_ui_background> function        
    */
            
    bool set_ui_image(string resource,int x,int y,int width,int height)
        [[
            result=self->get_controller()->set_ui_image(resource,x,y,width,height);    
        ]];

    /*
        Function: play_sound
        
        The play_sound() function instructs the device to play an audio sound a specified number of times. The sound must already have been declared by calling the <declare_resource> function. For this function to have an effect, the object's <has_sound> property must be true.
        
        *Arguments:*
        
        	resource - string name of the audio resource declared by the declare_resource() function
        	loop - number of times to play the sound. If 0, the sound will play repeatedly until the <stop_sound> function is called.
        	
        *Return Value:* true if the sound was played, else false
        
        *See Also:* the <has_sound> property and the <stop_sound> function
    */
    
    bool play_sound(string resource, int loop)
        [[
            result=self->get_controller()->play_sound(resource,loop);
        ]];

    /*
        Function: stop_sound
        
        The stop_sound() function instructs the device to stop playing an audio sound.
        
        *Arguments:* None
        
        *Return Value:* true if the sound was stopped, else false
    */
    
    bool stop_sound()
        [[
            result=self->get_controller()->stop_sound();
        ]];

    /*
        Function: declare_resource
        
        The declare_resource() function associates a resource, such as an image or an audio file, with a descriptive string. This string is used in subsequent calls that load the resource. A resource can be loaded from either a file or a URL address.
        
        When handing the declare_resource() function, the device may optionally pre-load and cache the referenced resource to eliminate latency issues that may occur when attempting to simultaneously load and process the resource. Alternatively, the device may decide to only link the resource to the specified name at this time, and perform no other processing until it receives a subsequent operation with the resource.

        *Arguments:*

        	resource - string name to associate with the resource. This string is used in subsequent function calls that accept a resource argument, such as the <play_sound>, <set_ui_background>, <set_ui_image> and <request_image> functions.
        	url - string filename or URL address of the resource
        	
        *Return Value:* true if the resource was succesfully processed, else false
        
        *See Also:* the <play_sound>, <set_ui_background>, <set_ui_image> and <request_image> functions
    */

    bool declare_resource(string resource, string url)
        [[
            if ( AppResource r = AppResource( L , url ) )
            {
                result = self->declare_resource( resource , r.get_uri().c_str() ); 
            }
            else
            {
                result = false;
            }
        ]];
        
    /*
        Function: enter_text
        
        The enter_text() function instructs the device to display a user interface for text entry, such as an on-screen keyboard, and then accept user input. For this function to have an effect, the object's <has_text_entry> property must be true.
        
        When the text input is complete and accepted, the <on_ui_event> handler is invoked. The application can hook the handler to retrieve the entered text. 

		*Arguments:*
		
			label - string label or query to display alongside the text-entry field
			text - initial string value of text field. This may be an empty string.
			
		*Return Value:* true if the text-entry screen was displayed, else false
		
		*See Also:* the <has_text_entry> property and <on_ui_event> event handler
    */
            
    bool enter_text(string label,string text)
        [[
            result=self->get_controller()->enter_text(label,text);    
        ]];

    /*
        Function: request_image
        
        The request_image() function instructs the device to send an image to the program. For this function to have an effect, the object's <has_images> property must be true.
        
        When the image is received, the <on_image> event handler is invoked. If the user cancels the process, the <on_image_cancelled> event handler is called. The application can hook these handlers to process the image retrieval or cancel operation.
        
        *Arguments:* All arguments are optional and will use default values if not specified.
        
        	max_dimensions - table specifying the image's maximum width and height in pixels. The table's format is { width, height }. If not specified or if both values are zero, an image of any size is acceptable.
        
			edit - boolean flag indicating whether or not the device may enable the user to edit the image before it is sent (true=user may edit the image). If not specified, the default value is false.
			
			mask - string reference to an image mask to combine with the requested image to form a composite image. The on_image() event handler makes available the resulting composite image. The mask must already have been processed by the <declare_resource> function. The mask string should be the string name that declare_resource() associates with the actual resource. If no mask is desired, specify an empty string (""). If the mask argument is not specified, the mask defaults to an empty string.
			
			dialog_label - string containing the user prompt to place on the device's screen. If not specified, a default prompt of "SendImageToTV" is displayed.
			
			cancel_label - string containing the text label displayed in the Cancel button. If the user selects this button, the on_image_cancelled() event handler is called. If not specified, a default label of "Cancel" is displayed.

		*Return Value:* true if the request was successfully submitted, else false. Note: This value does not indicate whether or not an image was actually received. To determine image reception, hook the on_image() and on_image_cancelled() event handlers.

		*See Also:* the <has_images> property and the <on_image> and <on_image_cancelled> event handlers
    */
            
    bool request_image( table max_dimensions = 0 , bool edit = false , string mask = "", string dialog_label = "SendImageToTV", string cancel_label = "Cancel" )
        [[
            unsigned int max_width = 0;
            unsigned int max_height = 0;

            if ( max_dimensions )
            {
                lua_rawgeti( L , max_dimensions , 1 );
                max_width = lua_tointeger( L , -1 );
                lua_pop( L , 1 );
                lua_rawgeti( L , max_dimensions , 2 );
                max_height = lua_tointeger( L , -1 );
                lua_pop( L , 1 );
            }

            result=self->get_controller()->request_image( max_width , max_height , edit , String( mask ), String( dialog_label ), String( cancel_label ) );
        ]];

    /*
        UndocumentedFunction: request_audio_clip
        
        *** There is currently nothing an application can do with an audio clip, so we won't taunt him with this function.
        
        Tells the controller to send an audio clip. The app will receive the audio clip via <on_audio_clip>.
        If the user cancels the audio selection, the app will receive <on_audio_clip_cancelled>.

        Arguments:

            dialog_label -   This should be a text label to place on the controller's screen
                             as a prompt for the user to select an image or capture a new one.
                             Default value is "Send audio to TV".

            cancel_label -   This should be a text label for the "cancel" button.  Default is
                             "Cancel", but you may wish to relabel this depending on how your app
                             will respond to such a cancellation -- "Use default" might be more
                             appropriate if user cancelling will result in a default image being
                             used instead, for example.

        Returns:
        
            true - If it was successful.
            
            false - Otherwise.      
    */
            
    bool request_audio_clip( string dialog_label = "SendAudioToTV", string cancel_label = "Cancel" )
        [[
            result=self->get_controller()->request_audio_clip( String( dialog_label ), String( cancel_label ) );
        ]];

    /*
        InternalFunction: advanced_ui
        
        *** This function is used by the "Advanced UI" Lua library to communicate with the TakeControl framework running on an external device. It should never be called directly by a TrickPlay application. Therefore, it will remain undocumented to the public.

        The advanced_ui() function provides a gateway from the "Advanced UI" Lua library to the TakeControl framework running on an external device. For this function to have an effect, the object's <has_advanced_ui> property must be true.
        
        The JSON-formatted payload argument is sent to the TakeControl framework, which processes it. Any return data is sent from the device by invoking the <on_advanced_ui_event> event handler.
        
        *Arguments:*
        
        	payload - table of JSON-formatted input data
        	
        *Return Value:* None
        
        *See Also:* the <has_advanced_ui> property and <on_advanced_ui_event> event handler
    */
      
    table advanced_ui( table payload )
        [[
            JSON::Value value = JSON::to_json( L , payload );

            if ( ! value.is<JSON::Array>() && ! value.is<JSON::Object>() )
            {
                lua_pushnil( L );
            }
            else
            {
                String response;

                bool result = self->get_controller()->advanced_ui( value.stringify() , response );

                if ( ! result )
                {
                    lua_pushnil( L );
                }
                else
                {
                    JSON::parse( L , response.c_str() );
                }
            }
        ]];
        
    /*
        Function: show_virtual_remote
        
        The show_virtual_remote() function instructs the device to display a virtual remote control. For this function to have an effect, the object's <has_virtual_remote> property must be true. Input with the virtual remote generates regular key events, processed through the <on_key_up> and <on_key_down> event handlers. The virtual remote can be removed from the display by calling the <hide_virtual_remote> function.
        
        *Arguments:* None
        
        *Return Value:* true if the virtual remote was displayed, else false
        
        *See Also:* the <has_virtual_remote> property and the <hide_virtual_remote> function
    */
    
    bool show_virtual_remote()
        [[
            result = self->get_controller()->show_virtual_remote();
        ]];        

    /*
        Function: hide_virtual_remote
        
        The hide_virtual_remote() function instructs the device to remove the virtual remote control from the display. For this function to have an effect, the object's <has_virtual_remote> property must be true. The virtual remote is displayed by calling the <show_virtual_remote> function.
        
        *Arguments:* None
        
        *Return Value:* true if the virtual remote was removed from the display, else false
        
        *See Also:* the <has_virtual_remote> property and the <show_virtual_remote> function
    */
    
    bool hide_virtual_remote()
        [[
            result = self->get_controller()->hide_virtual_remote();
        ]];        

    /*
        Event Handler: on_disconnected
        
        The on_disconnected() event handler is invoked when the device disconnects from the TrickPlay system.
        
        When a device disconnects, it is removed from the <controllers.connected> table of connected devices. Any variables owned by the application that reference the disconnected device will continue to exist, but attempts to perform operations on the device should fail gracefully by returning false.
        
        *Prototype:*
        
        	(code)
        	void on_disconnected( Controller controller )
        	(end)
        	
        *Arguments:*
        
        	controller - reference to the Controller device that has disconnected
        	
        *Return Value:* None
        
        *See Also:* the <controllers.connected> table of connected devices
    */  
    
    callback on_disconnected;
    
    /*
        Event Handler: on_key_down
        
        The on_key_down() event handler is invoked when a key is pressed or a key on the virtual remote control is pressed.
        
        A key-down event is processed initially by this function--the Controller's on_key_down() event handler. Afterward, the event is normally propagated up the event chain to any objects that have hooked into the <UIElement.on_key_down> event handler.
        
        *Prototype:*
        
        	(code)
        	boolean on_key_down( Controller controller, int key_code, int unicode, int modifiers )
        	(end)
        
        *Arguments:*
        
        	controller - reference to the Controller device that generated the event
        	key_code - key identifier in the <keys> global variable
        	unicode - key's Unicode character value, if any, else zero
        	modifiers - table of <keys.Key Modifiers> pressed in combination with the key_code. If no modifier keys were pressed, set to nil.
        	
        *Return Value:* true to propagate the event up the event chain, else false
        
        *See Also:* the <on_key_up> and <UIElement.on_key_down> event handlers
    */
    
    callback on_key_down;
    
    /*
        Event Handler: on_key_up
        
        The on_key_up() event handler is invoked when a key is released or a key on the virtual remote control is released.
        
        A key-up event is processed initially by this function--the Controller's on_key_up() event handler. Afterward, the event is normally propagated up the event chain to any objects that have hooked into the <UIElement.on_key_up> event handler.
        
        *Prototype:*
        
        	(code)
        	boolean on_key_up( Controller controller, int key_code, int unicode, int modifiers )
        	(end)
        	
        *Arguments:*
        
        	controller - reference to the Controller device that generated the event
        	key_code - key identifier in the <keys> global variable
        	unicode - key's Unicode character value, if any, else zero
        	modifiers - table of <keys.Key Modifiers> pressed in combination with the key_code. If no modifier keys were pressed, set to nil.
        	
        *Return Value:* true to propagate the event up the event chain, else false
        
        *See Also:* the <on_key_down> and <UIElement.on_key_up> event handlers
    */

    callback on_key_up;
    
    /*
        Event Handler: on_accelerometer
        
        The on_accelerometer() event handler is invoked when an accelerometer event occurs.
        
        *Prototype:*
        
        	(code)
        	void on_accelerometer( Controller controller, float x, float y, float z, int modifiers )
        	(end)
        	
        *Arguments:*
        
        	controller - reference to the Controller device that generated the event
        	x, y, z - accelerometer values for each axis
        	modifiers - table of <keys.Key Modifiers> pressed in combination with the accelerometer reading. If no modifier keys were pressed, set to nil.
        	
        *Return Value:* None
        
        *See Also:* the <start_accelerometer> and <stop_accelerometer> functions
    */
    
    callback on_accelerometer;

    /*
        Event Handler: on_pointer_button_down
        
        The on_pointer_button_down() event handler is invoked when a pointer device's button is pressed. For devices with multiple buttons, it is possible to identify which button was pressed.
        
        A pointer-button-down event is processed initially by this function--the Controller's on_pointer_button_down() event handler. Afterward, the event is normally propagated up the event chain to any objects that have hooked into the <UIElement.on_button_down> event handler.
        
        *Prototype:*
        
        	(code)
        	boolean on_pointer_button_down( Controller controller, int button, int x, int y, int modifiers )
        	(end)
        	
        *Arguments:*
        
        	controller - reference to the Controller device that generated the event
        	button - button number, where the first button has button number 1
        	x, y - pointer's X and Y coordinates when the button was pressed
        	modifiers - table of <keys.Key Modifiers> pressed in combination with the button press. If no modifier keys were pressed, set to nil.
        	
        *Return Value:* true to propagate the event up the event chain, else false
        
        *See Also:* the <start_pointer> and <stop_pointer> functions, the <on_pointer_button_up> and <UIElement.on_button_down> event handlers
    */

    callback on_pointer_button_down;

    /*
        Event Handler: on_pointer_move
        
        The on_pointer_move() event handler is invoked when a pointer device moves.
        
        A pointer-move event is processed initially by this function--the Controller's on_pointer_move() event handler. Afterward, the event is normally propagated up the event chain to any objects that have hooked into the <UIElement.on_motion> event handler.
        
        *Prototype:*
        
        	(code)
        	boolean on_pointer_move( Controller controller, int x, int y, int modifiers )
        	(end)
        	
        *Arguments:*
        
        	controller - reference to the Controller device that generated the event
        	x, y - pointer's X, Y coordinate location
        	modifiers - table of <keys.Key Modifiers> pressed in combination with the pointer movement. If no modifier keys were pressed, set to nil.
        	
        *Return Value:* true to propagate the event up the event chain, else false
        
        *See Also:* the <start_pointer> and <stop_pointer> functions and the <UIElement.on_motion> event handler
    */
        
    callback on_pointer_move;

    /*
        Event Handler: on_pointer_button_up
        
        The on_pointer_button_up() event handler is invoked when a pointer device's button is released. For devices with multiple buttons, it is possible to identify which button was released.
        
        A pointer-button_up event is processed initially by this function--the Controller's on_pointer_button_up() event handler. Afterward, the event is normally propagated up the event chain to any objects that have hooked into the <UIElement.on_button_up> event handler.
        
        *Prototype:*
        
        	(code)
        	boolean on_pointer_button_up( Controller controller, int button, int x, int y, int modifiers )
        	(end)
        	
        *Arguments:*
        
        	controller - reference to the Controller device that generated the event
        	button - button's number, where the first button has button number 1
        	x, y - pointer's X and Y coordinates when the button was released
        	modifiers - table of <keys.Key Modifiers> pressed in combination with the button release. If no modifier keys were pressed, set to nil.
        	
        *Return Value:* true to propagate the event up the event chain, else false
        
        *See Also:* the <start_pointer> and <stop_pointer> functions, the <on_pointer_button_down> and <UIElement.on_button_up> event handlers
    */

    callback on_pointer_button_up;

    /*
        Event Handler: on_touch_down
        
        The on_touch_down() event handler is invoked when a finger initially touches the device. Subsequent movements by the finger generate <on_touch_move> events. When the finger is lifted from the device, an <on_touch_up> event occurs.
        
        *Prototype:*
        
        	(code)
        	void on_touch_down( Controller controller, int finger, int x, int y, int modifiers )
        	(end)
        
        *Arguments:*
        
        	controller - reference to the Controller device that generated the event
        	finger - unique ID identifying the finger that has touched the device
        	x, y - finger's X and Y coordinates where the finger touched the device
        	modifiers - table of <keys.Key Modifiers> pressed in combination with the finger-touch. If no modifier keys were pressed, set to nil.
        	
        *Return Value:* None
        
        *See Also:* the <start_touches> and <stop_touches> functions and the <on_touch_up> and <on_touch_move> event handlers
    */
        
    callback on_touch_down;
    
    /*
        Event Handler: on_touch_move
        
        The on_touch_move() event handler is invoked when a finger drags across the device.
        
        *Prototype:*
        
        	(code)
        	void on_touch_move( Controller controller, int finger, int x, int y, int modifiers )
        	(end)
        	
        *Arguments:*
        
        	controller - reference to the Controller device that generated the event
        	finger - unique ID identifying the finger that has touched the device
        	x, y - finger's X and Y coordinates where the finger has moved to
        	modifiers - table of <keys.Key Modifiers> pressed in combination with the finger-movement. If no modifier keys were pressed, set to nil.
        	
        *Return Value:* None
        
        *See Also:* the <start_touches> and <stop_touches> functions and the <on_touch_up> and <on_touch_down> event handlers
    */

    callback on_touch_move;
    
    /*
        Event Handler: on_touch_up
        
        The on_touch_up() event handler is invoked when a finger lifts off the device.
        
        *Prototype:*
        
        	(code)
        	void on_touch_up( Controller controller, int finger, int x, int y, int modifiers )
        	(end)
        	
        *Arguments:*
        
        	controller - reference to the Controller device that generated the event
        	finger - unique ID identifying the finger that has lifted off the device
        	x, y - finger's X and Y coordinates where the finger lifted off the device
        	modifiers - table of <keys.Key Modifiers> pressed in combination with the finger-lift. If no modifier keys were pressed, set to nil.
        	
        *Return Value:* None
        
        *See Also:* the <start_touches> and <stop_touches> functions and the <on_touch_down> and <on_touch_move> event handlers
    */

    callback on_touch_up;
    
    /*
        Event Handler: on_scroll
        
        The on_scroll() event handler is invoked when the scroll wheel is moved.
        
        A scroll event is processed initially by this function--the Controller's on_scroll() event handler. Afterward, the event is normally propagated up the event chain to any objects that have hooked into the <UIElement.on_scroll> event handler.
        
        *Prototype:*
        
        	(code)
        	boolean on_scroll( Controller controller, int direction, int modifiers )
        	(end)
        
        *Arguments:*

            controller - reference to the Controller device that generated the event
            direction - 0 = scrolling up, 1 = scrolling down, 2 = scrolling left, 3 = scrolling right. Note: Some directions may not be supported on a particular scroll wheel.
            modifiers - table of <keys.Key Modifiers> pressed in combination with the scroll wheel movement. If no modifier keys were pressed, set to nil.

        *Return Value:* true to propagate the event up the event chain, else false
        
        *See Also:* the <UIElement.on_scroll> event handler
    */
    
    callback on_scroll;

    /*
        Event Handler: on_ui_event
        
        The on_ui_event() event handler is invoked when the user makes a selection from a <show_multiple_choice> list or when the user has finished entering text for the <enter_text> function. The on_ui_event() handler makes the selection or entered text available to the program.
        
        *Prototype:*
        
        	(code)
        	void on_ui_event( Controller controller, string text )
        	(end)
        	
        *Arguments:*
        
        	controller - reference to the Controller device that generated the event
        	text - string. If the on_ui_event() was invoked in response to a show_multiple_choice() function, the text argument contains the ID of the selected choice. If the event is a response to an enter_text() function, the text argument contains the text the user entered.
        	
        *Return Value:* None
        
        *See Also:* the <show_multiple_choice> and <enter_text> functions
    */
    
    callback on_ui_event;


    /*
        Event Handler: on_image
        
        The on_image() event handler is invoked when an image is received from the device in response to a call to the <request_image> function.
        
        *Prototype:*
        
        	(code)
        	void on_image( Controller controller, Bitmap bitmap )
        	(end)
        	
        *Arguments:*
        
        	controller - reference to the Controller device that generated the event
        	bitmap - <Bitmap> object containing received image
        	
        *Return Value:* None
        
        *See Also:* the <request_image> function
    */

    callback on_image;

    /*
        Event Handler: on_image_cancelled
        
        The on_image_cancelled() event handler is invoked when the user cancels the sending of an image in response to a call to the <request_image> function.
        
        *Prototype:*
        
        	(code)
        	void on_image_cancelled( Controller controller )
        	(end)
        	
        *Arguments:*
        
        	controller - reference to the Controller device that generated the event
        	
        *Return Value:* None
        
        *See Also:* the <request_image> function
    */

    callback on_image_cancelled;

    /*
        UndocumentedEvent Handler: on_audio_clip_cancelled
        
        *** There is currently nothing an application can do with an audio clip, so let's not provoke it by telling it about this event handler.
        
        This is sent when the user cancels sending an audio clip after you use <request_audio_clip>
        
        Arguments:
            controller - The controller that generated the event
    */

    callback on_audio_clip_cancelled;

    /*
        Event Handler: on_advanced_ui_ready
        
        The on_advanced_ui_ready() event handler is invoked when a TrickPlay-enabled device is prepared to connect to a TrickPlay application. At this point, the application can load the necessary libraries to make the connection. Refer to <Interacting with an External Smart Device> for further information.
        
        *Prototype:*

			(code)
			void on_advanced_ui_ready( Controller controller )
			(end)
			
		*Arguments:*
		
			controller - reference to the Controller device that generated the event
			
		*Return Value:* None
		
		*See Also:* the <has_advanced_ui> property
    */

    callback on_advanced_ui_ready;


    /*
        InternalEvent Handler: on_advanced_ui_event
        
        *** This event handler is used by the "Advanced UI" Lua library to communicate with the TakeControl framework. It should never be called directly by a TrickPlay application. Therefore, it will remain undocumented to the public.
        
        The on_advanced_ui_event() event handler is invoked when an "Advanced UI" event has occurred in response to a call to the <advanced_ui> function.
        
        *Prototype:*
        
        	(code)
        	void on_advanced_ui_event( Controller controller, string JSON_data )
        	(end)
        	
        *Arguments:*
        
        	controller - reference to the Controller device that generated the event
        	JSON_data - JSON-formatted text data returned from the device
        	
        *Return Value:* None
        
        *See Also:* the <advanced_ui> function
    */
    
    callback on_advanced_ui_event;
    
    /* TODO:Undocumented. We may want to restrict this one or move it somewhere else */

    bool save_key_map( table map )
        [[

#ifndef TP_PRODUCTION

            Controller::KeyMap km;
    
            lua_pushnil( L );

            while( lua_next( L , map ) )
            {
                if ( lua_isnumber( L , -2 ) && lua_isnumber( L , -1 ) )
                {
                    km.insert( std::make_pair( lua_tonumber( L , -2 ) , lua_tonumber( L , -1 ) ) );
                }
                lua_pop( L , 1 );
            }

            result = self->get_controller()->save_key_map( km );

#else
            result = false;
#endif

        ]];
}



module clutter_actor;

[[
#include "clutter/clutter.h"

#include "util.h"
#include "clutter_util.h"
]]

[[

void actor_on_show(ClutterActor*actor,lua_State*L)
{
	UserData::invoke_callback( G_OBJECT( actor ) , "on_show" , 0 , 0 , L );
}

void actor_on_hide(ClutterActor*actor,lua_State*L)
{
	UserData::invoke_callback( G_OBJECT( actor ) , "on_hide" , 0 , 0 , L );
}
    
void actor_on_key_focus_in(ClutterActor*actor,lua_State*L)
{
	UserData::invoke_callback( G_OBJECT( actor ) , "on_key_focus_in" , 0 , 0 , L );
}

void actor_on_key_focus_out(ClutterActor*actor,lua_State*L)
{
	UserData::invoke_callback( G_OBJECT( actor ) , "on_key_focus_out" , 0 , 0 , L );
}

gboolean actor_on_key_down(ClutterActor*actor,ClutterKeyEvent*event,lua_State*L)
{
    int result = FALSE;
    
    lua_pushinteger(L,event->keyval);
    lua_pushinteger(L,event->unicode_value);
    lua_pushinteger(L,event->time);
    
    if (UserData::invoke_callback( G_OBJECT( actor ) , "on_key_down" , 3 , 1 , L ))    
    {
		if (lua_toboolean(L,-1))
		{
	    	result = TRUE;
	    }
		lua_pop(L,1);
    }

    return result;
}

gboolean actor_on_key_up(ClutterActor*actor,ClutterKeyEvent*event,lua_State*L)
{
    int result = FALSE;
    
    lua_pushinteger(L,event->keyval);
    lua_pushinteger(L,event->unicode_value);
    lua_pushinteger(L,event->time);
    
    if(	UserData::invoke_callback( G_OBJECT( actor ) , "on_key_up" , 3 , 1 , L ))
    {
		if (lua_toboolean(L,-1))
		{
	    	result = TRUE;
	    }
		lua_pop(L,1);
    }

    return result;
}

gboolean actor_on_button_down(ClutterActor*actor,ClutterButtonEvent*event,lua_State*L)
{
    int result = FALSE;

    gdouble x = event->x, y = event->y;
    ClutterUtil::stage_coordinates_to_screen_coordinates(&x, &y);

    lua_pushnumber(L,x);
    lua_pushnumber(L,y);
    lua_pushinteger(L,event->button);
    lua_pushinteger(L,event->click_count);
    
    if(	UserData::invoke_callback( G_OBJECT( actor ) , "on_button_down" , 4 , 1 , L ))
    {
		if (lua_toboolean(L,-1))
		{
	    	result = TRUE;
	    }
		lua_pop(L,1);
    }

    return result;
}

gboolean actor_on_button_up(ClutterActor*actor,ClutterButtonEvent*event,lua_State*L)
{
    int result = FALSE;
    gdouble x = event->x, y = event->y;
    ClutterUtil::stage_coordinates_to_screen_coordinates(&x, &y);

    lua_pushnumber(L,x);
    lua_pushnumber(L,y);
    lua_pushinteger(L,event->button);
    lua_pushinteger(L,event->click_count);
    
    if(	UserData::invoke_callback( G_OBJECT( actor ) , "on_button_up" , 4 , 1 , L ))
    {
		if (lua_toboolean(L,-1))
		{
	    	result = TRUE;
	    }
		lua_pop(L,1);
    }

    return result;
}

gboolean actor_on_motion(ClutterActor*actor,ClutterMotionEvent*event,lua_State*L)
{
    int result = FALSE;
    gdouble x = event->x, y = event->y;
    ClutterUtil::stage_coordinates_to_screen_coordinates(&x, &y);

    lua_pushnumber(L,x);
    lua_pushnumber(L,y);
    
    if(	UserData::invoke_callback( G_OBJECT( actor ) , "on_motion" , 2 , 1 , L ))
    {
		if (lua_toboolean(L,-1))
		{
	    	result = TRUE;
	    }
		lua_pop(L,1);
    }

    return result;
}

gboolean actor_on_scroll(ClutterActor*actor,ClutterScrollEvent*event,lua_State*L)
{
    int result = FALSE;
    gdouble x = event->x, y = event->y;
    ClutterUtil::stage_coordinates_to_screen_coordinates(&x, &y);

    lua_pushnumber(L,x);
    lua_pushnumber(L,y);
    lua_pushinteger(L,event->direction);
    
    if(	UserData::invoke_callback( G_OBJECT( actor ) , "on_scroll" , 3 , 1 , L ))
    {
		if (lua_toboolean(L,-1))
		{
	    	result = TRUE;
	    }
		lua_pop(L,1);
    }

    return result;
}

static void animation_completed(ClutterAnimation * animation,lua_State * L)
{
	ClutterUtil::wrap_concrete_actor(L,CLUTTER_ACTOR(clutter_animation_get_object(animation)));
	
	UserData::invoke_callback(G_OBJECT(animation),"on_completed",1,0,L);
}

]]

interface Animation [[ClutterAnimation*]]
{
	Animation()
		[[
			self = lb_construct_gobject( ClutterAnimation , lua_touserdata( L , -2 ) );
		]];		
}


/*
    Interface: UIElement
    
    This is an interface that is supported by all UI classes, including screen.
 
*/

interface actor [[ClutterActor*]]
{
    /*
	Property: name
	
	Lets you set a name for this element.
    */
    
    string name
        [[name=clutter_actor_get_name(self);]]
        [[clutter_actor_set_name(self,name);]];
    
    /*
	Property: gid
	
	Every UI element has a unique identifier that is assigned automatically.
    */
    
    readonly long gid
        [[gid=clutter_actor_get_gid(self);]];
    
    /*
	Property: x
	
	The x coodinate of the UI element.
    */
    
    double x
        [[ x = clutter_actor_get_x( self ); ]]
        [[ clutter_actor_set_x( self , x ); ]];
    
    /*
	Property: y
	
	The y coordinate of the UI element.
    */
    
    double y
        [[ y = clutter_actor_get_y( self ); ]]
        [[ clutter_actor_set_y( self , y ); ]];
    
    /*
	Property: z
	
	The z coordinate of the UI element. Negative z is farther away.
    */
    
    double z
        [[ z = clutter_actor_get_depth( self ); ]]
        [[ clutter_actor_set_depth( self , z ); ]];

    /*
	Property: depth
	
	Another name for the z coordinate.
    */
    
    double depth
        [[depth=clutter_actor_get_depth(self);]]
        [[clutter_actor_set_depth(self,depth);]];
	
    /*
	Property: w
	
	The width of the UI element.
    */
    
    double w
        [[ w = clutter_actor_get_width( self ); ]]
        [[ clutter_actor_set_width( self , w ); ]];
    
    /*
	Property: h
	
	The height of the UI element.
    */
    
    double h
        [[ h = clutter_actor_get_height( self ); ]]
        [[ clutter_actor_set_height( self , h ); ]];

    /*
	Property: width
	
	Another name for the width of the UI element.
    */
    
    double width
        [[ width = clutter_actor_get_width( self ); ]]
        [[ clutter_actor_set_width( self , width ); ]];
    
    /*
	Property: height
	
	Another name for the height of the UI element.
    */
    
    double height
        [[ height = clutter_actor_get_height( self ); ]]
        [[ clutter_actor_set_height( self , height ); ]];

    /*
	Property: position
	
	A way to set the x and y coordinates of the UI element using a table.
	
	> element.position={10,20}
	
	Is the same as
	
	> element.x=10
	> element.y=20
	
    */
    
    table position
        [[
            lua_newtable(L);
            lua_pushnumber(L,clutter_actor_get_x(self));
            lua_rawseti(L,-2,1);
            lua_pushnumber(L,clutter_actor_get_y(self));
            lua_rawseti(L,-2,2);
            lua_pushnumber(L,clutter_actor_get_depth(self));
	    lua_rawseti(L,-2,3);
        ]]
        [[
            luaL_checktype(L,2,LUA_TTABLE);
            lua_rawgeti(L,2,1);
            lua_rawgeti(L,2,2);
	    lua_rawgeti(L,2,3);
            clutter_actor_set_position(self,lua_tonumber(L,-3),lua_tonumber(L,-2));
	    clutter_actor_set_depth(self,lua_tonumber(L,-1));
            lua_pop(L,3);
        ]];
            
    /*

    Property: center

    Returns a table with the x and y coordinates of the element relative to its
    parent.

    */

    readonly table center
        [[
            gfloat x;
            gfloat y;
            gfloat w;
            gfloat h;
            gfloat ax;
            gfloat ay;

            clutter_actor_get_position(self,&x,&y);
            clutter_actor_get_size(self,&w,&h);
            clutter_actor_get_anchor_point(self,&ax,&ay);

            lua_newtable(L);
            lua_pushnumber(L,x-ax+(w/2));
            lua_rawseti(L,-2,1);
            lua_pushnumber(L,y-ay+(h/2));
            lua_rawseti(L,-2,2);
        ]];


    /*
	Property: anchor_point
	
	The handle to the UI element. All UI elements have their handle set to
	0,0 initially. You can change this using the anchor_point property. A
	common thing to do is to set the anchor point to the center of the UI
	element, like this:
	
	> element.anchor_point={element.w/2,element.h/2}
    */
    
    table anchor_point
        [[
	    gfloat x;
	    gfloat y;
	    clutter_actor_get_anchor_point(self,&x,&y);
            lua_newtable(L);
            lua_pushnumber(L,x);
            lua_rawseti(L,-2,1);
            lua_pushnumber(L,y);
            lua_rawseti(L,-2,2);
        ]]
        [[
            luaL_checktype(L,2,LUA_TTABLE);
            lua_rawgeti(L,2,1);
            lua_rawgeti(L,2,2);	    
            clutter_actor_set_anchor_point(self,lua_tonumber(L,-2),lua_tonumber(L,-1));
            lua_pop(L,2);
        ]];
	
    /*
	Property: size
	
	The width and height of the UI element in a table. 
    */
        
    table size
        [[
            lua_newtable(L);
            lua_pushnumber(L,clutter_actor_get_width(self));
            lua_rawseti(L,-2,1);
            lua_pushnumber(L,clutter_actor_get_height(self));
            lua_rawseti(L,-2,2);
        ]]
        [[
            luaL_checktype(L,2,LUA_TTABLE);
            lua_rawgeti(L,2,1);
            lua_rawgeti(L,2,2);
            clutter_actor_set_size(self,lua_tonumber(L,-2),lua_tonumber(L,-1));
            lua_pop(L,2);
        ]];
        
    /*
	Property: scale
	
	The x and y scale of the UI element. For example, you can double the
	scale of an element like this:
	
	> element.scale={2,2}
    */
    
    table scale
        [[
            gdouble scalex;
            gdouble scaley;
            clutter_actor_get_scale(self,&scalex,&scaley);
            lua_newtable(L);
            lua_pushnumber(L,scalex);
            lua_rawseti(L,-2,1);
            lua_pushnumber(L,scaley);
            lua_rawseti(L,-2,2);
            
            gfloat x;
            gfloat y;
            clutter_actor_get_scale_center(self,&x,&y);
            lua_pushnumber(L,x);
            lua_rawseti(L,-2,3);
            lua_pushnumber(L,y);
            lua_rawseti(L,-2,4);
        ]]
        [[
            luaL_checktype(L,2,LUA_TTABLE);
            lua_rawgeti(L,2,1);
            lua_rawgeti(L,2,2);            
            lua_rawgeti(L,2,3);
            lua_rawgeti(L,2,4);
            if (!lua_isnil(L,-2)&&!lua_isnil(L,-1))
                clutter_actor_set_scale_full(self,lua_tonumber(L,-4),lua_tonumber(L,-3),lua_tonumber(L,-2),lua_tonumber(L,-1));
            else
                clutter_actor_set_scale(self,lua_tonumber(L,-4),lua_tonumber(L,-3));
            lua_pop(L,4);
        ]];
        
    /*
	Property: x_rotation
	
	Rotation about the y axis. This is a table that has 3 entries: the rotation
	angle in degrees, the y coordinate and the z coordinate for the center of
	rotation. You can flip an element about the x axis like this:
	
	> element.x_rotation={-180,element.h,0}		
    */
        
    table x_rotation
        [[
            gfloat x;
            gfloat y;
            gfloat z;
            gdouble angle = clutter_actor_get_rotation(self,CLUTTER_X_AXIS,&x,&y,&z);
            lua_newtable(L);
            lua_pushnumber(L,angle);
            lua_rawseti(L,-2,1);
            lua_pushnumber(L,y);
            lua_rawseti(L,-2,2);
            lua_pushnumber(L,z);
            lua_rawseti(L,-2,3);
        ]]
        [[
            luaL_checktype(L,2,LUA_TTABLE);
            lua_rawgeti(L,2,1);
            lua_rawgeti(L,2,2);
            lua_rawgeti(L,2,3);
            clutter_actor_set_rotation(self,CLUTTER_X_AXIS,lua_tonumber(L,-3),0,lua_tonumber(L,-2),lua_tonumber(L,-1));
            lua_pop(L,3);
        ]];

    /*
	Property: y_rotation
	
	Rotation about the y axis. This is a table that has 3 entries: the rotation
	angle in degrees, the x coordinate and the z coordinate for the center of
	rotation.
    */
    
    table y_rotation
        [[
            gfloat x;
            gfloat y;
            gfloat z;
            gdouble angle = clutter_actor_get_rotation(self,CLUTTER_Y_AXIS,&x,&y,&z);
            lua_newtable(L);
            lua_pushnumber(L,angle);
            lua_rawseti(L,-2,1);
            lua_pushnumber(L,x);
            lua_rawseti(L,-2,2);
            lua_pushnumber(L,z);
            lua_rawseti(L,-2,3);
        ]]
        [[
            luaL_checktype(L,2,LUA_TTABLE);
            lua_rawgeti(L,2,1);
            lua_rawgeti(L,2,2);
            lua_rawgeti(L,2,3);
            clutter_actor_set_rotation(self,CLUTTER_Y_AXIS,lua_tonumber(L,-3),lua_tonumber(L,-2),0,lua_tonumber(L,-1));
            lua_pop(L,3);
        ]];
        
    /*
	Property: z_rotation
	
	Rotation about the z axis. This is a table that has 3 entries: the rotation
	angle in degrees, the x coordinate and the y coordinate for the center of
	rotation.
    */

    table z_rotation
        [[
            gfloat x;
            gfloat y;
            gfloat z;
            gdouble angle = clutter_actor_get_rotation(self,CLUTTER_Z_AXIS,&x,&y,&z);
            lua_newtable(L);
            lua_pushnumber(L,angle);
            lua_rawseti(L,-2,1);
            lua_pushnumber(L,x);
            lua_rawseti(L,-2,2);
            lua_pushnumber(L,y);
            lua_rawseti(L,-2,3);
        ]]
        [[
            luaL_checktype(L,2,LUA_TTABLE);
            lua_rawgeti(L,2,1);
            lua_rawgeti(L,2,2);
            lua_rawgeti(L,2,3);
            clutter_actor_set_rotation(self,CLUTTER_Z_AXIS,lua_tonumber(L,-3),lua_tonumber(L,-2),lua_tonumber(L,-1),0);
            lua_pop(L,3);
        ]];
        
        
    /*
	Property: is_scaled
	
	Returns true if the UI element is scaled.
    */

    readonly bool is_scaled
        [[is_scaled=clutter_actor_is_scaled(self);]];
        
    /*
	Property: is_rotated
	
	Returns true if the UI element is rotated.
    */

    readonly bool is_rotated
        [[is_rotated=clutter_actor_is_rotated(self);]];
        
    /*
	Property: opacity
	
	This is a number that specifies the transparency of a UI element. It
	ranges from 0 (fully transparent) to 255 (fully opaque).
    */

    int opacity
        [[opacity=clutter_actor_get_opacity(self);]]
        [[clutter_actor_set_opacity(self,opacity);]];
        
    /*
	Property: clip
	
	This is a table with x,y,width and height for a clipping rectangle. If
	set, anything painted outside those bounds won't be visible. By
	default, UI elements are not clipped, so their contents can spill outside
	their bounds. You can clip an element like this:
	
	> element.clip={0,0,element.w,element.h}
    */

    table clip
        [[
            if (!clutter_actor_has_clip(self))
            {
                lua_pushnil(L);
            }
            else
            {
                gfloat x;
                gfloat y;
                gfloat w;
                gfloat h;
                clutter_actor_get_clip(self,&x,&y,&w,&h);
                lua_newtable(L);
                lua_pushnumber(L,x);
                lua_rawseti(L,-2,1);
                lua_pushnumber(L,y);
                lua_rawseti(L,-2,2);
                lua_pushnumber(L,w);
                lua_rawseti(L,-2,3);
                lua_pushnumber(L,h);
                lua_rawseti(L,-2,4);
            }
        ]]
        [[
            if (lua_isnil(L,2))
            {
                clutter_actor_remove_clip(self);
            }
            else
            {
                luaL_checktype(L,2,LUA_TTABLE);
                lua_rawgeti(L,2,1);
                lua_rawgeti(L,2,2);
                lua_rawgeti(L,2,3);
                lua_rawgeti(L,2,4);
                clutter_actor_set_clip(self,lua_tonumber(L,-4),lua_tonumber(L,-3),lua_tonumber(L,-2),lua_tonumber(L,-1));
                lua_pop(L,4);
            }
        ]];
        
    /*
	Property: has_clip
	
	Returns true if the element is clipped.
    */

    readonly bool has_clip
        [[has_clip=clutter_actor_has_clip(self);]];
        
    /*
	Property: parent
	
	If this UI element is inside a container, this property returns the
	container. Otherwise, it returns nil.
    */
    
    readonly UIElement parent
	[[ClutterUtil::wrap_concrete_actor(L,clutter_actor_get_parent(self));]];
	

    /*
	Property: reactive
	
	Wether the UI element will react to events.
	
	TODO:explain
    */
    
    bool reactive
	[[reactive=clutter_actor_get_reactive(self);]]
	[[clutter_actor_set_reactive(self,reactive);]];
	
    /*
	Property: transformed_size
	
	This is a table that has the width and height of the UI element after it
	has been transformed. It may be an approximation if the element is rotated.
    */
    
    readonly table transformed_size
	[[
	    gfloat w;
	    gfloat h;
	    clutter_actor_get_transformed_size(self,&w,&h);
	    lua_newtable(L);
	    lua_pushnumber(L,w);
	    lua_rawseti(L,-2,1);
	    lua_pushnumber(L,h);
	    lua_rawseti(L,-2,2);
	]];
	
    /*
	Property: transformed_position
	
	The x and y coordinates of the UI element after it has been transformed.
    */
    
    readonly table transformed_position
	[[
	    gfloat x;
	    gfloat y;
	    clutter_actor_get_transformed_position(self,&x,&y);
	    lua_newtable(L);
	    lua_pushnumber(L,x);
	    lua_rawseti(L,-2,1);
	    lua_pushnumber(L,y);
	    lua_rawseti(L,-2,2);
	]];
	
    /*
	Property: min_size
	
	This is either the preferred size of a UI element or its natural size,
	depending on how the element is transformed.
	
	TODO:explain
    */
    
    readonly table min_size
	[[
	    gfloat mw;
	    gfloat mh;
	    gfloat nw;
	    gfloat nh;
	    
	    clutter_actor_get_preferred_size(self,&mw,&mh,&nw,&nh);
	    lua_newtable(L);
	    lua_pushnumber(L,mw);
	    lua_rawseti(L,-2,1);
	    lua_pushnumber(L,mh);
	    lua_rawseti(L,-2,2);
	]];

    /*
	Property: natural_size
	
	This is the original, or natural size of a UI element. For example, it
	may be an image's orginal size before it was transformed.
    */
    
    readonly table natural_size
	[[
	    gfloat mw;
	    gfloat mh;
	    gfloat nw;
	    gfloat nh;
	    
	    clutter_actor_get_preferred_size(self,&mw,&mh,&nw,&nh);
	    lua_newtable(L);
	    lua_pushnumber(L,nw);
	    lua_rawseti(L,-2,1);
	    lua_pushnumber(L,nh);
	    lua_rawseti(L,-2,2);
	]];
	
    /*
	Property: request_mode
	
	Mostly useful for images, this lets you specify how to resize UI elements.
	It can have one of two values:
	
	"HEIGHT_FOR_WIDTH" - In this case, given a width, the height is
			    computed automatically.
			    
	"WIDTH_FOR_HEIGHT" - Given a new height, the width is calculated.
    */
    
    string request_mode
	[[
	    ClutterRequestMode mode;
	    g_object_get(G_OBJECT(self),"request-mode",&mode,NULL);
	    switch(mode)
	    {
		case CLUTTER_REQUEST_HEIGHT_FOR_WIDTH:
		    request_mode = "HEIGHT_FOR_WIDTH";
		    break;
		case CLUTTER_REQUEST_WIDTH_FOR_HEIGHT:
		    request_mode = "WIDTH_FOR_HEIGHT";
		    break;
		default:
		    request_mode = "";
	    }
	]]
	[[
	    ClutterRequestMode mode = CLUTTER_REQUEST_HEIGHT_FOR_WIDTH;
	    if (!strcmp(request_mode,"HEIGHT_FOR_WIDTH"))
		mode = CLUTTER_REQUEST_HEIGHT_FOR_WIDTH;
	    else if (!strcmp(request_mode,"WIDTH_FOR_HEIGHT"))
		mode = CLUTTER_REQUEST_WIDTH_FOR_HEIGHT;
	    else
		luaL_error(L,"Invalid request mode '%s'",request_mode);
	    g_object_set(G_OBJECT(self),"request-mode",mode,NULL);
	]];

    /*
	Property: is_animating
	
	Returns true if the UI element is being animated using the <animate>
	function.	
    */
    
    readonly bool is_animating
	[[
	    is_animating=clutter_actor_get_animation(self)!=NULL;    
	]];

    /*
    Property: is_visible

    Returns true if the UI element is visible.
    */

    readonly bool is_visible
    [[
        is_visible = CLUTTER_ACTOR_IS_VISIBLE(self);
    ]];

    /*
	Function: set
	
	This allows you to set any properties on a UI element using a table, the
	same way that you construct a UI element. For example:
	
	> element:set{size={100,100},position={10,15}}
	
	Arguments:
	
	props - A table of properties and values to set on the UI element.
	
	Returns:
	
	element - The UI element that it was called on, so you can chain calls.
    */

    UIElement set(table props)
	[[
	    ClutterUtil::set_props_from_table(L,props);
	    lua_pushvalue(L,1);
	]];

    /*
	Function: show
	
	Shows the UI element.
    */

    show()
        [[clutter_actor_show(self);]];
        
    /*
	Function: show_all
	
	Shows the UI element and any children that were previously hidden.
    */

    show_all()
        [[clutter_actor_show_all(self);]];
        
    /*
	Function: hide
	
	Hides the UI element.
    */

    hide()
        [[clutter_actor_hide(self);]];
        
    /*
	Function: hide_all
	
	Hides the UI element and all of its children.
    */

    hide_all()
        [[clutter_actor_hide_all(self);]];
	
    /*
	Function: move_by
	
	Lets you change the position of the element using relative distance.
	
	Arguments:
	
	dx - How many pixels to move in the x direction.
	dy - How many pixels to move in the y direction.
    */

    move_by( double dx , double dy )
	[[clutter_actor_move_by(self,dx,dy);]];
	
    /*
	Function: unparent
	
	If the UI element has a parent, this function removes the element from
	its parent.
    */

    unparent()
	[[
	    if(ClutterActor * parent=clutter_actor_get_parent(self))
	    {
		clutter_container_remove_actor(CLUTTER_CONTAINER(parent),self);
	    }
	]];
	
    /*
	Function: raise
	
	Raises the UI element above the one you pass in.
	
	Arguments:
	
	above - Another UI element that will end up just below this one.
    */

    raise( UIElement above )
	[[
	    ClutterActor* source =ClutterUtil::user_data_to_actor(L,above);
	    if(source)
	    {
		clutter_actor_raise(self,source);
	    }
	]];
	
    /*
	Function: lower
	
	Lowers the UI element below another one.
	
	Arguments:
	
	below - Another UI element that will end up just above this one.
    */

    lower( UIElement below )
	[[
	    ClutterActor* source=ClutterUtil::user_data_to_actor(L,below);
	    if (source)
	    {
		clutter_actor_lower(self,source);
	    }
	]];
	
    /*
	Function: raise_to_top
	
	Raises this element to the top.
    */

    raise_to_top()
	[[
	    clutter_actor_raise_top(self);    
	]];
	
    /*
	Function: lower_to_bottom
	
	Lowers this element to the bottom.
    */

    lower_to_bottom()
	[[
	    clutter_actor_lower_bottom(self);    
	]];
	
    /*
	Function: move_anchor_point
	
	Moves the anchor point to a new position within the UI element without
	moving the UI element.
	
	Arguments:
	
	x - The new x coordinate of the anchor point.
	y - The new y coordinate of the anchor point.
    */

    move_anchor_point( double x , double y )
	[[clutter_actor_move_anchor_point(self,x,y);]];
	
	/*
	Function: transform_point
	
	Transforms a point in this element's coordinate space into the coordinate space of 
	one of its ancestors.
	
	Arguments:
	
	ancestor - An ancestor of this element.
	x , y , z - The coordinates of the point.
	
	
	Returns:
	
	A table with 3 elements corresponding to the coordinates of the transformed point.
	*/
	
	table transform_point( UIElement ancestor, double x , double y , double z = 0 )
		[[
			lua_newtable(L);
			
			ClutterActor * a=ClutterUtil::user_data_to_actor(L,ancestor);
			
			if (a)
			{
				ClutterVertex point_in;
				point_in.x = x;
				point_in.y = y;
				point_in.z = z;
				
				ClutterVertex point_out;
				
				clutter_actor_apply_relative_transform_to_point( self , a , & point_in , & point_out );
				
				lua_pushnumber( L , point_out.x );
				lua_rawseti( L , -2 , 1 );
				lua_pushnumber( L , point_out.y );
				lua_rawseti( L , -2 , 2 );
				lua_pushnumber( L , point_out.z );
				lua_rawseti( L , -2 , 3 );
			}						
		]];  
	
    /*
	Function: grab_key_focus
	
	Causes this element to receive input events. By default, all input events
	are sent to the screen.
    */

    grab_key_focus()
	[[clutter_actor_grab_key_focus(self);]];
	
    
    /*
    Function: blur
    
    This function will apply a blur effect to the UI element.  Reversible with unblur()

    Returns:

        true - The effect was applied.

        false - If the effect is not available.
    */

    bool blur()
    [[
#if CLUTTER_CHECK_VERSION(1,4,0)

        clutter_actor_remove_effect_by_name(self, "blur_effect");
        clutter_actor_add_effect_with_name(self, "blur_effect", clutter_blur_effect_new());
        result = true;
#else
        result = false;
#endif
    ]];

    /*
    Function: unblur
    
    Turn off a blur effect on the UI element.  The opposite of blur()

    Returns:

        true - The effect was applied.

        false - If the effect is not available.
    */

    bool unblur()
    [[
#if CLUTTER_CHECK_VERSION(1,4,0)
        clutter_actor_remove_effect_by_name(self, "blur_effect");
        // Need to force a redraw or it sometimes doesn't update
        clutter_actor_queue_redraw(self);
        result = true;
#else
        result = false;
#endif
    ]];

    /*
	Function: desaturate
	
	How much to desaturate the UI element.  On a scale from 0.0 for fully saturated to 1.0 (default) for fully desaturated.

	Arguments:

        desturation - 0 for fully saturated, 1 for fully desaturated.

    Returns:

        true - The effect was applied.

        false - If the effect is not available.
    */

    bool desaturate(double desaturation)
    [[
#if CLUTTER_CHECK_VERSION(1,4,0)
        clutter_actor_remove_effect_by_name(self, "desaturation_effect");
        clutter_actor_add_effect_with_name(self, "desaturation_effect", clutter_desaturate_effect_new( desaturation ));
        result = true;
#else
        result = false;
#endif
    ]];

    /*
	Function: saturate
	
	Restore saturation to the UI element.  This undoes any call to <desaturate>.

    Returns:

        true - The effect was applied.

        false - If the effect is not available.
    */

    bool saturate()
    [[
#if CLUTTER_CHECK_VERSION(1,4,0)
        clutter_actor_remove_effect_by_name(self, "desaturation_effect");
        result = true;
#else
        result = false;
#endif
    ]];

    /*
    Function: tint
    
    Turn on a tint effect for the UI element.
    
    Arguments:

        color - Required.  The tint color to apply to the UI element.

    Returns:

        true - The effect was applied.

        false - If the effect is not available.
    */

    bool tint(...)
    [[
#if CLUTTER_CHECK_VERSION(1,4,0)
        ClutterColor color;
        ClutterUtil::to_clutter_color(L,2,&color);
        clutter_actor_remove_effect_by_name(self, "tint_effect");
        clutter_actor_add_effect_with_name(self, "tint_effect", clutter_colorize_effect_new( &color ));
        result = true;
#else
        result = false;
#endif
    ]];

    /*
    Function: untint
    
    Turn off any existing tint effect for the UI element.

    Returns:

        true - The effect was applied.

        false - If the effect is not available.
    */

    bool untint()
    [[
#if CLUTTER_CHECK_VERSION(1,4,0)
        clutter_actor_remove_effect_by_name(self, "tint_effect");
        result = true;
#else
        result = false;
#endif
    ]];


    /*
    Function: pageturn
    
    Apply a "page turn" effect to the UIElement.
    
    Arguments:
    
        period - The period of the page curl, between 0.0 (flat) and 1.0 (fully curled) [defaults to 0]

        angle - The angle of the page curl, in degrees, between 0.0 and 360.0 [defaults to 45]

        radius - The radius of the page curl effect, in pixels [defaults to 1/16 width of the UIElement]

    Returns:

        true - The effect was applied.

        false - If the effect is not available.
    */
    
    bool pageturn(double period=0.5, double angle=45, double radius=0)
    [[
#if CLUTTER_CHECK_VERSION(1,4,0)
        if(0 == radius)
        {
            radius = clutter_actor_get_width(self)/16;
        }
        ClutterPageTurnEffect *effect = (ClutterPageTurnEffect *)clutter_actor_get_effect(self, "pageturn_effect");
        if(effect)
        {
            clutter_page_turn_effect_set_period(effect, period);
            clutter_page_turn_effect_set_angle(effect, angle);
            clutter_page_turn_effect_set_radius(effect, radius);
        }
        else
        {
            clutter_actor_add_effect_with_name(self, "pageturn_effect", clutter_page_turn_effect_new(period,angle,radius));
        }
        result = true;
#else
        result = false;
#endif
    ]];

    /*
    Function: pageflatten
    
    Remove any "page turn" effect on the UIElement.

    Returns:

        true - The effect was applied.

        false - If the effect is not available.
    */

    bool pageflatten()
    [[
#if CLUTTER_CHECK_VERSION(1,4,0)
        clutter_actor_remove_effect_by_name(self, "pageturn_effect");
        result = true;
#else
        result = false;
#endif
    ]];

    /*
	Function: animate
	
	This function lets you animate a UI element. The function accepts a table
	with parameters that control the animation, for example:
	
	> element:animate{duration=1000,x=300,opacity=0}
	
	This will move the element to 300 and make it completely transparent
	over a duration of 1 second.
	
	All properties are animated from their current values to the ones you
	specify.
	
	Here are the possible values:
	
	duration - Required. How long the animation will run, in milliseconds.
	
	mode - A string describing the progression of the animation. TODO: explain and list.
	
	loop - If true, the animation will loop forever and will never call the
		on_completed callback.
		
	on_completed - A function that is called when the animation is finished.
	
	x - The final x coordinate for the element.
	
	y - The final y coordinate.
	
	z or depth - The final z coordinate.

	w or width - The final width.
	
	h or height - The final height.

	opacity - The final opacity of the element (0-255).
	
	position - An alternative way to specify both x and y as a table.
	
	size - An alternative way to specify both width and height as a table.
	
	scale - A table with two values, one for the final x scale and another for
		the final y scale of the element.
		
	x_rotation - The final angle of rotation around the x axis.
	
	y_rotation - The final angle of rotation around the y axis.
	
	z_rotation - The final angle of rotation around the z axis.	
    */

    Animation animate(table props)
	[[
	    lua_getfield(L,props,"duration");
	    guint duration=lua_tonumber(L,-1);
	    lua_pop(L,1);
	    
	    if ( duration <= 0 )
	    {
	    	lua_pushnil( L );
	    	luaL_error( L , "Call to animate has invalid or missing duration" );
	    	return 1; 
	    }
	    
	    lua_getfield(L,props,"mode");
	    gulong mode=ClutterUtil::to_clutter_animation_mode(lua_tostring(L,-1));
	    lua_pop(L,1);
	    
	    GPtrArray * names=g_ptr_array_new_with_free_func(g_free);
	    GValueArray * values=g_value_array_new(6);
	    
	    lua_pushnil(L);
	    
	    while(lua_next(L,props))
	    {
		GValue value={0};
		
		if (lua_isstring(L,-2)&&!lua_isnil(L,-2))
		{
		    const char * k=lua_tostring(L,-2);
		
		    if (!strcmp("x",k)||!strcmp("y",k))
		    {
			g_value_init(&value,G_TYPE_FLOAT);
			g_value_set_float(&value,lua_tonumber(L,-1));
			g_ptr_array_add(names,g_strdup(k));
			g_value_array_append(values,&value);
		    }
		    else if (!strcmp("w",k)||!strcmp("width",k))
		    {
			g_value_init(&value,G_TYPE_FLOAT);
			g_value_set_float(&value,lua_tonumber(L,-1));
			g_ptr_array_add(names,g_strdup("width"));
			g_value_array_append(values,&value);
		    }
		    else if (!strcmp("h",k)||!strcmp("height",k))
		    {
			g_value_init(&value,G_TYPE_FLOAT);
			g_value_set_float(&value,lua_tonumber(L,-1));
			g_ptr_array_add(names,g_strdup("height"));
			g_value_array_append(values,&value);
		    }
		    else if (!strcmp("z",k)||!strcmp("depth",k))
		    {
			g_value_init(&value,G_TYPE_FLOAT);
			g_value_set_float(&value,lua_tonumber(L,-1));			
			g_ptr_array_add(names,g_strdup("depth"));
			g_value_array_append(values,&value);			
		    }
		    else if (!strcmp("opacity",k))
		    {
			g_value_init(&value,G_TYPE_UCHAR);
			g_value_set_uchar(&value,lua_tointeger(L,-1));
			g_ptr_array_add(names,g_strdup(k));
			g_value_array_append(values,&value);
		    }
		    else if (!strcmp("position",k))
		    {
			if (lua_type(L,-1)==LUA_TTABLE)
			{
			    g_ptr_array_add(names,g_strdup("x"));
			    g_ptr_array_add(names,g_strdup("y"));
			    
			    lua_rawgeti(L,-1,1);
			    g_value_init(&value,G_TYPE_FLOAT);
			    g_value_set_float(&value,lua_tonumber(L,-1));
			    g_value_array_append(values,&value);			    
			    lua_pop(L,1);
			    
			    lua_rawgeti(L,-1,2);
			    g_value_unset(&value);
			    g_value_init(&value,G_TYPE_FLOAT);
			    g_value_set_float(&value,lua_tonumber(L,-1));
			    g_value_array_append(values,&value);
			    lua_pop(L,1);
			}
		    }
		    else if (!strcmp("size",k))
		    {
			if (lua_type(L,-1)==LUA_TTABLE)
			{
			    g_ptr_array_add(names,g_strdup("width"));
			    g_ptr_array_add(names,g_strdup("height"));
			    
			    lua_rawgeti(L,-1,1);
			    g_value_init(&value,G_TYPE_FLOAT);
			    g_value_set_float(&value,lua_tonumber(L,-1));
			    g_value_array_append(values,&value);			    
			    lua_pop(L,1);
			    
			    lua_rawgeti(L,-1,2);
			    g_value_unset(&value);
			    g_value_init(&value,G_TYPE_FLOAT);
			    g_value_set_float(&value,lua_tonumber(L,-1));
			    g_value_array_append(values,&value);
			    lua_pop(L,1);
			}			
		    }
		    else if (!strcmp("scale",k))
		    {
			if (lua_type(L,-1)==LUA_TTABLE)
			{
			    g_ptr_array_add(names,g_strdup("scale-x"));
			    g_ptr_array_add(names,g_strdup("scale-y"));
			    
			    lua_rawgeti(L,-1,1);
			    g_value_init(&value,G_TYPE_DOUBLE);
			    g_value_set_double(&value,lua_tonumber(L,-1));
			    g_value_array_append(values,&value);			    
			    lua_pop(L,1);
			    
			    lua_rawgeti(L,-1,2);
			    g_value_unset(&value);
			    g_value_init(&value,G_TYPE_DOUBLE);
			    g_value_set_double(&value,lua_tonumber(L,-1));
			    g_value_array_append(values,&value);
			    lua_pop(L,1);
			}			
		    }
		    else if (!strcmp("x_rotation",k))
		    {
			if (lua_type(L,-1)==LUA_TTABLE)
			{
			    
			}
			else
			{
			    g_ptr_array_add(names,g_strdup("rotation-angle-x"));
			    g_value_init(&value,G_TYPE_DOUBLE);
			    g_value_set_double(&value,lua_tonumber(L,-1));
			    g_value_array_append(values,&value);
			}
		    }
		    else if (!strcmp("y_rotation",k))
		    {
			if (lua_type(L,-1)==LUA_TTABLE)
			{
			    
			}
			else
			{
			    g_ptr_array_add(names,g_strdup("rotation-angle-y"));
			    g_value_init(&value,G_TYPE_DOUBLE);
			    g_value_set_double(&value,lua_tonumber(L,-1));
			    g_value_array_append(values,&value);
			}
		    }
		    else if (!strcmp("z_rotation",k))
		    {
			if (lua_type(L,-1)==LUA_TTABLE)
			{
			    
			}
			else
			{
			    g_ptr_array_add(names,g_strdup("rotation-angle-z"));
			    g_value_init(&value,G_TYPE_DOUBLE);
			    g_value_set_double(&value,lua_tonumber(L,-1));
			    g_value_array_append(values,&value);
			}
		    }
		}
		
		lua_pop(L,1);
	    }
	    
	    if ( values->n_values == 0 )
	    {
		    g_value_array_free(values);
		    g_ptr_array_free(names,TRUE);
		    lua_pushnil( L );
		    luaL_error( L , "Call to animate has no properties" );
		    return 1;
	    }
	    
	    ClutterAnimation * a=clutter_actor_animatev(self,mode,duration,
							values->n_values,
							(gchar**)names->pdata,
							values->values);
							
		if ( ! a )
		{
			lua_pushnil( L );
		}					
		else
		{	
			UserData * ud = UserData::get( G_OBJECT( a ) );
			
			if ( ud )
			{
				ud->push_proxy();
			}
			else
			{			 
				g_object_ref( a );
								
				lua_pushlightuserdata( L , a );
				new_Animation( L );
				lua_remove( L , -2 );
			}
			
			int animation = lua_gettop( L );						
		    
		    lua_getfield(L,props,"loop");
		    
		    if (!lua_isnil(L,-1))
		    {
				clutter_animation_set_loop(a,lua_toboolean(L,-1));
		    }
		    lua_pop(L,1);
		    
		    // If you call animate several times, clutter reuses the same
		    // ClutterAnimation object. So, if we are not set to loop,
		    // and the user passed an "on_completed" function, we may have
		    // to unref the old function and disconnect the old handler.
		    
		    if (!clutter_animation_get_loop(a))
		    {
				lua_getfield(L,props,"on_completed");
				
				if (lua_type(L,-1)==LUA_TFUNCTION)
				{
					UserData::set_callback( "on_completed" , L , animation , -1 );
					
					UserData * ud = UserData::get( L , animation );
					
					ud->connect_signal( "on_completed" , "completed" , G_CALLBACK( animation_completed ) , L , G_CONNECT_AFTER ); 							
				}
				else
				{
				    lua_pop(L,1);
				}
		    }
		}
			    
	    g_value_array_free(values);
	    g_ptr_array_free(names,TRUE);
	]];
	
	
    /*
	Function: complete_animation
	
	If the element is being animated using the <animate> function, you can
	finish it early by calling complete_animation. All properties that were
	animated will receive their final values and the on_completed callback,
	if you set one, will be called.
	
	Returns:
	
	true - If the element was being animated.
	false - Otherwise.
	
    */

    bool complete_animation()
	[[
	    ClutterAnimation * animation=clutter_actor_get_animation(self);
	    if (animation)
	    {
		clutter_animation_completed(animation);
		result=true;
	    }
	    else
	    {
		result=false;
	    }
	]];
	
    /*
	Event: on_key_focus_in
	
	This event is fired whenever this UI element receives key focus.
	
	Arguments:
	
	self - The UI element.
    */

    callback on_key_focus_in
	[[
		UserData::get(L)->connect_signal_if( 
	    	on_key_focus_in,
	    	"on_key_focus_in",
			"key-focus-in",
			G_CALLBACK(actor_on_key_focus_in),
			L);
	]];

    /*
	Event: on_key_focus_out
	
	This event is fired when the UI element loses key focus.
	
	Arguments:
	
	self - The UI element.
    */

    callback on_key_focus_out
	[[
		UserData::get(L)->connect_signal_if( 
			on_key_focus_out,
			"on_key_focus_out",
			"key-focus-out",
			G_CALLBACK(actor_on_key_focus_out),
			L);
	]];
	
    /*
	Event: on_key_down
	
	This event fires when the element receives a key down.
	
	Arguments:
	
	self - The actor that received the event.
	keyval - An integer key value. This can be compared with the <keys> global.
	unicode - The unicode character, if any.
	time - The time at which the event was generated.
	
    */

    callback on_key_down
	[[
		UserData::get(L)->connect_signal_if( 
			on_key_down,
			"on_key_down",
			"key-press-event",
			G_CALLBACK(actor_on_key_down),
			L);	    
	]];
	
    /*
	Event: on_key_up
	
	This event fires when the element receives a key up.
	
	Arguments:
	
	self - The actor that received the event.
	keyval - An integer key value. This can be compared with the <keys> global.
	unicode - The unicode character, if any.
	time - The time at which the event was generated.
	
    */

    callback on_key_up
	[[
		UserData::get(L)->connect_signal_if( 
			on_key_up,
			"on_key_up",
			"key-release-event",
			G_CALLBACK(actor_on_key_up),
			L);	    
	]];
	
    callback on_scroll
	[[
		UserData::get(L)->connect_signal_if( 
			on_scroll,
			"on_scroll",
			"scroll-event",
			G_CALLBACK(actor_on_scroll),
			L);	    
	]];
	
    callback on_button_down
	[[
		UserData::get(L)->connect_signal_if( 
			on_button_down,
			"on_button_down",
			"button-press-event",
			G_CALLBACK(actor_on_button_down),
			L);	    
	]];
	
    callback on_button_up
	[[
		UserData::get(L)->connect_signal_if( 
			on_button_up,
			"on_button_up",
			"button-release-event",
			G_CALLBACK(actor_on_button_up),
			L);	    
	]];
	
	callback on_motion
	[[
		UserData::get(L)->connect_signal_if( 
			on_motion,
			"on_motion",
			"motion-event",
			G_CALLBACK(actor_on_motion),
			L);	    
	]];

    /*
	Event: on_show
	
	This event fires when the UI element is shown.
	
	Arguments:
	
	self - The UI element.
    */
    
    callback on_show
	[[
		UserData::get(L)->connect_signal_if( 
			on_show,
			"on_show",
			"show",
			G_CALLBACK(actor_on_show),
			L);	    	    
	]];
	
    /*
	Event: on_hide
	
	This event fires when the UI element is hidden.
	
	Arguments:
	
	self - The UI element.
    */
    
    callback on_hide
	[[
		UserData::get(L)->connect_signal_if( 
			on_hide,
			"on_hide",
			"hide",
			G_CALLBACK(actor_on_hide),
			L);	    	    
	]];
}

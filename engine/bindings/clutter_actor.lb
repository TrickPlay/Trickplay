module clutter_actor;

[[
#include "tp-clutter.h"
#include "util.h"
#include "clutter_util.h"
#include "context.h"


static const gchar *property_from_setter_name(const gchar *setter_name)
{
    static const gchar *property;
    if(property)
    {
        g_free((gpointer)property);
    }

    // We call setters x_rotation, etc.  Clutter calls those properties rotation-angle-x, etc.
    if(strstr(setter_name, "_rotation"))
    {
        property = g_strdup_printf("rotation-angle-%c", setter_name[0]);
    }
    else
    {
        property = g_strdup(setter_name);
    }

    return property;
}

typedef bool (* PropertyFunction) (ClutterActor *, const char *property, void *);

static bool for_each_property(ClutterActor *actor, lua_State *L, PropertyFunction my_func, void *param)
{
    bool result = false;

    // Get the table of setters from the user_data
    if (luaL_getmetafield(L,1,"__setters__"))
    {
        int setters=lua_gettop(L);


        lua_pushnil(L);
        while(lua_next(L,setters))          // pops old key, pushes next key and value
        {
            lua_pop(L,1);                   // throw away the value (function)

            const gchar * property = property_from_setter_name(lua_tostring(L, -1));

            result |= my_func(actor, property, param);

        }
        lua_pop(L,1);                       // pop the setters table
    }
    else
    {
        luaL_error(L, "THERE WAS NO SETTERS TABLE FOUND");
    }

    return result;
}

static bool is_animating_check_function(ClutterActor *actor, const char *prop, void *)
{
    return (clutter_actor_get_transition(actor, prop) != NULL);
}

static bool complete_animation_function(ClutterActor *actor, const char *prop, void *)
{
    ClutterTimeline *transition = CLUTTER_TIMELINE(clutter_actor_get_transition(actor, prop));
    if(transition)
    {
        clutter_timeline_advance( transition, clutter_timeline_get_duration( transition ) );

        return true;
    }

    return false;
}

static bool stop_animation_function(ClutterActor *actor, const char *prop, void *)
{
    ClutterTimeline *transition = CLUTTER_TIMELINE(clutter_actor_get_transition(actor, prop));
    if(transition)
    {
        clutter_timeline_pause( transition );

        clutter_actor_remove_transition( actor, prop );
        return true;
    }

    return false;
}

static void actor_on_show(ClutterActor*actor,lua_State*L)
{
    UserData::invoke_callbacks( G_OBJECT( actor ) , "on_show" , 0 , 0 , L );
}

static void actor_on_hide(ClutterActor*actor,lua_State*L)
{
    UserData::invoke_callbacks( G_OBJECT( actor ) , "on_hide" , 0 , 0 , L );
}

static void actor_on_key_focus_in(ClutterActor*actor,lua_State*L)
{
    UserData::invoke_callbacks( G_OBJECT( actor ) , "on_key_focus_in" , 0 , 0 , L );
}

static void actor_on_key_focus_out(ClutterActor*actor,lua_State*L)
{
    UserData::invoke_callbacks( G_OBJECT( actor ) , "on_key_focus_out" , 0 , 0 , L );
}

static void actor_on_parent_changed( ClutterActor * actor , ClutterActor * old_parent , lua_State * L )
{
    ClutterUtil::wrap_concrete_actor( L , old_parent );

    UserData::invoke_callbacks( G_OBJECT( actor ) , "on_parent_changed" , 1 , 0 , L );
}

static gboolean actor_on_key_down(ClutterActor*actor,ClutterKeyEvent*event,lua_State*L)
{
    int result = FALSE;

    lua_pushinteger(L,event->keyval);
    lua_pushinteger(L,event->unicode_value);
    lua_pushinteger(L,event->time);
    ClutterUtil::push_event_modifiers( L , ( ClutterEvent * ) event );

    if (UserData::invoke_callbacks( G_OBJECT( actor ) , "on_key_down" , 4 , 1 , L ))
    {
        if (lua_toboolean(L,-1))
        {
            result = TRUE;
        }
        lua_pop(L,1);
    }

    return result;
}

static gboolean actor_on_key_up(ClutterActor*actor,ClutterKeyEvent*event,lua_State*L)
{
    int result = FALSE;

    lua_pushinteger(L,event->keyval);
    lua_pushinteger(L,event->unicode_value);
    lua_pushinteger(L,event->time);
    ClutterUtil::push_event_modifiers( L , ( ClutterEvent * ) event );

    if(    UserData::invoke_callbacks( G_OBJECT( actor ) , "on_key_up" , 4 , 1 , L ))
    {
        if (lua_toboolean(L,-1))
        {
            result = TRUE;
        }
        lua_pop(L,1);
    }

    return result;
}

static gboolean actor_on_button_down(ClutterActor*actor,ClutterButtonEvent*event,lua_State*L)
{
    int result = FALSE;

    gdouble x = event->x, y = event->y;
    ClutterUtil::stage_coordinates_to_screen_coordinates( App::get(L)->get_context()->get_stage(), &x, &y);

    lua_pushnumber(L,x);
    lua_pushnumber(L,y);
    lua_pushinteger(L,event->button);
    lua_pushinteger(L,event->click_count > 1 ? event->click_count - 1 : 1 );
    ClutterUtil::push_event_modifiers( L , ( ClutterEvent * ) event );

    if(    UserData::invoke_callbacks( G_OBJECT( actor ) , "on_button_down" , 5 , 1 , L ))
    {
        if (lua_toboolean(L,-1))
        {
            result = TRUE;
        }
        lua_pop(L,1);
    }

    return result;
}

static gboolean actor_on_button_up(ClutterActor*actor,ClutterButtonEvent*event,lua_State*L)
{
    int result = FALSE;
    gdouble x = event->x, y = event->y;
    ClutterUtil::stage_coordinates_to_screen_coordinates(App::get(L)->get_context()->get_stage(), &x, &y);

    lua_pushnumber(L,x);
    lua_pushnumber(L,y);
    lua_pushinteger(L,event->button);
    lua_pushinteger(L,event->click_count > 1 ? event->click_count - 1 : 1 );
    ClutterUtil::push_event_modifiers( L , ( ClutterEvent * ) event );

    if(    UserData::invoke_callbacks( G_OBJECT( actor ) , "on_button_up" , 5 , 1 , L ))
    {
        if (lua_toboolean(L,-1))
        {
            result = TRUE;
        }
        lua_pop(L,1);
    }

    return result;
}

static gboolean actor_on_motion(ClutterActor*actor,ClutterMotionEvent*event,lua_State*L)
{
    int result = FALSE;
    gdouble x = event->x, y = event->y;
    ClutterUtil::stage_coordinates_to_screen_coordinates(App::get(L)->get_context()->get_stage(), &x, &y);

    lua_pushnumber(L,x);
    lua_pushnumber(L,y);
    ClutterUtil::push_event_modifiers( L , ( ClutterEvent * ) event );

    if(    UserData::invoke_callbacks( G_OBJECT( actor ) , "on_motion" , 3 , 1 , L ))
    {
        if (lua_toboolean(L,-1))
        {
            result = TRUE;
        }
        lua_pop(L,1);
    }

    return result;
}

static gboolean actor_on_scroll(ClutterActor*actor,ClutterScrollEvent*event,lua_State*L)
{
    int result = FALSE;
    gdouble x = event->x, y = event->y;
    ClutterUtil::stage_coordinates_to_screen_coordinates(App::get(L)->get_context()->get_stage(), &x, &y);

    lua_pushnumber(L,x);
    lua_pushnumber(L,y);
    lua_pushinteger(L,event->direction);
    ClutterUtil::push_event_modifiers( L , ( ClutterEvent * ) event );

    if(    UserData::invoke_callbacks( G_OBJECT( actor ) , "on_scroll" , 4 , 1 , L ))
    {
        if (lua_toboolean(L,-1))
        {
            result = TRUE;
        }
        lua_pop(L,1);
    }

    return result;
}

static gboolean actor_on_enter(ClutterActor*actor,ClutterCrossingEvent*event,lua_State*L)
{
    int result = FALSE;
    gdouble x = event->x, y = event->y;
    ClutterUtil::stage_coordinates_to_screen_coordinates(App::get(L)->get_context()->get_stage(), &x, &y);

    lua_pushnumber(L,x);
    lua_pushnumber(L,y);

    if( UserData::invoke_callbacks( G_OBJECT( actor ) , "on_enter" , 2 , 1 , L ))
    {
        if (lua_toboolean(L,-1))
        {
            result = TRUE;
        }
        lua_pop(L,1);
    }

    return result;
}

static gboolean actor_on_leave(ClutterActor*actor,ClutterCrossingEvent*event,lua_State*L)
{
    int result = FALSE;
    gdouble x = event->x, y = event->y;
    ClutterUtil::stage_coordinates_to_screen_coordinates(App::get(L)->get_context()->get_stage(), &x, &y);

    lua_pushnumber(L,x);
    lua_pushnumber(L,y);

    if( UserData::invoke_callbacks( G_OBJECT( actor ) , "on_leave" , 2 , 1 , L ))
    {
        if (lua_toboolean(L,-1))
        {
            result = TRUE;
        }
        lua_pop(L,1);
    }

    return result;
}

#ifdef CLUTTER_VERSION_1_10
static void transitions_completed(ClutterActor * actor, lua_State *L)
{
    ClutterUtil::wrap_concrete_actor(L, actor);

    UserData::invoke_callback(G_OBJECT(actor), "on_completed",1,0,L);
}

#else

static void animation_completed(ClutterAnimation * animation,lua_State * L)
{
    ClutterUtil::wrap_concrete_actor(L,CLUTTER_ACTOR(clutter_animation_get_object(animation)));

    UserData::invoke_callback(G_OBJECT(animation),"on_completed",1,0,L);
}

#endif

]]

interface Animation [[ClutterAnimation*]]
{
    Animation()
        [[
            self = lb_construct_gobject( ClutterAnimation , lua_touserdata( L , -2 ) );
        ]];
}


/***************************************
    Interface: UIElement

    The UIElement defines a group of basic foundational properties and functions that are implemented by most of the TrickPlay data types, including <Rectangle>, <Image>, <Text>, and others.

*/

interface actor [[ClutterActor*]]
{

/***************************************
    Property: name

    The name property specifies a string identifier for the object. The name should be unique.

    The name property is used by the <Container.find_child> function when searching for a particular UIElement object stored in a Container.

    *Default Setting:* nil

    *See Also:* the <Container.find_child> function
*/

    string name
        [[name=clutter_actor_get_name(self);]]
        [[clutter_actor_set_name(self,name);]];

/***************************************
    Property: gid

    The gid property is a globally unique string for each instance of a UIElement object. The maximum number of characters in the gid string is 31. The gid is assigned automatically when the UIElement object is created.
*/

    readonly string gid
        [[
            char gid_str[32];
            snprintf( gid_str, 32, "%p", self );
            gid=gid_str;
        ]];

/***************************************
    Property: x

    The x property specifies the object's X coordinate location relative to its parent, which is usually the global <screen at file:clutter_screen-lb.html#Screen> variable. The property's unit of measure is pixels. The X coordinate's value does not take into account any transformations, such as rotation or scaling.

    *Default Setting:* 0

    *See Also:* the <y>, <z>, <depth> and <position> properties
*/

    double x
        [[ x = clutter_actor_get_x( self ); ]]
        [[ clutter_actor_set_x( self , x ); ]];

/***************************************
    Property: y

    The y property specifies the object's Y coordinate location relative to its parent, which is usually the global <screen at file:clutter_screen-lb.html#Screen> variable. The property's unit of measure is pixels. The Y coordinate's value does not take into account any transformations, such as rotation or scaling.

    *Default Setting:* 0

    *See Also:* the <x>, <z>, <depth> and <position> properties
*/

    double y
        [[ y = clutter_actor_get_y( self ); ]]
        [[ clutter_actor_set_y( self , y ); ]];

/***************************************
    Property: z

    The z property specifies the object's Z coordinate location relative to its parent, which is usually the global <screen at file:clutter_screen-lb.html#Screen> variable. Positive values move toward the viewer along the Z-axis; negative values move farther away. The Z coordinate's value does not take into account any transformations, such as rotation or scaling.

    The <depth> property sets and retrieves the same Z coordinate.

    *Default Setting:* 0

    *See Also:* the <x>, <y>, <depth> and <position> properties
*/

    double z
        [[
#ifdef CLUTTER_VERSION_1_12
            z = clutter_actor_get_z_position( self );
#else
            z = clutter_actor_get_depth( self );
#endif
        ]]
        [[
#ifdef CLUTTER_VERSION_1_12
            clutter_actor_set_z_position( self, z );
#else
            clutter_actor_set_depth( self, z );
#endif
        ]];

/***************************************
    Property: depth

    The depth property specifies the object's Z coordinate. It stores and retrieves the same value as the UIElement's z property. Refer to the <z> property for additional information.

    *See Also:* the <x>, <y>, <z> and <position> properties
*/

    double depth
        [[
#ifdef CLUTTER_VERSION_1_12
            depth = clutter_actor_get_z_position( self );
#else
            depth = clutter_actor_get_depth(self);
#endif
        ]]
        [[
#ifdef CLUTTER_VERSION_1_12
            clutter_actor_set_z_position( self, depth );
#else
            clutter_actor_set_depth( self, depth );
#endif
        ]];

/***************************************
    Property: position

    The position property is a table of three integer values specifying the object's X, Y and Z coordinates, respectively.

    The <x>, <y> and <z> properties will return the same coordinate values.

    *Format:* { x-coordinate, y-coodinate, z-coordinate }

    *See Also:* the <x>, <y>, <z> and <depth> properties
*/

    table position
        [[
            lua_newtable(L);
            lua_pushnumber(L,clutter_actor_get_x(self));
            lua_rawseti(L,-2,1);
            lua_pushnumber(L,clutter_actor_get_y(self));
            lua_rawseti(L,-2,2);
#ifdef CLUTTER_VERSION_1_12
            lua_pushnumber(L,clutter_actor_get_z_position(self));
#else
            lua_pushnumber(L,clutter_actor_get_depth(self));
#endif
        lua_rawseti(L,-2,3);
        ]]
        [[
            luaL_checktype(L,2,LUA_TTABLE);
            lua_rawgeti(L,2,1);
            lua_rawgeti(L,2,2);
            lua_rawgeti(L,2,3);
            clutter_actor_set_position(self,lua_tonumber(L,-3),lua_tonumber(L,-2));
            if ( lua_isnumber( L , -1 ) )
            {
#ifdef CLUTTER_VERSION_1_12
               clutter_actor_set_z_position(self, lua_tonumber(L, -1));
#else
               clutter_actor_set_depth(self,lua_tonumber(L,-1));
#endif
            }

            lua_pop(L,3);
        ]];

/***************************************
    Property: w

    The w property specifies the object's width in pixels.

    The <width> property will return the same value.

    *See Also:* the <width>, <h>, <height> and <size> properties
*/

    double w
        [[ w = clutter_actor_get_width( self ); ]]
        [[ clutter_actor_set_width( self , w ); ]];

/***************************************
    Property: h

    The h property specifies the object's height in pixels.

    The <height> property will return the same value.

    *See Also:* the <height>, <w>, <width> and <size> properties
*/

    double h
        [[ h = clutter_actor_get_height( self ); ]]
        [[ clutter_actor_set_height( self , h ); ]];

/***************************************
    Property: width

    The width property specifies the object's width in pixels.

    The <w> property will return the same value.

    *See Also:* the <w>, <h>, <height> and <size> properties
*/

    double width
        [[ width = clutter_actor_get_width( self ); ]]
        [[ clutter_actor_set_width( self , width ); ]];

/***************************************
    Property: height

    The height property specifies the object's height in pixels.

    The <h> property will return the same value.

    *See Also:* the <h>, <w>, <width> and <size> properties
*/

    double height
        [[ height = clutter_actor_get_height( self ); ]]
        [[ clutter_actor_set_height( self , height ); ]];

/***************************************
    Property: size

    The size property is a table that specifies the object's width and height, respectively.

    The <w>, <width>, <h> and <height> properties return the same width and height values as the size property.

    *Format:* { width, height }

    *See Also:* the <w>, <width>, <h> and <height> properties
*/

    table size
        [[
            lua_newtable(L);
            lua_pushnumber(L,clutter_actor_get_width(self));
            lua_rawseti(L,-2,1);
            lua_pushnumber(L,clutter_actor_get_height(self));
            lua_rawseti(L,-2,2);
        ]]
        [[
            luaL_checktype(L,2,LUA_TTABLE);
            lua_rawgeti(L,2,1);
            lua_rawgeti(L,2,2);
            clutter_actor_set_size(self,lua_tonumber(L,-2),lua_tonumber(L,-1));
            lua_pop(L,2);
        ]];

/***************************************
    Property: center

    The center property is a table specifying the X and Y coordinates, respectively, of the object's center, relative to its parent, which is usually the screen.

    *Format:* { x-coordinate, y-coordinate }

    *See Also:* the <position> and <size> properties
*/

    readonly table center
        [[
            gfloat x;
            gfloat y;
            gfloat w;
            gfloat h;
            gfloat ax;
            gfloat ay;

            clutter_actor_get_position(self,&x,&y);
            clutter_actor_get_size(self,&w,&h);
            clutter_actor_get_anchor_point(self,&ax,&ay);

            lua_newtable(L);
            lua_pushnumber(L,x-ax+(w/2));
            lua_rawseti(L,-2,1);
            lua_pushnumber(L,y-ay+(h/2));
            lua_rawseti(L,-2,2);
        ]];


/***************************************
    Property: anchor_point

    The anchor_point property is a table specifying X,Y offsets from the object's upper-left corner. An object's anchor point is used to position, scale and rotate the object.

    Because the anchor point is used to position the object, changing the offsets in the anchor_point property causes the object to move so the new anchor point remains located at the object's X and Y position. To change the anchor point without moving the object (but, instead, changing the object's X and Y coordinates), use the <move_anchor_point> function.

    It is possible to set the anchor point anywhere, including outside the object's boundary.

    *Format:* { X-axis offset, Y-axis offset }

    *Default Setting:* { 0, 0 }, i.e., the object's top-left corner

    *Code Example:* Set the object's anchor point to the object's center

        (code)
        myObject.anchor_point = { myObject.width / 2, myObject.height / 2 }
        (end)

    *See Also:* the <position> property and the <move_anchor_point> function
*/

    table anchor_point
        [[
        gfloat x;
        gfloat y;
        clutter_actor_get_anchor_point(self,&x,&y);
            lua_newtable(L);
            lua_pushnumber(L,x);
            lua_rawseti(L,-2,1);
            lua_pushnumber(L,y);
            lua_rawseti(L,-2,2);
        ]]
        [[
            luaL_checktype(L,2,LUA_TTABLE);
            lua_rawgeti(L,2,1);
            lua_rawgeti(L,2,2);
            clutter_actor_set_anchor_point(self,lua_tonumber(L,-2),lua_tonumber(L,-1));
            lua_pop(L,2);
        ]];

/***************************************
    Property: scale

    The scale property is a table of four numeric values specifying the object's X/Y scale factor and X/Y scaling-center coordinates. The scaling-center coordinates are specified in pixels and are relative to the object's anchor point, which is usually 0, 0.

    When setting the scale property, the scaling-center coordinates are optional and, if not specified, default to 0, 0, i.e., the object's default anchor point.

    To maintain the object's aspect ratio, scale the object's X and Y factors by the same amount. In such cases, the scale property can be specified as a single numeric value, rather than a table, as shown below.

        (code)
        -- Double the object's size, maintaining its aspect ratio
        myObject.scale = 2

        -- Equivalent method using a table
        myObject.scale = { 2, 2 }
        (end)

    *Format:* { X_scale_factor, Y_scale_factor, X_center_coordinate, Y_center_coordinate }

    *Default Setting:* { 1, 1, 0, 0 }

    *See Also:* the <anchor_point> and <is_scaled> properties
*/

    table scale
        [[
            gdouble scalex;
            gdouble scaley;
            clutter_actor_get_scale(self,&scalex,&scaley);
            lua_newtable(L);
            lua_pushnumber(L,scalex);
            lua_rawseti(L,-2,1);
            lua_pushnumber(L,scaley);
            lua_rawseti(L,-2,2);

            gfloat x;
            gfloat y;
            clutter_actor_get_scale_center(self,&x,&y);
            lua_pushnumber(L,x);
            lua_rawseti(L,-2,3);
            lua_pushnumber(L,y);
            lua_rawseti(L,-2,4);
        ]]
        [[
            if ( lua_isnumber( L , 2 ) )
            {
                gfloat scale = lua_tonumber( L , 2 );
                clutter_actor_set_scale( self , scale , scale );
            }
            else
            {
                luaL_checktype(L,2,LUA_TTABLE);
                lua_rawgeti(L,2,1);
                lua_rawgeti(L,2,2);
                lua_rawgeti(L,2,3);
                lua_rawgeti(L,2,4);
                if (!lua_isnil(L,-2)&&!lua_isnil(L,-1))
                    clutter_actor_set_scale_full(self,lua_tonumber(L,-4),lua_tonumber(L,-3),lua_tonumber(L,-2),lua_tonumber(L,-1));
                else
                    clutter_actor_set_scale(self,lua_tonumber(L,-4),lua_tonumber(L,-3));
                lua_pop(L,4);
            }
        ]];

/***************************************
    Property: x_rotation

    The x_rotation property is a table containing the rotation angle and Y and Z coordinates, respectively; the table's contents specify the object's rotation around the X axis. The rotation angle is specified in degrees; positive degrees rotate in a clockwise direction, negative degrees rotate counter-clockwise. The Y and Z coordinates specify the center of the rotation; the coordinates are relative to the object's anchor point.

    *Format:* { rotation_angle, y-coordinate, z-coordinate }

    *Code Example:* Flip the object horizontally to display its mirror image.

        (code)
        -- Flip 180 degrees around object's horizontal center
        myObject.x_rotation = { 180, 0, 0 }
        (end)

    *See Also:* the <y_rotation> and <z_rotation> properties
*/

    table x_rotation
        [[
            gfloat x;
            gfloat y;
            gfloat z;
            gdouble angle = clutter_actor_get_rotation(self,CLUTTER_X_AXIS,&x,&y,&z);
            lua_newtable(L);
            lua_pushnumber(L,angle);
            lua_rawseti(L,-2,1);
            lua_pushnumber(L,y);
            lua_rawseti(L,-2,2);
            lua_pushnumber(L,z);
            lua_rawseti(L,-2,3);
        ]]
        [[
            if(lua_type(L,2) == LUA_TTABLE)
            {
            lua_rawgeti(L,2,1);
            lua_rawgeti(L,2,2);
            lua_rawgeti(L,2,3);
            clutter_actor_set_rotation(self,CLUTTER_X_AXIS,lua_tonumber(L,-3),0,lua_tonumber(L,-2),lua_tonumber(L,-1));
            lua_pop(L,3);
            }
            else
            {
                luaL_checktype(L,2,LUA_TNUMBER);
                gfloat x;
                gfloat y;
                gfloat z;
                (void)clutter_actor_get_rotation(self,CLUTTER_X_AXIS,&x,&y,&z);
                clutter_actor_set_rotation(self,CLUTTER_X_AXIS,lua_tonumber(L,2),x,y,z);
            }
        ]];

/***************************************
    Property: y_rotation

    The y_rotation property is a table containing the rotation angle and X and Z coordinates, respectively; the table's contents specify the object's rotation around the Y axis. The rotation angle is specified in degrees; positive degrees rotate in a clockwise direction, negative degrees rotate counter-clockwise. The X and Z coordinates specify the center of the rotation; the coordinates are relative to the object's anchor point.

    *Format:* { rotation_angle, x-coordinate, z-coordinate }

    *Code Example:* Flip the object vertically to display its mirror image.

        (code)
        -- Flip 180 degrees around object's vertical center
        myObject.y_rotation = { 180, 0, 0 }
        (end)

    *See Also:* the <x_rotation> and <z_rotation> properties
*/

    table y_rotation
        [[
            gfloat x;
            gfloat y;
            gfloat z;
            gdouble angle = clutter_actor_get_rotation(self,CLUTTER_Y_AXIS,&x,&y,&z);
            lua_newtable(L);
            lua_pushnumber(L,angle);
            lua_rawseti(L,-2,1);
            lua_pushnumber(L,x);
            lua_rawseti(L,-2,2);
            lua_pushnumber(L,z);
            lua_rawseti(L,-2,3);
        ]]
        [[
            if(lua_type(L,2) == LUA_TTABLE)
            {
            lua_rawgeti(L,2,1);
            lua_rawgeti(L,2,2);
            lua_rawgeti(L,2,3);
            clutter_actor_set_rotation(self,CLUTTER_Y_AXIS,lua_tonumber(L,-3),lua_tonumber(L,-2),0,lua_tonumber(L,-1));
            lua_pop(L,3);
            }
            else
            {
                luaL_checktype(L,2,LUA_TNUMBER);
                gfloat x;
                gfloat y;
                gfloat z;
                (void)clutter_actor_get_rotation(self,CLUTTER_Y_AXIS,&x,&y,&z);
                clutter_actor_set_rotation(self,CLUTTER_Y_AXIS,lua_tonumber(L,2),x,y,z);
            }
        ]];

/***************************************
    Property: z_rotation

    The z_rotation property is a table containing the rotation angle and X and Y coordinates, respectively; the table's contents specify the object's rotation around the Z axis. The rotation angle is specified in degrees; positive degrees rotate in a clockwise direction, negative degrees rotate counter-clockwise. The X and Y coordinates specify the center of the rotation; the coordinates are relative to the object's anchor point.

    *Format:* { rotation_angle, x-coordinate, y-coordinate }

    *Code Example:* Rotate the object along the z-axis to display its image upside-down.

        (code)
        -- Rotate 180 degrees around object's horizontal and vertical centers
        myObject.z_rotation = { 180, 0, 0 }
        (end)

    *See Also:* the <x_rotation> and <y_rotation> properties
*/

    table z_rotation
        [[
            gfloat x;
            gfloat y;
            gfloat z;
            gdouble angle = clutter_actor_get_rotation(self,CLUTTER_Z_AXIS,&x,&y,&z);
            lua_newtable(L);
            lua_pushnumber(L,angle);
            lua_rawseti(L,-2,1);
            lua_pushnumber(L,x);
            lua_rawseti(L,-2,2);
            lua_pushnumber(L,y);
            lua_rawseti(L,-2,3);
        ]]
        [[
            if(lua_type(L,2) == LUA_TTABLE)
            {
            lua_rawgeti(L,2,1);
            lua_rawgeti(L,2,2);
            lua_rawgeti(L,2,3);
            clutter_actor_set_rotation(self,CLUTTER_Z_AXIS,lua_tonumber(L,-3),lua_tonumber(L,-2),lua_tonumber(L,-1),0);
            lua_pop(L,3);
            }
            else
            {
                luaL_checktype(L,2,LUA_TNUMBER);
                gfloat x;
                gfloat y;
                gfloat z;
                (void)clutter_actor_get_rotation(self,CLUTTER_Z_AXIS,&x,&y,&z);
                clutter_actor_set_rotation(self,CLUTTER_Z_AXIS,lua_tonumber(L,2),x,y,z);
            }
        ]];


/***************************************
    Property: is_scaled

    The is_scaled property is a boolean value indicating whether or not the object is scaled in any dimension (true = scaled).

    *Default Setting:* false (object is not scaled)

    *See Also:* the <scale> property
*/

    readonly bool is_scaled
        [[is_scaled=clutter_actor_is_scaled(self);]];

/***************************************
    Property: is_rotated

    The is_rotated property is a boolean value indicating whether or not the object is rotated (true = rotated).

    *See Also:* the <x_rotation>, <y_rotation> and <z_rotation> properties
*/

    readonly bool is_rotated
        [[is_rotated=clutter_actor_is_rotated(self);]];

/***************************************
    Property: opacity

    The opacity property is an integer value specifying the object's opacity/transparency setting; valid settings are from 0 (completely transparent) to 255 (completely opaque), inclusive.

    *Valid Settings:* 0..255 (completely transparent..completely opaque)

    *Default Setting:* 255 (completely opaque)

    *See Also:* the <is_visible> property and the <show> and <hide> functions
*/

    int opacity
        [[opacity=clutter_actor_get_opacity(self);]]
        [[clutter_actor_set_opacity(self,opacity);]];

/***************************************
    Property: clip

    The clip property is a table specifying the object's clipping rectangle. The table's format is { X origin, Y origin, width, height }. All values are measured in pixels.

    By default, objects are not clipped, even if output is placed beyond the object's width and height boundaries. To activate clipping, define a clipping rectangle in the clip property.

    Retrieving the clip property when there is no clipping rectangle defined, returns a value of nil.

    To clear a defined clipping rectangle and deactivate clipping, set the clip property to a value of nil.

    *Format:* { X origin, Y origin, width, height }

    *Default Setting:* nil (clipping does not occur)

    *Code Examples:*

        (code)
        -- Define a clipping rectangle around the object's normal boundaries
        myObject.clip = { 0, 0, myObject.width, myObject.height }
        (end)

        (code)
        -- Clear the clipping rectangle and deactivate clipping
        myObject.clip = nil
        (end)

    *See Also:* the <has_clip> property
*/

    table clip
        [[
            if (!clutter_actor_has_clip(self))
            {
                lua_pushnil(L);
            }
            else
            {
                gfloat x;
                gfloat y;
                gfloat w;
                gfloat h;
                clutter_actor_get_clip(self,&x,&y,&w,&h);
                lua_newtable(L);
                lua_pushnumber(L,x);
                lua_rawseti(L,-2,1);
                lua_pushnumber(L,y);
                lua_rawseti(L,-2,2);
                lua_pushnumber(L,w);
                lua_rawseti(L,-2,3);
                lua_pushnumber(L,h);
                lua_rawseti(L,-2,4);
            }
        ]]
        [[
            if (lua_isnil(L,2))
            {
                clutter_actor_remove_clip(self);
            }
            else
            {
                luaL_checktype(L,2,LUA_TTABLE);
                lua_rawgeti(L,2,1);
                lua_rawgeti(L,2,2);
                lua_rawgeti(L,2,3);
                lua_rawgeti(L,2,4);
                clutter_actor_set_clip(self,lua_tonumber(L,-4),lua_tonumber(L,-3),lua_tonumber(L,-2),lua_tonumber(L,-1));
                lua_pop(L,4);
            }
        ]];

/***************************************
    Property: has_clip

    The has_clip property is a boolean value specifying whether or not the object has enabled clipping. Clipping can be enabled by either defining a clipping rectangle via the <clip> property or setting the clip_to_size property to true.

    *Default Setting:* false (clipping is not enabled)

    *See Also:* the <clip> and <clip_to_size> properties
*/

    readonly bool has_clip
        [[
            has_clip=clutter_actor_has_clip(self) || clutter_actor_get_clip_to_allocation(self);
        ]];

/***************************************
    Property: clip_to_size

    The clip_to_size property is a boolean value that enables and disables clipping on a <Group at file:clutter_group-lb.html> object. By default, objects within a Group can be displayed outside of the Group's defined size. To enable clipping to the Group's defined size, set the clip_to_size property to true.

    Clipping on a Group object can also be enabled by defining a clipping rectangle via the <clip> property.

    The clip_to_size property affects objects of type Group only; it has no effect on other object types.

    *Default Setting:* false (clipping in the Group is disabled)

    *See Also:* the <Group at file:clutter_group-lb.html> class and the <clip> and <has_clip> properties
*/

    bool clip_to_size
        [[
            clip_to_size = clutter_actor_get_clip_to_allocation( self );
        ]]
        [[
            clutter_actor_set_clip_to_allocation( self , clip_to_size );
        ]];

/***************************************
    Property: parent

    The parent property contains the parent UIElement object of the current object. An object has a parent if it is contained within a <Group at file:clutter_group-lb.html#Group> or has been added to the <screen at file:clutter_screen-lb.html#screen> global variable. If the object has no parent, the parent property contains nil.

    An object cannot be added to a Group by setting its parent property. To add an object to a Group, call the Group object's <add at file:clutter_container-lb.html#Container.add> function.

    *Default Setting:* nil (the object has no parent)

    *See Also:* the Container interface's <add at file:clutter_container-lb.html#Container.add> function
*/

    readonly UIElement parent
    [[ClutterUtil::wrap_concrete_actor(L,clutter_actor_get_parent(self));]];


/***************************************
    Property: reactive

    The reactive property is a boolean value specifying whether or not the object should send pointer events and receive mouse and scroll wheel events (true = send pointer events and receive mouse and scroll wheel events).

    Mouse events include button clicks, including the <on_button_down> and <on_button_up> events. Scroll wheel events (such as the <on_scroll> event) occur when the wheel moves in any direction. Pointer events include motion notifications and enter-element and leave-element events (the <on_motion>, <on_enter> and <on_leave> events, respectively).

    Scroll wheel events are enabled by setting the object's reactive property to true. To receive mouse events and send pointer events, two steps are required: (1) set the object's reactive property to true and (2) start mouse and pointer events by calling the global <controllers.start_pointer> function.

    *Default Setting:* false (the object neither receives mouse/scroll wheel events nor sends pointer events)

    *See Also:* the <on_button_down>, <on_button_up>, <on_motion>, <on_scroll>, <on_enter> and <on_leave> events
*/

    bool reactive
    [[reactive=clutter_actor_get_reactive(self);]]
    [[clutter_actor_set_reactive(self,reactive);]];

/***************************************
    Property: transformed_size

    The transformed_size property is a table that contains the width and height in pixels of the object; the values take into account any transformations applied to the object.

    If the object has been rotated on its X and/or Y axes, the resulting object will be a quadrangle with sides of unequal lengths. In such cases, the values in the transformed_size property specify a rectangle large enough to contain the entire quadrangle. One side effect of this is that the X, Y position of the rectangle, as specified in the <transformed_position> property, may not contain the actual coordinates of the quadrangle.

    *Note:* The transformed_size property is nil until the object has been added to the global <screen> variable.

    *Format:* { transformed_width, transformed_height }

    *See Also:* the <transformed_position> property and the <transform_point> function
*/

    readonly table transformed_size
    [[
        if(CLUTTER_ACTOR_IS_REALIZED(self))
        {
        gfloat w;
        gfloat h;
        clutter_actor_get_transformed_size(self,&w,&h);
        lua_newtable(L);
        lua_pushnumber(L,w);
        lua_rawseti(L,-2,1);
        lua_pushnumber(L,h);
        lua_rawseti(L,-2,2);
        }
        else
        {
            lua_pushnil(L);
        }
    ]];

/***************************************
    Property: transformed_position

    The transformed_position property is a table that contains the X and Y coordinates in pixels of the object's location taking into account any transformations applied to the object.

    If the object has been rotated on its X and/or Y axes, the resulting object will be a quadrangle with sides of unequal lengths. The transformed_position property specifies the X, Y coordinates of a rectangle large enough to contain the entire quadrangle. Depending upon the nature of the quadrangle, its X, Y position coordinates may not be identical to those of the enclosing rectangle.

    *Note:* The transformed_position property is nil until the object has been added to the global <screen> variable.

    *Format:* { transformed_X, transformed_Y }

    *See Also:* the <transformed_size> property and the <transform_point> function
*/

    readonly table transformed_position
    [[
        if(CLUTTER_ACTOR_IS_REALIZED(self))
        {
        gfloat x;
        gfloat y;
        clutter_actor_get_transformed_position(self,&x,&y);
        lua_newtable(L);
        lua_pushnumber(L,x);
        lua_rawseti(L,-2,1);
        lua_pushnumber(L,y);
        lua_rawseti(L,-2,2);
        }
        else
        {
            lua_pushnil(L);
        }
    ]];

/***************************************
    UndocumentedProperty: min_size

    This property seems to be associated with build-it-yourself type layout managers, which TrickPlay does not support. Until further information is discovered, this property will remain undocumented.

    This is either the preferred size of a UI element or its natural size, depending on how the element is transformed.
*/

    readonly table min_size
    [[
        gfloat mw;
        gfloat mh;
        gfloat nw;
        gfloat nh;

        clutter_actor_get_preferred_size(self,&mw,&mh,&nw,&nh);
        lua_newtable(L);
        lua_pushnumber(L,mw);
        lua_rawseti(L,-2,1);
        lua_pushnumber(L,mh);
        lua_rawseti(L,-2,2);
    ]];

/***************************************
    UndocumentedProperty: natural_size

    This property seems to be associated with build-it-yourself type layout managers, which TrickPlay does not support. Until further information is discovered, this property will remain undocumented.

    This is the original, or natural size of a UI element. For example, it may be an image's orginal size before it was transformed.
*/

    readonly table natural_size
    [[
        gfloat mw;
        gfloat mh;
        gfloat nw;
        gfloat nh;

        clutter_actor_get_preferred_size(self,&mw,&mh,&nw,&nh);
        lua_newtable(L);
        lua_pushnumber(L,nw);
        lua_rawseti(L,-2,1);
        lua_pushnumber(L,nh);
        lua_rawseti(L,-2,2);
    ]];


/***************************************
    UndocumentedProperty: request_mode

    This property seems to be associated with build-it-yourself type layout managers, which TrickPlay does not support. Until further information is discovered, this property will remain undocumented.

    Mostly useful for images, this lets you specify how to resize UI elements. It can have one of two values:

    HEIGHT_FOR_WIDTH - In this case, given a width, the height is computed automatically. Default setting.

    WIDTH_FOR_HEIGHT - Given a new height, the width is calculated.
*/

    string request_mode
    [[
        ClutterRequestMode mode;
        g_object_get(G_OBJECT(self),"request-mode",&mode,NULL);
        switch(mode)
        {
        case CLUTTER_REQUEST_HEIGHT_FOR_WIDTH:
            request_mode = "HEIGHT_FOR_WIDTH";
            break;
        case CLUTTER_REQUEST_WIDTH_FOR_HEIGHT:
            request_mode = "WIDTH_FOR_HEIGHT";
            break;
        default:
            request_mode = "";
        }
    ]]
    [[
        ClutterRequestMode mode = CLUTTER_REQUEST_HEIGHT_FOR_WIDTH;
        if (!strcmp(request_mode,"HEIGHT_FOR_WIDTH"))
        mode = CLUTTER_REQUEST_HEIGHT_FOR_WIDTH;
        else if (!strcmp(request_mode,"WIDTH_FOR_HEIGHT"))
        mode = CLUTTER_REQUEST_WIDTH_FOR_HEIGHT;
        else
        luaL_error(L,"Invalid request mode '%s'",request_mode);
        g_object_set(G_OBJECT(self),"request-mode",mode,NULL);
    ]];

/***************************************
    Property: is_visible

    The is_visible property is a boolean value specifying whether the object is shown or hidden (true = shown).

    If the object uses the <show> and <hide> functions to determine its visibility, the is_visible property will accurately represent the object's current state.

    If the object uses the <opacity> property to determine its visibility, e.g., sets opacity to 0 to make itself completely transparent/invisible, then the is_visible property may not return the expected state. If the opacity is set to zero, the object is still shown -- even though it happens to be completely transparent-- and thus is_visible returns true. To determine if the object is visible in such cases, check the current value of the opacity property (if equal to zero, object is not visible, else is visible).

    *Default Setting:* true (object is shown)

    *See Also:* the <show> and <hide> functions
*/

    readonly bool is_visible
    [[
        is_visible = CLUTTER_ACTOR_IS_VISIBLE(self);
    ]];

    bool visible
        [[
            visible = CLUTTER_ACTOR_IS_VISIBLE(self);
        ]]
        [[
            if ( visible )
            {
                clutter_actor_show( self );
            }
            else
            {
                clutter_actor_hide( self );
            }
        ]];

/***************************************
    Property: is_animating

    The is_animating property is a boolean value specifying whether or not the object is currently running an animation started by the <animate> function (true = running an animation).

    *Default Setting:* false

    *See Also:* the <animate> and <is_property_animating> functions
*/

    readonly bool is_animating
    [[
#ifdef CLUTTER_VERSION_1_10
        is_animating =  for_each_property(self,L,is_animating_check_function,NULL);
#else
        is_animating=clutter_actor_get_animation(self)!=NULL;
#endif
    ]];

/***************************************
    Function: set

    The set() function enables the setting of multiple properties using a table. The syntax used is identical to that used when initializing property values during object creation and is shown below.

    *Arguments:*

        props - table of properties and settings. One or more table entries can be specified. Each entry is separated by a comma. Table entries use the following syntax:

            (code)
            propertyName = propertySetting
            (end)

    *Return Value:*

        UIElement - returns the modified object

    *Code Examples:* Sample calls to the set() function

        (code)
        myObject:set( { name = "OkButton" } )
        myObject:set( { size = { 100, 100 }, position = { 10, 15 } } )
        myObject:set( { opacity = 255, x = 200, y = 300, size = { 100, 100 } } )
        (end)
*/

    UIElement set(table props)
    [[
        ClutterUtil::set_props_from_table(L,props);
        lua_pushvalue(L,1);
    ]];

/***************************************
    Function: show

    The show() function makes the object "shown" on the screen. Note: The object will be shown, but it may not be visible, depending upon its <opacity> setting and any obstructing objects in front of it.

    If the object has children, the show() function does not apply to them. To show the object and its children, call the <show_all> function.

    By default, objects on the screen are shown.

    To show an object on the display, it should be added to the <screen at file:clutter_screen-lb.html#Screen> global variable. Refer to the Code Example below for a demonstration.

    *Return Value:* None

    *Code Example:* Create a Rectangle object, add it to the screen, and then show it

        (code)
        myRect = Rectangle{ color    = { 255, 0, 0, 255 },
                            position = { 600, 100, 0 },
                            size     = { 100, 250 } }
        screen:add( myRect )
        myRect:show()
        (end)

    *See Also:* the <is_visible> property and the <show_all> and <hide> functions
*/

    show()
        [[clutter_actor_show(self);]];

/***************************************
    Function: show_all

    The show_all() function makes the object and all its children "shown" on the screen. Note: The object(s) will be shown, but they may not be visible, depending upon their <opacity> settings and any obstructing objects in front of them.

    To show only the parent object and not its children, call the <show> function.

    By default, objects on the screen are shown.

    To show an object on the display, it should be added to the <screen at file:clutter_screen-lb.html#Screen> global variable. Refer to the Code Example in the <show> function for a demonstration.

    *Return Value:* None

    *See Also:* the <is_visible> property and the <show> and <hide_all> functions
*/

    show_all()
        [[
#ifndef CLUTTER_VERSION_1_10
            clutter_actor_show_all(self);
#else
            clutter_actor_show(self);
#endif
        ]];

/***************************************
    Function: hide

    The hide() function prevents the object from showing on the screen. To show the object on the screen again, call the <show> function.

    If the object has children, the hide() function does not apply to them. To hide the object and its children, call the <hide_all> function.

    By default, objects on the screen are shown.

    *Return Value:* None

    *Code Example:* Create a Rectangle object, show it on the screen, hide it, then show it again

        (code)
        myRect = Rectangle{ color    = { 255, 0, 0, 255 },
                            position = { 600, 100, 0 },
                            size     = { 100, 250 } }
        screen:add( myRect )
        myRect:show()

        -- ... Do some operations, then hide the object
        myRect:hide()

        -- ... Do some more operations, then show the object again
        myRect:show()
        (end)

    *See Also:* the <is_visible> property and the <hide_all> and <show> functions
*/

    hide()
        [[clutter_actor_hide(self);]];

/***************************************
    Function: hide_all

    The hide_all() function prevents the object and all its children from showing on the screen. To show the object and its children again, call the <show_all> function.

    To hide only the parent object and not its children, call the <hide> function.

    By default, objects on the screen are shown.

    *Return Value:* None

    *See Also:* the <is_visible> property and the <hide> and <show_all> functions
*/

    hide_all()
        [[
#ifndef CLUTTER_VERSION_1_10
            clutter_actor_hide_all(self);
#else
            clutter_actor_hide(self);
#endif
        ]];

/***************************************
    Function: move_by

    The move_by() function moves the object a specified number of pixels along the X and Y axes. The function's arguments are relative to the object's current location.

    Changing the object's anchor point will also move the object.

    *Arguments:*

        dx - number of pixels to move along the x-axis. Value is relative to the object's current location.
        dy - number of pixels to move along the y-axis. Value is relative to the object's current location.

    *Return Value:* None

    *Code Example:* Move an object a few pixels along the x and y axes

        (code)
        -- Move object 10 pixels to the right (along x-axis) and 20 pixels up (along the y-axis)
        myObject.move_by( 10, -20 )
        (end)

    *See Also:* the <x>, <y>, <position> and <anchor_point> properties
*/

    move_by( double dx, double dy )
    [[clutter_actor_move_by(self,dx,dy);]];

/***************************************
    Function: unparent

    The unparent() function removes the object from its parent, such as the screen or a Group object.

    Another method to remove an object from its parent is to call the Container remove() function.

    To define a parent for the object, call the Container add() function.

    *Return Value:* None

    *See Also:* the <Container.add> and <Container.remove> functions
*/

    unparent()
    [[
        if(ClutterActor * parent=clutter_actor_get_parent(self))
        {
#ifdef CLUTTER_VERSION_1_10
        clutter_actor_remove_child( parent, self );
#else
        clutter_container_remove_actor(CLUTTER_CONTAINER(parent),self);
#endif
        }
    ]];

/***************************************
    Function: raise

    The raise() function moves the object within its group (usually the screen) so that the object is located immediately in front of the specified object. Both objects must belong to the same group (either the <screen at file:clutter_screen-lb.html#screen> or a <Group at file:clutter_group-lb.html#Group> object).

    To better understand what the raise() function does, think of it as a move_before() operation, where the calling object will be moved immediately in front of the argument object. The discussion below will explain this in more detail.

    *Argument:*

        above - a UIElement object in the group. The calling object will be placed immediately in front of this object.

    *Return Value:* None

    There are two factors that determine how objects are positioned in depth relative to each other on the screen or in any other type of Group: first, their positions along the Z-axis and, second, their positions within the group's <Container.children> table.

    An object's location along the Z-axis is the first determining factor. Objects with a <z> setting of zero are positioned directly on the display plane. Objects with negative z settings are positioned further back along the Z-axis, away from the display; they will also appear smaller than objects of the same size that have larger z settings. Objects with positive z settings are located in front of the display plane and will appear larger than objects of the same size that have lower z settings. By default, objects have z settings of zero.

    The three squares shown below are actually the same size, but because they are located at different points along the Z-axis, they appear to have different sizes.

    (see uiElementRaiseZaxis.png)

    Objects that have the same z setting are further organized based upon their order within the group; objects at the end of the group's children table are positioned *in front of* objects earlier in the list. That may seem counter-intuitive, at first. To repeat: Objects at the end of the children table are positioned in front of objects at the beginning of the table. The relationship between an object's position within the children table and its depth order is shown in the children table below. As a final note, when an object is added to a group, it is appended to the end of the group's list, i.e, in *front* of any other objects in the group with the same z setting.

    (see uiElementRaiseChildren.png)

    Of these two ordering factors, the location along the Z-axis takes precedence. When multiple objects have the same z value, their position within the group determines their final ordering.

    When an object calls the raise() function, it can affect both its z setting and its position within the group. First, if the z settings of the moving object and the argument objects are different, the moving object is assigned the argument object's z setting. This change to the moving object's z setting occurs regardless of its original setting; the moving object may already be located on the Z-axis in front of the argument object, but it will still be assigned the argument object's z setting. Then, the moving object is positioned in the group's children table so that it immediately follows the argument object (and is, thus, in terms of depth, immediately in front of the argument object). Again, this repositioning occurs even if the moving object was already positioned somewhere in the table after the argument object, and was therefore already in front of the argument object.

    It should now be clear why the raise() function can more accurately be thought of as move_before(). Similarly, the lower() function can be thought of as move_behind().

    *See Also:* the <raise_to_top>, <lower> and <lower_to_bottom> functions
*/

    raise( UIElement above )
    [[
        if(ClutterActor * parent G_GNUC_UNUSED =clutter_actor_get_parent(self))
        {
            ClutterActor* source =ClutterUtil::user_data_to_actor(L,above);
            if(source)
            {
#ifdef CLUTTER_VERSION_1_10
                clutter_actor_set_child_above_sibling( parent, self, source );
#else
                clutter_actor_raise(self,source);
#endif
            }
        }
        else
        {
            g_warning( "Trying to raise() an actor that is not in a group: %s", Util::where_am_i_lua(L).c_str() );
        }
    ]];

/***************************************
    Function: lower

    The lower() function moves the object within its group (usually the screen) so that it is located immediately behind the specified object. Both objects must belong to the same group (either the <screen at file:clutter_screen-lb.html#screen> or a <Group at file:clutter_group-lb.html#Group> object).

    *Argument:*

        below - a UIElement object in the group. The calling object will be placed immediately behind this object.

    *Return Value:* None

    To better understand what the lower() function does, think of it as a move_behind() operation, where the calling object will be moved immediately behind the argument object.

    Refer to the <raise> function for a discussion on the depth ordering of objects within a group.

    *See Also:* the <lower_to_bottom>, <raise> and <raise_to_top> functions
*/

    lower( UIElement below )
    [[
        if(ClutterActor * parent G_GNUC_UNUSED =clutter_actor_get_parent(self))
        {
            ClutterActor* source =ClutterUtil::user_data_to_actor(L,below);
            if(source)
            {
#ifdef CLUTTER_VERSION_1_10
                clutter_actor_set_child_below_sibling( parent, self, source );
#else
                clutter_actor_lower(self,source);
#endif
            }
        }
        else
        {
            g_warning( "Trying to lower() an actor that is not in a group: %s", Util::where_am_i_lua(L).c_str() );
        }
    ]];

/***************************************
    Function: raise_to_top

    The raise_to_top() function moves the object to the front of its group (usually the screen), placing it in front of all other objects in the group.

    *Return Value:* None

    The raise_to_top() function sets the object's <z> position on the Z-axis to the same setting as the current front object, and then moves the object to the end of the group's <Container.children> table, making it the first object in the group. Refer to the discussion in the <raise> function for additional details.

    *See Also:* the <raise>, <lower> and <lower_to_bottom> functions
*/

    raise_to_top()
    [[
        if(ClutterActor * parent G_GNUC_UNUSED =clutter_actor_get_parent(self))
        {
#ifdef CLUTTER_VERSION_1_10
                clutter_actor_set_child_above_sibling( parent, self, NULL );
#else
                clutter_actor_raise_top(self);
#endif
        }
        else
        {
            g_warning( "Trying to raise_to_top() an actor that is not in a group: %s", Util::where_am_i_lua(L).c_str() );
        }
    ]];

/***************************************
    Function: lower_to_bottom

    The lower_to_bottom() function moves the object to the end of its group (usually the screen), placing it behind all other objects in the group.

    *Return Value:* None

    The lower_to_bottom() function sets the object's <z> position on the Z-axis to the same setting as the current last object, and then moves the object to the beginning of the group's <Container.children> table, making it the last object in the group. Refer to the discussion in the <raise> function for additional details.

    *See Also:* the <lower>, <raise> and <raise_to_top> functions
*/

    lower_to_bottom()
    [[
        if(ClutterActor * parent G_GNUC_UNUSED =clutter_actor_get_parent(self))
        {
#ifdef CLUTTER_VERSION_1_10
                clutter_actor_set_child_below_sibling( parent, self, NULL );
#else
                clutter_actor_lower_bottom(self);
#endif
        }
        else
        {
            g_warning( "Trying to lower_to_bottom() an actor that is not in a group: %s", Util::where_am_i_lua(L).c_str() );
        }
    ]];

/***************************************
    Function: move_anchor_point

    The move_anchor_point() function sets the object's anchor point and adjusts the object's X and Y coordinates so the object does not move from its current position. The anchor point is used when positioning, scaling and rotating the object.

    The function's x and y arguments specify the new anchor point and are relative to the object's top-left corner.

    *Arguments:*

        x - new anchor point's X coordinate. Value is relative to the object's top-left corner.
        y - new anchor point's Y coordinate. Value is relative to the object's top-left corner.

    *Return Value:* None

    To modify the anchor point without adjusting the object's X and Y coordinates (but, instead, moving the object), set the <anchor_point> property.

    It is possible to set the anchor point anywhere, including outside the object's boundary.

    *Code Example:* Set the object's anchor point to the object's center, adjusting the object's X and Y coordinates so the object does not move

        (code)
        myObject:move_anchor_point( myObject.width / 2, myObject.height / 2 )
        (end)

    *See Also:* the <x>, <y> and <anchor_point> properties
*/

    move_anchor_point( double x, double y )
    [[clutter_actor_move_anchor_point(self,x,y);]];

/***************************************
    Function: transform_point

    The transform_point() function accepts an X, Y and Z coodinate point relative to the object and returns the same point relative to an ancestor object (such as the screen), after any transformations, such as rotation and scaling, have been performed upon it.

    *Arguments:*

        ancestor - a UIElement ancestor object, such as the screen or another Group
        x , y , z - coordinates relative to the object. The X and Y coordinates are required; the Z coordinate is optional, and defaults to 0.

    *Returns:* A table containing the X, Y and Z coordinates, respectively, of the transformed point relative to the ancestor.

    *Format:* { transformed_X, transformed_Y, transformed_Z }

    *See Also:* the <transformed_position> and <transformed_size> properties
*/

    table transform_point( UIElement ancestor, double x, double y, double z = 0 )
        [[
            lua_newtable(L);

            ClutterActor * a=ClutterUtil::user_data_to_actor(L,ancestor);

            if (a)
            {
                ClutterVertex point_in;
                point_in.x = x;
                point_in.y = y;
                point_in.z = z;

                ClutterVertex point_out;

                clutter_actor_apply_relative_transform_to_point( self , a , & point_in , & point_out );

                lua_pushnumber( L , point_out.x );
                lua_rawseti( L , -2 , 1 );
                lua_pushnumber( L , point_out.y );
                lua_rawseti( L , -2 , 2 );
                lua_pushnumber( L , point_out.z );
                lua_rawseti( L , -2 , 3 );
            }
        ]];

/***************************************
    Function: grab_key_focus

    The grab_key_focus() function directs all keyboard and remote control events to the object. Calling grab_key_focus() will also cause an <on_key_focus_in> event to occur.

    By default, keyboard and remote control events are directed to the <screen at file:clutter_screen-lb.html#Screen> global variable.

    Keyboard/remote keypresses result in the firing of <on_key_down> and <on_key_up> events.

    To receive mouse events and send pointer events, call the global <controllers.start_pointer> function and set the object's <reactive> property to true.

    *Arguments:* None

    *Return Value:* None

    *See Also:* the <on_key_down>, <on_key_up> and <on_key_focus_in> events
*/

    grab_key_focus()
    [[clutter_actor_grab_key_focus(self);]];

/***************************************
    UndocumentedFunction: blur

    This function will apply a blur effect to the UI element.  Reversible with unblur()

    Returns:

        true - The effect was applied.
        false - If the effect is not available.
*/

    bool blur()
    [[
#if CLUTTER_CHECK_VERSION(1,4,0)

        clutter_actor_remove_effect_by_name(self, "blur_effect");
        clutter_actor_add_effect_with_name(self, "blur_effect", clutter_blur_effect_new());
        result = true;
#else
        result = false;
#endif
    ]];

/***************************************
    UndocumentedFunction: unblur

    Turn off a blur effect on the UI element.  The opposite of blur()

    Returns:

        true - The effect was applied.
        false - If the effect is not available.
*/

    bool unblur()
    [[
#if CLUTTER_CHECK_VERSION(1,4,0)
        clutter_actor_remove_effect_by_name(self, "blur_effect");
        // Need to force a redraw or it sometimes doesn't update
        clutter_actor_queue_redraw(self);
        result = true;
#else
        result = false;
#endif
    ]];

/***************************************
    UndocumentedFunction: desaturate

    How much to desaturate the UI element.  On a scale from 0.0 for fully saturated to 1.0 (default) for fully desaturated.

    Arguments:

        desaturation - 0 for fully saturated, 1 for fully desaturated.

    Returns:

        true - The effect was applied.
        false - If the effect is not available.
*/

    bool desaturate(double desaturation)
    [[
#if CLUTTER_CHECK_VERSION(1,4,0)
        clutter_actor_remove_effect_by_name(self, "desaturation_effect");
        clutter_actor_add_effect_with_name(self, "desaturation_effect", clutter_desaturate_effect_new( desaturation ));
        result = true;
#else
        result = false;
#endif
    ]];

/***************************************
    UndocumentedFunction: saturate

    Restore saturation to the UI element.  This undoes any call to <desaturate>.

    Returns:

        true - The effect was applied.
        false - If the effect is not available.
*/

    bool saturate()
    [[
#if CLUTTER_CHECK_VERSION(1,4,0)
        clutter_actor_remove_effect_by_name(self, "desaturation_effect");
        result = true;
#else
        result = false;
#endif
    ]];

/***************************************
    UndocumentedFunction: tint

    Turn on a tint effect for the UI element.

    Arguments:

        color - Required.  The tint color to apply to the UI element.

    Returns:

        true - The effect was applied.
        false - If the effect is not available.
*/

    bool tint(...)
    [[
#if CLUTTER_CHECK_VERSION(1,4,0)
        ClutterColor color;
        ClutterUtil::to_clutter_color(L,2,&color);
        clutter_actor_remove_effect_by_name(self, "tint_effect");
        clutter_actor_add_effect_with_name(self, "tint_effect", clutter_colorize_effect_new( &color ));
        result = true;
#else
        result = false;
#endif
    ]];

/***************************************
    UndocumentedFunction: untint

    Turn off any existing tint effect for the UI element.

     Returns:

        true - The effect was applied.
        false - If the effect is not available.
*/

    bool untint()
    [[
#if CLUTTER_CHECK_VERSION(1,4,0)
        clutter_actor_remove_effect_by_name(self, "tint_effect");
        result = true;
#else
        result = false;
#endif
    ]];

/***************************************
    UndocumentedFunction: pageturn

    Apply a "page turn" effect to the UIElement.

    Arguments:

        period - The period of the page curl, between 0.0 (flat) and 1.0 (fully curled) [defaults to 0]
        angle - The angle of the page curl, in degrees, between 0.0 and 360.0 [defaults to 45]
        radius - The radius of the page curl effect, in pixels [defaults to 1/16 width of the UIElement]

    Returns:

        true - The effect was applied.
        false - If the effect is not available.
*/

    bool pageturn(double period=0.5, double angle=45, double radius=0)
    [[
#if CLUTTER_CHECK_VERSION(1,4,0)
        if(0 == radius)
        {
            radius = clutter_actor_get_width(self)/16;
        }
        ClutterPageTurnEffect *effect = (ClutterPageTurnEffect *)clutter_actor_get_effect(self, "pageturn_effect");
        if(effect)
        {
            clutter_page_turn_effect_set_period(effect, period);
            clutter_page_turn_effect_set_angle(effect, angle);
            clutter_page_turn_effect_set_radius(effect, radius);
        }
        else
        {
            clutter_actor_add_effect_with_name(self, "pageturn_effect", clutter_page_turn_effect_new(period,angle,radius));
        }
        result = true;
#else
        result = false;
#endif
    ]];

/***************************************
    UndocumentedFunction; pageflatten

    Remove any "page turn" effect on the UIElement.

    Returns:

        true - The effect was applied.
        false - If the effect is not available.
*/

    bool pageflatten()
    [[
#if CLUTTER_CHECK_VERSION(1,4,0)
        clutter_actor_remove_effect_by_name(self, "pageturn_effect");
        result = true;
#else
        result = false;
#endif
    ]];

/***************************************
    Function: animate

    The animate() function performs an asynchronous animation by changing one or more property values, such as X, Y coordinates, opacity and rotation, over a period of time.

    If the object's animate() function is called while an animation is already in progress, the running animation is terminated immediately, all its animating properties are set to their ending values, and the new animation begins.

    A program can be notified when the animation completes by specifying a function name for the on_completed property.

    The animation provides no notifications while it is running. For an animation that requires in-progress notifications, consider basing the animation on the <Timeline> class.

    *Arguments:*

        props - table of comma-separated properties and settings that define the animation. Supported properties and settings are listed below.

    *Supported Animation Properties:* Property names are case-sensitive. The duration property is required; all other properties are optional.

        duration - length of animation in milliseconds. Required.
        delay - length in milliseconds before animation begins. Default = 0.
        mode - string specifying the Ease mode to apply to the animated property. For descriptions of the supported modes, refer to the <Ease> class. Default = "LINEAR"
        on_completed - function to call when the animation is finished. The function should accept no arguments and have no return value.
        x - X coordinate at end of animation
        y - Y coordinate at end of animation
        z - Z coordinate at end of animation
        depth - Z coordinate at end of animation. Another name for the z property
        w - width at end of animation
        width - width at end of animation. Another name for the w property
        h - height at end of animation
        height - height at end of animation. Another name for the h property
        opacity - opacity at end of animation. Possible values: 0 (completely transparent) to 255 (completely opaque), inclusive.
        position - X and Y coordinates at end of animation. Same as specifying x and y properties individually. The position property is specified as a table with two integers in the format { x, y }.
        size - width and height at end of animation. Same as specifying width and height properties individually. The size property is specified as a table with two floating point values in the format { width, height }.
        scale - object's scaling factor at end of animation. The scale property is specified as a table with two double values in the format { X_scale_factor, Y_scale_factor }.
        clip - object's clipping rectangle at end of animation. The clipping rectangle is specified as a table with four integer values in the format { X_origin, Y_origin, width, height }.
        x_rotation - object's rotation in degrees along the X-axis at end of animation
        y_rotation - object's rotation in degrees along the Y-axis at end of animation
        z_rotation - object's rotation in degrees along the Z-axis at end of animation

    *Return Value:* If the animation was started successfully, returns a reference to an Animation object. Else returns nil.

    *Code Example:* Create a simple rectangle and rotate it while moving it across the screen in an infinite loop

        (code)
        -- Create the rectangle
        movingRect = Rectangle{ position = { -100, 400 },
                                size     = { 100, 100 },
                                color    = { 225, 225, 0, 0 } }
        -- Show it on the screen
        screen:add( movingRect )

        --Animate it
        movingRect:animate( { duration   = 5000,    -- 5 seconds
                              loop       = true,    -- loop forever
                              x          = 2020,    -- move to off-screen right
                              x_rotation = 360,     -- flip all the way around
        } )
        (end)

    *See Also:* the <complete_animation> function and the <Timeline> class
*/

    Animation animate(table props)
    [[
        lua_getfield(L,props,"duration");
        guint duration = 0;

        if(!lua_isnil(L, -1))
        {
            if(!lua_isnumber(L, -1))
            {
                return luaL_error(L, "Call to animate has invalid duration: must be a number");
            }
            if ( lua_tointeger(L, -1) <= 0 )
            {
                return luaL_error(L, "Call to animate has invalid duration: must be positive non-zero number");
            }
            duration=lua_tointeger(L,-1);
        }
        else
        {
            return luaL_error(L, "Call to animate has missing duration");
        }
        lua_pop(L,1);

        lua_getfield(L,props,"mode");
        gulong mode=ClutterUtil::to_clutter_animation_mode(lua_tostring(L,-1));
        lua_pop(L,1);

#ifdef CLUTTER_VERSION_1_10
        lua_getfield(L,props,"on_completed");

        UserData * ud = UserData::get( L );

        if (lua_type(L,-1)==LUA_TFUNCTION)
        {
            ud->push_proxy();

            UserData::set_callback( "on_completed" , L , -1 , -2 );

            ud->connect_signal( "on_completed" , "transitions-completed" , G_CALLBACK( transitions_completed ) , L , G_CONNECT_AFTER );
        }
        else
        {
            ud->disconnect_signal( "on_completed" );

            lua_pop(L,1); // pop the nil
        }

        clutter_actor_save_easing_state( self );
        clutter_actor_set_easing_duration( self, duration );

        lua_getfield(L,props,"delay");

        if(!lua_isnil(L,-1))
        {
            if(!lua_isnumber(L,-1))
            {
                return luaL_error(L, "Call to animate has invalid delay: must be a number");
            }
            if(lua_tointeger(L,-1) <= 0)
            {
                return luaL_error(L, "Call to animate has invalid delay: must be positive non-zero number");
            }
        }
        clutter_actor_set_easing_delay( self, lua_tointeger(L,-1) );
        lua_pop(L,1);

        clutter_actor_set_easing_mode( self, (ClutterAnimationMode)mode );

        ClutterUtil::set_props_from_table(L,props);

        lua_getfield(L, props, "loop");
        int loop = lua_toboolean(L,-1);
        lua_pop(L,1);

        // We need to tell each property transition that was just set to loop if loop was true, or not loop if it was false or unspecified
        // To determine which properties, we'll iterate through the "props" table and find every property with a setter
        // Then retrieve the ClutterTransition for that property and tell it whether to loop

        // Get the table of setters from the user_data
        if (luaL_getmetafield(L,1,"__setters__"))
        {
            int setters=lua_gettop(L);

            lua_pushnil(L);
            while(lua_next(L,props))            // pops old key, pushes next key and value
            {
                lua_pop(L, 1);                  // discard the property value

                lua_pushvalue(L,-1);            // push the key again
                lua_rawget(L,setters);          // pops the key, check if that key is in the setters table
                if (!lua_isnil(L,-1))
                {
                    // We found a property that has a setter, so retrieve its transition and loop it
                    // The property name is underneath the value we just got from setters
                    const gchar * property = property_from_setter_name(lua_tostring(L, -2));

                    ClutterTransition *transition = clutter_actor_get_transition(self, property);
                    if(transition)
                    {
                        clutter_timeline_set_repeat_count( CLUTTER_TIMELINE(transition), loop ? -1 : 0 );
                    }
                }
                lua_pop(L,1);                   // Pop the setter function
            }

            lua_pop(L, 1);                      // Pop the setters table
        }

        clutter_actor_restore_easing_state( self );
#else
        GPtrArray * names=g_ptr_array_new_with_free_func(g_free);
#ifndef GLIB_VERSION_2_32
        GValueArray * values=g_value_array_new(6);
#else
        GArray * values = g_array_sized_new(FALSE, FALSE, sizeof(GValue), 6);
#endif

        lua_pushnil(L);

        while(lua_next(L,props))
        {
            GValue value={0};

            if (lua_really_isstring(L,-2)&&!lua_isnil(L,-2))
            {
                const char * k=lua_tostring(L,-2);

                if (!strcmp("x",k)||!strcmp("y",k))
                {
                    g_value_init(&value,G_TYPE_FLOAT);
                    g_value_set_float(&value,lua_tonumber(L,-1));
                    g_ptr_array_add(names,g_strdup(k));
#ifndef GLIB_VERSION_2_32
                    g_value_array_append(values,&value);
#else
                    g_array_append_val(values,value);
#endif
                }
                else if (!strcmp("w",k)||!strcmp("width",k))
                {
                    g_value_init(&value,G_TYPE_FLOAT);
                    g_value_set_float(&value,lua_tonumber(L,-1));
                    g_ptr_array_add(names,g_strdup("width"));
#ifndef GLIB_VERSION_2_32
                    g_value_array_append(values,&value);
#else
                    g_array_append_val(values,value);
#endif
                }
                else if (!strcmp("h",k)||!strcmp("height",k))
                {
                    g_value_init(&value,G_TYPE_FLOAT);
                    g_value_set_float(&value,lua_tonumber(L,-1));
                    g_ptr_array_add(names,g_strdup("height"));
#ifndef GLIB_VERSION_2_32
                    g_value_array_append(values,&value);
#else
                    g_array_append_val(values,value);
#endif
                }
                else if (!strcmp("z",k)||!strcmp("depth",k))
                {
                    g_value_init(&value,G_TYPE_FLOAT);
                    g_value_set_float(&value,lua_tonumber(L,-1));
                    g_ptr_array_add(names,g_strdup("depth"));
#ifndef GLIB_VERSION_2_32
                    g_value_array_append(values,&value);
#else
                    g_array_append_val(values,value);
#endif
                }
                else if (!strcmp("opacity",k))
                {
                    g_value_init(&value,G_TYPE_UINT);
                    g_value_set_uint(&value,lua_tointeger(L,-1));
                    g_ptr_array_add(names,g_strdup(k));
#ifndef GLIB_VERSION_2_32
                    g_value_array_append(values,&value);
#else
                    g_array_append_val(values,value);
#endif
                }
                else if (!strcmp("position",k))
                {
                    if (lua_type(L,-1)==LUA_TTABLE)
                    {
                        g_ptr_array_add(names,g_strdup("x"));
                        g_ptr_array_add(names,g_strdup("y"));

                        lua_rawgeti(L,-1,1);
                        g_value_init(&value,G_TYPE_FLOAT);
                        g_value_set_float(&value,lua_tonumber(L,-1));
#ifndef GLIB_VERSION_2_32
                        g_value_array_append(values,&value);
#else
                        g_array_append_val(values,value);
#endif
                        lua_pop(L,1);

                        lua_rawgeti(L,-1,2);
                        g_value_unset(&value);
                        g_value_init(&value,G_TYPE_FLOAT);
                        g_value_set_float(&value,lua_tonumber(L,-1));
#ifndef GLIB_VERSION_2_32
                        g_value_array_append(values,&value);
#else
                        g_array_append_val(values,value);
#endif
                        lua_pop(L,1);
                    }
                }
                else if (!strcmp("size",k))
                {
                    if (lua_type(L,-1)==LUA_TTABLE)
                    {
                        g_ptr_array_add(names,g_strdup("width"));
                        g_ptr_array_add(names,g_strdup("height"));

                        lua_rawgeti(L,-1,1);
                        g_value_init(&value,G_TYPE_FLOAT);
                        g_value_set_float(&value,lua_tonumber(L,-1));
#ifndef GLIB_VERSION_2_32
                        g_value_array_append(values,&value);
#else
                        g_array_append_val(values,value);
#endif
                        lua_pop(L,1);

                        lua_rawgeti(L,-1,2);
                        g_value_unset(&value);
                        g_value_init(&value,G_TYPE_FLOAT);
                        g_value_set_float(&value,lua_tonumber(L,-1));
#ifndef GLIB_VERSION_2_32
                        g_value_array_append(values,&value);
#else
                        g_array_append_val(values,value);
#endif
                        lua_pop(L,1);
                    }
                }
                else if (!strcmp("scale",k))
                {
                    if (lua_type(L,-1)==LUA_TTABLE)
                    {
                        g_ptr_array_add(names,g_strdup("scale-x"));
                        g_ptr_array_add(names,g_strdup("scale-y"));

                        lua_rawgeti(L,-1,1);
                        g_value_init(&value,G_TYPE_DOUBLE);
                        g_value_set_double(&value,lua_tonumber(L,-1));
#ifndef GLIB_VERSION_2_32
                        g_value_array_append(values,&value);
#else
                        g_array_append_val(values,value);
#endif
                        lua_pop(L,1);

                        lua_rawgeti(L,-1,2);
                        g_value_unset(&value);
                        g_value_init(&value,G_TYPE_DOUBLE);
                        g_value_set_double(&value,lua_tonumber(L,-1));
#ifndef GLIB_VERSION_2_32
                        g_value_array_append(values,&value);
#else
                        g_array_append_val(values,value);
#endif
                        lua_pop(L,1);
                    }
                }
                else if (!strcmp("x_rotation",k))
                {
                    if (lua_type(L,-1)==LUA_TTABLE)
                    {

                    }
                    else
                    {
                        g_ptr_array_add(names,g_strdup("rotation-angle-x"));
                        g_value_init(&value,G_TYPE_DOUBLE);
                        g_value_set_double(&value,lua_tonumber(L,-1));
#ifndef GLIB_VERSION_2_32
                        g_value_array_append(values,&value);
#else
                        g_array_append_val(values,value);
#endif
                    }
                }
                else if (!strcmp("y_rotation",k))
                {
                    if (lua_type(L,-1)==LUA_TTABLE)
                    {

                    }
                    else
                    {
                        g_ptr_array_add(names,g_strdup("rotation-angle-y"));
                        g_value_init(&value,G_TYPE_DOUBLE);
                        g_value_set_double(&value,lua_tonumber(L,-1));
#ifndef GLIB_VERSION_2_32
                        g_value_array_append(values,&value);
#else
                        g_array_append_val(values,value);
#endif
                    }
                }
                else if (!strcmp("z_rotation",k))
                {
                    if (lua_type(L,-1)==LUA_TTABLE)
                    {

                    }
                    else
                    {
                        g_ptr_array_add(names,g_strdup("rotation-angle-z"));
                        g_value_init(&value,G_TYPE_DOUBLE);
                        g_value_set_double(&value,lua_tonumber(L,-1));
#ifndef GLIB_VERSION_2_32
                        g_value_array_append(values,&value);
#else
                        g_array_append_val(values,value);
#endif
                    }
                }
                else if ( ! strcmp( "clip" , k ) )
                {
                    if ( lua_type( L , - 1 ) == LUA_TTABLE )
                    {
                        ClutterGeometry geometry;
                        ClutterUtil::to_clutter_geometry(L, lua_gettop(L), &geometry);

                        g_ptr_array_add(names,g_strdup("clip"));
                        g_value_init(&value, CLUTTER_TYPE_GEOMETRY);
                        g_value_set_boxed(&value, &geometry);
#ifndef GLIB_VERSION_2_32
                        g_value_array_append(values,&value);
#else
                        g_array_append_val(values,value);
#endif
                    }
                }
            }

            lua_pop(L,1);
        }

#ifndef GLIB_VERSION_2_32
        if ( values->n_values == 0 )
#else
        if ( values->len == 0 )
#endif
        {
#ifndef GLIB_VERSION_2_32
            g_value_array_free(values);
#else
            g_array_unref(values);
#endif
            g_ptr_array_free(names,TRUE);
            lua_pushnil( L );
            luaL_error( L , "Call to animate has no properties" );
            return 1;
        }

        ClutterAnimation * a=clutter_actor_animatev(self,mode,duration,
#ifndef GLIB_VERSION_2_32
                            values->n_values,
#else
                            values->len,
#endif
                            (gchar**)names->pdata,
#ifndef GLIB_VERSION_2_32
                            values->values
#else
                            (const GValue *)values->data
#endif
                            );

        if ( ! a )
        {
            lua_pushnil( L );
        }
        else
        {
            UserData * ud = UserData::get( G_OBJECT( a ) );

            if ( ud )
            {
                ud->push_proxy();
            }
            else
            {
                g_object_ref( a );

                lua_pushlightuserdata( L , a );
                new_Animation( L );
                lua_remove( L , -2 );
            }

            int animation = lua_gettop( L );

            lua_getfield(L,props,"loop");
            clutter_animation_set_loop(a,lua_toboolean(L,-1));
            lua_pop(L,1);

            // If you call animate several times, clutter reuses the same
            // ClutterAnimation object. So, if we are not set to loop,
            // and the user passed an "on_completed" function, we may have
            // to unref the old function and disconnect the old handler.

            if (!clutter_animation_get_loop(a))
            {
                lua_getfield(L,props,"on_completed");

                if (lua_type(L,-1)==LUA_TFUNCTION)
                {
                    UserData::set_callback( "on_completed" , L , animation , -1 );

                    UserData * ud = UserData::get( L , animation );

                    ud->connect_signal( "on_completed" , "completed" , G_CALLBACK( animation_completed ) , L , G_CONNECT_AFTER );
                }
                else
                {
                    lua_pop(L,1);
                }
            }
        }

#ifndef GLIB_VERSION_2_32
        g_value_array_free(values);
#else
        g_array_unref(values);
#endif
        g_ptr_array_free(names,TRUE);

#endif

    ]];


/***************************************
    Function: complete_animation

    The complete_animation() function terminates the current cycle of an animation started with a call to <animate>. All the properties that were being animated are forced immediately to their final values. If the animation specified an on_completed handler, it is invoked. If the animation is a looping animation, the next animation cycle begins. To terminate a looping animation, call the <stop_animation> function.

    *Arguments:*

        property_names - Optional.  Can be a string, or a table of strings.  The passed strings, if any, will be treated as property names, and any animations on those properties will be completed.  Animations on other properties will continue.  If no argument is passed, then ALL properties' animations will be completed.

    *Return Value:* Boolean indicating whether or not an animation had been running for the specified propert(y|ies) (true = animation was running and was terminated).

    *See Also:* the <animate> function and the <stop_animation> function
*/

    bool complete_animation(...)
    [[
        result =  false;

#ifdef CLUTTER_VERSION_1_10
        // Check for argument
        if(lua_isstring(L,2))
        {
            result = complete_animation_function(self, lua_tostring(L, 2),NULL);
        }
        else if(lua_istable(L,2))
        {
            int complete_list = 2;

            size_t num_props = lua_rawlen(L, complete_list);
            for(size_t i=1; i <= num_props; i++)
            {
                lua_rawgeti(L, complete_list, i);
                luaL_checkstring(L, -1);

                result |= complete_animation_function(self, lua_tostring(L, -1), NULL);

                lua_pop(L, 1);
            }
        }
        else if(!lua_isuserdata(L,-1))
        {
            luaL_error(L, "ERROR: DID NOT SPECIFY STRING OR TABLE OF STRINGS IN CALL TO complete_animation()");
        }
        else
        {
            result = for_each_property(self, L, complete_animation_function, NULL);
        }
#else
        if(!lua_isuserdata(L,-1))
        {
            g_error("This version of clutter does not support multiple animations on different properties.  Stopping all animations.");
        }

        if ( ClutterAnimation * animation=clutter_actor_get_animation( self ) )
        {
            if ( ClutterTimeline * timeline = clutter_animation_get_timeline( animation ) )
            {
                clutter_timeline_advance( timeline , clutter_timeline_get_duration( timeline ) );

                result=true;
            }
        }
#endif
    ]];

/***************************************
    Function: stop_animation

    The stop_animation() function terminates the animation (including a looping animation) started with a call to <animate>. All the properties that were being animated remain at their stopped values. If the animation specified an on_completed handler, it is not called.

    *Arguments:*

        property_names - Optional.  Can be a string, or a table of strings.  The passed strings, if any, will be treated as property names, and any animations on those properties will be stopped.  Animations on other properties will continue.  If no argument is passed, then ALL properties' animations will be stopped.

    *Return Value:* Boolean indicating whether or not an animation had been running (true = animation was running and was stopped).

    *See Also:* the <animate> function and <complete_animation> function
*/

    bool stop_animation(...)
    [[
        result = false;

#ifdef CLUTTER_VERSION_1_10
        // Check for argument
        if(lua_isstring(L,-1))
        {
            result = stop_animation_function(self, lua_tostring(L,-1),NULL);
        }
        else if(lua_istable(L,-1))
        {
            int complete_list = lua_gettop(L);

            size_t num_props = lua_rawlen(L, complete_list);
            for(size_t i=1; i <= num_props; i++)
            {
                lua_rawgeti(L, complete_list, i);
                luaL_checkstring(L, -1);

                result |= stop_animation_function(self, lua_tostring(L, -1), NULL);

                lua_pop(L, 1);
            }
        }
        else if(!lua_isuserdata(L,-1))
        {
            luaL_error(L, "ERROR: DID NOT SPECIFY STRING OR TABLE OF STRINGS IN CALL TO stop_animation()");
        }
        else
        {
            result = for_each_property(self, L, stop_animation_function, NULL);
        }
#else
        if ( ClutterAnimation *anim = clutter_actor_get_animation( self ) )
        {
            ClutterTimeline *timeline = clutter_animation_get_timeline( anim );
            clutter_timeline_pause( timeline );
            clutter_actor_detach_animation( self );

            result=true;
        }
#endif
    ]];

/***************************************
    Function: is_property_animating

    The is_property_animating() function is a boolean value specifying whether or not the object's property is currently running an animation started by the <animate> function (true = running an animation).

    *Arguments:*

        property_name - the name of the property to check

    *Return Value:* Returns true if the specified property is animating; false if it is not

    *See Also:* the <animate> function and the <is_animating> property
*/

    bool is_property_animating(string property_name)
    [[
#ifdef CLUTTER_VERSION_1_10
        result = (clutter_actor_get_transition(self, property_name) != NULL);
#else
        g_error("is_property_animating not supported with this version of the clutter library")
        result = false
#endif
    ]];

/***************************************
    UndocumentedProperty: constraints

*/

    table constraints
       [[
            GList * list = clutter_actor_get_constraints( self );

            lua_newtable(L);
            int n = 1;
            for( GList * item = g_list_first( list ); item; item = g_list_next( item ) , ++n )
            {
                ClutterUtil::wrap_constraint( L , CLUTTER_CONSTRAINT( item->data ) );
                lua_rawseti( L , -2 , n );
            }
            g_list_free( list );
       ]]
       [[
           luaL_checktype( L , 2 , LUA_TTABLE );

           clutter_actor_clear_constraints( self );

           lua_pushnil( L );

           while( lua_next( L , 2 ) )
           {
                if ( ClutterConstraint * c = ClutterUtil::user_data_to_constraint( L , lua_gettop( L ) ) )
                {
                    if ( clutter_actor_meta_get_actor( CLUTTER_ACTOR_META( c ) ) )
                    {
                        g_warning( "Trying to add a constraint that has already been added to another actor: %s", Util::where_am_i_lua(L).c_str() );
                    }
                    else
                    {
                        clutter_actor_add_constraint( self , c );
                    }
                }

                lua_pop( L , 1 );
           }

       ]];

/***************************************
    UndocumentedFunction: add_constraints

    Note: The add_constraints(), remove_constraints() and clear_constraints() functions use the ClutterConstraint AlignConstraint, BindConstraint, SnapConstraint and PathConstraint bindings in clutter_constraint.lb.  For the moment, these functions will remain undocumented.

*/

    add_constraints( ... )
        [[
            for ( int i = 2; i <= lua_gettop( L ); ++i )
            {
                if ( ! lua_isnil( L , i ) )
                {
                    if ( ClutterConstraint * c = ClutterUtil::user_data_to_constraint( L , i ) )
                    {
                        if ( clutter_actor_meta_get_actor( CLUTTER_ACTOR_META( c ) ) )
                        {
                            luaL_error( L , "Constraints cannot be added to multiple UI elements" );
                        }
                        else
                        {
                            clutter_actor_add_constraint( self , c );
                        }
                    }
                }
            }
        ]];

/***************************************
    UndocumentedFunction: remove_contraints

*/

    remove_constraints( ... )
        [[
            for ( int i = 2; i <= lua_gettop( L ); ++i )
            {
                if ( ! lua_isnil( L , i ) )
                {
                    if ( ClutterConstraint * c = ClutterUtil::user_data_to_constraint( L , i ) )
                    {
                        clutter_actor_remove_constraint( self , c );
                    }
                }
            }
        ]];

/***************************************
    UndocumentedFunction: clear_constraints

*/

    clear_constraints( )
        [[
            clutter_actor_clear_constraints( self );
        ]];

/***************************************
    Function: add_onkeyfocusin_listener

    The add_onkeyfocusin_listener() function registers a handler function for <on_key_focus_in> events.

    *Arguments:*

        f - reference to handler function. The function prototype is described below.

    *Return Value:* Handle to the registered handler. Pass this handle to the <remove_onkeyfocusin_listener> function to unregister the handler.

    *Handler Prototype:*

        (code)
        int f( self )
        (end)

    *Handler Arguments:*

        self - reference to the object receiving key focus

    *Handler Return Value:* Return 1 if the event should *not* be passed down the event chain to the next object. Else return 0.

    *See Also:* the <on_key_focus_in> event and the <remove_onkeyfocusin_listener> function
*/

    int add_onkeyfocusin_listener( function f )
        [[
            result = UserData::get( L )->add_callback( (char*) "on_key_focus_in" , L );
            UserData::get( L )->connect_signal(
                "on_key_focus_in",
                "key-focus-in",
                G_CALLBACK(actor_on_key_focus_in),
                L);
        ]];

/***************************************
    Function: remove_onkeyfocusin_listener

    The remove_onkeyfocusin_listener() function unregisters the specified event handler.

    *Arguments:*

        ref - handle for event handler to unregister. This handle is returned by the <add_onkeyfocusin_listener> function.

    *Return Value:* None

    *See Also:* the <add_onkeyfocusin_listener> function
*/

    remove_onkeyfocusin_listener( int ref )
        [[
            UserData::get( L )->remove_callback( (char*) "on_key_focus_in" , L );
        ]];

/***************************************
    Function: add_onkeyfocusout_listener

    The add_onkeyfocusout_listener() function registers a handler function for <on_key_focus_out> events.

    *Arguments:*

        f - reference to handler function. The function prototype is described below.

    *Return Value:* Handle to the registered handler. Pass this handle to the <remove_onkeyfocusout_listener> function to unregister the handler.

    *Handler Prototype:*

        (code)
        int f( self )
        (end)

    *Handler Arguments:*

        self - reference to the object losing key focus

    *Handler Return Value:* Return 1 if the event should *not* be passed down the event chain to the next object. Else return 0.

    *See Also:* the <on_key_focus_out> event and the <remove_onkeyfocusout_listener> function
*/

    int add_onkeyfocusout_listener( function f )
        [[
            result = UserData::get( L )->add_callback( (char*) "on_key_focus_out" , L );
            UserData::get( L )->connect_signal(
                "on_key_focus_out",
                "key-focus-out",
                G_CALLBACK(actor_on_key_focus_out),
                L);
        ]];

/***************************************
    Function: remove_onkeyfocusout_listener

    The remove_onkeyfocusout_listener() function unregisters the specified event handler.

    *Arguments:*

        ref - handle for event handler to unregister. This handle is returned by the <add_onkeyfocusout_listener> function.

    *Return Value:* None

    *See Also:* the <add_onkeyfocusout_listener> function
*/

    remove_onkeyfocusout_listener( int ref )
        [[
            UserData::get( L )->remove_callback( (char*) "on_key_focus_out" , L );
        ]];

/***************************************
    Function: add_onkeydown_listener

    The add_onkeydown_listener() function registers a handler function for <on_key_down> events.

    *Arguments:*

        f - reference to handler function. The function prototype is described below.

    *Return Value:* Handle to the registered handler. Pass this handle to the <remove_onkeydown_listener> function to unregister the handler.

    *Handler Prototype:*

        (code)
        int f( self, keyval, unicode, time, modifiers )
        (end)

    *Handler Arguments:*

        self - reference to the object receiving the event
        keyval - integer key value. This value can be compared to the global <keys> variable.
        unicode - the key's Unicode representation, if any
        time - system time when the event was generated. The argument is an unsigned 32-bit numeric value.
        modifiers - table of pressed <keys.Key Modifiers>. If no modifier keys were pressed, set to nil.

    *Handler Return Value:* Return 1 if the event should *not* be passed down the event chain to the next object. Else return 0.

    *See Also:* the <on_key_down> event and the <remove_onkeydown_listener> function
*/

    int add_onkeydown_listener( function f )
        [[
            result = UserData::get( L )->add_callback( (char*) "on_key_down" , L );
            UserData::get( L )->connect_signal(
                "on_key_down",
                "key-press-event",
                G_CALLBACK(actor_on_key_down),
                L);
        ]];

/***************************************
    Function: remove_onkeydown_listener

    The remove_onkeydown_listener() function unregisters the specified event handler.

    *Arguments:*

        ref - handle for event handler to unregister. This handle is returned by the <add_onkeydown_listener> function.

    *Return Value:* None

    *See Also:* the <add_onkeydown_listener> function
*/

    remove_onkeydown_listener( int ref )
        [[
            UserData::get( L )->remove_callback( (char*) "on_key_down" , L );
        ]];

/***************************************
    Function: add_onkeyup_listener

    The add_onkeyup_listener() function registers a handler function for <on_key_up> events.

    *Arguments:*

        f - reference to handler function. The function prototype is described below.

    *Return Value:* Handle to the registered handler. Pass this handle to the <remove_onkeyup_listener> function to unregister the handler.

    *Handler Prototype:*

        (code)
        int f( self, keyval, unicode, time, modifiers )
        (end)

    *Handler Arguments:*

        self - reference to the object receiving the event
        keyval - integer key value. This value can be compared to the global <keys> variable.
        unicode - the key's Unicode representation, if any
        time - system time when the event was generated. The argument is an unsigned 32-bit numeric value.
        modifiers - table of pressed <keys.Key Modifiers>. If no modifier keys were pressed, set to nil.

    *Handler Return Value:* Return 1 if the event should *not* be passed down the event chain to the next object. Else return 0.

    *See Also:* the <on_key_up> event and the <remove_onkeyup_listener> function
*/

    int add_onkeyup_listener( function f )
        [[
            result = UserData::get( L )->add_callback( (char*) "on_key_up" , L );
            UserData::get( L )->connect_signal(
                "on_key_up",
                "key-release-event",
                G_CALLBACK(actor_on_key_up),
                L);
        ]];

/***************************************
    Function: remove_onkeyup_listener

    The remove_onkeyup_listener() function unregisters the specified event handler.

    *Arguments:*

        ref - handle for event handler to unregister. This handle is returned by the <add_onkeyup_listener> function.

    *Return Value:* None

    *See Also:* the <add_onkeyup_listener> function
*/

    remove_onkeyup_listener( int ref )
        [[
            UserData::get( L )->remove_callback( (char*) "on_key_up" , L );
        ]];

/***************************************
    Function: add_onbuttondown_listener

    The add_onbuttondown_listener() function registers a handler function for <on_button_down> events.

    *Arguments:*

        f - reference to handler function. The function prototype is described below.

    *Return Value:* Handle to the registered handler. Pass this handle to the <remove_onbuttondown_listener> function to unregister the handler.

    *Handler Prototype:*

        (code)
        int f( self, x, y, button, num_clicks, modifiers )
        (end)

    *Handler Arguments:*

        self - reference to the object receiving the event
        x - X coordinate position of the mouse pointer
        y - Y coordinate position of the mouse pointer
        button - identification of the pressed button. Possible values are: 1 - left mouse button; 2 - middle mouse button; 3 - right mouse button.
        num_clicks - number of repeated mouse clicks
        modifiers - table of pressed <keys.Key Modifiers>. If no modifier keys were pressed, set to nil.

    *Handler Return Value:* Return 1 if the event should *not* be passed down the event chain to the next object. Else return 0.

    *See Also:* the <on_button_down> event and the <remove_onbuttondown_listener> function
*/

    int add_onbuttondown_listener( function f )
        [[
            result = UserData::get( L )->add_callback( (char*) "on_button_down" , L );
            UserData::get( L )->connect_signal(
                "on_button_down",
                "button-press-event",
                G_CALLBACK(actor_on_button_down),
                L);
        ]];

/***************************************
    Function: remove_onbuttondown_listener

    The remove_onbuttondown_listener() function unregisters the specified event handler.

    *Arguments:*

        ref - handle for event handler to unregister. This handle is returned by the <add_onbuttondown_listener> function.

    *Return Value:* None

    *See Also:* the <add_onbuttondown_listener> function
*/

    remove_onbuttondown_listener( int ref )
        [[
            UserData::get( L )->remove_callback( (char*) "on_button_down" , L );
        ]];

/***************************************
    Function: add_onbuttonup_listener

    The add_onbuttonup_listener() function registers a handler function for <on_button_up> events.

    *Arguments:*

        f - reference to handler function. The function prototype is described below.

    *Return Value:* Handle to the registered handler. Pass this handle to the <remove_onbuttonup_listener> function to unregister the handler.

    *Handler Prototype:*

        (code)
        int f( self, x, y, button, num_clicks, modifiers )
        (end)

    *Handler Arguments:*

        self - reference to the object receiving the event
        x - X coordinate position of the mouse pointer
        y - Y coordinate position of the mouse pointer
        button - identification of the pressed button. Possible values are: 1 - left mouse button; 2 - middle mouse button; 3 - right mouse button.
        num_clicks - number of repeated mouse clicks
        modifiers - table of pressed <keys.Key Modifiers>. If no modifier keys were pressed, set to nil.

    *Handler Return Value:* Return 1 if the event should *not* be passed down the event chain to the next object. Else return 0.

    *See Also:* the <on_button_up> event and the <remove_onbuttonup_listener> function
*/

    int add_onbuttonup_listener( function f )
        [[
            result = UserData::get( L )->add_callback( (char*) "on_button_up" , L );
            UserData::get( L )->connect_signal(
                "on_button_up",
                "button-release-event",
                G_CALLBACK(actor_on_button_up),
                L);
        ]];

/***************************************
    Function: remove_onbuttonup_listener

    The remove_onbuttonup_listener() function unregisters the specified event handler.

    *Arguments:*

        ref - handle for event handler to unregister. This handle is returned by the <add_onbuttonup_listener> function.

    *Return Value:* None

    *See Also:* the <add_onbuttonup_listener> function
*/

    remove_onbuttonup_listener( int ref )
        [[
            UserData::get( L )->remove_callback( (char*) "on_button_up" , L );
        ]];

/***************************************
    Function: add_onmotion_listener

    The add_onmotion_listener() function registers a handler function for <on_motion> events.

    *Arguments:*

        f - reference to handler function. The function prototype is described below.

    *Return Value:* Handle to the registered handler. Pass this handle to the <remove_onmotion_listener> function to unregister the handler.

    *Handler Prototype:*

        (code)
        int f( self, x, y, modifiers )
        (end)

    *Handler Arguments:*

        self - reference to the object receiving the event
        x - X coordinate position of the mouse pointer
        y - Y coordinate position of the mouse pointer
        modifiers - table of pressed <keys.Key Modifiers>. If no modifier keys were pressed, set to nil.

    *Handler Return Value:* Return 1 if the event should *not* be passed down the event chain to the next object. Else return 0.

    *See Also:* the <on_motion> event and the <remove_onmotion_listener> function
*/

    int add_onmotion_listener( function f )
        [[
            result = UserData::get( L )->add_callback( (char*) "on_motion" , L );
            UserData::get( L )->connect_signal(
                "on_motion",
                "motion-event",
                G_CALLBACK(actor_on_motion),
                L);
        ]];

/***************************************
    Function: remove_onmotion_listener

    The remove_onmotion_listener() function unregisters the specified event handler.

    *Arguments:*

        ref - handle for event handler to unregister. This handle is returned by the <add_onmotion_listener> function.

    *Return Value:* None

    *See Also:* the <add_onmotion_listener> function
*/

    remove_onmotion_listener( int ref )
        [[
            UserData::get( L )->remove_callback( (char*) "on_motion" , L );
        ]];

/***************************************
    Function: add_onscroll_listener

    The add_onscroll_listener() function registers a handler function for <on_scroll> events.

    *Arguments:*

        f - reference to handler function. The function prototype is described below.

    *Return Value:* Handle to the registered handler. Pass this handle to the <remove_onscroll_listener> function to unregister the handler.

    *Handler Prototype:*

        (code)
        int f( self, x, y, scroll_direction, modifiers )
        (end)

    *Handler Arguments:*

        self - reference to the object receiving the event
        x - X coordinate position of the pointer
        y - Y coordinate position of the pointer
        scroll_direction - direction of scroll wheel. 0 = scrolling up, 1 = scrolling down, 2 = scrolling left, 3 = scrolling right. Note: Some directions may not be supported on a particular scroll wheel.
        modifiers - table of pressed <keys.Key Modifiers>. If no modifier keys were pressed, set to nil.

    *Handler Return Value:* Return 1 if the event should *not* be passed down the event chain to the next object. Else return 0.

    *See Also:* the <on_scroll> event and the <remove_onscroll_listener> function
*/

    int add_onscroll_listener( function f )
        [[
            result = UserData::get( L )->add_callback( (char*) "on_scroll" , L );
            UserData::get( L )->connect_signal(
                "on_scroll",
                "scroll-event",
                G_CALLBACK(actor_on_scroll),
                L);
        ]];

/***************************************
    Function: remove_onscroll_listener

    The remove_onscroll_listener() function unregisters the specified event handler.

    *Arguments:*

        ref - handle for event handler to unregister. This handle is returned by the <add_onscroll_listener> function.

    *Return Value:* None

    *See Also:* the <add_onscroll_listener> function
*/

    remove_onscroll_listener( int ref )
        [[
            UserData::get( L )->remove_callback( (char*) "on_scroll" , L );
        ]];

/***************************************
    Function: add_onenter_listener

    The add_onenter_listener() function registers a handler function for <on_enter> events.

    *Arguments:*

        f - reference to handler function. The function prototype is described below.

    *Return Value:* Handle to the registered handler. Pass this handle to the <remove_onenter_listener> function to unregister the handler.

    *Handler Prototype:*

        (code)
        int f( self, x, y )
        (end)

    *Handler Arguments:*

        self - reference to the object receiving the event
        x - X coordinate position of the mouse pointer
        y - Y coordinate position of the mouse pointer

    *Handler Return Value:* Return 1 if the event should *not* be passed down the event chain to the next object. Else return 0.

    *See Also:* the <on_enter> event and the <remove_onenter_listener> function
*/

    int add_onenter_listener( function f )
        [[
            result = UserData::get( L )->add_callback( (char*) "on_enter" , L );
            UserData::get( L )->connect_signal(
                "on_enter",
                "enter-event",
                G_CALLBACK(actor_on_enter),
                L);
        ]];

/***************************************
    Function: remove_onenter_listener

    The remove_onenter_listener() function unregisters the specified event handler.

    *Arguments:*

        ref - handle for event handler to unregister. This handle is returned by the <add_onenter_listener> function.

    *Return Value:* None

    *See Also:* the <add_onenter_listener> function
*/

    remove_onenter_listener( int ref )
        [[
            UserData::get( L )->remove_callback( (char*) "on_enter" , L );
        ]];

/***************************************
    Function: add_onleave_listener

    The add_onleave_listener() function registers a handler function for <on_leave> events.

    *Arguments:*

        f - reference to handler function. The function prototype is described below.

    *Return Value:* Handle to the registered handler. Pass this handle to the <remove_onleave_listener> function to unregister the handler.

    *Handler Prototype:*

        (code)
        int f( self, x, y )
        (end)

    *Handler Arguments:*

        self - reference to the object receiving the event
        x - X coordinate position of the mouse pointer
        y - Y coordinate position of the mouse pointer

    *Handler Return Value:* Return 1 if the event should *not* be passed down the event chain to the next object. Else return 0.

    *See Also:* the <on_leave> event and the <remove_onleave_listener> function
*/

    int add_onleave_listener( function f )
        [[
            result = UserData::get( L )->add_callback( (char*) "on_leave" , L );
            UserData::get( L )->connect_signal(
                "on_leave",
                "leave-event",
                G_CALLBACK(actor_on_leave),
                L);
        ]];

/***************************************
    Function: remove_onleave_listener

    The remove_onleave_listener() function unregisters the specified event handler.

    *Arguments:*

        ref - handle for event handler to unregister. This handle is returned by the <add_onleave_listener> function.

    *Return Value:* None

    *See Also:* the <add_onleave_listener> function
*/

    remove_onleave_listener( int ref )
        [[
            UserData::get( L )->remove_callback( (char*) "on_leave" , L );
        ]];

/***************************************
    Function: add_onshow_listener

    The add_onshow_listener() function registers a handler function for <on_show> events.

    *Arguments:*

        f - reference to handler function. The function prototype is described below.

    *Return Value:* Handle to the registered handler. Pass this handle to the <remove_onshow_listener> function to unregister the handler.

    *Handler Prototype:*

        (code)
        int f( self )
        (end)

    *Handler Arguments:*

        self - reference to the object receiving the event

    *Handler Return Value:* Return 1 if the event should *not* be passed down the event chain to the next object. Else return 0.

    *See Also:* the <on_show> event and the <remove_onshow_listener> function
*/

    int add_onshow_listener( function f )
        [[
            result = UserData::get( L )->add_callback( (char*) "on_show" , L );
            UserData::get( L )->connect_signal(
                "on_show",
                "show",
                G_CALLBACK(actor_on_show),
                L);
        ]];

/***************************************
    Function: remove_onshow_listener

    The remove_onshow_listener() function unregisters the specified event handler.

    *Arguments:*

        ref - handle for event handler to unregister. This handle is returned by the <add_onshow_listener> function.

    *Return Value:* None

    *See Also:* the <add_onshow_listener> function
*/

    remove_onshow_listener( int ref )
        [[
            UserData::get( L )->remove_callback( (char*) "on_show" , L );
        ]];

/***************************************
    Function: add_onhide_listener

    The add_onhide_listener() function registers a handler function for <on_hide> events.

    *Arguments:*

        f - reference to handler function. The function prototype is described below.

    *Return Value:* Handle to the registered handler. Pass this handle to the <remove_onhide_listener> function to unregister the handler.

    *Handler Prototype:*

        (code)
        int f( self )
        (end)

    *Handler Arguments:*

        self - reference to the object receiving the event

    *Handler Return Value:* Return 1 if the event should *not* be passed down the event chain to the next object. Else return 0.

    *See Also:* the <on_hide> event and the <remove_onhide_listener> function
*/

    int add_onhide_listener( function f )
        [[
            result = UserData::get( L )->add_callback( (char*) "on_hide" , L );
            UserData::get( L )->connect_signal(
                "on_hide",
                "hide",
                G_CALLBACK(actor_on_hide),
                L);
        ]];

/***************************************
    Function: remove_onhide_listener

    The remove_onhide_listener() function unregisters the specified event handler.

    *Arguments:*

        ref - handle for event handler to unregister. This handle is returned by the <add_onhide_listener> function.

    *Return Value:* None

    *See Also:* the <add_onhide_listener> function
*/

    remove_onhide_listener( int ref )
        [[
            UserData::get( L )->remove_callback( (char*) "on_hide" , L );
        ]];

/***************************************
    Function: add_onparentchanged_listener

    The add_onparentchanged_listener() function registers a handler function for <on_parent_changed> events.

    *Arguments:*

        f - reference to handler function. The function prototype is described below.

    *Return Value:* Handle to the registered handler. Pass this handle to the <remove_onparentchanged_listener> function to unregister the handler.

    *Handler Prototype:*

        (code)
        f( self, old_parent )
        (end)

    *Handler Arguments:*

        self - reference to the object receiving the event
        old_parent - reference to the parent object (now unparented). If the object had no parent, this argument will be nil.

    *Handler Return Value:* None

    *See Also:* the <on_parent_changed> event and the <remove_onparentchanged_listener> function
*/

    int add_onparentchanged_listener( function f )
        [[
            result = UserData::get( L )->add_callback( (char*) "on_parent_changed" , L );
            UserData::get( L )->connect_signal(
                "on_parent_changed",
                "parent-set",
                G_CALLBACK(actor_on_parent_changed),
                L);
        ]];

/***************************************
    Function: remove_onparentchanged_listener

    The remove_onparentchanged_listener() function unregisters the specified event handler.

    *Arguments:*

        ref - handle for event handler to unregister. This handle is returned by the <add_onparentchanged_listener> function.

    *Return Value:* None

    *See Also:* the <add_onparentchanged_listener> function
*/

    remove_onparentchanged_listener( int ref )
        [[
            UserData::get( L )->remove_callback( (char*) "on_parent_changed" , L );
        ]];

/***************************************
    Event: on_key_focus_in

    The on_key_focus_in event occurs whenever the object receives the key focus. Focus can be directed to the object by the user or the object can force focus to itself by calling its <grab_key_focus> function.

    *See Also:* the <add_onkeyfocusin_listener> function
*/

    function on_key_focus_in
        [[
            return UserData::get( L )->get_last_callback( (char*) "on_key_focus_in" , L );
        ]]
        [[
            UserData::get( L )->set_last_callback( (char*) "on_key_focus_in" , L );
            UserData::get( L )->connect_signal(
                "on_key_focus_in",
                "key-focus-in",
                G_CALLBACK(actor_on_key_focus_in),
                L);
        ]];

/***************************************
    Event: on_key_focus_out

    The on_key_focus_out event occurs whenever the object loses the key focus.

    *See Also:* the <add_onkeyfocusout_listener> function
*/

    function on_key_focus_out
        [[
            return UserData::get( L )->get_last_callback( (char*) "on_key_focus_out" , L );
        ]]
        [[
            UserData::get( L )->set_last_callback( (char*) "on_key_focus_out" , L );
            UserData::get( L )->connect_signal(
                "on_key_focus_out",
                "key-focus-out",
                G_CALLBACK(actor_on_key_focus_out),
                L);
        ]];

/***************************************
    Event: on_key_down

    The on_key_down event occurs whenever a key is pressed while the object has the key focus.

    *See Also:* the <add_onkeydown_listener> function
*/

    function on_key_down
        [[
            return UserData::get( L )->get_last_callback( (char*) "on_key_down" , L );
        ]]
        [[
            UserData::get( L )->set_last_callback( (char*) "on_key_down" , L );
            UserData::get( L )->connect_signal(
                "on_key_down",
                "key-press-event",
                G_CALLBACK(actor_on_key_down),
                L);
        ]];

/***************************************
    Event: on_key_up

    The on_key_up event occurs whenever a key is released while the object has the key focus.

    *See Also:* the <add_onkeyup_listener> function
*/

    function on_key_up
        [[
            return UserData::get( L )->get_last_callback( (char*) "on_key_up" , L );
        ]]
        [[
            UserData::get( L )->set_last_callback( (char*) "on_key_up" , L );
            UserData::get( L )->connect_signal(
                "on_key_up",
                "key-release-event",
                G_CALLBACK(actor_on_key_up),
                L);
        ]];

/***************************************
    Event: on_button_down

    The on_button_down event occurs whenever a mouse button is pressed. To receive on_button_down events, the object's <reactive> property must be set to true and a call must have been made to the global <controllers.start_pointer> function.

    *See Also:* the <add_onbuttondown_listener> function
*/

    function on_button_down
        [[
            return UserData::get( L )->get_last_callback( (char*) "on_button_down" , L );
        ]]
        [[
            UserData::get( L )->set_last_callback( (char*) "on_button_down" , L );
            UserData::get( L )->connect_signal(
                "on_button_down",
                "button-press-event",
                G_CALLBACK(actor_on_button_down),
                L);
        ]];

/***************************************
    Event: on_button_up

    The on_button_up event occurs whenever a mouse button is released. To receive on_button_up events, the object's <reactive> property must be set to true and a call must have been made to the global <controllers.start_pointer> function.

    *See Also:* the <add_onbuttonup_listener> function
*/

    function on_button_up
        [[
            return UserData::get( L )->get_last_callback( (char*) "on_button_up" , L );
        ]]
        [[
            UserData::get( L )->set_last_callback( (char*) "on_button_up" , L );
            UserData::get( L )->connect_signal(
                "on_button_up",
                "button-release-event",
                G_CALLBACK(actor_on_button_up),
                L);
        ]];

/***************************************
    Event: on_motion

    The on_motion event occurs whenever the mouse pointer moves. To receive on_motion events, the object's <reactive> property must be set to true and a call must have been made to the global <controllers.start_pointer> function.

    *See Also:* the <add_onmotion_listener> function
*/

    function on_motion
        [[
            return UserData::get( L )->get_last_callback( (char*) "on_motion" , L );
        ]]
        [[
            UserData::get( L )->set_last_callback( (char*) "on_motion" , L );
            UserData::get( L )->connect_signal(
                "on_motion",
                "motion-event",
                G_CALLBACK(actor_on_motion),
                L);
        ]];

/***************************************
    Event: on_scroll

    The on_scroll event is fired whenever a scroll wheel event occurs. Scroll wheels are commonly found on computer mice and can be on other input devices, as well. To enable receiving scroll wheel events, the object's <reactive> property must be set to true.

    *See Also:* the <add_onscroll_listener> function
*/

    function on_scroll
        [[
            return UserData::get( L )->get_last_callback( (char*) "on_scroll" , L );
        ]]
        [[
            UserData::get( L )->set_last_callback( (char*) "on_scroll" , L );
            UserData::get( L )->connect_signal(
                "on_scroll",
                "scroll-event",
                G_CALLBACK(actor_on_scroll),
                L);
        ]];

/***************************************
    Event: on_enter

    The on_enter event occurs whenever the mouse pointer enters the object's display space. To receive on_enter events, the object's <reactive> property must be set to true and a call must have been made to the global <controllers.start_pointer> function.

    *See Also:* the <add_onenter_listener> function
*/

    function on_enter
        [[
            return UserData::get( L )->get_last_callback( (char*) "on_enter" , L );
        ]]
        [[
            UserData::get( L )->set_last_callback( (char*) "on_enter" , L );
            UserData::get( L )->connect_signal(
                "on_enter",
                "enter-event",
                G_CALLBACK(actor_on_enter),
                L);
        ]];

/***************************************
    Event: on_leave

    The on_leave event occurs whenever the mouse pointer leaves the object's display space. To receive on_leave events, the object's <reactive> property must be set to true and a call must have been made to the global <controllers.start_pointer> function.

    *See Also:* the <add_onleave_listener> function
*/

    function on_leave
        [[
            return UserData::get( L )->get_last_callback( (char*) "on_leave" , L );
        ]]
        [[
            UserData::get( L )->set_last_callback( (char*) "on_leave" , L );
            UserData::get( L )->connect_signal(
                "on_leave",
                "leave-event",
                G_CALLBACK(actor_on_leave),
                L);
        ]];

/***************************************
    Event: on_show

    The on_show event occurs whenever the object's <show> or <show_all> function is called.

    *See Also:* the <add_onshow_listener> function
*/

    function on_show
        [[
            return UserData::get( L )->get_last_callback( (char*) "on_show" , L );
        ]]
        [[
            UserData::get( L )->set_last_callback( (char*) "on_show" , L );
            UserData::get( L )->connect_signal(
                "on_show",
                "show",
                G_CALLBACK(actor_on_show),
                L);
        ]];

/***************************************
    Event: on_hide

    The on_hide event occurs whenever the object's <hide> or <hide_all> function is called.

    *See Also:* the <add_onhide_listener> function
*/

    function on_hide
        [[
            return UserData::get( L )->get_last_callback( (char*) "on_hide" , L );
        ]]
        [[
            UserData::get( L )->set_last_callback( (char*) "on_hide" , L );
            UserData::get( L )->connect_signal(
                "on_hide",
                "hide",
                G_CALLBACK(actor_on_hide),
                L);
        ]];

/***************************************
    Event: on_parent_changed

    The on_parent_changed event occurs whenever the object's parent changes.

    *See Also:* the <add_onparentchanged_listener> function
*/

    function on_parent_changed
        [[
            return UserData::get( L )->get_last_callback( (char*) "on_parent_changed" , L );
        ]]
        [[
            UserData::get( L )->set_last_callback( (char*) "on_parent_changed" , L );
            UserData::get( L )->connect_signal(
                "on_parent_changed",
                "parent-set",
                G_CALLBACK(actor_on_parent_changed),
                L);
        ]];

/***************************************
    UndocumentedFunction: grab_pointer

    Experimental. Clutter warns about using it.
*/

    grab_pointer()
        [[
            clutter_grab_pointer( self );
        ]];

/***************************************
    UndocumentedFunction: ungrab_pointer

    Experimental. Clutter warns about using it.
*/

    ungrab_pointer()
        [[
            clutter_ungrab_pointer();
        ]];

/***************************************

*/

}

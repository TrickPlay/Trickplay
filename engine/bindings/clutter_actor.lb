module clutter_actor;

[[
#include "clutter/clutter.h"

#include "util.h"
#include "signal_collector.h"
#include "clutter_util.h"
]]

[[

void actor_on_show(ClutterActor*actor,lua_State*L)
{
    lb_invoke_callback(L,actor,ClutterUtil::get_actor_metatable(actor),"on_show",0,0);        
}

void actor_on_hide(ClutterActor*actor,lua_State*L)
{
    lb_invoke_callback(L,actor,ClutterUtil::get_actor_metatable(actor),"on_hide",0,0);        
}
    
void actor_on_key_focus_in(ClutterActor*actor,lua_State*L)
{
    lb_invoke_callback(L,actor,ClutterUtil::get_actor_metatable(actor),"on_key_focus_in",0,0);        
}

void actor_on_key_focus_out(ClutterActor*actor,lua_State*L)
{
    lb_invoke_callback(L,actor,ClutterUtil::get_actor_metatable(actor),"on_key_focus_out",0,0);        
}

gboolean actor_on_key_down(ClutterActor*actor,ClutterKeyEvent*event,lua_State*L)
{
    int result = FALSE;
    
    lua_pushinteger(L,event->keyval);
    lua_pushinteger(L,event->unicode_value);
    lua_pushinteger(L,event->time);
    
    if(lb_invoke_callback(L,actor,ClutterUtil::get_actor_metatable(actor),"on_key_down",3,1))
    {
	if (lua_toboolean(L,-1))
	    result = TRUE;
	lua_pop(L,1);
    }

    return result;
}

gboolean actor_on_key_up(ClutterActor*actor,ClutterKeyEvent*event,lua_State*L)
{
    int result = FALSE;
    
    lua_pushinteger(L,event->keyval);
    lua_pushinteger(L,event->unicode_value);
    lua_pushinteger(L,event->time);
    
    if(lb_invoke_callback(L,actor,ClutterUtil::get_actor_metatable(actor),"on_key_up",3,1))
    {
	if (lua_toboolean(L,-1))
	    result = TRUE;
	lua_pop(L,1);
    }

    return result;
}

gboolean actor_on_button_down(ClutterActor*actor,ClutterButtonEvent*event,lua_State*L)
{
    int result = FALSE;
    
    lua_pushnumber(L,event->x);
    lua_pushnumber(L,event->y);
    lua_pushinteger(L,event->button);
    lua_pushinteger(L,event->click_count);
    
    if(lb_invoke_callback(L,actor,ClutterUtil::get_actor_metatable(actor),"on_button_down",4,1))
    {
	if (lua_toboolean(L,-1))
	    result = TRUE;
	lua_pop(L,1);
    }

    return result;
}

gboolean actor_on_button_up(ClutterActor*actor,ClutterButtonEvent*event,lua_State*L)
{
    int result = FALSE;
    
    lua_pushnumber(L,event->x);
    lua_pushnumber(L,event->y);
    lua_pushinteger(L,event->button);
    lua_pushinteger(L,event->click_count);
    
    if(lb_invoke_callback(L,actor,ClutterUtil::get_actor_metatable(actor),"on_button_up",4,1))
    {
	if (lua_toboolean(L,-1))
	    result = TRUE;
	lua_pop(L,1);
    }

    return result;
}

gboolean actor_on_scroll(ClutterActor*actor,ClutterScrollEvent*event,lua_State*L)
{
    int result = FALSE;
    
    lua_pushnumber(L,event->x);
    lua_pushnumber(L,event->y);
    lua_pushinteger(L,event->direction);
    
    if(lb_invoke_callback(L,actor,ClutterUtil::get_actor_metatable(actor),"on_scroll",3,1))
    {
	if (lua_toboolean(L,-1))
	    result = TRUE;
	lua_pop(L,1);
    }

    return result;
}

static void actor_animation_completed(ClutterAnimation * animation,lua_State * L)
{
    // Get the ref to the callback, which we stored in the animation
    
    int function_ref=GPOINTER_TO_INT(g_object_get_data(G_OBJECT(animation),"tp-completed"));
    
    if (function_ref)
    {
	// Get the function from the registry
	lua_rawgeti(L,LUA_REGISTRYINDEX,function_ref);
	
	// Wrap the actor
	ClutterUtil::wrap_concrete_actor(L,CLUTTER_ACTOR(clutter_animation_get_object(animation)));

	// Call the function	
	lua_call(L,1,0);
	
	// Unref it
	luaL_unref(L,LUA_REGISTRYINDEX,function_ref);
    }
}

]]

/*
    Interface: UI Element 
 
*/

interface actor [[ClutterActor*]]
{
    string name
        [[name=clutter_actor_get_name(self);]]
        [[clutter_actor_set_name(self,name);]];
        
    readonly long gid
        [[gid=clutter_actor_get_gid(self);]];
    
    double x
        [[ x = clutter_actor_get_x( self ); ]]
        [[ clutter_actor_set_x( self , x ); ]];
    
    double y
        [[ y = clutter_actor_get_y( self ); ]]
        [[ clutter_actor_set_y( self , y ); ]];
    
    double z
        [[ z = clutter_actor_get_depth( self ); ]]
        [[ clutter_actor_set_depth( self , z ); ]];

    double w
        [[ w = clutter_actor_get_width( self ); ]]
        [[ clutter_actor_set_width( self , w ); ]];
    
    double h
        [[ h = clutter_actor_get_height( self ); ]]
        [[ clutter_actor_set_height( self , h ); ]];

    double width
        [[ width = clutter_actor_get_width( self ); ]]
        [[ clutter_actor_set_width( self , width ); ]];
    
    double height
        [[ height = clutter_actor_get_height( self ); ]]
        [[ clutter_actor_set_height( self , height ); ]];

    table position
        [[
            lua_newtable(L);
            lua_pushnumber(L,clutter_actor_get_x(self));
            lua_rawseti(L,-2,1);
            lua_pushnumber(L,clutter_actor_get_y(self));
            lua_rawseti(L,-2,2);
            lua_pushnumber(L,clutter_actor_get_depth(self));
	    lua_rawseti(L,-2,3);
        ]]
        [[
            luaL_checktype(L,2,LUA_TTABLE);
            lua_rawgeti(L,2,1);
            lua_rawgeti(L,2,2);
	    lua_rawgeti(L,2,3);
            clutter_actor_set_position(self,lua_tonumber(L,-3),lua_tonumber(L,-2));
	    clutter_actor_set_depth(self,lua_tonumber(L,-1));
            lua_pop(L,3);
        ]];
        
    table anchor_point
        [[
	    gfloat x;
	    gfloat y;
	    clutter_actor_get_anchor_point(self,&x,&y);
            lua_newtable(L);
            lua_pushnumber(L,x);
            lua_rawseti(L,-2,1);
            lua_pushnumber(L,y);
            lua_rawseti(L,-2,2);
        ]]
        [[
            luaL_checktype(L,2,LUA_TTABLE);
            lua_rawgeti(L,2,1);
            lua_rawgeti(L,2,2);	    
            clutter_actor_set_anchor_point(self,lua_tonumber(L,-2),lua_tonumber(L,-2));
            lua_pop(L,2);
        ]];
	
    table size
        [[
            lua_newtable(L);
            lua_pushnumber(L,clutter_actor_get_width(self));
            lua_rawseti(L,-2,1);
            lua_pushnumber(L,clutter_actor_get_height(self));
            lua_rawseti(L,-2,2);
        ]]
        [[
            luaL_checktype(L,2,LUA_TTABLE);
            lua_rawgeti(L,2,1);
            lua_rawgeti(L,2,2);
            clutter_actor_set_size(self,lua_tonumber(L,-2),lua_tonumber(L,-1));
            lua_pop(L,2);
        ]];
        
    table scale
        [[
            gdouble scalex;
            gdouble scaley;
            clutter_actor_get_scale(self,&scalex,&scaley);
            lua_newtable(L);
            lua_pushnumber(L,scalex);
            lua_rawseti(L,-2,1);
            lua_pushnumber(L,scaley);
            lua_rawseti(L,-2,2);
            
            gfloat x;
            gfloat y;
            clutter_actor_get_scale_center(self,&x,&y);
            lua_pushnumber(L,x);
            lua_rawseti(L,-2,3);
            lua_pushnumber(L,y);
            lua_rawseti(L,-2,4);
        ]]
        [[
            luaL_checktype(L,2,LUA_TTABLE);
            lua_rawgeti(L,2,1);
            lua_rawgeti(L,2,2);            
            lua_rawgeti(L,2,3);
            lua_rawgeti(L,2,4);
            if (!lua_isnil(L,-2)&&!lua_isnil(L,-1))
                clutter_actor_set_scale_full(self,lua_tonumber(L,-4),lua_tonumber(L,-3),lua_tonumber(L,-2),lua_tonumber(L,-1));
            else
                clutter_actor_set_scale(self,lua_tonumber(L,-4),lua_tonumber(L,-3));
            lua_pop(L,4);
        ]];
        
    table x_rotation
        [[
            gfloat x;
            gfloat y;
            gfloat z;
            gdouble angle = clutter_actor_get_rotation(self,CLUTTER_X_AXIS,&x,&y,&z);
            lua_newtable(L);
            lua_pushnumber(L,angle);
            lua_rawseti(L,-2,1);
            lua_pushnumber(L,y);
            lua_rawseti(L,-2,2);
            lua_pushnumber(L,z);
            lua_rawseti(L,-2,3);
        ]]
        [[
            luaL_checktype(L,2,LUA_TTABLE);
            lua_rawgeti(L,2,1);
            lua_rawgeti(L,2,2);
            lua_rawgeti(L,2,3);
            clutter_actor_set_rotation(self,CLUTTER_X_AXIS,lua_tonumber(L,-3),0,lua_tonumber(L,-2),lua_tonumber(L,-1));
            lua_pop(L,3);
        ]];

    table y_rotation
        [[
            gfloat x;
            gfloat y;
            gfloat z;
            gdouble angle = clutter_actor_get_rotation(self,CLUTTER_Y_AXIS,&x,&y,&z);
            lua_newtable(L);
            lua_pushnumber(L,angle);
            lua_rawseti(L,-2,1);
            lua_pushnumber(L,x);
            lua_rawseti(L,-2,2);
            lua_pushnumber(L,z);
            lua_rawseti(L,-2,3);
        ]]
        [[
            luaL_checktype(L,2,LUA_TTABLE);
            lua_rawgeti(L,2,1);
            lua_rawgeti(L,2,2);
            lua_rawgeti(L,2,3);
            clutter_actor_set_rotation(self,CLUTTER_Y_AXIS,lua_tonumber(L,-3),lua_tonumber(L,-2),0,lua_tonumber(L,-1));
            lua_pop(L,3);
        ]];
        
    table z_rotation
        [[
            gfloat x;
            gfloat y;
            gfloat z;
            gdouble angle = clutter_actor_get_rotation(self,CLUTTER_Z_AXIS,&x,&y,&z);
            lua_newtable(L);
            lua_pushnumber(L,angle);
            lua_rawseti(L,-2,1);
            lua_pushnumber(L,x);
            lua_rawseti(L,-2,2);
            lua_pushnumber(L,y);
            lua_rawseti(L,-2,3);
        ]]
        [[
            luaL_checktype(L,2,LUA_TTABLE);
            lua_rawgeti(L,2,1);
            lua_rawgeti(L,2,2);
            lua_rawgeti(L,2,3);
            clutter_actor_set_rotation(self,CLUTTER_Z_AXIS,lua_tonumber(L,-3),lua_tonumber(L,-2),lua_tonumber(L,-1),0);
            lua_pop(L,3);
        ]];
        
        
    readonly bool is_scaled
        [[is_scaled=clutter_actor_is_scaled(self);]];
        
    readonly bool is_rotated
        [[is_rotated=clutter_actor_is_rotated(self);]];
        
    int opacity
        [[opacity=clutter_actor_get_opacity(self);]]
        [[clutter_actor_set_opacity(self,opacity);]];
        
    table clip
        [[
            if (!clutter_actor_has_clip(self))
            {
                lua_pushnil(L);
            }
            else
            {
                gfloat x;
                gfloat y;
                gfloat w;
                gfloat h;
                clutter_actor_get_clip(self,&x,&y,&w,&h);
                lua_newtable(L);
                lua_pushnumber(L,x);
                lua_rawseti(L,-2,1);
                lua_pushnumber(L,y);
                lua_rawseti(L,-2,2);
                lua_pushnumber(L,w);
                lua_rawseti(L,-2,3);
                lua_pushnumber(L,h);
                lua_rawseti(L,-2,4);
            }
        ]]
        [[
            if (lua_isnil(L,2))
            {
                clutter_actor_remove_clip(self);
            }
            else
            {
                luaL_checktype(L,2,LUA_TTABLE);
                lua_rawgeti(L,2,1);
                lua_rawgeti(L,2,2);
                lua_rawgeti(L,2,3);
                lua_rawgeti(L,2,4);
                clutter_actor_set_clip(self,lua_tonumber(L,-4),lua_tonumber(L,-3),lua_tonumber(L,-2),lua_tonumber(L,-1));
                lua_pop(L,4);
            }
        ]];
        
    readonly bool has_clip
        [[has_clip=clutter_actor_has_clip(self);]];
        
    double depth
        [[depth=clutter_actor_get_depth(self);]]
        [[clutter_actor_set_depth(self,depth);]];
	
    udata set(table props)
	[[
	    ClutterUtil::set_props_from_table(L,props);
	    lua_pushvalue(L,1);
	]];
#if 0	
    string valign
	[[
	    valign=(const char *)g_object_get_data(G_OBJECT(self),"tp-valign");    
	]]
	[[
	    g_object_set_data_full(G_OBJECT(self),"tp-valign",g_strdup(valign),g_free);
	]];

    string halign
	[[
	    halign=(const char *)g_object_get_data(G_OBJECT(self),"tp-halign");    
	]]
	[[
	    g_object_set_data_full(G_OBJECT(self),"tp-halign",g_strdup(halign),g_free);
	]];
#endif
    show()
        [[clutter_actor_show(self);]];
        
    show_all()
        [[clutter_actor_show_all(self);]];
        
    hide()
        [[clutter_actor_hide(self);]];
        
    hide_all()
        [[clutter_actor_hide_all(self);]];
	
    move_by( double dx , double dy )
	[[clutter_actor_move_by(self,dx,dy);]];
	
    readonly udata parent
	[[ClutterUtil::wrap_concrete_actor(L,clutter_actor_get_parent(self));]];
	
    unparent()
	[[
	    if(ClutterActor * parent=clutter_actor_get_parent(self))
	    {
		clutter_container_remove_actor(CLUTTER_CONTAINER(parent),self);
	    }
	]];
	
    raise( udata above )
	[[
	    ClutterActor* source =ClutterUtil::user_data_to_actor(L,above);
	    if(source)
	    {
		clutter_actor_raise(self,source);
	    }
	]];
	
    lower( udata below )
	[[
	    ClutterActor* source=ClutterUtil::user_data_to_actor(L,below);
	    if (source)
	    {
		clutter_actor_lower(self,source);
	    }
	]];
	
    raise_to_top()
	[[
	    clutter_actor_raise_top(self);    
	]];
	
    lower_to_bottom()
	[[
	    clutter_actor_lower_bottom(self);    
	]];
	
    move_anchor_point( double x , double y )
	[[clutter_actor_move_anchor_point(self,x,y);]];
	
    grab_key_focus()
	[[clutter_actor_grab_key_focus(self);]];
	
    bool reactive
	[[reactive=clutter_actor_get_reactive(self);]]
	[[clutter_actor_set_reactive(self,reactive);]];
	
    readonly table transformed_size
	[[
	    gfloat w;
	    gfloat h;
	    clutter_actor_get_transformed_size(self,&w,&h);
	    lua_newtable(L);
	    lua_pushnumber(L,w);
	    lua_rawseti(L,-2,1);
	    lua_pushnumber(L,h);
	    lua_rawseti(L,-2,2);
	]];
	
    readonly table transformed_position
	[[
	    gfloat x;
	    gfloat y;
	    clutter_actor_get_transformed_position(self,&x,&y);
	    lua_newtable(L);
	    lua_pushnumber(L,x);
	    lua_rawseti(L,-2,1);
	    lua_pushnumber(L,y);
	    lua_rawseti(L,-2,2);
	]];
	
    readonly table min_size
	[[
	    gfloat mw;
	    gfloat mh;
	    gfloat nw;
	    gfloat nh;
	    
	    clutter_actor_get_preferred_size(self,&mw,&mh,&nw,&nh);
	    lua_newtable(L);
	    lua_pushnumber(L,mw);
	    lua_rawseti(L,-2,1);
	    lua_pushnumber(L,mh);
	    lua_rawseti(L,-2,2);
	]];

    readonly table natural_size
	[[
	    gfloat mw;
	    gfloat mh;
	    gfloat nw;
	    gfloat nh;
	    
	    clutter_actor_get_preferred_size(self,&mw,&mh,&nw,&nh);
	    lua_newtable(L);
	    lua_pushnumber(L,nw);
	    lua_rawseti(L,-2,1);
	    lua_pushnumber(L,nh);
	    lua_rawseti(L,-2,2);
	]];
	
    table extra
	[[
	    ClutterUtil::Extra * e = (ClutterUtil::Extra*)g_object_get_data(G_OBJECT(self),"tp-extra");
	    
	    if (!e)
	    {
		g_object_set_data_full(G_OBJECT(self),"tp-extra",new ClutterUtil::Extra(L),ClutterUtil::Extra::destroy);
	    }
	    else
	    {
		e->push_table();
	    }
	]]
	[[
	    if (lua_isnil(L,2))
	    {
		g_object_set_data_full(G_OBJECT(self),"tp-extra",NULL,ClutterUtil::Extra::destroy);
	    }
	    else
	    {
		lb_checktable(L,2);
		g_object_set_data_full(G_OBJECT(self),"tp-extra",new ClutterUtil::Extra(L,2),ClutterUtil::Extra::destroy);
	    }
	]];
	
    string request_mode
	[[
	    ClutterRequestMode mode;
	    g_object_get(G_OBJECT(self),"request-mode",&mode,NULL);
	    switch(mode)
	    {
		case CLUTTER_REQUEST_HEIGHT_FOR_WIDTH:
		    request_mode = "HEIGHT_FOR_WIDTH";
		    break;
		case CLUTTER_REQUEST_WIDTH_FOR_HEIGHT:
		    request_mode = "WIDTH_FOR_HEIGHT";
		    break;
		default:
		    request_mode = "";
	    }
	]]
	[[
	    ClutterRequestMode mode = CLUTTER_REQUEST_HEIGHT_FOR_WIDTH;
	    if (!strcmp(request_mode,"HEIGHT_FOR_WIDTH"))
		mode = CLUTTER_REQUEST_HEIGHT_FOR_WIDTH;
	    else if (!strcmp(request_mode,"WIDTH_FOR_HEIGHT"))
		mode = CLUTTER_REQUEST_WIDTH_FOR_HEIGHT;
	    else
		luaL_error(L,"Invalid request mode '%s'",request_mode);
	    g_object_set(G_OBJECT(self),"request-mode",mode,NULL);
	]];

    animate(table props)
	[[
	    lua_getfield(L,props,"duration");
	    guint duration=lua_tonumber(L,-1);
	    lua_pop(L,1);
	    
	    lua_getfield(L,props,"mode");
	    gulong mode=ClutterUtil::to_clutter_animation_mode(lua_tostring(L,-1));
	    lua_pop(L,1);
	    
	    GPtrArray * names=g_ptr_array_new_with_free_func(g_free);
	    GValueArray * values=g_value_array_new(6);
	    
	    lua_pushnil(L);
	    
	    while(lua_next(L,props))
	    {
		GValue value={0};
		
		if (lua_isstring(L,-2)&&!lua_isnil(L,-2))
		{
		    const char * k=lua_tostring(L,-2);
		
		    if (!strcmp("x",k)||!strcmp("y",k))
		    {
			g_value_init(&value,G_TYPE_FLOAT);
			g_value_set_float(&value,lua_tonumber(L,-1));
			g_ptr_array_add(names,g_strdup(k));
			g_value_array_append(values,&value);
		    }
		    else if (!strcmp("w",k)||!strcmp("width",k))
		    {
			g_value_init(&value,G_TYPE_FLOAT);
			g_value_set_float(&value,lua_tonumber(L,-1));
			g_ptr_array_add(names,g_strdup("width"));
			g_value_array_append(values,&value);
		    }
		    else if (!strcmp("h",k)||!strcmp("height",k))
		    {
			g_value_init(&value,G_TYPE_FLOAT);
			g_value_set_float(&value,lua_tonumber(L,-1));
			g_ptr_array_add(names,g_strdup("height"));
			g_value_array_append(values,&value);
		    }
		    else if (!strcmp("z",k)||!strcmp("depth",k))
		    {
			g_value_init(&value,G_TYPE_FLOAT);
			g_value_set_float(&value,lua_tonumber(L,-1));			
			g_ptr_array_add(names,g_strdup("depth"));
			g_value_array_append(values,&value);			
		    }
		    else if (!strcmp("opacity",k))
		    {
			g_value_init(&value,G_TYPE_UCHAR);
			g_value_set_uchar(&value,lua_tointeger(L,-1));
			g_ptr_array_add(names,g_strdup(k));
			g_value_array_append(values,&value);
		    }
		    else if (!strcmp("position",k))
		    {
			if (lua_type(L,-1)==LUA_TTABLE)
			{
			    g_ptr_array_add(names,g_strdup("x"));
			    g_ptr_array_add(names,g_strdup("y"));
			    
			    lua_rawgeti(L,-1,1);
			    g_value_init(&value,G_TYPE_FLOAT);
			    g_value_set_float(&value,lua_tonumber(L,-1));
			    g_value_array_append(values,&value);			    
			    lua_pop(L,1);
			    
			    lua_rawgeti(L,-1,2);
			    g_value_unset(&value);
			    g_value_init(&value,G_TYPE_FLOAT);
			    g_value_set_float(&value,lua_tonumber(L,-1));
			    g_value_array_append(values,&value);
			    lua_pop(L,1);
			}
		    }
		    else if (!strcmp("size",k))
		    {
			if (lua_type(L,-1)==LUA_TTABLE)
			{
			    g_ptr_array_add(names,g_strdup("width"));
			    g_ptr_array_add(names,g_strdup("height"));
			    
			    lua_rawgeti(L,-1,1);
			    g_value_init(&value,G_TYPE_FLOAT);
			    g_value_set_float(&value,lua_tonumber(L,-1));
			    g_value_array_append(values,&value);			    
			    lua_pop(L,1);
			    
			    lua_rawgeti(L,-1,2);
			    g_value_unset(&value);
			    g_value_init(&value,G_TYPE_FLOAT);
			    g_value_set_float(&value,lua_tonumber(L,-1));
			    g_value_array_append(values,&value);
			    lua_pop(L,1);
			}			
		    }
		    else if (!strcmp("scale",k))
		    {
			if (lua_type(L,-1)==LUA_TTABLE)
			{
			    g_ptr_array_add(names,g_strdup("scale-x"));
			    g_ptr_array_add(names,g_strdup("scale-y"));
			    
			    lua_rawgeti(L,-1,1);
			    g_value_init(&value,G_TYPE_DOUBLE);
			    g_value_set_double(&value,lua_tonumber(L,-1));
			    g_value_array_append(values,&value);			    
			    lua_pop(L,1);
			    
			    lua_rawgeti(L,-1,2);
			    g_value_unset(&value);
			    g_value_init(&value,G_TYPE_DOUBLE);
			    g_value_set_double(&value,lua_tonumber(L,-1));
			    g_value_array_append(values,&value);
			    lua_pop(L,1);
			}			
		    }
		    else if (!strcmp("x_rotation",k))
		    {
			if (lua_type(L,-1)==LUA_TTABLE)
			{
			    
			}
			else
			{
			    g_ptr_array_add(names,g_strdup("rotation-angle-x"));
			    g_value_init(&value,G_TYPE_DOUBLE);
			    g_value_set_double(&value,lua_tonumber(L,-1));
			    g_value_array_append(values,&value);
			}
		    }
		    else if (!strcmp("y_rotation",k))
		    {
			if (lua_type(L,-1)==LUA_TTABLE)
			{
			    
			}
			else
			{
			    g_ptr_array_add(names,g_strdup("rotation-angle-y"));
			    g_value_init(&value,G_TYPE_DOUBLE);
			    g_value_set_double(&value,lua_tonumber(L,-1));
			    g_value_array_append(values,&value);
			}
		    }
		    else if (!strcmp("z_rotation",k))
		    {
			if (lua_type(L,-1)==LUA_TTABLE)
			{
			    
			}
			else
			{
			    g_ptr_array_add(names,g_strdup("rotation-angle-z"));
			    g_value_init(&value,G_TYPE_DOUBLE);
			    g_value_set_double(&value,lua_tonumber(L,-1));
			    g_value_array_append(values,&value);
			}
		    }
		}
		
		lua_pop(L,1);
	    }
	    
	    ClutterAnimation * a=clutter_actor_animatev(self,mode,duration,
							values->n_values,
							(gchar**)names->pdata,
							values->values);
	    
	    lua_getfield(L,props,"loop");
	    if (!lua_isnil(L,-1))
	    {
		clutter_animation_set_loop(a,lua_toboolean(L,-1));
	    }
	    lua_pop(L,1);
	    
	    // If you call animate several times, clutter reuses the same
	    // ClutterAnimation object. So, if we are not set to loop,
	    // and the user passed an "on_completed" function, we may have
	    // to unref the old function and disconnect the old handler.
	    
	    if (!clutter_animation_get_loop(a))
	    {
		lua_getfield(L,props,"on_completed");
		
		if (lua_type(L,-1)==LUA_TFUNCTION)
		{
		    int function_ref=luaL_ref(L,LUA_REGISTRYINDEX);
		    
		    // Remove the old one, if any
		    
		    int old_function_ref=GPOINTER_TO_INT(g_object_get_data(G_OBJECT(a),"tp-completed"));
		    
		    if (old_function_ref)
		    {
			luaL_unref(L,LUA_REGISTRYINDEX,old_function_ref);
		    }
		    
		    g_signal_handlers_disconnect_by_func(a,gpointer(actor_animation_completed),L);
		    
		    // Attach the new one
		    
		    g_object_set_data(G_OBJECT(a),"tp-completed",GINT_TO_POINTER(function_ref));
		    
		    g_signal_connect_after(a,"completed",G_CALLBACK(actor_animation_completed),L);
		}
		else
		{
		    lua_pop(L,1);
		}
	    }
	    
	    g_value_array_free(values);
	    g_ptr_array_free(names,TRUE);
	]];
	
    bool complete_animation()
	[[
	    ClutterAnimation * animation=clutter_actor_get_animation(self);
	    g_debug("ANIMATION=%p",animation);
	    if (animation)
	    {
		clutter_animation_completed(animation);
		result=true;
	    }
	    else
	    {
		result=false;
	    }
	]];
	
    readonly bool is_animating
	[[
	    is_animating=clutter_actor_get_animation(self)!=NULL;    
	]];

    callback on_key_focus_in
	[[
	    SignalCollector::get(L)->connect_if(
		on_key_focus_in,"on_key_focus_in",
		self,"key-focus-in",G_CALLBACK(actor_on_key_focus_in),L);
	]];

    callback on_key_focus_out
	[[
	    SignalCollector::get(L)->connect_if(
		on_key_focus_out,"on_key_focus_out",
		self,"key-focus-out",G_CALLBACK(actor_on_key_focus_out),L);
	]];
	
    callback on_key_down
	[[
	    SignalCollector::get(L)->connect_if(
		on_key_down,"on_key_down",
		self,"key-press-event",G_CALLBACK(actor_on_key_down),L);	    
	]];
	
    callback on_key_up
	[[
	    SignalCollector::get(L)->connect_if(
		on_key_up,"on_key_up",
		self,"key-release-event",G_CALLBACK(actor_on_key_up),L);	    
	]];
	
    callback on_scroll
	[[
	    SignalCollector::get(L)->connect_if(
		on_scroll,"on_scroll",
		self,"scroll-event",G_CALLBACK(actor_on_scroll),L);	    
	]];
	
    callback on_button_down
	[[
	    SignalCollector::get(L)->connect_if(
		on_button_down,"on_button_down",
		self,"button-press-event",G_CALLBACK(actor_on_button_down),L);	    
	]];
	
    callback on_button_up
	[[
	    SignalCollector::get(L)->connect_if(
		on_button_up,"on_button_up",
		self,"button-release-event",G_CALLBACK(actor_on_button_up),L);	    
	]];
	
    callback on_show
	[[
	    SignalCollector::get(L)->connect_if(
		on_show,"on_show",
		self,"show",G_CALLBACK(actor_on_show),L);	    	    
	]];
	
    callback on_hide
	[[
	    SignalCollector::get(L)->connect_if(
		on_hide,"on_hide",
		self,"hide",G_CALLBACK(actor_on_hide),L);	    	    
	]];
}

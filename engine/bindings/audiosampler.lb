
module audiosampler_module;

[[
#include "glib.h"
#include "util.h"
#include "kiss_fftr.h"
#include "common.h"
#include <sstream>

class AudioSample
{
public:
    
    AudioSample(lua_State * l, size_t size):
		L ( l ),
		the_array ( new kiss_fft_scalar[size] ),
		the_array_size ( size )
    {
    }

    ~AudioSample()
    {
    	delete [] the_array;
    }
    
	kiss_fft_scalar get_element_at(size_t position)
	{
		g_assert(position < the_array_size);
		return the_array[position];
	}

	void set_element_at(size_t position, kiss_fft_scalar scalar)
	{
		g_assert(position < the_array_size);
		the_array[position] = scalar;
	}

	size_t get_length()
	{
		return the_array_size;
	}

	const String to_string()
	{
		std::stringstream out;
		size_t i;
		for(i=0; i<the_array_size; i++)
		{
			out << i << ": " << the_array[i] << std::endl;
		}

		return out.str();
	}


private:
    lua_State * L;

friend class AudioSampler;
friend int audiosample_fourier_transform(lua_State*L);
friend int audiosampler_get_sample(lua_State*);

protected:
    kiss_fft_scalar *the_array;
    size_t the_array_size;

};

int new_audiosample( lua_State * );

]]


#	Global: audiosampler
#	
#	Audio sampler lets you sample the audio stream

global audiosampler [[void*]]
{
	audiosampler()
	[[
		g_info("RAND_MAX is 2^%.0f",log2(RAND_MAX));
		lb_construct_empty();
	]];

	# Function: get_sample
	# Record and return an audio sample of nsamples samples, at sample rate of rate Hz, with resolution bits in each sample
	# Defaults to 65536 16-bit samples at 44100 Hz
	udata get_sample(int nsamples=65536, int rate=44100, int resolution=16)
	[[
		// Should really do some actual sampling, but just in case the user wants some white noise:
		AudioSample *sample = new AudioSample(L, nsamples);
		int trunc = exp2(resolution);
		for(int i=0; i<nsamples; i++)
		{
			int rnd = rand();
//			g_info(rnd);
			sample->the_array[i] = rnd % trunc;
		}

		lua_pushlightuserdata( L , sample );
		new_audiosample( L );
		lua_remove( L , -2 );
	]];
}


# Interface: audiosample
# An array of reals representing a PCM audio sample -- the data is stored efficiently and intended to be passed around as a "blob".
# You can access the elements of the array, but this is not especially efficient.  However,
# performing fourier transform operations on this blob works quite nicely.

interface audiosample [[AudioSample*]]
{
	audiosample()
		[[
			self=lb_construct( AudioSample , lua_touserdata( L , -2 ) );
		]];

    ~audiosample()
        [[
            delete self;
        ]];

	# Property: length
	# The number of elements in the array
	readonly int length
		[[
			length = self->get_length();
		]];

	# Function: get_element_at
	# Retrieve the element at the given position in the array, base 0
    double get_element_at(int i)
		[[
			result=self->get_element_at(i);
		]];

	# Function: fourier_transform
	# Calculate the Fourier Transform of part of the sample, returning the results as another sample
	# The section starting at sample #start and continuing for nfft samples will be transformed
	udata fourier_transform(int start=0, int nfft=0)
		[[
			if(0 == nfft)
			{
				nfft = self->the_array_size;
			}
			g_assert(nfft%2 == 0);
			kiss_fft_cpx *cpx = new kiss_fft_cpx[nfft/2+1];
			kiss_fftr_cfg st = kiss_fftr_alloc(nfft, 0, NULL, NULL);

			kiss_fftr( st, &(self->the_array[start]), cpx);

			AudioSample *fft = new AudioSample(L, nfft/2+1);
			for(int i=0; i<nfft/2+1; i++)
			{
				fft->the_array[i] = cpx[i].r;
			}

			delete [] cpx;
			kiss_fft_free(st);

			lua_pushlightuserdata( L , fft );
			new_audiosample( L );
			lua_remove( L , -2 );
		]];

	string __tostring()
		[[
			String s(self->to_string());
			result = s.c_str();
		]];
}

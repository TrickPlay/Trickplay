module clutter_timeline;

[[
#include "clutter/clutter.h"

#include "util.h"
#include "clutter_util.h"
]]

[[
void Timeline_on_new_frame(ClutterTimeline*timeline,gint msecs,lua_State*L);
void Timeline_on_started(ClutterTimeline*timeline,lua_State*L);
void Timeline_on_completed(ClutterTimeline*timeline,lua_State*L);
void Timeline_on_paused(ClutterTimeline*timeline,lua_State*L);
void Timeline_on_marker_reached(ClutterTimeline *timeline,gchar*marker_name,gint msecs,lua_State*L);

// We use these signal handlers to keep the timeline alive as long as
// it is running. There is still an issue with timelines that have
// delays...while the delay is ticking away, they can get collected.

void Timeline_started( ClutterTimeline * timeline , gpointer )
{
    g_object_ref( timeline );
}

void Timeline_paused( ClutterTimeline * timeline , gpointer )
{
    g_object_unref( timeline );
}

void Timeline_completed( ClutterTimeline * timeline , gpointer )
{
    if ( ! clutter_timeline_get_loop( timeline ) )
    {
        g_object_unref( timeline );
    }
}

]]

/*
    Class: Timeline
    
    The Timeline class enables the asynchronous animation of UIElement objects. A Timeline-based animation is most appropriate for animations having a known running time.
    
    The <UIElement.animate> function provides a similar asynchronous method of animating UIElement objects. The animate() function defines beginning and ending property settings, starts running, and continues until completion without changing its initial settings or requiring further intervention by the program. The property settings for each frame of the animation are generated automatically based on a linear progression from the beginning to the ending settings. For an animation that does not require modification during its running, the animate() function provides a simple method of implementation.
    
    A Timeline-based animation enables finer control over the animation, but at the cost of requiring the program to perform animation maintenance during its running. A Timeline-based animation defines its initial property settings, starts running, and then receives periodic notifications in the form of on_new_frame() events that enables--and, in fact, requires--the program to update and modify the property settings based upon the current progress of the animation. Unlike animations created with animate(), the property settings for each frame of a Timeline-based animation must be generated by the program in the on_new_event() event handler. For animations that have a fixed and known running time, a Timeline animation provides a reasonable and powerful method of implementation.
    
    *Code Example:* The following statements use a Timeline object to animate a Rectangle so it moves across the display while rotating around its X-axis.
    
    (code)
    -- Create the Rectangle to animate
   	movingRect = Rectangle{ position = { -100, 400 },
	                        size = { 100, 100 },
	                        color = { 225, 225, 0, 255 } }

	-- Show it on the screen
	screen:add( movingRect )	                        

	-- Animate the Rectangle using a Timeline
	movingRect_tl = Timeline{ duration = 5000,  -- 5 seconds
							  loop = true,      -- loop forever

		-- Event handler
		on_new_frame = function( self, msecs, progress )
		
			-- X changes from -100 to 2020
			movingRect.x = -100 + (2120 * progress)
			
			-- X rotation changes from 0 to 360
			movingRect.x_rotation = { 360 * progress, 0, 0 }
		end
	}

	-- Start the Timeline animation
	movingRect_tl:start()
    (end)

*/

class Timeline [[ClutterTimeline*]]
{
    Timeline(table props = 0)
	[[
		self=clutter_timeline_new(1000);
		g_object_ref(self);
		self=lb_construct_gobject(ClutterTimeline,self);
    	ClutterUtil::set_props_from_table(L,props);

    	g_signal_connect( self , "started" , ( GCallback ) Timeline_started , 0 );
    	g_signal_connect( self , "paused" , ( GCallback ) Timeline_paused , 0 );
        g_signal_connect( self , "completed" , ( GCallback ) Timeline_completed , 0 );

    	g_object_unref(self);
	]];
	
    ~Timeline()
	[[
	]];
	
	/*
		Property: duration
		
		The duration property is an integer value specifying the length of the Timeline in milliseconds.
		
		*Default Setting:* 1000 milliseconds, i.e., one second
		
		*See Also:* the <delay> property
	*/
	
    int duration
	[[duration=clutter_timeline_get_duration(self);]]
	[[clutter_timeline_set_duration(self,duration);]];
	
	/*
		Property: loop
		
		The loop property is a boolean flag indicating whether or not the Timeline should loop infinitely (true = loop). A looping Timeline can be terminated by calling the <stop> function.
		
		*Default Setting:* false, i.e., Timeline does not loop infinitely
		
		*See Also:* the <duration> property and the <stop> function
	*/
	
    bool loop
	[[loop=clutter_timeline_get_loop(self);]]
	[[clutter_timeline_set_loop(self,loop);]];
	
	/*
		Property: delay
		
		The delay property is an integer value specifying the number of milliseconds the Timeline should delay before starting. This is a one-time delay that precedes the initial running of the Timeline. If the Timeline loops, the delay does not occur at the start of subsequent iterations.
		
		*Default Setting:* 0 milliseconds, i.e., no delay
		
		*See Also:* the <duration> property and the <start> function
	*/
	
    int delay
	[[delay=clutter_timeline_get_delay(self);]]
	[[clutter_timeline_set_delay(self,delay);]];
	
	/*
		Property: direction
		
		The direction property is a string specifying the Timeline's direction.
		
		The direction property can be set while the Timeline is running to change its direction.

		*Supported Settings:* The direction string is case-sensitive.
		
			FORWARD - The Timeline will move from its first frame to its last frame
			BACKWARD - The Timeline will move from its last frame to its first frame
			
		*Default Setting:* "FORWARD"
		
		*See Also:* the <duration> property
	*/
	
    string direction
	[[direction=(clutter_timeline_get_direction(self)==CLUTTER_TIMELINE_FORWARD?"FORWARD":"BACKWARD");]]
	[[
	    static const char * directions[3] = { "FORWARD" , "BACKWARD" , NULL };
	    clutter_timeline_set_direction(self,luaL_checkoption(L,-1,directions[0],directions)==0?CLUTTER_TIMELINE_FORWARD:CLUTTER_TIMELINE_BACKWARD);
	]];

	/*
		Property: elapsed
		
		The elapsed property is an integer value specifying the number of milliseconds elapsed since the Timeline began its current iteration.
		
		The elapsed property has a valid value only while the Timeline is running.
		
		*Default Setting:* 0
		
		*See Also:* the <duration> and <loop> properties
	*/
	
    readonly int elapsed
	[[elapsed=clutter_timeline_get_elapsed_time(self);]];
	
	/*
		Property: delta
		
		The delta property is an integer value specifying the number of milliseconds since the last on_new_frame() event handler was invoked.
		
		The delta property contains a valid value only while processing the on_new_frame() event handler; outside of the handler, the property's setting is undefined.
		
		The delta value enables physics-based simulations that require knowledge of the exact amount of time elapsed since the previous callback.
		
		*Default Setting:* Undefined, valid only within the on_new_frame() event handler
		
		*See Also:* the <elapsed> and <duration> properties and the <on_new_frame> event handler
	*/
	
    readonly int delta
	[[delta=clutter_timeline_get_delta(self);]];
	
	/*
		Property: progress
		
		The progress property is a double value between 0 and 1 that indicates the percentage of a running Timeline iteration that has completed. For example, a value of 0.10 indicates that 10% of the current iteration has completed.
		
		The progress property has a valid value only while a Timeline is running. A program can determine if a Timeline is running by accessing the <is_playing> property.
		
		*Default Setting:* Undefined, valid only while the Timeline is running
		
		*See Also:* the <duration>, <elapsed> and <is_playing> properties
	*/
    readonly double progress
	[[progress=clutter_timeline_get_progress(self);]];
	
	/*
		Property: is_playing
		
		The is_playing property is a boolean flag specifying whether or not the Timeline is currently running (true = running).
		
		During the period when a running Timeline is paused, the is_playing property will be false until the Timeline resumes.
		
		*Default Setting:* false
		
		*See Also:* the <progress> property
	*/
	
    readonly bool is_playing
	[[is_playing=clutter_timeline_is_playing(self);]];
	
	/*
		Property: markers
		
		The markers property is a table containing all the markers defined for the Timeline. Each entry in the table is a unique string specifying a marker name. If no markers are defined for the Timeline, the property is set to an empty table.

		*Default Setting:* {}, i.e., an empty table
		
		*See Also:* the <add_marker> and <list_markers> functions
	*/
	
    readonly table markers
	[[Timeline_list_markers(L);]];

	/*
		Function: reverse
		
		The reverse() function toggles the direction of the Timeline, from either "FORWARD" to "BACKWARD" or vice versa. If the reverse() function is called when the Timeline is running, it will reverse direction and run all the way back to its opposite starting/ending point.
		
		*Arguments:* None
		
		*Return Value:* None
		
		*See Also:* the <direction> property
	*/
	
	reverse()
	[[clutter_timeline_set_direction(self,
			clutter_timeline_get_direction(self)==CLUTTER_TIMELINE_FORWARD
			?CLUTTER_TIMELINE_BACKWARD
			:CLUTTER_TIMELINE_FORWARD);]];
	
	/*
		Function: start
		
		The start() function causes the Timeline to begin running and invokes the on_started() event handler.
		
		If a <delay> has been defined, it counts down before the animation begins and the on_started() event handler is called.
		
		If a running Timeline has been paused, it can resume running by calling start() again.
		
		*Arguments:* None
		
		*Return Value:* None
		
		*See Also:* the <on_started> event handler and the <pause> and <stop> functions
	*/
	
    start()
	[[
	  clutter_timeline_start(self);
    ]];
	
	/*
		Function: pause
		
		The pause() function halts a running Timeline at its current position and invokes the on_paused() event handler.
		
		To resume the paused Timeline, call the start() function again; the Timeline will resume from the point at which it had been paused. Note: Calling start() to resume a paused Timeline causes the on_started() event handler to be called.
		
		*Arguments:* None
		
		*Return Value:* None
		
		*See Also:* the <on_paused> event handler and the <start> and <stop> functions
	*/
	
    pause()
	[[clutter_timeline_pause(self);]];
	
	/*
		Function: stop
		
		The stop() function halts a running Timeline and resets the Timeline to its starting position. The stop() function does *not* cause the on_completed() event handler to be called.
		
		*Arguments:* None
		
		*Return Value:* None
		
		*See Also:* the <start> and <pause> functions
	*/
	
    stop()
	[[clutter_timeline_stop(self);]];
	
	/*
		Function: rewind
		
		The rewind() function moves the animation back to its original starting position. If the Timeline is running, it will continue running from its new position.
		
		*Arguments:* None
		
		*Return Value:* None
		
		*See Also:* the <start> and <stop> functions
	*/
	
    rewind()
	[[clutter_timeline_rewind(self);]];
	
	/*
		Function: skip
		
		The skip() function moves the Timeline ahead a specified number of milliseconds.
		
		To skip to a specific time on the Timeline, use the advance() function.

		Note: It is not possible to skip backwards along the Timeline by specifying a negative number of milliseconds. Instead, use the advance() function or define a marker for the desired position and then call advance_to_marker().

		*Arguments:*
		
			msecs - positive integer value specifying the number of milliseconds to advance along the Timeline
			
		*Return Value:* None
		
		*See Also:* the <advance> and <advance_to_marker> functions
	*/

    skip(int msecs)
	[[clutter_timeline_skip(self,msecs);]];
	
	/*
		Function: advance
		
		The advance() function moves the current position to a time specified in milliseconds since the Timeline's beginning. Any non-negative time along the Timeline can be specified, including zero.
		
		The on_new_frame() event handler is not immediately called following a call to advance().
		
		To advance a specific number of milliseconds on the Timeline, use the skip() function.

		*Arguments:*
		
			msecs - non-negative integer value specifying the number of milliseconds along the Timeline at which to set the current position
			
		*Return Value:* None
		
		*See Also:* the <skip> and <advance_to_marker> functions
	*/
	
    advance(int msecs)
	[[clutter_timeline_advance(self,msecs);]];
	
	/*
		Function: add_marker
		
		The add_marker() function defines a named marker that is attached to a specific time on the Timeline. During the running of the Timeline's animation, when the marked time is reached, the on_marker_reached() event handler is called.
		
		Each marker defined for the object must be a unique string. An attempt to add a marker with an existing name has no effect.
		
		The marked time on the Timeline is specified in milliseconds from the start of the animation, not including any initial delay.
		
		A marker can be removed by calling the <remove_marker> function.
		
		The animiation can jump to a particular marker by calling the <advance_to_marker> function.
		
		A table of defined markers can be retrieved from the <markers> property.

		*Arguments:*
		
			name - unique string name of the marker
			msecs - time position in milliseconds from start of Timeline at which to add the marker
			
		*Return Value:* None
		
		*Code Example:* The following statements use a Timeline object to animate a Rectangle so it moves across the display while rotating around its X-axis. It also places  markers at one-second intervals along the Timeline and defines an on_marker_reached() event handler to output an informational message to the console every time a marker is hit during the animation.
    
	    (code)
    	-- Create the Rectangle to animate
   		movingRect = Rectangle{ position = { -100, 400 },
		                        size = { 100, 100 },
		                        color = { 225, 225, 0, 255 } }

		-- Show it on the screen
		screen:add( movingRect )	                        

		-- Animate the Rectangle using a Timeline
		movingRect_tl = Timeline{ duration = 5000,  -- 5 seconds
								  loop = true,      -- loop forever

			-- on_marker_reached() event handler
			on_marker_reached = function( self, name, msecs )
				print( "In on_marker_reached(): Name = ", name, ", time = ", msecs )
			end,

			-- on_new_frame() event handler
			on_new_frame = function( self, msecs, progress )
				-- X changes from -100 to 2020
				movingRect.x = -100 + (2120 * progress)
				-- X rotation changes from 0 to 360
				movingRect.x_rotation = { 360 * progress, 0, 0 }
			end
		}

		-- Define Timeline markers at one-second intervals
		movingRect_tl:add_marker( "Marker1000", 1000 )
		movingRect_tl:add_marker( "Marker2000", 2000 )
		movingRect_tl:add_marker( "Marker3000", 3000 )
		movingRect_tl:add_marker( "Marker4000", 4000 )

		-- Start the Timeline animation
		movingRect_tl:start()
    	(end)

		*See Also:* the <markers> property, the <remove_marker> and <advance_to_marker> functions and the <on_marker_reached> event handler
	*/

    add_marker(string name,int msecs)
	[[clutter_timeline_add_marker_at_time(self,name,msecs);]];

	/*
		Function: remove_marker
		
		The remove_marker() function removes the specified marker from the Timeline. If no marker with the specified name is found, the function has no effect. The <has_marker> function can be used to determine whether a particular marker name is attached to the Timeline.
		
		*Arguments:*
		
			name - string name of the marker to remove
			
		*Return Value:* None
		
		*See Also:* the <markers> property and the <add_marker> function
	*/
		
    remove_marker(string name)
	[[clutter_timeline_remove_marker(self,name);]];
	
	/*
		Function: has_marker
		
		The has_marker() function returns a boolean value specifying whether or not a specified marker name has been defined (true = is defined).
		
		The name-comparison operation is case-sensitive.

		*Arguments:*
		
			name - string name of the marker to search for
			
		*Return Value:* Returns true if marker exists, else returns false.
		
		*See Also:* the <markers> property and the <add_marker> function
	*/
	
    bool has_marker(string name)
	[[result=clutter_timeline_has_marker(self,name);]];
	
	/*
		Function: advance_to_marker
		
		The advance_to_marker() function moves the animation to the specified marker. This also causes the on_marker_reached() event handler to be called with the specified marker name.
		
		The advance_to_marker() function can move the animation to any time point on the Timeline.
		
		*Arguments:*
		
			name - string name of the marker. The string must match a defined marker exactly, including case.
			
		*Return Value:* None
		
		*See Also:* the <add_marker> function and the <on_marker_reached> event handler
	*/
	
    advance_to_marker(string name)
	[[clutter_timeline_advance_to_marker(self,name);]];
    
    /*
    	Function: list_markers
    	
    	The list_markers() function returns a table of markers that have been defined for a specified time. If no time is specified, the returned table contains all the markers defined for the Timeline.
    	
    	*Arguments:*
    	
    		msecs - time position in milliseconds for which to retrieve markers. Optional.
    		
    	*Return Value:* Table of marker name strings defined for the specified time. If no time was specified, the table contains all the markers defined for the Timeline.
    	
    	*See Also:* the <add_marker> function and the <markers> property
    */
    
    table list_markers(int msecs = -1)
	[[
	    gsize len;
	    gchar** markers=clutter_timeline_list_markers(self,msecs,&len);
	    gchar** m = markers;
	    lua_newtable(L);
	    for(int i=1;len;--len,++m,++i)
	    {
		lua_pushstring(L,*m);
		lua_rawseti(L,-2,i);
	    }
	    g_strfreev(markers);
	]];
	
	/*
		Event Handler: on_new_frame
		
		The on_new_frame() event handler is called for each frame of the animation (in theory), enabling the program to update the animation's settings to appropriate values based upon the current position within the animation. In reality, the handler is called as often as possible during the running of the animation and will vary depending primarily upon the underlying hardware.
		
		*Arguments:*
		
			timeline - Timeline object the event applies to
			elapsed - integer value specifying the elapsed time in milliseconds from the animation's start. The same value will be in the object's <elapsed> property.
			progress - double value between 0 and 1 that indicates the percentage of the current Timeline iteration that has completed. The same value will be in the object's <progress> property.
			
		*Return Value:* None
		
		*See Also:* the <duration>, <elapsed> and <progress> properties
	*/
		
    callback on_new_frame
	[[
	    UserData::get(L)->connect_signal_if(
			on_new_frame,
			"on_new_frame",
			"new-frame",
			G_CALLBACK(Timeline_on_new_frame),
			L);
	]];
	
	/*
		Event Handler: on_started
		
		The on_started() event handler is called when the Timeline is started. If a <delay> has been defined, the handler is called after the delay has expired.
		
		*Argument:*
		
			timeline - Timeline object the event applies to
			
		*Return Value:* None
		
		*See Also:* the <start> function
	*/
	
    callback on_started
	[[
	    UserData::get(L)->connect_signal_if(
			on_started,
			"on_started",
			"started",
			G_CALLBACK(Timeline_on_started),
			L);	    
	]];
    
    /*
    	Event Handler: on_completed
    	
    	The on_completed() event handler is called each time the Timeline completes a single iteration. If the object's <loop> property is false, the Timeline will perform a single iteration; otherwise, it will loop infinitely or until it is stopped explicitly by calling the stop() function.
		
		*Argument:*
		
			timeline - Timeline object the event applies to
			
		*Return Value:* None
		
		*See Also:* the <duration> and <loop> properties and the <start> and <stop> functions
    */
    
    callback on_completed
	[[
	    UserData::get(L)->connect_signal_if(
			on_completed,
			"on_completed",
			"completed",
			G_CALLBACK(Timeline_on_completed),
			L);	    	    
	]];
	
	/*
		Event Handler: on_paused
		
		The on_paused() event handler is called when a running Timeline is paused by calling the pause() function.
		
		Paused animations can be resumed by calling the start() function.
		
		*Argument:*
		
			timeline - Timeline object the event applies to
			
		*Return Value:* None
		
		*See Also:* the <pause> and <start> functions
	*/
	
    callback on_paused
	[[
	    UserData::get(L)->connect_signal_if(
			on_paused,
			"on_paused",
			"paused",
			G_CALLBACK(Timeline_on_paused),
			L);	    	    
	]];
	
	/*
		Event Handler: on_marker_reached
		
		The on_marker_reached() event handler is called when a running Timeline arrives at a defined marker.
				
		*Arguments:*
		
			timeline - Timeline object the event applies to
			name - string name of the marker reached
			msecs - integer elapsed time in milliseconds from the animation's beginning
			
		*Return Value:* None
		
		*Code Example:* To see an example of the on_marker_reached() event handler, refer to the code example in the <add_marker> function 
		
		*See Also:* the <add_marker> function
	*/
	
    callback on_marker_reached
	[[
	    UserData::get(L)->connect_signal_if(
			on_marker_reached,
			"on_marker_reached",
			"marker-reached",
			G_CALLBACK(Timeline_on_marker_reached),
			L);	    	    	    
	]];
}

[[
void Timeline_on_new_frame(ClutterTimeline*timeline,gint msecs,lua_State*L)
{
    lua_pushinteger(L,clutter_timeline_get_elapsed_time(timeline));
    lua_pushnumber(L,clutter_timeline_get_progress(timeline));
    UserData::invoke_callback(G_OBJECT(timeline),"on_new_frame",2,0,L);
}

void Timeline_on_started(ClutterTimeline*timeline,lua_State*L)
{
    UserData::invoke_callback(G_OBJECT(timeline),"on_started",0,0,L);
}

void Timeline_on_completed(ClutterTimeline*timeline,lua_State*L)
{
    UserData::invoke_callback(G_OBJECT(timeline),"on_completed",0,0,L);
}

void Timeline_on_paused(ClutterTimeline*timeline,lua_State*L)
{
    UserData::invoke_callback(G_OBJECT(timeline),"on_paused",0,0,L);
}

void Timeline_on_marker_reached(ClutterTimeline *timeline,gchar*marker_name,gint msecs,lua_State*L)
{
    lua_pushstring(L,marker_name);
    lua_pushinteger(L,msecs);
    UserData::invoke_callback(G_OBJECT(timeline),"on_marker_reached",2,0,L);
}

]]

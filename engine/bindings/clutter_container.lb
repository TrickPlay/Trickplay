module clutter_container;

[[
#include "clutter/clutter.h"

#include "util.h"
#include "signal_collector.h"
#include "clutter_util.h"
]]

[[
void container_foreach_callback(ClutterActor*actor,lua_State*L)
{
    // The callback is always at 2
    lua_pushvalue(L,2);
    ClutterUtil::wrap_concrete_actor(L,actor);
    lua_call(L,1,0);
}

]]

interface container [[ClutterActor*]]
{
    add( )
        [[
            for(int i=2;i<=lua_gettop(L);++i)
            {
		if (ClutterActor * actor=ClutterUtil::user_data_to_actor(L,i))
		        clutter_container_add_actor(CLUTTER_CONTAINER(self),actor);
            }
        ]];
	
    remove()
	[[
            for(int i=2;i<=lua_gettop(L);++i)
            {
		if (ClutterActor * actor=ClutterUtil::user_data_to_actor(L,i))
		        clutter_container_remove_actor(CLUTTER_CONTAINER(self),actor);
            }	    
	]];
	
    clear()
	[[
            clutter_group_remove_all(CLUTTER_GROUP(self));	    
	]];
	
    foreach_child( function f )
	[[
	    clutter_container_foreach(CLUTTER_CONTAINER(self),(ClutterCallback)container_foreach_callback,L);    
	]];
	
    table find_child( string name )
	[[
	    ClutterUtil::wrap_concrete_actor(L,clutter_container_find_child_by_name(CLUTTER_CONTAINER(self),name));    
	]];
	
    raise_child( udata child , udata sibling = 0 )
	[[
	    ClutterActor * c = ClutterUtil::user_data_to_actor(L,child);
	    ClutterActor * s = sibling?ClutterUtil::user_data_to_actor(L,sibling):NULL;
	    
	    if (c)
	    {
		clutter_container_raise_child(CLUTTER_CONTAINER(self),c,s);
	    }
	]];
	
    lower_child( udata child , udata sibling = 0 )
	[[
	    ClutterActor * c = ClutterUtil::user_data_to_actor(L,child);
	    ClutterActor * s = sibling?ClutterUtil::user_data_to_actor(L,sibling):NULL;

	    if (c)
	    {
		clutter_container_lower_child(CLUTTER_CONTAINER(self),c,s);
	    }
	]];

    # This one is very wasteful - it has to create and free the list as well as
    # traverse it to determine the number of children. Should consider removing
    # it altogether
    
    readonly int count
	[[
            GList * list=clutter_container_get_children(CLUTTER_CONTAINER(self));
	    count = g_list_length(list);
	    g_list_free(list);
	]];
	
    table children
        [[
            GList * list=clutter_container_get_children(CLUTTER_CONTAINER(self));
	    
	    lua_newtable(L);
	    int n = 1;
	    for(GList*item=g_list_first(list);item;item=g_list_next(item),++n)
	    {
		ClutterUtil::wrap_concrete_actor(L,CLUTTER_ACTOR(item->data));
		lua_rawseti(L,-2,n);
	    }
	    g_list_free(list);
        ]]
        [[
            luaL_checktype(L,2,LUA_TTABLE);
            clutter_group_remove_all(CLUTTER_GROUP(self));
            lua_pushnil(L);
            while(lua_next(L,2))
            {
                ClutterActor* source=ClutterUtil::user_data_to_actor(L,-1);
                if(source)
		{
                    clutter_container_add_actor(CLUTTER_CONTAINER(self),source);
		}
                lua_pop(L,1);
            }
        ]];
	
}


#include "app.h"
#include "sysdb.h"
#include "util.h"
#include "context.h"
#include "network.h"
#include "lb.h"
#include "profiler.h"
#include "json.h"
#include "common.h"

static Debug_OFF ai( "APP-IMAGE" );

//-----------------------------------------------------------------------------
#define APP_TABLE_NAME          "app"
#define APP_FIELD_ID            "id"
#define APP_FIELD_NAME          "name"
#define APP_FIELD_DESCRIPTION   "description"
#define APP_FIELD_AUTHOR        "author"
#define APP_FIELD_COPYRIGHT     "copyright"
#define APP_FIELD_RELEASE       "release"
#define APP_FIELD_VERSION       "version"
#define APP_FIELD_ACTIONS       "actions"

//-----------------------------------------------------------------------------
// Bindings
//-----------------------------------------------------------------------------

extern int luaopen_clutter_actor( lua_State * L );
extern int luaopen_clutter_container( lua_State * L );
extern int luaopen_clutter_screen( lua_State * L );
extern int luaopen_clutter_text( lua_State * L );
extern int luaopen_clutter_rectangle( lua_State * L );
extern int luaopen_clutter_clone( lua_State * L );
extern int luaopen_clutter_group( lua_State * L );
extern int luaopen_clutter_image( lua_State * L );

extern int luaopen_clutter_timeline( lua_State * L );
extern int luaopen_clutter_score( lua_State * L );
extern int luaopen_clutter_alpha( lua_State * L );
extern int luaopen_clutter_interval( lua_State * L );
extern int luaopen_clutter_path( lua_State * L );

extern int luaopen_idle( lua_State * L );
extern int luaopen_timer( lua_State * L );
extern int luaopen_url_request( lua_State * L );
extern int luaopen_globals( lua_State * L );
extern int luaopen_app( lua_State * L );
extern int luaopen_system( lua_State * L );
extern int luaopen_settings( lua_State * L );
extern int luaopen_profile( lua_State * L );
extern int luaopen_xml( lua_State * L );
extern int luaopen_controllers_module( lua_State * L );
extern int luaopen_mediaplayer_module( lua_State * L );
extern int luaopen_audiosampler_module( lua_State * L );
extern int luaopen_stopwatch( lua_State * L );
extern int luaopen_json( lua_State * L );

extern int luaopen_socket( lua_State * L );

extern int luaopen_uri( lua_State * L );
extern int luaopen_physics_module( lua_State * L );
extern int luaopen_editor( lua_State * L );
extern int luaopen_trickplay( lua_State * L );
extern int luaopen_bitmap( lua_State * L );
extern int luaopen_canvas( lua_State * L );

extern int luaopen_typed_array( lua_State * L );
extern int luaopen_webgl( lua_State * L );

#ifndef TP_PRODUCTION
extern int luaopen_devtools( lua_State * L );
#endif

#ifdef TP_UPNP_CLIENT
extern int luaopen_upnp( lua_State * L );
#endif

extern int luaopen_restricted( lua_State * L );
extern int luaopen_apps( lua_State * L );

// This one comes from keys.cpp and is not generated by lb

extern void luaopen_keys( lua_State * L );

// The address to use as a key for the app itself

static char TP_APP_KEY = 0;

//=============================================================================

//=============================================================================

LuaStateProxy::LuaStateProxy( lua_State * l )
    :
    L( l )
{
//    g_debug( "CREATED LSP %p", this );
}

LuaStateProxy::~LuaStateProxy()
{
//    g_debug( "DESTROYED LSP %p", this );
}

void LuaStateProxy::invalidate()
{
    L = NULL;
//    g_debug( "INVALIDATED LSP %p", this );
}

lua_State * LuaStateProxy::get_lua_state()
{
    return L;
}

bool LuaStateProxy::is_valid()
{
    return L != NULL;
}

//=============================================================================

class App::RunAction : public ::Action
{
public:

    RunAction( App * _app , const StringSet & _allowed_names , RunCallback _run_callback , ClutterActor * _splash )
    :
        app( _app ),
        allowed_names( _allowed_names ),
        run_callback( _run_callback ),
        splash( _splash )
    {
        g_assert( app );
        g_assert( run_callback );

        app->ref();

        if ( splash )
        {
            g_object_ref( splash );
        }
    }

    ~RunAction()
    {
        app->unref();

        if ( splash )
        {
            g_object_unref( splash );
        }
    }

protected:

    bool run()
    {
        app->run_part2( allowed_names , run_callback );

        if ( splash )
        {
            if ( ClutterActor * parent = clutter_actor_get_parent( splash ) )
            {
                clutter_container_remove_actor( CLUTTER_CONTAINER( parent ) , splash );
            }
        }

        return false;
    }

private:

    App *               app;
    StringSet           allowed_names;
    App::RunCallback    run_callback;
    ClutterActor *      splash;

};


//=============================================================================

bool App::load_metadata_from_data( const gchar * data, Metadata & md)
{
    // To clear the incoming metadata

    md = Metadata();

    // Open a state with no libraries - not even the base one

    lua_State * L = lua_open();

    g_assert( L );

    try
    {
        // Now, run it with Lua

        int result = luaL_dostring( L, data );

        // Check that it ran OK

        if ( result )
        {
            // Parsing it as Lua failed, try to parse it as JSON.

            if ( JSON::parse( L , data ) )
            {
                if ( ! lua_istable( L , -1 ) )
                {
                    lua_pop( L , 1 );

                    throw String( "FAILED TO PARSE APP METADATA : " ) + lua_tostring( L , -1 );
                }

                lua_setglobal( L , APP_TABLE_NAME );

                lua_pop( L , 1 );
            }
            else
            {
                lua_pop( L , 1 );

                throw String( "FAILED TO PARSE APP METADATA : " ) + lua_tostring( L, -1 );
            }
        }

        // Look for the 'app' global

        lua_getglobal( L, APP_TABLE_NAME );
        if ( !lua_istable( L, -1 ) )
        {
            throw String( "MISSING OR INVALID 'app' TABLE" );
        }

        // Look for the id
        lua_getfield( L, -1, APP_FIELD_ID );
        if ( lua_type( L, -1 ) != LUA_TSTRING )
        {
            throw String( "MISSING OR INVALID APP ID" );
        }

        // Validate the id

        size_t len;
        const char * s = lua_tolstring( L, -1, &len );

        if ( len > 64 )
        {
            throw String( "APP ID IS TOO LONG" );
        }

        static const char * valid_id_characters = "_-.";

        for ( const char * c = s; *c; ++c )
        {
            if ( !g_ascii_isalnum( *c ) )
            {
                if ( !strchr( valid_id_characters, *c ) )
                {
                    throw String( "APP ID CONTAINS INVALID CHARACTERS" );
                }
            }
        }

        if ( strstr( s, ".." ) )
        {
            throw String( "APP ID CONTAINS TWO DOTS" );
        }

        if ( strstr( s, "--" ) )
        {
            throw String( "APP ID CONTAINS TWO DASHES" );
        }

        if ( strstr( s, "__" ) )
        {
            throw String( "APP ID CONTAINS TWO UNDERSCORES" );
        }


        // Store it
        md.id = s;
        lua_pop( L, 1 );

        // Look for the other fields
        lua_getfield( L, -1, APP_FIELD_NAME );
        if ( lua_type( L, -1 ) != LUA_TSTRING )
        {
            throw String( "MISSING OR INVALID APP NAME" );
        }
        md.name = lua_tostring( L, -1 );
        lua_pop( L, 1 );

        lua_getfield( L, -1, APP_FIELD_RELEASE );
        if ( lua_tointeger( L, -1 ) <= 0 )
        {
            throw String( "MISSING OR INVALID APP RELEASE, IT MUST BE A NUMBER GREATER THAN 0" );
        }
        md.release = lua_tointeger( L, -1 );
        lua_pop( L, 1 );

        lua_getfield( L, -1, APP_FIELD_VERSION );
        if ( lua_type( L, -1 ) != LUA_TSTRING )
        {
            throw String( "MISSING OR INVALID APP VERSION" );
        }
        md.version = lua_tostring( L, -1 );
        lua_pop( L, 1 );

        lua_getfield( L, -1, APP_FIELD_DESCRIPTION );
        if ( lua_isstring( L, -1 ) )
        {
            md.description = lua_tostring( L, -1 );
        }
        lua_pop( L, 1 );

        lua_getfield( L, -1, APP_FIELD_AUTHOR );
        if ( lua_isstring( L, -1 ) )
        {
            md.author = lua_tostring( L, -1 );
        }
        lua_pop( L, 1 );

        lua_getfield( L, -1, APP_FIELD_COPYRIGHT );
        if ( lua_isstring( L, -1 ) )
        {
            md.copyright = lua_tostring( L, -1 );
        }
        lua_pop( L, 1 );

        // Look for actions

        lua_getfield( L, -1, APP_FIELD_ACTIONS );
        if ( lua_type( L, -1 ) == LUA_TTABLE )
        {
            lua_pushnil( L );

            while ( lua_next( L, -2 ) )
            {
                if ( lua_isstring( L, -2 ) && lua_type( L, -1 ) == LUA_TTABLE )
                {
                    String action_name = lua_tostring( L, -2 );
                    String uri;
                    String type;
                    String description;

                    lua_getfield( L, -1, "description" );
                    if ( lua_isstring( L, -1 ) )
                    {
                        description = lua_tostring( L, -1 );
                    }
                    lua_pop( L, 1 );

                    lua_getfield( L, -1, "uri" );
                    if ( lua_isstring( L, -1 ) )
                    {
                        uri = lua_tostring( L, -1 );
                    }
                    lua_pop( L, 1 );

                    lua_getfield( L, -1, "type" );
                    if ( lua_isstring( L, -1 ) )
                    {
                        type = lua_tostring( L , -1 );
                    }
                    lua_pop( L, 1 );

                    md.actions[ action_name ] = Action( description, uri, type );

                    lua_pop( L, 1 );
                }
            }
        }
        lua_pop( L, 1 );



        lua_close( L );

        return true;
    }
    catch ( const String & e )
    {
        lua_close( L );
        g_warning( "FAILED TO LOAD APP METADATA FILE : %s", e.c_str() );
        return false;
    }
}


bool App::load_metadata( const char * app_path, App::Metadata & md )
{
    FreeLater free_later;

    g_assert( app_path );

    // Build the path to the metadata file and load its contents

    gchar * path = g_build_filename( app_path, APP_METADATA_FILENAME, NULL );

    free_later( path );

    GError * error = NULL;

    gchar * contents = NULL;

    g_file_get_contents( path, &contents, NULL, &error );

    free_later( contents );

    if ( error )
    {
        g_warning( "FAILED TO LOAD APP METADATA FROM '%s' : %s", path, error->message );

        g_clear_error( &error );

        return false;
    }

    bool result = App::load_metadata_from_data( contents, md );

    if ( result )
    {
        md.path = app_path;
    }

    return result;
}



//-----------------------------------------------------------------------------

void App::scan_app_sources( SystemDatabase * sysdb, const char * app_sources, const char * installed_apps_root, bool force )
{
    FreeLater free_later;

    // If the scan is not forced and we already have apps in the database, bail

    if ( !force && sysdb->get_app_count() > 0 )
    {
        return;
    }

    // Otherwise, let's do the scan

    if ( !app_sources )
    {
        g_warning( "NO APP SOURCES TO SCAN" );
        return;
    }

    std::map< String, Metadata::List > apps;

    //.........................................................................
    // First scan app sources

    gchar ** paths = g_strsplit( app_sources, ";", 0 );

    for ( gchar ** p = paths; *p; ++p )
    {
        gchar * path = g_strstrip( *p );

        GDir * dir = g_dir_open( path, 0, NULL );

        if ( !dir )
        {
            g_warning( "FAILED TO SCAN APP SOURCE %s", path );
        }
        else
        {
            while ( const gchar * base = g_dir_read_name( dir ) )
            {
                gchar * md_file_name = g_build_filename( path, base, "app", NULL );
                free_later( md_file_name );

                if ( !g_file_test( md_file_name, G_FILE_TEST_IS_REGULAR ) )
                {
                    continue;
                }

                gchar * app_path = g_build_filename( path, base, NULL );
                free_later( app_path );

                Metadata md;

                if ( load_metadata( app_path, md ) )
                {
                    g_info( "SCAN FOUND %s (%s/%d) @ %s",
                            md.id.c_str(),
                            md.version.c_str(),
                            md.release,
                            app_path );

                    apps[md.id].push_back( md );
                }
            }

            g_dir_close( dir );
        }
    }

    g_strfreev( paths );

    //.........................................................................
    // Now scan the data directory - where apps may be installed

    if ( g_file_test( installed_apps_root, G_FILE_TEST_EXISTS ) )
    {
        GDir * dir = g_dir_open( installed_apps_root, 0, NULL );

        if ( !dir )
        {
            g_warning( "FAILED TO SCAN APP SOURCE %s", installed_apps_root );
        }
        else
        {
            while ( const gchar * base = g_dir_read_name( dir ) )
            {
                gchar * app_path = g_build_filename( installed_apps_root, base, "source", NULL );
                free_later( app_path );

                gchar * md_file_name = g_build_filename( app_path, "app", NULL );
                free_later( md_file_name );

                if ( !g_file_test( md_file_name, G_FILE_TEST_IS_REGULAR ) )
                {
                    continue;
                }

                Metadata md;

                if ( load_metadata( app_path, md ) )
                {
                    g_info( "SCAN FOUND %s (%s/%d) @ %s",
                            md.id.c_str(),
                            md.version.c_str(),
                            md.release,
                            app_path );

                    apps[md.id].push_back( md );
                }
            }

            g_dir_close( dir );
        }
    }

    if ( !apps.empty() )
    {
        //.........................................................................
        // Now we have a map of app ids - each entry has a list of versions found
        // We are going to gather the latest version of each into a final list.

        Metadata::List final_list;

        std::map< String, Metadata::List >::iterator it = apps.begin();

        for ( ; it != apps.end(); ++it )
        {
            if ( it->second.size() > 1 )
            {
                // Get a reference to the list, so it is easier to deal with

                const Metadata::List & versions( it->second );

                // Now, we point an iterator to the first one in the list. If one of the
                // others has a greater release number, we point the iterator at it.
                //
                // When we are done, this iterator will point to the app metadata
                // with the greatest release number.

                Metadata::List::const_iterator latest = versions.begin();

                for ( Metadata::List::const_iterator vit = ++( versions.begin() ); vit != versions.end(); ++vit )
                {
                    if ( vit->release > latest->release )
                    {
                        latest = vit;
                    }
                }

                // Now, we put the latest one into the final list

                final_list.push_back( *latest );
            }
            else
            {
                // The list only has one element

                final_list.push_back( it->second.front() );
            }
        }

        sysdb->update_all_apps( final_list );
    }
}


//-----------------------------------------------------------------------------

String App::get_data_directory( TPContext * context, const String & app_id )
{
    FreeLater free_later;

    g_assert( context );

    // Get the data directory ready

    gchar * id_hash = g_compute_checksum_for_string( G_CHECKSUM_SHA1, app_id.c_str(), -1 );

    free_later( id_hash );

    gchar * app_data_path = g_build_filename( context->get( TP_DATA_PATH ), "apps", id_hash, NULL );

    free_later( app_data_path );

    if ( !g_file_test( app_data_path, G_FILE_TEST_EXISTS ) )
    {
        if ( g_mkdir_with_parents( app_data_path, 0700 ) != 0 )
        {
            g_warning( "FAILED TO CREATE APP DATA PATH '%s'", app_data_path );

            return String();
        }
    }

    return String( app_data_path );
}


//-----------------------------------------------------------------------------

App * App::load( TPContext * context, const App::Metadata & md, const LaunchInfo & launch )
{
    String app_data_path = get_data_directory( context, md.id );

    if ( app_data_path.empty() )
    {
        return NULL;
    }

    return new App( context, md, app_data_path, launch );
}

//-----------------------------------------------------------------------------

int App::lua_panic_handler( lua_State * L )
{
    g_critical( "%s", String( 60, '=' ).c_str() );
    g_critical( "LUA PANIC : %s", lua_tostring( L, -1 ) );
    g_critical( "%s", String( 60, '=' ).c_str() );

    throw LUA_ERRRUN;
}

//-----------------------------------------------------------------------------

App::App( TPContext * c, const App::Metadata & md, const String & dp, const LaunchInfo & _launch )
    :
    context( c ),
    metadata( md ),
    data_path( dp ),
    L( NULL ),
    lua_state_proxy( NULL ),
    network( NULL ),
    event_group( new EventGroup() ),
    cookie_jar( NULL ),
    screen_gid( 0 ),
    launch( _launch ),
    stage_allocation_handler( 0 )

#ifndef TP_PRODUCTION

    ,debugger( this )

#endif
{

    // Create the user agent

    user_agent = Network::format_user_agent(
                     context->get( TP_SYSTEM_LANGUAGE ),
                     context->get( TP_SYSTEM_COUNTRY ),
                     md.id.c_str(),
                     md.release,
                     context->get( TP_SYSTEM_NAME ),
                     context->get( TP_SYSTEM_VERSION ) );

    // Create the network

    network = new Network( context , event_group );

    // Register to get all notifications

    context->add_notification_handler( "*", forward_notification_handler, this );

    // Register for profile switch

    context->add_notification_handler( TP_NOTIFICATION_PROFILE_CHANGE, profile_notification_handler, this );

    // Create the Lua state

    L = lua_open();
    g_assert( L );

    // Install panic handler that throws an exception

    lua_atpanic( L, lua_panic_handler );

    // Create the lua state proxy

    lua_state_proxy = new LuaStateProxy( L );

    // Put a pointer to us in Lua so bindings can get to it

    lua_pushlightuserdata( L, &TP_APP_KEY );
    lua_pushlightuserdata( L, this );
    lua_rawset( L, LUA_REGISTRYINDEX );
}

#if 0
void debug_hook( lua_State * L, lua_Debug * ar )
{
    printf( "DEBUG: %d\n", ar->event );

    switch ( ar->event )
    {
        case LUA_HOOKCALL:
        {
            lua_getstack( L, 0, ar );
            lua_getinfo( L, "nsl", ar );
            printf( "  CALL\n" );
            break;
        }
    }

    if ( ar->event == LUA_HOOKLINE )
    {
        lua_getinfo( L, "nsl", ar );
        printf( "  LINE: %d : %s : %s\n", ar->currentline, ar->short_src, ar->source );
    }
}
#endif

//-----------------------------------------------------------------------------
// Signal handler that tells us when the stage changes dimensions, so we can
// update the screen's scale.

void App::stage_allocation_notify( gpointer , gpointer , gpointer screen_gid )
{
    ClutterActor * screen = clutter_get_actor_by_gid( GPOINTER_TO_INT( screen_gid ) );

    if ( screen )
    {
        ClutterActor * stage = clutter_stage_get_default();

        gfloat width;
        gfloat height;

        clutter_actor_get_size( stage , & width , & height );

        clutter_actor_set_scale( screen, width / 1920, height / 1080 );

        g_debug( "DISPLAY SIZE CHANGED TO %1.0fx%1.0f" , width , height );
    }
}

//-----------------------------------------------------------------------------

void App::run( const StringSet & allowed_names , RunCallback run_callback )
{
    FreeLater free_later;

    Util::GTimer t;

    // Get the screen ready for the app

    ClutterActor * stage = clutter_stage_get_default();

    g_assert( stage );

    //.........................................................................
    // Look for a splash image

    ClutterActor * splash = 0;

    String splash_path;

    gchar * splash_jpg = g_build_filename( metadata.path.c_str(), "default.jpg", NULL );

    free_later( splash_jpg );

    if ( g_file_test( splash_jpg , G_FILE_TEST_EXISTS ) )
    {
        splash_path = splash_jpg;
    }
    else
    {
        gchar * splash_png = g_build_filename( metadata.path.c_str(), "default.png", NULL );

        free_later( splash_png );

        if ( g_file_test( splash_png , G_FILE_TEST_EXISTS ) )
        {
            splash_path = splash_png;
        }
    }

    if ( ! splash_path.empty() )
    {
        Image * splash_image = Image::decode( splash_path.c_str() );

        if ( ! splash_image )
        {
            g_warning( "SPLASH IMAGE EXISTS BUT COULD NOT BE DECODED" );
        }
        else
        {
            splash = clutter_texture_new();

            clutter_actor_set_name( splash , "splash" );

            Images::load_texture( CLUTTER_TEXTURE( splash ) , splash_image );

            gfloat width;
            gfloat height;

            clutter_actor_get_size( stage , & width , & height );

            clutter_actor_set_scale( splash , width / splash_image->width() , height / splash_image->height() );

            clutter_container_add_actor( CLUTTER_CONTAINER( stage ) , splash );

            clutter_actor_show( stage );

            clutter_actor_queue_redraw( stage );

            delete splash_image;

            g_info( "APP SPLASH %s : %1.3f s", metadata.id.c_str() , t.elapsed() );
        }
    }

    //.........................................................................

    ::Action::post( new RunAction( this , allowed_names , run_callback , splash ) );
}


void App::run_part2( const StringSet & allowed_names , RunCallback run_callback )
{
    PROFILER( "App::run" , PROFILER_INTERNAL_CALLS );

    g_info( "RUNNING %s" , metadata.id.c_str() );

    Util::GTimer t;

    ClutterActor * stage = clutter_stage_get_default();

    g_assert( stage );

    ClutterActor * screen = clutter_group_new();

    g_assert( screen );

    clutter_actor_set_position( screen, 0, 0 );
    clutter_actor_set_size( screen, 1920, 1080 );

    clutter_actor_set_name( screen , "screen" );

    screen_gid = clutter_actor_get_gid( screen );

    stage_allocation_handler = g_signal_connect( stage , "notify::allocation" , ( GCallback ) stage_allocation_notify , GINT_TO_POINTER( screen_gid ) );

    // Call it now to set the screen's initial scale

    stage_allocation_notify( 0 , 0 , GINT_TO_POINTER( screen_gid ) );

    secure_lua_state( allowed_names );

    // Open our stuff
    luaopen_globals( L );

    luaopen_clutter_actor( L );
    luaopen_clutter_container( L );

    luaopen_clutter_screen( L );

    //.........................................................................
    // Lazy loaded

    lua_pushinteger( L , LB_LAZY_LOAD );

    luaopen_clutter_rectangle( L );
    luaopen_clutter_text( L );
    luaopen_clutter_clone( L );
    luaopen_clutter_group( L );
    luaopen_clutter_image( L );
    luaopen_clutter_timeline( L );
    luaopen_clutter_score( L );
    luaopen_clutter_alpha( L );
    luaopen_clutter_interval( L );
    luaopen_clutter_path( L );

    luaopen_idle( L );
    luaopen_timer( L );
    luaopen_xml( L );
    luaopen_app( L );
    luaopen_system( L );
    luaopen_settings( L );
    luaopen_profile( L );
    luaopen_stopwatch( L );
    luaopen_json( L );
    luaopen_controllers_module( L );
    luaopen_audiosampler_module( L );
    luaopen_mediaplayer_module( L );
    luaopen_socket( L );
    luaopen_url_request( L );
    luaopen_uri( L );
    luaopen_physics_module( L );
    luaopen_editor( L );
    luaopen_trickplay( L );
    luaopen_bitmap( L );
    luaopen_canvas( L );
    luaopen_typed_array( L );
    luaopen_webgl( L );

#ifndef TP_PRODUCTION
    luaopen_devtools( L );
#endif

#ifdef TP_UPNP_CLIENT
    luaopen_upnp( L );
#endif

    luaopen_apps( L );
    luaopen_restricted( L );

    lua_pop( L , 1 );

    //.........................................................................

    luaopen_keys( L );

    // Run the script

    FreeLater free_later;

    gchar * main_path = g_build_filename( metadata.path.c_str() , "main.lua" , NULL );

    free_later( main_path );

    int top = lua_gettop( L );

    int result = TP_RUN_OK;

    if ( luaL_dofile( L , main_path ) )
    {
        g_critical( "%s", String( 60, '=' ).c_str() );
        g_critical( "LUA ERROR : %s", lua_tostring( L, -1 ) );
        g_critical( "%s", String( 60, '=' ).c_str() );

        lua_pop( L , lua_gettop( L ) - top );

        result = TP_RUN_APP_ERROR;
    }
    else
    {
        lua_pop( L , lua_gettop( L ) - top );

        // Make it small

        //clutter_actor_set_scale( screen, 0, 0 );

        // By adding it to the stage, the ref is sunk, so we don't need
        // to unref it here.

        clutter_container_add_actor( CLUTTER_CONTAINER( stage ), screen );

        g_info( "APP RUN %s : %1.3f s", metadata.id.c_str(), t.elapsed() );

        notify( context , TP_NOTIFICATION_APP_LOADED );
    }

    run_callback( this , result );
}

//-----------------------------------------------------------------------------

App::~App()
{
#ifndef TP_PRODUCTION

    debugger.uninstall();

#endif

    notify( context , TP_NOTIFICATION_APP_CLOSING );

    context->remove_notification_handler( "*", forward_notification_handler, this );
    context->remove_notification_handler( TP_NOTIFICATION_PROFILE_CHANGE, profile_notification_handler, this );

    // Stops the network thread and waits

    delete network;

    // Cancels all outstanding idle callbacks

    event_group->cancel_all();

    // Release the cookie jar

    release_cookie_jar();

    // Close Lua

    lua_close( L );

    // Invalidate and release the lua state proxy

    lua_state_proxy->invalidate();

    lua_state_proxy->unref();

    // Release the event group

    event_group->unref();

    if ( stage_allocation_handler )
    {
        g_signal_handler_disconnect( clutter_stage_get_default() , stage_allocation_handler );
    }
}

//-----------------------------------------------------------------------------
// Replacement function for math.randomseed that does nothing

static int disabled_randomseed( lua_State * )
{
    return 0;
}

//-----------------------------------------------------------------------------

void App::secure_lua_state( const StringSet & allowed_names )
{
    //.........................................................................
    // Open standard libs

    // We do NOT open these, as they pose security risks

    //      {LUA_IOLIBNAME, luaopen_io},
    //      {LUA_DBLIBNAME, luaopen_debug},

    const luaL_Reg lualibs[] =
    {
        { "", luaopen_base },
        { LUA_TABLIBNAME, luaopen_table },
        { LUA_STRLIBNAME, luaopen_string },
        { LUA_MATHLIBNAME, luaopen_math },
        { LUA_OSLIBNAME, luaopen_os },
        { LUA_LOADLIBNAME, luaopen_package },
        { NULL, NULL }
    };

    for ( const luaL_Reg * lib = lualibs; lib->func; ++lib )
    {
        lua_pushcfunction( L, lib->func );
        lua_pushstring( L, lib->name );
        lua_call( L, 1, 0 );
    }

    //.........................................................................
    // Now, we have to nuke some 'os' functions

    lua_getglobal( L, "os" );

    const char * os_nuke[] =
    {
        "execute",
        "exit",
        "getenv",
        "remove",
        "rename",
        "setlocale",
        "tmpname",
        NULL
    };

    for( const char * * name = os_nuke; * name; ++name )
    {
        lua_pushstring( L, * name );
        lua_pushnil( L );
        lua_rawset( L, -3 );
    }

    lua_pop( L, 1 );

    //.........................................................................
    // Nuke package stuff

    lua_getglobal( L, "package" );

    const char * package_nuke[] =
    {
        "cpath",
        "loaders",
        "loadlib",
        "path",
        "preload",
        NULL
    };

    for( const char * * name = package_nuke; * name; ++name )
    {
        lua_pushstring( L, * name );
        lua_pushnil( L );
        lua_rawset( L, -3 );
    }

#if 0
    // Set "loaders" to an empty table
    // We have to do this if we want 'require' to work

    lua_pushstring( L, "loaders" );
    lua_newtable( L );
    lua_rawset( L, -3 );

#endif

    lua_pop( L, 1 );

    //.........................................................................
    // Nuke globals

    const char * global_nuke[] =
    {
        "require",
        NULL
    };

    for( const char * * name = global_nuke; * name; ++name )
    {
        lua_pushnil( L );
        lua_setglobal( L, * name );
    }

    //.........................................................................

    for ( StringSet::const_iterator it = allowed_names.begin(); it != allowed_names.end(); ++it )
    {
        lb_allow( L, it->c_str() );
    }

    //.........................................................................
    // If there is a fixed random seed, set it and also replace math.randomseed

    int seed = context->get_int( TP_RANDOM_SEED , 0 );

    if ( seed != 0 )
    {
        lua_getglobal( L , "math" );

        lua_getfield( L , -1 , "randomseed" );
        lua_pushinteger( L , seed );
        lua_call( L , 1 , 0 );

        lua_pushcfunction( L , disabled_randomseed );
        lua_setfield( L , -2 , "randomseed" );

        lua_pop( L , 1 );
    }
}

//-----------------------------------------------------------------------------

App * App::get( lua_State * L )
{
    g_assert( L );
    lua_pushlightuserdata( L, &TP_APP_KEY );
    lua_rawget( L, LUA_REGISTRYINDEX );
    App * result = ( App * )lua_touserdata( L, -1 );
    lua_pop( L, 1 );
    g_assert( result );
    return result;
}

//-----------------------------------------------------------------------------

TPContext * App::get_context()
{
    return context;
}

//-----------------------------------------------------------------------------


String App::get_data_path() const
{
    return data_path;
}

//-----------------------------------------------------------------------------

int App::get_profile_id() const
{
    return context->get_int( PROFILE_ID );
}

//-----------------------------------------------------------------------------

const App::Metadata & App::get_metadata() const
{
    return metadata;
}

//-----------------------------------------------------------------------------

const String & App::get_id() const
{
    return metadata.id;
}

//-----------------------------------------------------------------------------

const App::LaunchInfo & App::get_launch_info() const
{
    return launch;
}

//-----------------------------------------------------------------------------

void App::release_cookie_jar()
{
    // Will unref it and set it to NULL
    cookie_jar = Network::cookie_jar_unref( cookie_jar );
}

//-----------------------------------------------------------------------------

Network::CookieJar * App::get_cookie_jar()
{
    if ( !cookie_jar )
    {
        FreeLater free_later;

        gchar * name = g_strdup_printf( "cookies-%d.txt", get_profile_id() );
        free_later( name );

        gchar * file_name = g_build_filename( data_path.c_str(), name, NULL );
        free_later( file_name );

        cookie_jar = Network::cookie_jar_new( file_name );
    }

    return cookie_jar;
}

//-----------------------------------------------------------------------------

Network * App::get_network()
{
    return network;
}

//-----------------------------------------------------------------------------

String App::get_user_agent() const
{
    return user_agent;
}

//-----------------------------------------------------------------------------
// This one forwards all notifications from the context to our listeners

void App::forward_notification_handler( TPContext * context , const char * subject, void * data )
{
    ( ( App * )data )->notify( context , subject );
}

//-----------------------------------------------------------------------------
// Notification handler for profile switches

void App::profile_notification_handler( TPContext * context , const char * subject, void * data )
{
    ( ( App * )data )->profile_switch();
}

//-----------------------------------------------------------------------------

void App::profile_switch()
{
    release_cookie_jar();
}

//-----------------------------------------------------------------------------

lua_State * App::get_lua_state()
{
    return L;
}

//-----------------------------------------------------------------------------

LuaStateProxy * App::ref_lua_state_proxy()
{
    lua_state_proxy->ref();

    return lua_state_proxy;
}

//-----------------------------------------------------------------------------

EventGroup * App::get_event_group()
{
    return event_group;
}

//-----------------------------------------------------------------------------

char * App::normalize_path( const gchar * path_or_uri, bool * is_uri, const StringSet & additional_uri_schemes )
{
    bool it_is_a_uri = false;

    const char * app_path = metadata.path.c_str();

    char * result = NULL;

    // First, see if there is a scheme

    gchar ** parts = g_strsplit( path_or_uri, ":", 2 );

    guint count = g_strv_length( parts );

    if ( count == 0 )
    {
        // What do we do? This is clearly not a good path

        g_critical( "INVALID EMPTY PATH OR URI" );
    }

    else if ( count == 1 )
    {
        // There is no scheme, so this is a simple path

        result = Util::rebase_path( app_path, path_or_uri );
    }
    else
    {
        // There is a scheme

        gchar * scheme = parts[0];
        gchar * uri = parts[1];

        // The scheme is only one character long - assume it
        // is a windows drive letter

        if ( strlen( scheme ) == 1 )
        {
            result = Util::rebase_path( app_path, path_or_uri );
        }
        else
        {
            // If it is HTTP or HTTPS, we just return the whole thing passed in

            if ( !strcmp( scheme, "http" ) || !strcmp( scheme, "https" ) )
            {
                it_is_a_uri = true;

                result = g_strdup( path_or_uri );
            }

            // If it is one of the additional schemes passed in, do the same

            else if ( additional_uri_schemes.find( scheme ) != additional_uri_schemes.end() )
            {
                it_is_a_uri = true;

                result = g_strdup( path_or_uri );
            }

            // Localized file

            else if ( !strcmp( scheme, "localized" ) )
            {
                const char * language = context->get( TP_SYSTEM_LANGUAGE, TP_SYSTEM_LANGUAGE_DEFAULT );
                const char * country = context->get( TP_SYSTEM_COUNTRY, TP_SYSTEM_COUNTRY_DEFAULT );

                gchar * try_path = NULL;

                // Try <app>/localized/en/US/<path>

                try_path = g_build_filename( app_path, "localized", language, country, NULL );

                result = Util::rebase_path( try_path, uri );

                g_free( try_path );

                if ( !g_file_test( result, G_FILE_TEST_EXISTS ) )
                {
                    // Try <app>/localized/en/<path>

                    g_free( result );

                    try_path = g_build_filename( app_path, "localized", language, NULL );

                    result = Util::rebase_path( try_path, uri );

                    g_free( try_path );

                    if ( !g_file_test( result, G_FILE_TEST_EXISTS ) )
                    {
                        // Try <app>/localized/<path>

                        g_free( result );

                        try_path = g_build_filename( app_path, "localized", NULL );

                        result = Util::rebase_path( try_path, uri );

                        g_free( try_path );

                        if ( !g_file_test( result, G_FILE_TEST_EXISTS ) )
                        {
                            // End up with <app>/<path>

                            g_free( result );

                            result = Util::rebase_path( app_path, uri );
                        }
                    }
                }
            }
            else
            {
                g_critical( "INVALID SCHEME IN '%s'", path_or_uri );
            }
        }
    }

    g_strfreev( parts );

    if ( result && is_uri )
    {
        *is_uri = it_is_a_uri;
    }

#ifdef TP_PRODUCTION

    // Check for links

    if ( result && !it_is_a_uri && g_file_test( result, G_FILE_TEST_IS_SYMLINK ) )
    {
        g_critical( "SYMBOLIC LINKS NOT ALLOWED : %s", result );
        g_free( result );
        result = NULL;
    }

#endif

    return result;
}

//-----------------------------------------------------------------------------

bool App::change_app_path( const char * path )
{
    g_assert( path );

    if ( ! g_file_test( path , G_FILE_TEST_IS_DIR ) )
    {
        return false;
    }

    metadata.path = path;

    g_warning( "*** APP SANDBOX CHANGED FOR %s TO '%s'" , metadata.id.c_str() , path );
    return true;
}

//-----------------------------------------------------------------------------

guint32 App::get_screen_gid() const
{
    return screen_gid;
}

//-----------------------------------------------------------------------------

Debugger * App::get_debugger()
{
#ifndef TP_PRODUCTION

    return & debugger;

#else

    return NULL;

#endif
}

//-----------------------------------------------------------------------------

void App::animate_in()
{
    if ( !screen_gid )
    {
        return;
    }

    ClutterActor * screen = clutter_get_actor_by_gid( screen_gid );

    if ( !screen )
    {
        return;
    }

    ClutterActor * stage = clutter_stage_get_default();

    gfloat width;
    gfloat height;

    clutter_actor_get_size( stage, &width , &height );


    // TODO
    // Here, we should ref the screen, create a timeline that animates the
    // screen and unref it when the timeline completes.

    clutter_actor_raise_top( screen );

    clutter_actor_set_scale( screen, width / 1920, height / 1080 );

    clutter_actor_grab_key_focus( screen );
}

//-----------------------------------------------------------------------------

void App::animate_out()
{
    if ( !screen_gid )
    {
        return;
    }

    ClutterActor * screen = clutter_get_actor_by_gid( screen_gid );

    if ( !screen )
    {
        return;
    }

    // So we can hold on to it until we are done

    g_object_ref( G_OBJECT( screen ) );

    g_idle_add_full( G_PRIORITY_HIGH, animate_out_callback, screen, NULL );
}

//-----------------------------------------------------------------------------

static void animate_out_completed( ClutterAnimation * animation, ClutterActor * actor )
{
    ClutterActor * parent = clutter_actor_get_parent( actor );

    if ( parent )
    {
        clutter_container_remove_actor( CLUTTER_CONTAINER( parent ), actor );
    }
}


gboolean App::animate_out_callback( gpointer s )
{
    ClutterActor * screen = CLUTTER_ACTOR( s );

    ClutterActor * parent = clutter_actor_get_parent( screen );

    if ( parent )
    {
        // TODO
        // What we would actually do here is to animate the screen out
        // and in the completed callback for that, remove it from its
        // parent and unref it

        //clutter_container_remove_actor( CLUTTER_CONTAINER( parent ), screen );

        gfloat width;
        gfloat height;

        clutter_actor_get_size( parent, &width, &height );

        clutter_actor_set_anchor_point( screen, 960, 540 );

        clutter_actor_set_position( screen, width / 2, height / 2 );

        clutter_actor_set_clip( screen, 0, 0, 1920, 1080 );

        clutter_actor_animate( screen, CLUTTER_EASE_IN_CUBIC, 250,
                               "opacity", 0,
                               "scale-x", ( gdouble ) 0,
                               "scale-y", ( gdouble ) 0,
                               "signal::completed", animate_out_completed, screen,
                               NULL );
    }

    g_object_unref( G_OBJECT( screen ) );

    return FALSE;
}

//-----------------------------------------------------------------------------


Image * App::load_image( const gchar * source )
{
    ai( "LOADING SYNC '%s'" , source );

    if ( ! source )
    {
        return 0;
    }

    bool is_uri;

    char * path = normalize_path( source , & is_uri );

    if ( ! path )
    {
        ai( "  INVALID PATH" );
        return 0;
    }

    FreeLater free_later( path );

    Image * image = 0;

    if ( is_uri )
    {
        ai( "  STARTING REQUEST" );

        Network::Request request( get_user_agent(), path );

        Network::Response response = get_network()->perform_request( request, get_cookie_jar() );

        if ( ! response.failed && response.body->len > 0 )
        {
            ai( "  DECODING" );

            image = Image::decode( response.body->data, response.body->len, response.get_header( "Content-Type" ) );
        }
        else
        {
            ai( "  REQUEST FAILED" );
        }
    }
    else
    {
        ai( "  PATH IS '%s'" , path );
        ai( "  DECODING" );

        image = Image::decode( path );
    }

    ai( "  %s" , image ? "SUCCEEDED" : "FAILED" );

    return image;
}

class ImageResponseClosure
{
public:

    ImageResponseClosure( Image::DecodeAsyncCallback _callback , gpointer _user , GDestroyNotify _destroy_notify )
    :
        callback( _callback ),
        user( _user ),
        destroy_notify( _destroy_notify )
    {
    }

    static void response_callback( const Network::Response & response , gpointer me )
    {
        ImageResponseClosure * self = ( ImageResponseClosure * ) me;

        if ( response.failed || response.body->len == 0 )
        {
            ai( "  REQUEST FAILED" );

            self->callback( 0 , self->user );
        }
        else
        {
            ai( "  STARTING DECODE FOM BUFFER" );

            Image::decode_async( response.body ,
                    response.get_header( "Content-Type" ),
                    self->callback,
                    self->user,
                    self->destroy_notify );

            self->destroy_notify = 0;
        }
    }

    static void destroy( gpointer me )
    {
        ImageResponseClosure * self = ( ImageResponseClosure * ) me;

        if ( self->destroy_notify )
        {
            self->destroy_notify( self->user );
        }

        delete self;
    }

private:


    Image::DecodeAsyncCallback  callback;
    gpointer                    user;
    GDestroyNotify              destroy_notify;
};

bool App::load_image_async( const gchar * source , Image::DecodeAsyncCallback callback , gpointer user , GDestroyNotify destroy_notify )
{
    ai( "LOADING ASYNC '%s'" , source );

    if ( ! source )
    {
        return false;
    }

    bool is_uri;

    char * path = normalize_path( source , & is_uri );

    if ( ! path )
    {
        ai( "  INVALID PATH" );
        return false;
    }

    FreeLater free_later( path );

    if ( is_uri )
    {
        ai( "  STARTING NETWORK REQUEST" );

        Network::Request request( get_user_agent(), path );

        get_network()->perform_request_async(
            request,
            get_cookie_jar(),
            ImageResponseClosure::response_callback,
            new ImageResponseClosure( callback , user , destroy_notify ),
            ImageResponseClosure::destroy );
    }
    else
    {
        ai( "  PATH IS '%s'" , path );
        ai( "  STARTING DECODE FROM FILE" );

        Image::decode_async( path , callback , user , destroy_notify );
    }

    return true;
}

void App::audio_match( const String & json )
{
    // TODO: Not terribly excited about doing it this way

    lua_getglobal( L , "app" );

    if ( lua_isnil( L , -1 ) )
    {
        lua_pop( L , 1 );
        return;
    }

    if ( UserData * ud = UserData::get( L , lua_gettop( L ) ) )
    {
        JSON::parse( L , json.c_str() );

        if ( lua_isnil( L , -1 ) )
        {
            lua_pop( L , 1 );
        }
        else
        {
            ud->invoke_callback( "on_audio_match" , 1 , 0 );
        }
    }

    lua_pop( L , 1 );
}


#include "app.h"
#include "sysdb.h"
#include "util.h"
#include "context.h"
#include "network.h"
#include "lb.h"
#include "profiler.h"
#include "json.h"
#include "common.h"
#include "keyboard.h"
#include "app_resource.h"
#include "plugin.h"
#include "trickplay/plugins/lua-api.h"

#ifdef TP_WITH_GAMESERVICE
#include "game.h"
#include "gameservice_support.h"
#endif

//.............................................................................

#define TP_LOG_DOMAIN   "APP"
#define TP_LOG_ON       false
#define TP_LOG2_ON      false

#include "log.h"

//-----------------------------------------------------------------------------
#define APP_TABLE_NAME          "app"
#define APP_FIELD_ID            "id"
#define APP_FIELD_NAME          "name"
#define APP_FIELD_DESCRIPTION   "description"
#define APP_FIELD_AUTHOR        "author"
#define APP_FIELD_COPYRIGHT     "copyright"
#define APP_FIELD_RELEASE       "release"
#define APP_FIELD_VERSION       "version"
#define APP_FIELD_ACTIONS       "actions"
#define APP_FIELD_ATTRIBUTES    "attributes"
#define APP_FIELD_GAMESERVICE_ATTRIBUTE    "gameservice"

//-----------------------------------------------------------------------------
// Bindings
//-----------------------------------------------------------------------------

extern int luaopen_clutter_actor( lua_State * L );
extern int luaopen_clutter_container( lua_State * L );
extern int luaopen_clutter_screen( lua_State * L );
extern int luaopen_clutter_text( lua_State * L );
extern int luaopen_clutter_rectangle( lua_State * L );
extern int luaopen_clutter_clone( lua_State * L );
extern int luaopen_clutter_group( lua_State * L );
extern int luaopen_clutter_image( lua_State * L );

extern int luaopen_sprite_sheet( lua_State * L );
extern int luaopen_sprite( lua_State * L );
extern int luaopen_nineslice( lua_State * L );

extern int luaopen_clutter_timeline( lua_State * L );
extern int luaopen_clutter_animator( lua_State * L );
extern int luaopen_clutter_state( lua_State * L );
extern int luaopen_clutter_score( lua_State * L );
extern int luaopen_clutter_alpha( lua_State * L );
extern int luaopen_clutter_interval( lua_State * L );
extern int luaopen_clutter_path( lua_State * L );
extern int luaopen_clutter_constraint( lua_State * L );

extern int luaopen_idle( lua_State * L );
extern int luaopen_timer( lua_State * L );
extern int luaopen_url_request( lua_State * L );
extern int luaopen_globals( lua_State * L );
extern int luaopen_app( lua_State * L );
extern int luaopen_system( lua_State * L );
extern int luaopen_settings( lua_State * L );
extern int luaopen_profile( lua_State * L );
extern int luaopen_xml( lua_State * L );
extern int luaopen_controllers( lua_State * L );
extern int luaopen_Controller( lua_State * L );
extern int luaopen_tuners( lua_State * L );
extern int luaopen_Tuner( lua_State * L );
extern int luaopen_mediaplayer_module( lua_State * L );
extern int luaopen_stopwatch( lua_State * L );
extern int luaopen_json( lua_State * L );
extern int luaopen_regex( lua_State * L);

extern int luaopen_socket( lua_State * L );

extern int luaopen_uri( lua_State * L );
extern int luaopen_physics_module( lua_State * L );
extern int luaopen_physics_bullet( lua_State * L );
extern int luaopen_editor( lua_State * L );
extern int luaopen_trickplay( lua_State * L );
extern int luaopen_bitmap( lua_State * L );
extern int luaopen_canvas( lua_State * L );
extern int luaopen_keyboard( lua_State * L );
extern int luaopen_http_module( lua_State * L );
extern int luaopen_ease( lua_State * L );
extern int luaopen_matrix( lua_State * L );

#ifdef TP_WITH_GAMESERVICE
extern int luaopen_gameservice( lua_State * L );
#endif

#ifdef TP_WITH_WEBGL
extern int luaopen_typed_array( lua_State * L );
extern int luaopen_webgl( lua_State * L );
#endif

#ifndef TP_PRODUCTION
extern int luaopen_devtools( lua_State * L );
#endif

#ifdef TP_UPNP_CLIENT
extern int luaopen_upnp( lua_State * L );
#endif

extern int luaopen_restricted( lua_State * L );
extern int luaopen_apps( lua_State * L );

// This one comes from keys.cpp and is not generated by lb

extern void luaopen_keys( lua_State * L );

// The address to use as a key for the app itself

static char TP_APP_KEY = 0;

//=============================================================================

//=============================================================================

LuaStateProxy::LuaStateProxy( lua_State * l )
    :
    L( l )
{
//    g_debug( "CREATED LSP %p", this );
}

LuaStateProxy::~LuaStateProxy()
{
//    g_debug( "DESTROYED LSP %p", this );
}

void LuaStateProxy::invalidate()
{
    L = NULL;
//    g_debug( "INVALIDATED LSP %p", this );
}

lua_State * LuaStateProxy::get_lua_state()
{
    return L;
}

bool LuaStateProxy::is_valid()
{
    return L != NULL;
}

//=============================================================================

bool App::Metadata::set_root( const String & uri_or_native_path )
{
    GFile * file = g_file_new_for_commandline_arg( uri_or_native_path.c_str() );

    char * uri = g_file_get_uri( file );

    char * path = g_file_is_native( file ) ? g_file_get_path( file ) : 0;

    g_object_unref( file );

    bool result = uri != 0;

    if ( result )
    {
        root_uri = uri;
        root_native_path = path ? path : "";
    }

    g_free( uri );
    g_free( path );

    return result;
}

class LuaAPIPlugin
{
public:

    static void call_open( lua_State * L )
    {
        App * app = App::get( L );

        String app_id = app->get_id();

        List * list = get_list( app->get_context() );

        for ( List::const_iterator it = list->begin(); it != list->end(); ++it )
        {
            tplog2( "CALLING OPEN ON PLUGIN '%s'..." , (*it)->plugin->name().c_str() );

            int top_before = lua_gettop( L );

            int result = (*it)->open( L , app_id.c_str() , (*it)->plugin->user_data() );

            if ( 0 != result )
            {
                tpwarn( "  PLUGIN OPEN RETURNED %d" , result );
            }
            else
            {
                tplog2( "  PLUGIN OPENED" );
            }

            int top_after = lua_gettop( L );

            if ( top_after > top_before )
            {
                tpwarn( "  PLUGIN OPEN LEFT %d VALUE(S) ON THE STACK" , top_after - top_before );

                lua_pop( L , top_after - top_before + 1 );
            }
            else if ( top_after < top_before )
            {
                tpwarn( "  PLUGIN OPEN POPPED TOO MANY VALUES OFF THE STACK" );
            }
        }
    }

    static void call_close( lua_State * L )
    {
        App * app = App::get( L );

        String app_id = app->get_id();

        List * list = get_list( app->get_context() );

        for ( List::const_iterator it = list->begin(); it != list->end(); ++it )
        {
            tplog2( "CALLING CLOSE ON PLUGIN '%s'..." , (*it)->plugin->name().c_str() );

            int top_before = lua_gettop( L );

            (*it)->close( L , app_id.c_str() , (*it)->plugin->user_data() );

            tplog2( "  PLUGIN CLOSED" );

            int top_after = lua_gettop( L );

            if ( top_after > top_before )
            {
                tpwarn( "  PLUGIN CLOSE LEFT %d VALUE(S) ON THE STACK" , top_after - top_before );

                lua_pop( L , top_after - top_before + 1 );
            }
            else if ( top_after < top_before )
            {
                tpwarn( "  PLUGIN CLOSE POPPED TOO MANY VALUES OFF THE STACK" );
            }
        }
    }

private:

    LuaAPIPlugin( TrickPlay::Plugin * _plugin )
    :
        plugin( _plugin )
    {
        g_assert( plugin );

        open = ( TPLuaAPIOpen ) plugin->get_symbol( TP_LUA_API_OPEN );
        close = ( TPLuaAPIClose ) plugin->get_symbol( TP_LUA_API_CLOSE );

        g_assert( open );
        g_assert( close );
    }

    ~LuaAPIPlugin()
    {
        delete plugin;
    }

    typedef std::list< LuaAPIPlugin * > List;

    static List * get_list( TPContext * context )
    {
        static char key = 0;

        List * result = ( List * ) context->get_internal( & key );

        if ( ! result )
        {
            result = new List;

            StringList symbols;
            symbols.push_back( TP_LUA_API_OPEN );
            symbols.push_back( TP_LUA_API_CLOSE );

            TrickPlay::Plugin::List plugins = TrickPlay::Plugin::scan( context , "tp_lua_api-" , symbols );

            for ( TrickPlay::Plugin::List::const_iterator it = plugins.begin(); it != plugins.end(); ++it )
            {
                result->push_back( new LuaAPIPlugin( * it ) );
            }

            context->add_internal( & key , result , destroy_list );
        }

        return result;
    }

    static void destroy_list( gpointer _list )
    {
        g_assert( _list );

        List * list = ( List * ) _list;

        for ( List::const_iterator it = list->begin(); it != list->end(); ++it )
        {
            delete * it;
        }

        delete list;
    }

    TrickPlay::Plugin *    plugin;
    TPLuaAPIOpen        open;
    TPLuaAPIClose        close;
};

//=============================================================================

class App::RunAction : public ::Action
{
public:

    RunAction( App * _app , const StringSet & _allowed_names , RunCallback _run_callback , ClutterActor * _splash )
    :
        app( _app ),
        allowed_names( _allowed_names ),
        run_callback( _run_callback ),
        splash( _splash )
    {
        g_assert( app );
        g_assert( run_callback );

        app->ref();

        if ( splash )
        {
            g_object_ref( splash );
        }
    }

    ~RunAction()
    {
        app->unref();

        if ( splash )
        {
            g_object_unref( splash );
        }
    }

protected:

    bool run()
    {
        app->run_part2( allowed_names , run_callback );

        if ( splash )
        {
            if ( ClutterActor * parent = clutter_actor_get_parent( splash ) )
            {
#ifdef CLUTTER_VERSION_1_10
                clutter_actor_remove_child( parent, splash );
#else
                clutter_container_remove_actor( CLUTTER_CONTAINER( parent ) , splash );
#endif
            }
        }

        return false;
    }

private:

    App *               app;
    StringSet           allowed_names;
    App::RunCallback    run_callback;
    ClutterActor *      splash;

};


//=============================================================================

bool App::load_metadata_from_data( const gchar * data ,  Metadata & md)
{
    // To clear the incoming metadata

    md = Metadata();

    // Open a state with no libraries - not even the base one

    lua_State * L = luaL_newstate( );

    g_assert( L );

    try
    {
        // Now, run it with Lua

        int result = luaL_dostring( L, data );

        // Check that it ran OK

        if ( result )
        {
            // Parsing it as Lua failed, try to parse it as JSON.

            if ( JSON::parse( L , data ) )
            {
                if ( ! lua_istable( L , -1 ) )
                {
                    lua_pop( L , 1 );

                    throw String( "FAILED TO PARSE APP METADATA : " ) + lua_tostring( L , -1 );
                }

                lua_setglobal( L , APP_TABLE_NAME );

                lua_pop( L , 1 );
            }
            else
            {
                lua_pop( L , 1 );

                throw String( "FAILED TO PARSE APP METADATA : " ) + lua_tostring( L, -1 );
            }
        }

        // Look for the 'app' global

        lua_getglobal( L, APP_TABLE_NAME );
        if ( !lua_istable( L, -1 ) )
        {
            throw String( "MISSING OR INVALID 'app' TABLE" );
        }

        // Look for the id
        lua_getfield( L, -1, APP_FIELD_ID );
        if ( lua_type( L, -1 ) != LUA_TSTRING )
        {
            throw String( "MISSING OR INVALID APP ID" );
        }

        // Validate the id

        size_t len;
        const char * s = lua_tolstring( L, -1, &len );

        if ( len > 64 )
        {
            throw String( "APP ID IS TOO LONG" );
        }

        static const char * valid_id_characters = "_-.";

        for ( const char * c = s; *c; ++c )
        {
            if ( !g_ascii_isalnum( *c ) )
            {
                if ( !strchr( valid_id_characters, *c ) )
                {
                    throw String( "APP ID CONTAINS INVALID CHARACTERS" );
                }
            }
        }

        if ( strstr( s, ".." ) )
        {
            throw String( "APP ID CONTAINS TWO DOTS" );
        }

        if ( strstr( s, "--" ) )
        {
            throw String( "APP ID CONTAINS TWO DASHES" );
        }

        if ( strstr( s, "__" ) )
        {
            throw String( "APP ID CONTAINS TWO UNDERSCORES" );
        }


        // Store it
        md.id = s;
        lua_pop( L, 1 );

        // Look for the other fields
        lua_getfield( L, -1, APP_FIELD_NAME );
        if ( lua_type( L, -1 ) != LUA_TSTRING )
        {
            throw String( "MISSING OR INVALID APP NAME" );
        }
        md.name = lua_tostring( L, -1 );
        lua_pop( L, 1 );

        lua_getfield( L, -1, APP_FIELD_RELEASE );
        if ( lua_tointeger( L, -1 ) <= 0 )
        {
            throw String( "MISSING OR INVALID APP RELEASE, IT MUST BE A NUMBER GREATER THAN 0" );
        }
        md.release = lua_tointeger( L, -1 );
        lua_pop( L, 1 );

        lua_getfield( L, -1, APP_FIELD_VERSION );
        if ( lua_type( L, -1 ) != LUA_TSTRING )
        {
            throw String( "MISSING OR INVALID APP VERSION" );
        }
        md.version = lua_tostring( L, -1 );
        lua_pop( L, 1 );

        lua_getfield( L, -1, APP_FIELD_DESCRIPTION );
        if ( lua_isstring( L, -1 ) )
        {
            md.description = lua_tostring( L, -1 );
        }
        lua_pop( L, 1 );

        lua_getfield( L, -1, APP_FIELD_AUTHOR );
        if ( lua_isstring( L, -1 ) )
        {
            md.author = lua_tostring( L, -1 );
        }
        lua_pop( L, 1 );

        lua_getfield( L, -1, APP_FIELD_COPYRIGHT );
        if ( lua_isstring( L, -1 ) )
        {
            md.copyright = lua_tostring( L, -1 );
        }
        lua_pop( L, 1 );

        // Look for attributes

        lua_getfield( L , -1 , APP_FIELD_ATTRIBUTES );
        if ( lua_istable( L , -1 ) )
        {
            lua_pushnil( L );
            while( lua_next( L , -2 ) )
            {
                if ( lua_type( L , -1 ) == LUA_TSTRING )
                {
                    md.attributes.insert( lua_tostring( L , -1 ) );
                }
                lua_pop( L , 1 );
            }
        }
        lua_pop( L , 1 );

        // Look for actions

        lua_getfield( L, -1, APP_FIELD_ACTIONS );
        if ( lua_type( L, -1 ) == LUA_TTABLE )
        {
            lua_pushnil( L );

            while ( lua_next( L, -2 ) )
            {
                if ( lua_really_isstring( L, -2 ) && lua_type( L, -1 ) == LUA_TTABLE )
                {
                    String action_name = lua_tostring( L, -2 );
                    String uri;
                    String type;
                    String description;

                    lua_getfield( L, -1, "description" );
                    if ( lua_isstring( L, -1 ) )
                    {
                        description = lua_tostring( L, -1 );
                    }
                    lua_pop( L, 1 );

                    lua_getfield( L, -1, "uri" );
                    if ( lua_isstring( L, -1 ) )
                    {
                        uri = lua_tostring( L, -1 );
                    }
                    lua_pop( L, 1 );

                    lua_getfield( L, -1, "type" );
                    if ( lua_isstring( L, -1 ) )
                    {
                        type = lua_tostring( L , -1 );
                    }
                    lua_pop( L, 1 );

                    md.actions[ action_name ] = Action( description, uri, type );

                    lua_pop( L, 1 );
                }
            }
        }
        lua_pop( L, 1 );



        lua_close( L );

        return true;
    }
    catch ( const String & e )
    {
        lua_close( L );
        g_warning( "FAILED TO LOAD APP METADATA FILE : %s", e.c_str() );
        return false;
    }
}

bool App::load_metadata( const char * app_path, App::Metadata & md )
{
    g_assert( app_path );

    Util::Buffer contents( AppResource( app_path , APP_METADATA_FILENAME , AppResource::URI_NOT_ALLOWED | AppResource::LOCALIZED_NOT_ALLOWED ).load_contents( 0 ) );

    if ( ! contents )
    {
        g_warning( "FAILED TO LOAD APP METADATA FROM '%s'" , app_path );
        return false;
    }

    bool result = App::load_metadata_from_data( contents.data() , md );

    if ( result )
    {
        md.set_root( app_path );
    }

    return result;
}

//-----------------------------------------------------------------------------

void App::scan_app_sources( SystemDatabase * sysdb, const char * app_sources, const char * installed_apps_root, bool force )
{
    FreeLater free_later;

    // If the scan is not forced and we already have apps in the database, bail

    if ( !force && sysdb->get_app_count() > 0 )
    {
        return;
    }

    // Otherwise, let's do the scan

    if ( !app_sources )
    {
        g_warning( "NO APP SOURCES TO SCAN" );
        return;
    }

    std::map< String, Metadata::List > apps;

    //.........................................................................
    // First scan app sources

    gchar ** paths = g_strsplit( app_sources, ";", 0 );

    for ( gchar ** p = paths; *p; ++p )
    {
        gchar * path = g_strstrip( *p );

        GDir * dir = g_dir_open( path, 0, NULL );

        if ( !dir )
        {
            g_warning( "FAILED TO SCAN APP SOURCE %s", path );
        }
        else
        {
            while ( const gchar * base = g_dir_read_name( dir ) )
            {
                gchar * md_file_name = g_build_filename( path, base, "app", NULL );
                free_later( md_file_name );

                if ( !g_file_test( md_file_name, G_FILE_TEST_IS_REGULAR ) )
                {
                    continue;
                }

                gchar * app_path = g_build_filename( path, base, NULL );
                free_later( app_path );

                Metadata md;

                if ( load_metadata( app_path, md ) )
                {
                    g_info( "SCAN FOUND %s (%s/%d) @ %s",
                            md.id.c_str(),
                            md.version.c_str(),
                            md.release,
                            app_path );

                    apps[md.id].push_back( md );
                }
            }

            g_dir_close( dir );
        }
    }

    g_strfreev( paths );

    //.........................................................................
    // Now scan the data directory - where apps may be installed

    if ( g_file_test( installed_apps_root, G_FILE_TEST_EXISTS ) )
    {
        GDir * dir = g_dir_open( installed_apps_root, 0, NULL );

        if ( !dir )
        {
            g_warning( "FAILED TO SCAN APP SOURCE %s", installed_apps_root );
        }
        else
        {
            while ( const gchar * base = g_dir_read_name( dir ) )
            {
                gchar * app_path = g_build_filename( installed_apps_root, base, "source", NULL );
                free_later( app_path );

                gchar * md_file_name = g_build_filename( app_path, "app", NULL );
                free_later( md_file_name );

                if ( !g_file_test( md_file_name, G_FILE_TEST_IS_REGULAR ) )
                {
                    continue;
                }

                Metadata md;

                if ( load_metadata( app_path, md ) )
                {
                    g_info( "SCAN FOUND %s (%s/%d) @ %s",
                            md.id.c_str(),
                            md.version.c_str(),
                            md.release,
                            app_path );

                    apps[md.id].push_back( md );
                }
            }

            g_dir_close( dir );
        }
    }

    if ( !apps.empty() )
    {
        //.........................................................................
        // Now we have a map of app ids - each entry has a list of versions found
        // We are going to gather the latest version of each into a final list.

        Metadata::List final_list;

        std::map< String, Metadata::List >::iterator it = apps.begin();

        for ( ; it != apps.end(); ++it )
        {
            if ( it->second.size() > 1 )
            {
                // Get a reference to the list, so it is easier to deal with

                const Metadata::List & versions( it->second );

                // Now, we point an iterator to the first one in the list. If one of the
                // others has a greater release number, we point the iterator at it.
                //
                // When we are done, this iterator will point to the app metadata
                // with the greatest release number.

                Metadata::List::const_iterator latest = versions.begin();

                for ( Metadata::List::const_iterator vit = ++( versions.begin() ); vit != versions.end(); ++vit )
                {
                    if ( vit->release > latest->release )
                    {
                        latest = vit;
                    }
                }

                // Now, we put the latest one into the final list

                final_list.push_back( *latest );
            }
            else
            {
                // The list only has one element

                final_list.push_back( it->second.front() );
            }
        }

        sysdb->update_all_apps( final_list );
    }
}


//-----------------------------------------------------------------------------

String App::get_data_directory( TPContext * context, const String & app_id )
{
    FreeLater free_later;

    g_assert( context );

    // Get the data directory ready

    gchar * id_hash = g_compute_checksum_for_string( G_CHECKSUM_SHA1, app_id.c_str(), -1 );

    free_later( id_hash );

    gchar * app_data_path = g_build_filename( context->get( TP_DATA_PATH ), "apps", id_hash, NULL );

    free_later( app_data_path );

    if ( !g_file_test( app_data_path, G_FILE_TEST_EXISTS ) )
    {
        if ( g_mkdir_with_parents( app_data_path, 0700 ) != 0 )
        {
            g_warning( "FAILED TO CREATE APP DATA PATH '%s'", app_data_path );

            return String();
        }
    }

    return String( app_data_path );
}


//-----------------------------------------------------------------------------

App * App::load( TPContext * context, const App::Metadata & md, const LaunchInfo & launch )
{
    String app_data_path = get_data_directory( context, md.id );

    if ( app_data_path.empty() )
    {
        return NULL;
    }

    return new App( context, md, app_data_path, launch );
}

//-----------------------------------------------------------------------------

int App::lua_panic_handler( lua_State * L )
{
    g_critical( "%s", String( 60, '=' ).c_str() );
    g_critical( "LUA PANIC : %s", lua_tostring( L, -1 ) );
    g_critical( "%s", String( 60, '=' ).c_str() );

    throw LUA_ERRRUN;
}


static gboolean lua_gc_every_frame( gpointer state )
{
    static GTimer *gc_timer = g_timer_new();
    static unsigned num_steps = 0;

    lua_State *L = (lua_State *)state;

    g_timer_stop(gc_timer); // In case it was running -- ie the first time
    g_timer_continue(gc_timer);
    int result = lua_gc( L, LUA_GCSTEP, 1);
    g_timer_stop(gc_timer);
    num_steps++;
    if(1 == result)
    {
        tplog2("GC completed; total time: %fms, num steps = %d", g_timer_elapsed( gc_timer, NULL )*1000, num_steps);
        g_timer_reset(gc_timer);
        num_steps=0;
    }

    return true;
}

//-----------------------------------------------------------------------------

App::App( TPContext * c, const App::Metadata & md, const String & dp, const LaunchInfo & _launch )
    :
    context( c ),
    metadata( md ),
    data_path( dp ),
    L( NULL ),
    lua_state_proxy( NULL ),
    network( NULL ),
    event_group( new EventGroup() ),
    cookie_jar( NULL ),
    screen( NULL ),
    launch( _launch ),
    stage_allocation_handler( 0 ),
    lua_gc_func ( 0 )

#ifndef TP_PRODUCTION

    ,debugger( this )

#endif
{
    // Create the user agent

    user_agent = Network::format_user_agent(
                     context->get( TP_SYSTEM_LANGUAGE ),
                     context->get( TP_SYSTEM_COUNTRY ),
                     md.id.c_str(),
                     md.release,
                     context->get( TP_SYSTEM_NAME ),
                     context->get( TP_SYSTEM_VERSION ) );

    // Create the network

    network = new Network( context , event_group );

    // Register to get all notifications

    context->add_notification_handler( "*", forward_notification_handler, this );

    // Register for profile switch

    context->add_notification_handler( TP_NOTIFICATION_PROFILE_CHANGE, profile_notification_handler, this );

    // Create the Lua state

    L = luaL_newstate( );

    g_assert( L );

    // Install panic handler that throws an exception

    lua_atpanic( L, lua_panic_handler );

    // Create the lua state proxy

    lua_state_proxy = new LuaStateProxy( L );

    // Put a pointer to us in Lua so bindings can get to it

    lua_pushlightuserdata( L, &TP_APP_KEY );
    lua_pushlightuserdata( L, this );
    lua_rawset( L, LUA_REGISTRYINDEX );
}

#if 0
void debug_hook( lua_State * L, lua_Debug * ar )
{
    printf( "DEBUG: %d\n", ar->event );

    switch ( ar->event )
    {
        case LUA_HOOKCALL:
        {
            lua_getstack( L, 0, ar );
            lua_getinfo( L, "nsl", ar );
            printf( "  CALL\n" );
            break;
        }
    }

    if ( ar->event == LUA_HOOKLINE )
    {
        lua_getinfo( L, "nsl", ar );
        printf( "  LINE: %d : %s : %s\n", ar->currentline, ar->short_src, ar->source );
    }
}
#endif

//-----------------------------------------------------------------------------
// Signal handler that tells us when the stage changes dimensions, so we can
// update the screen's scale.

void App::stage_allocation_notify( gpointer the_stage , gpointer , gpointer screen )
{
    if ( screen )
    {
        ClutterActor * stage = CLUTTER_ACTOR( the_stage );

        gfloat width;
        gfloat height;

        clutter_actor_get_size( stage , & width , & height );

        clutter_actor_set_scale( CLUTTER_ACTOR( screen ), width / 1920, height / 1080 );

        g_debug( "DISPLAY SIZE CHANGED TO %1.0fx%1.0f" , width , height );
    }
}

//-----------------------------------------------------------------------------

void App::run( const StringSet & allowed_names , RunCallback run_callback )
{
    FreeLater free_later;

    Util::GTimer t;

    // Get the screen ready for the app

    ClutterActor * stage = context->get_stage();

    g_assert( stage );

    //.........................................................................
    // Look for a splash image

    ClutterActor * splash = 0;

    Image * splash_image = 0;

    if ( AppResource( this , "default.jpg" ).exists( this ) )
    {
        splash_image = load_image( "default.jpg" , false );
    }
    else if ( AppResource( this , "default.png" ).exists( this ) )
    {
        splash_image = load_image( "default.png" , false );
    }

    if ( splash_image )
    {
        splash = clutter_texture_new();

        clutter_actor_set_name( splash , "splash" );

        Images::load_texture( CLUTTER_TEXTURE( splash ) , splash_image );

        gfloat width;
        gfloat height;

        clutter_actor_get_size( stage , & width , & height );

        clutter_actor_set_scale( splash , width / splash_image->width() , height / splash_image->height() );

#ifdef CLUTTER_VERSION_1_10
        clutter_actor_add_child( stage, splash );
#else
        clutter_container_add_actor( CLUTTER_CONTAINER( stage ) , splash );
#endif

        clutter_actor_show( stage );

        clutter_actor_queue_redraw( stage );

        delete splash_image;

        g_info( "APP SPLASH %s : %1.3f s", metadata.id.c_str() , t.elapsed() );
    }

    //.........................................................................

    ::Action::post( new RunAction( this , allowed_names , run_callback , splash ) );
}

//-----------------------------------------------------------------------------

int App::global_tracker( lua_State * L )
{
    lua_pushvalue( L , 2 );
    lua_pushvalue( L , 3 );
    lua_rawset( L , 1 );

    if ( lua_type( L , 2 ) == LUA_TSTRING )
    {
        if ( App * app = App::get( L ) )
        {
            String where;

            lua_Debug ar;

            if ( lua_getstack( L , 1 , & ar ) )
            {
                if ( lua_getinfo( L , "Sl" , & ar ) )
                {
                    if ( ar.source )
                    {
                        where = Util::format( "%s:%d" , ar.source , ar.currentline );
                    }
                }
            }

            app->globals[ String( lua_tostring( L , 2 ) ) ] = where;
        }
    }

    return 0;
}

//-----------------------------------------------------------------------------

void App::run_part2( const StringSet & allowed_names , RunCallback run_callback )
{
    PROFILER( "App::run" , PROFILER_INTERNAL_CALLS );

    g_info( "RUNNING %s" , metadata.id.c_str() );

    Util::GTimer t;

    ClutterActor * stage = context->get_stage();

    g_assert( stage );

#ifdef CLUTTER_VERSION_1_10
    screen = clutter_actor_new();
#else
    screen = clutter_group_new();
#endif

    g_assert( screen );

    clutter_actor_set_position( screen, 0, 0 );
    clutter_actor_set_size( screen, 1920, 1080 );

    clutter_actor_set_name( screen , "screen" );

    stage_allocation_handler = g_signal_connect( stage , "notify::allocation" , ( GCallback ) stage_allocation_notify ,  screen );

    // Call it now to set the screen's initial scale

    stage_allocation_notify( stage , 0 , screen );

    secure_lua_state( allowed_names );

    // Open our stuff
    luaopen_globals( L );

    luaopen_clutter_actor( L );
    luaopen_clutter_container( L );

    luaopen_clutter_screen( L );

    //.........................................................................
    // Lazy loaded

    lua_pushinteger( L , LB_LAZY_LOAD );

    luaopen_clutter_rectangle( L );
    luaopen_clutter_text( L );
    luaopen_clutter_clone( L );
    luaopen_clutter_group( L );
    luaopen_clutter_image( L );
    luaopen_clutter_timeline( L );
    luaopen_clutter_animator( L );
    luaopen_clutter_state( L );
    luaopen_clutter_score( L );
    luaopen_clutter_alpha( L );
    luaopen_clutter_interval( L );
    luaopen_clutter_path( L );
    luaopen_clutter_constraint( L );

    luaopen_sprite_sheet( L );
    luaopen_sprite( L );
    luaopen_nineslice( L );

    luaopen_idle( L );
    luaopen_timer( L );
    luaopen_xml( L );
    luaopen_app( L );
    luaopen_system( L );
    luaopen_settings( L );
    luaopen_profile( L );
    luaopen_stopwatch( L );
    luaopen_json( L );
    luaopen_regex( L );
    luaopen_Controller( L );
    luaopen_controllers( L );
    luaopen_Tuner( L );
    luaopen_tuners( L );
    luaopen_mediaplayer_module( L );
    luaopen_socket( L );
    luaopen_url_request( L );
    luaopen_uri( L );
    luaopen_physics_module( L );
    luaopen_physics_bullet( L );
    luaopen_editor( L );
    luaopen_trickplay( L );
    luaopen_bitmap( L );
    luaopen_canvas( L );
    luaopen_http_module( L );
    luaopen_keyboard( L );
    luaopen_ease( L );
    luaopen_matrix( L );

#ifdef TP_WITH_WEBGL
    luaopen_typed_array( L );
    luaopen_webgl( L );
#endif

#ifndef TP_PRODUCTION
    luaopen_devtools( L );
#endif

#ifdef TP_UPNP_CLIENT
    luaopen_upnp( L );
#endif

#ifdef TP_WITH_GAMESERVICE
    if ( context->get_bool( TP_GAMESERVICE_ENABLED ) )
    {
        if (metadata.attributes.find(APP_FIELD_GAMESERVICE_ATTRIBUTE) != metadata.attributes.end())
        {
            g_info("Performing luaopen_gameservice()");
            luaopen_gameservice( L );

			AppId appId(metadata.id, 1);
		//	g_info("calling gameservice->RegisterApp(%s, %d) ", metadata.id.c_str(), 1);
		//	context->get_gameservice()->RegisterApp(appId);

			g_info("calling gameservice->OpenApp(%s, %d) ", metadata.id.c_str(), 1);
			context->get_gameservice()->OpenApp(appId);
		}
    }
#endif

    luaopen_apps( L );
    luaopen_restricted( L );

    lua_pop( L , 1 );

    //.........................................................................

    luaopen_keys( L );

#ifndef TP_PRODUCTION

    if ( context->get_bool( TP_START_DEBUGGER , false ) || launch.debug )
    {
        debugger.break_next_line();
    }

    //.........................................................................
    // Install a __newindex metamethod on the globals table that stores
    // information about global values added by the user.

    lua_rawgeti( L , LUA_REGISTRYINDEX , LUA_RIDX_GLOBALS );

    if ( ! lua_isnil( L , -1 ) )
    {
        if ( lua_getmetatable( L , -1 ) )
        {
            lua_pushliteral( L , "__newindex" );
            lua_pushcfunction( L , global_tracker );
            lua_rawset( L , -3 );
            lua_pop( L , 1 );
        }
    }

    lua_pop( L , 1 );


#endif

    //.........................................................................
    // Open plugins

    LuaAPIPlugin::call_open( L );

    //.........................................................................
    // Collect garbage every frame

    lua_gc_func = clutter_threads_add_repaint_func( lua_gc_every_frame, L, 0 );
    lua_gc( L, LUA_GCGEN, 0 ); // Switch to generational collector
    lua_gc( L, LUA_GCSETMAJORINC, 110 ); // Reduce threshold for major collection

    //.........................................................................
    // Run the script

    FreeLater free_later;

    int result = TP_RUN_OK;

    int top = lua_gettop( L );

    if ( AppResource( this , APP_MAIN_FILENAME , AppResource::URI_NOT_ALLOWED ).lua_load( L ) || lua_pcall( L , 0 , LUA_MULTRET , 0 ) )
    {
        g_critical( "%s", String( 60, '=' ).c_str() );
        g_critical( "LUA ERROR : %s", lua_tostring( L, -1 ) );
        g_critical( "%s", String( 60, '=' ).c_str() );

        lua_pop( L , lua_gettop( L ) - top );

        result = TP_RUN_APP_ERROR;
    }
    else
    {
        lua_pop( L , lua_gettop( L ) - top );

        // Make it small

        //clutter_actor_set_scale( screen, 0, 0 );

        // By adding it to the stage, the ref is sunk, so we don't need
        // to unref it here.

#ifdef CLUTTER_VERSION_1_10
        clutter_actor_add_child( stage, screen );
#else
        clutter_container_add_actor( CLUTTER_CONTAINER( stage ), screen );
#endif

        g_info( "APP RUN %s : %1.3f s", metadata.id.c_str(), t.elapsed() );

        notify( context , TP_NOTIFICATION_APP_LOADED );
    }

    run_callback( this , result );
}

//-----------------------------------------------------------------------------

App::~App()
{
#ifndef TP_PRODUCTION

    debugger.uninstall();

#endif

    // Get rid of the keyboard

    Keyboard::hide( L , true );

    notify( context , TP_NOTIFICATION_APP_CLOSING );

    context->remove_notification_handler( "*", forward_notification_handler, this );
    context->remove_notification_handler( TP_NOTIFICATION_PROFILE_CHANGE, profile_notification_handler, this );

    // Stops the network thread and waits

    delete network;

    // Cancels all outstanding idle callbacks

    event_group->cancel_all();

    // Release the cookie jar

    release_cookie_jar();

    // Close plugins

    LuaAPIPlugin::call_close( L );

    // Remove GC callback per frame

    clutter_threads_remove_repaint_func( lua_gc_func );

    // Close Lua

    lua_close( L );

    // Invalidate and release the lua state proxy

    lua_state_proxy->invalidate();

    lua_state_proxy->unref();

    // Release the event group

    event_group->unref();

    if ( stage_allocation_handler )
    {
        g_signal_handler_disconnect( context->get_stage() , stage_allocation_handler );
    }
}

//-----------------------------------------------------------------------------
// Replacement function for math.randomseed that does nothing

static int disabled_randomseed( lua_State * )
{
    return 0;
}

//-----------------------------------------------------------------------------

void App::secure_lua_state( const StringSet & allowed_names )
{
    //.........................................................................
    // Open standard libs

    // We do NOT open these, as they pose security risks

    //      {LUA_IOLIBNAME, luaopen_io},
    //      {LUA_DBLIBNAME, luaopen_debug},

    const luaL_Reg lualibs[] =
    {
        { "_G", luaopen_base },
        {LUA_COLIBNAME, luaopen_coroutine},
        {LUA_OSLIBNAME, luaopen_os},
        {LUA_BITLIBNAME, luaopen_bit32},
        { LUA_TABLIBNAME, luaopen_table },
        { LUA_STRLIBNAME, luaopen_string },
        { LUA_MATHLIBNAME, luaopen_math },
        { LUA_OSLIBNAME, luaopen_os },
        { LUA_LOADLIBNAME, luaopen_package },
        { NULL, NULL }
    };

    for ( const luaL_Reg * lib = lualibs; lib->func; ++lib )
    {
        luaL_requiref(L, lib->name, lib->func, 1);
        lua_pop(L, 1);  /* remove lib */
    }

    //.........................................................................
    // Now, we have to nuke some 'os' functions

    lua_getglobal( L, "os" );

    const char * os_nuke[] =
    {
        "execute",
        "exit",
        "getenv",
        "remove",
        "rename",
        "setlocale",
        "tmpname",
        NULL
    };

    for( const char * * name = os_nuke; * name; ++name )
    {
        lua_pushstring( L, * name );
        lua_pushnil( L );
        lua_rawset( L, -3 );
    }

    lua_pop( L, 1 );

    //.........................................................................
    // Nuke package stuff

    lua_getglobal( L, "package" );

    const char * package_nuke[] =
    {
        "cpath",
        "loaders",
        "loadlib",
        "path",
        "preload",
        NULL
    };

    for( const char * * name = package_nuke; * name; ++name )
    {
        lua_pushstring( L, * name );
        lua_pushnil( L );
        lua_rawset( L, -3 );
    }

#if 0
    // Set "loaders" to an empty table
    // We have to do this if we want 'require' to work

    lua_pushstring( L, "loaders" );
    lua_newtable( L );
    lua_rawset( L, -3 );

#endif

    lua_pop( L, 1 );

    //.........................................................................
    // Nuke globals

    const char * global_nuke[] =
    {
        "require",
        "load",
        "loadstring",
        "module",
        0
    };

    for( const char * * name = global_nuke; * name; ++name )
    {
        lua_pushnil( L );
        lua_setglobal( L, * name );
    }

    //.........................................................................
    // In Lua 5.2, unpack moved to table.unpack. We create a global for it.

    lua_getglobal( L , "table" );
    lua_getfield( L , -1 , "unpack" );
    lua_setglobal( L , "unpack" );
    lua_pop( L , 1 );

    //.........................................................................

    for ( StringSet::const_iterator it = allowed_names.begin(); it != allowed_names.end(); ++it )
    {
        lb_allow( L, it->c_str() );
    }

    //.........................................................................
    // If there is a fixed random seed, set it and also replace math.randomseed

    int seed = context->get_int( TP_RANDOM_SEED , 0 );

    if ( seed != 0 )
    {
        lua_getglobal( L , "math" );

        lua_getfield( L , -1 , "randomseed" );
        lua_pushinteger( L , seed );
        lua_call( L , 1 , 0 );

        lua_pushcfunction( L , disabled_randomseed );
        lua_setfield( L , -2 , "randomseed" );

        lua_pop( L , 1 );
    }
}

//-----------------------------------------------------------------------------

App * App::get( lua_State * L )
{
    g_assert( L );
    lua_pushlightuserdata( L, &TP_APP_KEY );
    lua_rawget( L, LUA_REGISTRYINDEX );
    App * result = ( App * )lua_touserdata( L, -1 );
    lua_pop( L, 1 );
    g_assert( result );
    return result;
}

//-----------------------------------------------------------------------------

TPContext * App::get_context()
{
    return context;
}

//-----------------------------------------------------------------------------


String App::get_data_path() const
{
    return data_path;
}

//-----------------------------------------------------------------------------

int App::get_profile_id() const
{
    return context->get_int( PROFILE_ID );
}

//-----------------------------------------------------------------------------

const App::Metadata & App::get_metadata() const
{
    return metadata;
}

//-----------------------------------------------------------------------------

const String & App::get_id() const
{
    return metadata.id;
}

//-----------------------------------------------------------------------------

const App::LaunchInfo & App::get_launch_info() const
{
    return launch;
}

//-----------------------------------------------------------------------------

void App::release_cookie_jar()
{
    // Will unref it and set it to NULL
    cookie_jar = Network::cookie_jar_unref( cookie_jar );
}

//-----------------------------------------------------------------------------

Network::CookieJar * App::get_cookie_jar()
{
    if ( !cookie_jar )
    {
        FreeLater free_later;

        gchar * name = g_strdup_printf( "cookies-%d.txt", get_profile_id() );
        free_later( name );

        gchar * file_name = g_build_filename( data_path.c_str(), name, NULL );
        free_later( file_name );

        cookie_jar = Network::cookie_jar_new( file_name );
    }

    return cookie_jar;
}

//-----------------------------------------------------------------------------

Network * App::get_network()
{
    return network;
}

//-----------------------------------------------------------------------------

String App::get_user_agent() const
{
    return user_agent;
}

//-----------------------------------------------------------------------------
// This one forwards all notifications from the context to our listeners

void App::forward_notification_handler( TPContext * context , const char * subject, void * data )
{
    ( ( App * )data )->notify( context , subject );
}

//-----------------------------------------------------------------------------
// Notification handler for profile switches

void App::profile_notification_handler( TPContext * context , const char * subject, void * data )
{
    ( ( App * )data )->profile_switch();
}

//-----------------------------------------------------------------------------

void App::profile_switch()
{
    release_cookie_jar();
}

//-----------------------------------------------------------------------------

lua_State * App::get_lua_state()
{
    return L;
}

//-----------------------------------------------------------------------------

LuaStateProxy * App::ref_lua_state_proxy()
{
    lua_state_proxy->ref();

    return lua_state_proxy;
}

//-----------------------------------------------------------------------------

EventGroup * App::get_event_group()
{
    return event_group;
}

//-----------------------------------------------------------------------------

bool App::change_app_path( const char * path )
{
    g_assert( path );

    if ( ! g_file_test( path , G_FILE_TEST_IS_DIR ) )
    {
        return false;
    }

    if ( ! metadata.set_root( path ) )
    {
        return false;
    }

    g_warning( "*** APP SANDBOX CHANGED FOR %s TO '%s'" , metadata.id.c_str() , metadata.get_root_uri().c_str() );

    return true;
}

//-----------------------------------------------------------------------------

ClutterActor * App::get_screen() const
{
    return screen;
}

//-----------------------------------------------------------------------------

Debugger * App::get_debugger()
{
#ifndef TP_PRODUCTION

    return & debugger;

#else

    return 0;

#endif
}

//-----------------------------------------------------------------------------

guint16 App::get_debugger_port()
{
#ifndef TP_PRODUCTION

    return debugger.get_server_port();

#else

    return 0;

#endif

}

//-----------------------------------------------------------------------------

void App::animate_in()
{
    if ( !screen )
    {
        return;
    }

    ClutterActor * stage = get_context()->get_stage();

    gfloat width;
    gfloat height;

    clutter_actor_get_size( stage, &width , &height );

    // TODO
    // Here, we should ref the screen, create a timeline that animates the
    // screen and unref it when the timeline completes.
    // unless TP_APP_ANIMATIONS_ENABLED is false

#ifdef CLUTTER_VERSION_1_10
    clutter_actor_set_child_above_sibling( stage, screen, NULL );
#else
    clutter_actor_raise_top( screen );
#endif

    clutter_actor_set_scale( screen, width / 1920, height / 1080 );

    clutter_actor_grab_key_focus( screen );
}

//-----------------------------------------------------------------------------

static void animate_out_completed( ClutterAnimation *anim , ClutterActor * actor )
{
    ClutterActor * parent = clutter_actor_get_parent( actor );

    if ( parent )
    {
#ifdef CLUTTER_VERSION_1_10
        clutter_actor_remove_child( parent, actor );
#else
        clutter_container_remove_actor( CLUTTER_CONTAINER( parent ), actor );
#endif
    }
   // Something is holding an extra ref.  We'll release it here, but this is wrong
   // We cannot find where the extra ref is being taken; our hope is de-reffing it
   // will one day cause a crash that we can then track down!
   g_object_unref( G_OBJECT ( actor ) );
   g_object_unref( G_OBJECT ( actor ) );
   if(anim) g_object_unref( G_OBJECT ( anim ) );
}

void App::animate_out()
{
    if ( !screen )
    {
        return;
    }

    // So we can hold on to it until we are done
    g_object_ref( G_OBJECT( screen ) );

    if ( ! context->get_bool( TP_APP_ANIMATIONS_ENABLED , true ) )
    {
        animate_out_completed( 0 , screen );
    }
    else
    {
        g_idle_add_full( G_PRIORITY_HIGH, animate_out_callback, screen, NULL );
    }
}

//-----------------------------------------------------------------------------

gboolean App::animate_out_callback( gpointer s )
{
    ClutterActor * screen = CLUTTER_ACTOR( s );

    ClutterActor * parent = clutter_actor_get_parent( screen );

    if ( parent )
    {
        // TODO
        // What we would actually do here is to animate the screen out
        // and in the completed callback for that, remove it from its
        // parent and unref it

        //clutter_container_remove_actor( CLUTTER_CONTAINER( parent ), screen );

        gfloat width;
        gfloat height;

        clutter_actor_get_size( parent, &width, &height );

        clutter_actor_set_anchor_point( screen, 960, 540 );

        clutter_actor_set_position( screen, width / 2, height / 2 );

        clutter_actor_set_clip( screen, 0, 0, 1920, 1080 );

        ClutterAnimator *animator = clutter_animator_new();
        clutter_animator_set_duration(animator, 750);
        clutter_animator_set(animator,
                                screen, "scale-x", CLUTTER_LINEAR, 0.0, 1.0,
                                screen, "scale-y", CLUTTER_LINEAR, 0.0, 1.0,
                                screen, "scale-x", CLUTTER_EASE_OUT_EXPO, 0.2, 0.3,
                                screen, "scale-y", CLUTTER_EASE_OUT_EXPO, 0.2, 0.005,
                                screen, "scale-x", CLUTTER_LINEAR, 0.5, 0.4,
                                screen, "scale-y", CLUTTER_LINEAR, 0.5, 0.002,
                                screen, "scale-x", CLUTTER_EASE_OUT_EXPO, 1.0, 0.002,
                                screen, "scale-y", CLUTTER_EASE_OUT_EXPO, 1.0, 0.002,
                                NULL
                            );
        ClutterTimeline *timeline = clutter_animator_start(animator);

        g_signal_connect_after( timeline, "completed", G_CALLBACK(animate_out_completed), screen );
    } else {
	g_object_unref( G_OBJECT( screen ) );
    }

    return FALSE;
}

//-----------------------------------------------------------------------------

Image * App::load_image( const gchar * source , bool read_tags )
{
    tplog( "LOADING SYNC '%s'" , source );

    if ( ! source )
    {
        return 0;
    }

    AppResource resource( this , source );

    if ( ! resource.good() )
    {
        return 0;
    }

    Image * image = 0;

    if ( resource.is_http() )
    {
        tplog( "  STARTING REQUEST" );

        Network::Request request( get_user_agent() , resource.get_uri() );

        Network::Response response = get_network()->perform_request( request, get_cookie_jar() );

        if ( ! response.failed && response.body->len > 0 )
        {
            tplog( "  DECODING" );

            image = Image::decode( response.body->data, response.body->len, read_tags , response.get_header( "Content-Type" ) );
        }
        else
        {
            tplog( "  REQUEST FAILED" );
        }
    }
    else if ( resource.is_native() )
    {
        String path( resource.get_native_path().c_str() );

        tplog( "  PATH IS '%s'" , path.c_str() );
        tplog( "  DECODING" );

        image = Image::decode( path.c_str() , read_tags );
    }

    tplog( "  %s" , image ? "SUCCEEDED" : "FAILED" );

    return image;
}

//-----------------------------------------------------------------------------

class ImageResponseClosure
{
public:

    ImageResponseClosure( bool _read_tags , Image::DecodeAsyncCallback _callback , gpointer _user , GDestroyNotify _destroy_notify )
    :
        read_tags( _read_tags ),
        callback( _callback ),
        user( _user ),
        destroy_notify( _destroy_notify )
    {
    }

    static void response_callback( const Network::Response & response , gpointer me )
    {
        ImageResponseClosure * self = ( ImageResponseClosure * ) me;

        if ( response.failed || response.body->len == 0 )
        {
            tplog( "  REQUEST FAILED" );

            self->callback( 0 , self->user );
        }
        else
        {
            tplog( "  STARTING DECODE FOM BUFFER" );

            Image::decode_async( response.body ,
                    self->read_tags ,
                    response.get_header( "Content-Type" ),
                    self->callback,
                    self->user,
                    self->destroy_notify );

            self->destroy_notify = 0;
        }
    }

    static void destroy( gpointer me )
    {
        ImageResponseClosure * self = ( ImageResponseClosure * ) me;

        if ( self->destroy_notify )
        {
            self->destroy_notify( self->user );
        }

        delete self;
    }

private:

    bool                        read_tags;
    Image::DecodeAsyncCallback  callback;
    gpointer                    user;
    GDestroyNotify              destroy_notify;
};

//-----------------------------------------------------------------------------

bool App::load_image_async( const gchar * source , bool read_tags , Image::DecodeAsyncCallback callback , gpointer user , GDestroyNotify destroy_notify )
{
    tplog( "LOADING ASYNC '%s'" , source );

    if ( ! source )
    {
        if ( destroy_notify )
        {
            destroy_notify( user );
        }

        return false;
    }

    AppResource resource( this , source );

    if ( ! resource.good() )
    {
        tplog( "  INVALID PATH" );

        if ( destroy_notify )
        {
            destroy_notify( user );
        }

        return false;
    }

    if ( resource.is_http() )
    {
        tplog( "  STARTING NETWORK REQUEST" );

        Network::Request request( get_user_agent() , resource.get_uri() );

        get_network()->perform_request_async(
            request,
            get_cookie_jar(),
            ImageResponseClosure::response_callback,
            new ImageResponseClosure( read_tags , callback , user , destroy_notify ),
            ImageResponseClosure::destroy );
    }
    else if ( resource.is_native() )
    {
        String path( resource.get_native_path() );

        tplog( "  PATH IS '%s'" , path.c_str() );
        tplog( "  STARTING DECODE FROM FILE" );

        Image::decode_async( path.c_str() , read_tags , callback , user , destroy_notify );
    }

    return true;
}

//-----------------------------------------------------------------------------

void App::audio_match( const String & json )
{
    // TODO: Not terribly excited about doing it this way

    lua_getglobal( L , "app" );

    if ( lua_isnil( L , -1 ) )
    {
        lua_pop( L , 1 );
        return;
    }

    if ( UserData * ud = UserData::get( L , lua_gettop( L ) ) )
    {
        JSON::parse( L , json.c_str() );

        if ( lua_isnil( L , -1 ) )
        {
            lua_pop( L , 1 );
        }
        else
        {
            ud->invoke_callbacks( "on_audio_match" , 1 , 0 );
        }
    }

    lua_pop( L , 1 );
}

//.........................................................................
